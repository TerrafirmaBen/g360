(function (factory) {
  typeof define === 'function' && define.amd ? define(factory) :
  factory();
}((function () { 'use strict';

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  /**
   * @module ol/Disposable
   */
  /**
   * @classdesc
   * Objects that need to clean up after themselves.
   */
  var Disposable = /** @class */ (function () {
      function Disposable() {
          /**
           * The object has already been disposed.
           * @type {boolean}
           * @protected
           */
          this.disposed = false;
      }
      /**
       * Clean up.
       */
      Disposable.prototype.dispose = function () {
          if (!this.disposed) {
              this.disposed = true;
              this.disposeInternal();
          }
      };
      /**
       * Extension point for disposable objects.
       * @protected
       */
      Disposable.prototype.disposeInternal = function () { };
      return Disposable;
  }());

  /**
   * @module ol/array
   */
  /**
   * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
   * https://github.com/darkskyapp/binary-search
   *
   * @param {Array<*>} haystack Items to search through.
   * @param {*} needle The item to look for.
   * @param {Function=} opt_comparator Comparator function.
   * @return {number} The index of the item if found, -1 if not.
   */
  function binarySearch(haystack, needle, opt_comparator) {
      var mid, cmp;
      var comparator = opt_comparator || numberSafeCompareFunction;
      var low = 0;
      var high = haystack.length;
      var found = false;
      while (low < high) {
          /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
           * to double (which gives the wrong results). */
          mid = low + ((high - low) >> 1);
          cmp = +comparator(haystack[mid], needle);
          if (cmp < 0.0) {
              /* Too low. */
              low = mid + 1;
          }
          else {
              /* Key found or too high */
              high = mid;
              found = !cmp;
          }
      }
      /* Key not found. */
      return found ? low : ~low;
  }
  /**
   * Compare function for array sort that is safe for numbers.
   * @param {*} a The first object to be compared.
   * @param {*} b The second object to be compared.
   * @return {number} A negative number, zero, or a positive number as the first
   *     argument is less than, equal to, or greater than the second.
   */
  function numberSafeCompareFunction(a, b) {
      return a > b ? 1 : a < b ? -1 : 0;
  }
  /**
   * Whether the array contains the given object.
   * @param {Array<*>} arr The array to test for the presence of the element.
   * @param {*} obj The object for which to test.
   * @return {boolean} The object is in the array.
   */
  function includes(arr, obj) {
      return arr.indexOf(obj) >= 0;
  }
  /**
   * @param {Array<number>} arr Array.
   * @param {number} target Target.
   * @param {number} direction 0 means return the nearest, > 0
   *    means return the largest nearest, < 0 means return the
   *    smallest nearest.
   * @return {number} Index.
   */
  function linearFindNearest(arr, target, direction) {
      var n = arr.length;
      if (arr[0] <= target) {
          return 0;
      }
      else if (target <= arr[n - 1]) {
          return n - 1;
      }
      else {
          var i = void 0;
          if (direction > 0) {
              for (i = 1; i < n; ++i) {
                  if (arr[i] < target) {
                      return i - 1;
                  }
              }
          }
          else if (direction < 0) {
              for (i = 1; i < n; ++i) {
                  if (arr[i] <= target) {
                      return i;
                  }
              }
          }
          else {
              for (i = 1; i < n; ++i) {
                  if (arr[i] == target) {
                      return i;
                  }
                  else if (arr[i] < target) {
                      if (arr[i - 1] - target < target - arr[i]) {
                          return i - 1;
                      }
                      else {
                          return i;
                      }
                  }
              }
          }
          return n - 1;
      }
  }
  /**
   * @param {Array<*>} arr Array.
   * @param {number} begin Begin index.
   * @param {number} end End index.
   */
  function reverseSubArray(arr, begin, end) {
      while (begin < end) {
          var tmp = arr[begin];
          arr[begin] = arr[end];
          arr[end] = tmp;
          ++begin;
          --end;
      }
  }
  /**
   * @param {Array<VALUE>} arr The array to modify.
   * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
   * @template VALUE
   */
  function extend(arr, data) {
      var extension = Array.isArray(data) ? data : [data];
      var length = extension.length;
      for (var i = 0; i < length; i++) {
          arr[arr.length] = extension[i];
      }
  }
  /**
   * @param {Array<VALUE>} arr The array to search in.
   * @param {function(VALUE, number, ?) : boolean} func The function to compare.
   * @template VALUE
   * @return {VALUE|null} The element found or null.
   */
  function find(arr, func) {
      var length = arr.length >>> 0;
      var value;
      for (var i = 0; i < length; i++) {
          value = arr[i];
          if (func(value, i, arr)) {
              return value;
          }
      }
      return null;
  }
  /**
   * @param {Array|Uint8ClampedArray} arr1 The first array to compare.
   * @param {Array|Uint8ClampedArray} arr2 The second array to compare.
   * @return {boolean} Whether the two arrays are equal.
   */
  function equals(arr1, arr2) {
      var len1 = arr1.length;
      if (len1 !== arr2.length) {
          return false;
      }
      for (var i = 0; i < len1; i++) {
          if (arr1[i] !== arr2[i]) {
              return false;
          }
      }
      return true;
  }
  /**
   * @param {Array<*>} arr The array to search in.
   * @param {Function} func Comparison function.
   * @return {number} Return index.
   */
  function findIndex(arr, func) {
      var index;
      var found = !arr.every(function (el, idx) {
          index = idx;
          return !func(el, idx, arr);
      });
      return found ? index : -1;
  }
  /**
   * @param {Array<*>} arr The array to test.
   * @param {Function=} opt_func Comparison function.
   * @param {boolean=} opt_strict Strictly sorted (default false).
   * @return {boolean} Return index.
   */
  function isSorted(arr, opt_func, opt_strict) {
      var compare = opt_func || numberSafeCompareFunction;
      return arr.every(function (currentVal, index) {
          if (index === 0) {
              return true;
          }
          var res = compare(arr[index - 1], currentVal);
          return !(res > 0 || (opt_strict && res === 0));
      });
  }

  /**
   * @module ol/functions
   */
  /**
   * Always returns true.
   * @returns {boolean} true.
   */
  function TRUE() {
      return true;
  }
  /**
   * Always returns false.
   * @returns {boolean} false.
   */
  function FALSE() {
      return false;
  }
  /**
   * A reusable function, used e.g. as a default for callbacks.
   *
   * @return {void} Nothing.
   */
  function VOID() { }
  /**
   * Wrap a function in another function that remembers the last return.  If the
   * returned function is called twice in a row with the same arguments and the same
   * this object, it will return the value from the first call in the second call.
   *
   * @param {function(...any): ReturnType} fn The function to memoize.
   * @return {function(...any): ReturnType} The memoized function.
   * @template ReturnType
   */
  function memoizeOne(fn) {
      var called = false;
      /** @type {ReturnType} */
      var lastResult;
      /** @type {Array<any>} */
      var lastArgs;
      var lastThis;
      return function () {
          var nextArgs = Array.prototype.slice.call(arguments);
          if (!called || this !== lastThis || !equals(nextArgs, lastArgs)) {
              called = true;
              lastThis = this;
              lastArgs = nextArgs;
              lastResult = fn.apply(this, arguments);
          }
          return lastResult;
      };
  }

  /**
   * @module ol/util
   */
  /**
   * @return {?} Any return.
   */
  function abstract() {
      return /** @type {?} */ ((function () {
          throw new Error('Unimplemented abstract method.');
      })());
  }
  /**
   * Counter for getUid.
   * @type {number}
   * @private
   */
  var uidCounter_ = 0;
  /**
   * Gets a unique ID for an object. This mutates the object so that further calls
   * with the same object as a parameter returns the same value. Unique IDs are generated
   * as a strictly increasing sequence. Adapted from goog.getUid.
   *
   * @param {Object} obj The object to get the unique ID for.
   * @return {string} The unique ID for the object.
   * @api
   */
  function getUid(obj) {
      return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
  }
  /**
   * OpenLayers version.
   * @type {string}
   */
  var VERSION = '6.4.3';

  var __extends = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * Error object thrown when an assertion failed. This is an ECMA-262 Error,
   * extended with a `code` property.
   * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error.
   */
  var AssertionError = /** @class */ (function (_super) {
      __extends(AssertionError, _super);
      /**
       * @param {number} code Error code.
       */
      function AssertionError(code) {
          var _this = this;
          var path =  'v' + VERSION.split('-')[0];
          var message = 'Assertion failed. See https://openlayers.org/en/' +
              path +
              '/doc/errors/#' +
              code +
              ' for details.';
          _this = _super.call(this, message) || this;
          /**
           * Error code. The meaning of the code can be found on
           * https://openlayers.org/en/latest/doc/errors/ (replace `latest` with
           * the version found in the OpenLayers script's header comment if a version
           * other than the latest is used).
           * @type {number}
           * @api
           */
          _this.code = code;
          /**
           * @type {string}
           */
          _this.name = 'AssertionError';
          // Re-assign message, see https://github.com/Rich-Harris/buble/issues/40
          _this.message = message;
          return _this;
      }
      return AssertionError;
  }(Error));

  /**
   * @module ol/asserts
   */
  /**
   * @param {*} assertion Assertion we expected to be truthy.
   * @param {number} errorCode Error code.
   */
  function assert(assertion, errorCode) {
      if (!assertion) {
          throw new AssertionError(errorCode);
      }
  }

  /**
   * @module ol/transform
   */
  /**
   * An array representing an affine 2d transformation for use with
   * {@link module:ol/transform} functions. The array has 6 elements.
   * @typedef {!Array<number>} Transform
   * @api
   */
  /**
   * Collection of affine 2d transformation functions. The functions work on an
   * array of 6 elements. The element order is compatible with the [SVGMatrix
   * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
   * a subset (elements a to f) of a 3×3 matrix:
   * ```
   * [ a c e ]
   * [ b d f ]
   * [ 0 0 1 ]
   * ```
   */
  /**
   * @private
   * @type {Transform}
   */
  var tmp_ = new Array(6);
  /**
   * Create an identity transform.
   * @return {!Transform} Identity transform.
   */
  function create() {
      return [1, 0, 0, 1, 0, 0];
  }
  /**
   * Set the transform components a-f on a given transform.
   * @param {!Transform} transform Transform.
   * @param {number} a The a component of the transform.
   * @param {number} b The b component of the transform.
   * @param {number} c The c component of the transform.
   * @param {number} d The d component of the transform.
   * @param {number} e The e component of the transform.
   * @param {number} f The f component of the transform.
   * @return {!Transform} Matrix with transform applied.
   */
  function set(transform, a, b, c, d, e, f) {
      transform[0] = a;
      transform[1] = b;
      transform[2] = c;
      transform[3] = d;
      transform[4] = e;
      transform[5] = f;
      return transform;
  }
  /**
   * Set transform on one matrix from another matrix.
   * @param {!Transform} transform1 Matrix to set transform to.
   * @param {!Transform} transform2 Matrix to set transform from.
   * @return {!Transform} transform1 with transform from transform2 applied.
   */
  function setFromArray(transform1, transform2) {
      transform1[0] = transform2[0];
      transform1[1] = transform2[1];
      transform1[2] = transform2[2];
      transform1[3] = transform2[3];
      transform1[4] = transform2[4];
      transform1[5] = transform2[5];
      return transform1;
  }
  /**
   * Transforms the given coordinate with the given transform returning the
   * resulting, transformed coordinate. The coordinate will be modified in-place.
   *
   * @param {Transform} transform The transformation.
   * @param {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} coordinate The coordinate to transform.
   * @return {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} return coordinate so that operations can be
   *     chained together.
   */
  function apply(transform, coordinate) {
      var x = coordinate[0];
      var y = coordinate[1];
      coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
      coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
      return coordinate;
  }
  /**
   * Creates a scale transform.
   * @param {!Transform} target Transform to overwrite.
   * @param {number} x Scale factor x.
   * @param {number} y Scale factor y.
   * @return {!Transform} The scale transform.
   */
  function makeScale(target, x, y) {
      return set(target, x, 0, 0, y, 0, 0);
  }
  /**
   * Creates a composite transform given an initial translation, scale, rotation, and
   * final translation (in that order only, not commutative).
   * @param {!Transform} transform The transform (will be modified in place).
   * @param {number} dx1 Initial translation x.
   * @param {number} dy1 Initial translation y.
   * @param {number} sx Scale factor x.
   * @param {number} sy Scale factor y.
   * @param {number} angle Rotation (in counter-clockwise radians).
   * @param {number} dx2 Final translation x.
   * @param {number} dy2 Final translation y.
   * @return {!Transform} The composite transform.
   */
  function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
      var sin = Math.sin(angle);
      var cos = Math.cos(angle);
      transform[0] = sx * cos;
      transform[1] = sy * sin;
      transform[2] = -sx * sin;
      transform[3] = sy * cos;
      transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
      transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
      return transform;
  }
  /**
   * Invert the given transform.
   * @param {!Transform} target Transform to be set as the inverse of
   *     the source transform.
   * @param {!Transform} source The source transform to invert.
   * @return {!Transform} The inverted (target) transform.
   */
  function makeInverse(target, source) {
      var det = determinant(source);
      assert(det !== 0, 32); // Transformation matrix cannot be inverted
      var a = source[0];
      var b = source[1];
      var c = source[2];
      var d = source[3];
      var e = source[4];
      var f = source[5];
      target[0] = d / det;
      target[1] = -b / det;
      target[2] = -c / det;
      target[3] = a / det;
      target[4] = (c * f - d * e) / det;
      target[5] = -(a * f - b * e) / det;
      return target;
  }
  /**
   * Returns the determinant of the given matrix.
   * @param {!Transform} mat Matrix.
   * @return {number} Determinant.
   */
  function determinant(mat) {
      return mat[0] * mat[3] - mat[1] * mat[2];
  }
  /**
   * A string version of the transform.  This can be used
   * for CSS transforms.
   * @param {!Transform} mat Matrix.
   * @return {string} The transform as a string.
   */
  function toString(mat) {
      return 'matrix(' + mat.join(', ') + ')';
  }

  /**
   * @module ol/extent/Corner
   */
  /**
   * Extent corner.
   * @enum {string}
   */
  var Corner = {
      BOTTOM_LEFT: 'bottom-left',
      BOTTOM_RIGHT: 'bottom-right',
      TOP_LEFT: 'top-left',
      TOP_RIGHT: 'top-right',
  };

  /**
   * @module ol/extent/Relationship
   */
  /**
   * Relationship to an extent.
   * @enum {number}
   */
  var Relationship = {
      UNKNOWN: 0,
      INTERSECTING: 1,
      ABOVE: 2,
      RIGHT: 4,
      BELOW: 8,
      LEFT: 16,
  };

  /**
   * @module ol/extent
   */
  /**
   * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
   * @typedef {Array<number>} Extent
   * @api
   */
  /**
   * Build an extent that includes all given coordinates.
   *
   * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
   * @return {Extent} Bounding extent.
   * @api
   */
  function boundingExtent(coordinates) {
      var extent = createEmpty();
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
          extendCoordinate(extent, coordinates[i]);
      }
      return extent;
  }
  /**
   * @param {Array<number>} xs Xs.
   * @param {Array<number>} ys Ys.
   * @param {Extent=} opt_extent Destination extent.
   * @private
   * @return {Extent} Extent.
   */
  function _boundingExtentXYs(xs, ys, opt_extent) {
      var minX = Math.min.apply(null, xs);
      var minY = Math.min.apply(null, ys);
      var maxX = Math.max.apply(null, xs);
      var maxY = Math.max.apply(null, ys);
      return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
  }
  /**
   * Return extent increased by the provided value.
   * @param {Extent} extent Extent.
   * @param {number} value The amount by which the extent should be buffered.
   * @param {Extent=} opt_extent Extent.
   * @return {Extent} Extent.
   * @api
   */
  function buffer(extent, value, opt_extent) {
      if (opt_extent) {
          opt_extent[0] = extent[0] - value;
          opt_extent[1] = extent[1] - value;
          opt_extent[2] = extent[2] + value;
          opt_extent[3] = extent[3] + value;
          return opt_extent;
      }
      else {
          return [
              extent[0] - value,
              extent[1] - value,
              extent[2] + value,
              extent[3] + value,
          ];
      }
  }
  /**
   * Creates a clone of an extent.
   *
   * @param {Extent} extent Extent to clone.
   * @param {Extent=} opt_extent Extent.
   * @return {Extent} The clone.
   */
  function clone(extent, opt_extent) {
      if (opt_extent) {
          opt_extent[0] = extent[0];
          opt_extent[1] = extent[1];
          opt_extent[2] = extent[2];
          opt_extent[3] = extent[3];
          return opt_extent;
      }
      else {
          return extent.slice();
      }
  }
  /**
   * @param {Extent} extent Extent.
   * @param {number} x X.
   * @param {number} y Y.
   * @return {number} Closest squared distance.
   */
  function closestSquaredDistanceXY(extent, x, y) {
      var dx, dy;
      if (x < extent[0]) {
          dx = extent[0] - x;
      }
      else if (extent[2] < x) {
          dx = x - extent[2];
      }
      else {
          dx = 0;
      }
      if (y < extent[1]) {
          dy = extent[1] - y;
      }
      else if (extent[3] < y) {
          dy = y - extent[3];
      }
      else {
          dy = 0;
      }
      return dx * dx + dy * dy;
  }
  /**
   * Check if the passed coordinate is contained or on the edge of the extent.
   *
   * @param {Extent} extent Extent.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} The coordinate is contained in the extent.
   * @api
   */
  function containsCoordinate(extent, coordinate) {
      return containsXY(extent, coordinate[0], coordinate[1]);
  }
  /**
   * Check if one extent contains another.
   *
   * An extent is deemed contained if it lies completely within the other extent,
   * including if they share one or more edges.
   *
   * @param {Extent} extent1 Extent 1.
   * @param {Extent} extent2 Extent 2.
   * @return {boolean} The second extent is contained by or on the edge of the
   *     first.
   * @api
   */
  function containsExtent(extent1, extent2) {
      return (extent1[0] <= extent2[0] &&
          extent2[2] <= extent1[2] &&
          extent1[1] <= extent2[1] &&
          extent2[3] <= extent1[3]);
  }
  /**
   * Check if the passed coordinate is contained or on the edge of the extent.
   *
   * @param {Extent} extent Extent.
   * @param {number} x X coordinate.
   * @param {number} y Y coordinate.
   * @return {boolean} The x, y values are contained in the extent.
   * @api
   */
  function containsXY(extent, x, y) {
      return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
  }
  /**
   * Get the relationship between a coordinate and extent.
   * @param {Extent} extent The extent.
   * @param {import("./coordinate.js").Coordinate} coordinate The coordinate.
   * @return {import("./extent/Relationship.js").default} The relationship (bitwise compare with
   *     import("./extent/Relationship.js").Relationship).
   */
  function coordinateRelationship(extent, coordinate) {
      var minX = extent[0];
      var minY = extent[1];
      var maxX = extent[2];
      var maxY = extent[3];
      var x = coordinate[0];
      var y = coordinate[1];
      var relationship = Relationship.UNKNOWN;
      if (x < minX) {
          relationship = relationship | Relationship.LEFT;
      }
      else if (x > maxX) {
          relationship = relationship | Relationship.RIGHT;
      }
      if (y < minY) {
          relationship = relationship | Relationship.BELOW;
      }
      else if (y > maxY) {
          relationship = relationship | Relationship.ABOVE;
      }
      if (relationship === Relationship.UNKNOWN) {
          relationship = Relationship.INTERSECTING;
      }
      return relationship;
  }
  /**
   * Create an empty extent.
   * @return {Extent} Empty extent.
   * @api
   */
  function createEmpty() {
      return [Infinity, Infinity, -Infinity, -Infinity];
  }
  /**
   * Create a new extent or update the provided extent.
   * @param {number} minX Minimum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxX Maximum X.
   * @param {number} maxY Maximum Y.
   * @param {Extent=} opt_extent Destination extent.
   * @return {Extent} Extent.
   */
  function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {
      if (opt_extent) {
          opt_extent[0] = minX;
          opt_extent[1] = minY;
          opt_extent[2] = maxX;
          opt_extent[3] = maxY;
          return opt_extent;
      }
      else {
          return [minX, minY, maxX, maxY];
      }
  }
  /**
   * Create a new empty extent or make the provided one empty.
   * @param {Extent=} opt_extent Extent.
   * @return {Extent} Extent.
   */
  function createOrUpdateEmpty(opt_extent) {
      return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);
  }
  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {Extent=} opt_extent Extent.
   * @return {Extent} Extent.
   */
  function createOrUpdateFromCoordinate(coordinate, opt_extent) {
      var x = coordinate[0];
      var y = coordinate[1];
      return createOrUpdate(x, y, x, y, opt_extent);
  }
  /**
   * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {Extent=} opt_extent Extent.
   * @return {Extent} Extent.
   */
  function createOrUpdateFromCoordinates(coordinates, opt_extent) {
      var extent = createOrUpdateEmpty(opt_extent);
      return extendCoordinates(extent, coordinates);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {Extent=} opt_extent Extent.
   * @return {Extent} Extent.
   */
  function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {
      var extent = createOrUpdateEmpty(opt_extent);
      return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
  }
  /**
   * Determine if two extents are equivalent.
   * @param {Extent} extent1 Extent 1.
   * @param {Extent} extent2 Extent 2.
   * @return {boolean} The two extents are equivalent.
   * @api
   */
  function equals$1(extent1, extent2) {
      return (extent1[0] == extent2[0] &&
          extent1[2] == extent2[2] &&
          extent1[1] == extent2[1] &&
          extent1[3] == extent2[3]);
  }
  /**
   * Modify an extent to include another extent.
   * @param {Extent} extent1 The extent to be modified.
   * @param {Extent} extent2 The extent that will be included in the first.
   * @return {Extent} A reference to the first (extended) extent.
   * @api
   */
  function extend$1(extent1, extent2) {
      if (extent2[0] < extent1[0]) {
          extent1[0] = extent2[0];
      }
      if (extent2[2] > extent1[2]) {
          extent1[2] = extent2[2];
      }
      if (extent2[1] < extent1[1]) {
          extent1[1] = extent2[1];
      }
      if (extent2[3] > extent1[3]) {
          extent1[3] = extent2[3];
      }
      return extent1;
  }
  /**
   * @param {Extent} extent Extent.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   */
  function extendCoordinate(extent, coordinate) {
      if (coordinate[0] < extent[0]) {
          extent[0] = coordinate[0];
      }
      if (coordinate[0] > extent[2]) {
          extent[2] = coordinate[0];
      }
      if (coordinate[1] < extent[1]) {
          extent[1] = coordinate[1];
      }
      if (coordinate[1] > extent[3]) {
          extent[3] = coordinate[1];
      }
  }
  /**
   * @param {Extent} extent Extent.
   * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
   * @return {Extent} Extent.
   */
  function extendCoordinates(extent, coordinates) {
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
          extendCoordinate(extent, coordinates[i]);
      }
      return extent;
  }
  /**
   * @param {Extent} extent Extent.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @return {Extent} Extent.
   */
  function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
      for (; offset < end; offset += stride) {
          extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
      }
      return extent;
  }
  /**
   * @param {Extent} extent Extent.
   * @param {number} x X.
   * @param {number} y Y.
   */
  function extendXY(extent, x, y) {
      extent[0] = Math.min(extent[0], x);
      extent[1] = Math.min(extent[1], y);
      extent[2] = Math.max(extent[2], x);
      extent[3] = Math.max(extent[3], y);
  }
  /**
   * This function calls `callback` for each corner of the extent. If the
   * callback returns a truthy value the function returns that value
   * immediately. Otherwise the function returns `false`.
   * @param {Extent} extent Extent.
   * @param {function(import("./coordinate.js").Coordinate): S} callback Callback.
   * @return {S|boolean} Value.
   * @template S
   */
  function forEachCorner(extent, callback) {
      var val;
      val = callback(getBottomLeft(extent));
      if (val) {
          return val;
      }
      val = callback(getBottomRight(extent));
      if (val) {
          return val;
      }
      val = callback(getTopRight(extent));
      if (val) {
          return val;
      }
      val = callback(getTopLeft(extent));
      if (val) {
          return val;
      }
      return false;
  }
  /**
   * Get the size of an extent.
   * @param {Extent} extent Extent.
   * @return {number} Area.
   * @api
   */
  function getArea(extent) {
      var area = 0;
      if (!isEmpty(extent)) {
          area = getWidth(extent) * getHeight(extent);
      }
      return area;
  }
  /**
   * Get the bottom left coordinate of an extent.
   * @param {Extent} extent Extent.
   * @return {import("./coordinate.js").Coordinate} Bottom left coordinate.
   * @api
   */
  function getBottomLeft(extent) {
      return [extent[0], extent[1]];
  }
  /**
   * Get the bottom right coordinate of an extent.
   * @param {Extent} extent Extent.
   * @return {import("./coordinate.js").Coordinate} Bottom right coordinate.
   * @api
   */
  function getBottomRight(extent) {
      return [extent[2], extent[1]];
  }
  /**
   * Get the center coordinate of an extent.
   * @param {Extent} extent Extent.
   * @return {import("./coordinate.js").Coordinate} Center.
   * @api
   */
  function getCenter(extent) {
      return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
  }
  /**
   * Get a corner coordinate of an extent.
   * @param {Extent} extent Extent.
   * @param {import("./extent/Corner.js").default} corner Corner.
   * @return {import("./coordinate.js").Coordinate} Corner coordinate.
   */
  function getCorner(extent, corner) {
      var coordinate;
      if (corner === Corner.BOTTOM_LEFT) {
          coordinate = getBottomLeft(extent);
      }
      else if (corner === Corner.BOTTOM_RIGHT) {
          coordinate = getBottomRight(extent);
      }
      else if (corner === Corner.TOP_LEFT) {
          coordinate = getTopLeft(extent);
      }
      else if (corner === Corner.TOP_RIGHT) {
          coordinate = getTopRight(extent);
      }
      else {
          assert(false, 13); // Invalid corner
      }
      return coordinate;
  }
  /**
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @param {Extent=} opt_extent Destination extent.
   * @return {Extent} Extent.
   */
  function getForViewAndSize(center, resolution, rotation, size, opt_extent) {
      var dx = (resolution * size[0]) / 2;
      var dy = (resolution * size[1]) / 2;
      var cosRotation = Math.cos(rotation);
      var sinRotation = Math.sin(rotation);
      var xCos = dx * cosRotation;
      var xSin = dx * sinRotation;
      var yCos = dy * cosRotation;
      var ySin = dy * sinRotation;
      var x = center[0];
      var y = center[1];
      var x0 = x - xCos + ySin;
      var x1 = x - xCos - ySin;
      var x2 = x + xCos - ySin;
      var x3 = x + xCos + ySin;
      var y0 = y - xSin - yCos;
      var y1 = y - xSin + yCos;
      var y2 = y + xSin + yCos;
      var y3 = y + xSin - yCos;
      return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);
  }
  /**
   * Get the height of an extent.
   * @param {Extent} extent Extent.
   * @return {number} Height.
   * @api
   */
  function getHeight(extent) {
      return extent[3] - extent[1];
  }
  /**
   * Get the intersection of two extents.
   * @param {Extent} extent1 Extent 1.
   * @param {Extent} extent2 Extent 2.
   * @param {Extent=} opt_extent Optional extent to populate with intersection.
   * @return {Extent} Intersecting extent.
   * @api
   */
  function getIntersection(extent1, extent2, opt_extent) {
      var intersection = opt_extent ? opt_extent : createEmpty();
      if (intersects(extent1, extent2)) {
          if (extent1[0] > extent2[0]) {
              intersection[0] = extent1[0];
          }
          else {
              intersection[0] = extent2[0];
          }
          if (extent1[1] > extent2[1]) {
              intersection[1] = extent1[1];
          }
          else {
              intersection[1] = extent2[1];
          }
          if (extent1[2] < extent2[2]) {
              intersection[2] = extent1[2];
          }
          else {
              intersection[2] = extent2[2];
          }
          if (extent1[3] < extent2[3]) {
              intersection[3] = extent1[3];
          }
          else {
              intersection[3] = extent2[3];
          }
      }
      else {
          createOrUpdateEmpty(intersection);
      }
      return intersection;
  }
  /**
   * Get the top left coordinate of an extent.
   * @param {Extent} extent Extent.
   * @return {import("./coordinate.js").Coordinate} Top left coordinate.
   * @api
   */
  function getTopLeft(extent) {
      return [extent[0], extent[3]];
  }
  /**
   * Get the top right coordinate of an extent.
   * @param {Extent} extent Extent.
   * @return {import("./coordinate.js").Coordinate} Top right coordinate.
   * @api
   */
  function getTopRight(extent) {
      return [extent[2], extent[3]];
  }
  /**
   * Get the width of an extent.
   * @param {Extent} extent Extent.
   * @return {number} Width.
   * @api
   */
  function getWidth(extent) {
      return extent[2] - extent[0];
  }
  /**
   * Determine if one extent intersects another.
   * @param {Extent} extent1 Extent 1.
   * @param {Extent} extent2 Extent.
   * @return {boolean} The two extents intersect.
   * @api
   */
  function intersects(extent1, extent2) {
      return (extent1[0] <= extent2[2] &&
          extent1[2] >= extent2[0] &&
          extent1[1] <= extent2[3] &&
          extent1[3] >= extent2[1]);
  }
  /**
   * Determine if an extent is empty.
   * @param {Extent} extent Extent.
   * @return {boolean} Is empty.
   * @api
   */
  function isEmpty(extent) {
      return extent[2] < extent[0] || extent[3] < extent[1];
  }
  /**
   * @param {Extent} extent Extent.
   * @param {Extent=} opt_extent Extent.
   * @return {Extent} Extent.
   */
  function returnOrUpdate(extent, opt_extent) {
      if (opt_extent) {
          opt_extent[0] = extent[0];
          opt_extent[1] = extent[1];
          opt_extent[2] = extent[2];
          opt_extent[3] = extent[3];
          return opt_extent;
      }
      else {
          return extent;
      }
  }
  /**
   * @param {Extent} extent Extent.
   * @param {number} value Value.
   */
  function scaleFromCenter(extent, value) {
      var deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);
      var deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);
      extent[0] -= deltaX;
      extent[2] += deltaX;
      extent[1] -= deltaY;
      extent[3] += deltaY;
  }
  /**
   * Determine if the segment between two coordinates intersects (crosses,
   * touches, or is contained by) the provided extent.
   * @param {Extent} extent The extent.
   * @param {import("./coordinate.js").Coordinate} start Segment start coordinate.
   * @param {import("./coordinate.js").Coordinate} end Segment end coordinate.
   * @return {boolean} The segment intersects the extent.
   */
  function intersectsSegment(extent, start, end) {
      var intersects = false;
      var startRel = coordinateRelationship(extent, start);
      var endRel = coordinateRelationship(extent, end);
      if (startRel === Relationship.INTERSECTING ||
          endRel === Relationship.INTERSECTING) {
          intersects = true;
      }
      else {
          var minX = extent[0];
          var minY = extent[1];
          var maxX = extent[2];
          var maxY = extent[3];
          var startX = start[0];
          var startY = start[1];
          var endX = end[0];
          var endY = end[1];
          var slope = (endY - startY) / (endX - startX);
          var x = void 0, y = void 0;
          if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {
              // potentially intersects top
              x = endX - (endY - maxY) / slope;
              intersects = x >= minX && x <= maxX;
          }
          if (!intersects &&
              !!(endRel & Relationship.RIGHT) &&
              !(startRel & Relationship.RIGHT)) {
              // potentially intersects right
              y = endY - (endX - maxX) * slope;
              intersects = y >= minY && y <= maxY;
          }
          if (!intersects &&
              !!(endRel & Relationship.BELOW) &&
              !(startRel & Relationship.BELOW)) {
              // potentially intersects bottom
              x = endX - (endY - minY) / slope;
              intersects = x >= minX && x <= maxX;
          }
          if (!intersects &&
              !!(endRel & Relationship.LEFT) &&
              !(startRel & Relationship.LEFT)) {
              // potentially intersects left
              y = endY - (endX - minX) * slope;
              intersects = y >= minY && y <= maxY;
          }
      }
      return intersects;
  }
  /**
   * Apply a transform function to the extent.
   * @param {Extent} extent Extent.
   * @param {import("./proj.js").TransformFunction} transformFn Transform function.
   * Called with `[minX, minY, maxX, maxY]` extent coordinates.
   * @param {Extent=} opt_extent Destination extent.
   * @param {number=} opt_stops Number of stops per side used for the transform.
   * By default only the corners are used.
   * @return {Extent} Extent.
   * @api
   */
  function applyTransform(extent, transformFn, opt_extent, opt_stops) {
      var coordinates = [];
      if (opt_stops > 1) {
          var width = extent[2] - extent[0];
          var height = extent[3] - extent[1];
          for (var i = 0; i < opt_stops; ++i) {
              coordinates.push(extent[0] + (width * i) / opt_stops, extent[1], extent[2], extent[1] + (height * i) / opt_stops, extent[2] - (width * i) / opt_stops, extent[3], extent[0], extent[3] - (height * i) / opt_stops);
          }
      }
      else {
          coordinates = [
              extent[0],
              extent[1],
              extent[2],
              extent[1],
              extent[2],
              extent[3],
              extent[0],
              extent[3],
          ];
      }
      transformFn(coordinates, coordinates, 2);
      var xs = [];
      var ys = [];
      for (var i = 0, l = coordinates.length; i < l; i += 2) {
          xs.push(coordinates[i]);
          ys.push(coordinates[i + 1]);
      }
      return _boundingExtentXYs(xs, ys, opt_extent);
  }
  /**
   * Modifies the provided extent in-place to be within the real world
   * extent.
   *
   * @param {Extent} extent Extent.
   * @param {import("./proj/Projection.js").default} projection Projection
   * @return {Extent} The extent within the real world extent.
   */
  function wrapX(extent, projection) {
      var projectionExtent = projection.getExtent();
      var center = getCenter(extent);
      if (projection.canWrapX() &&
          (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
          var worldWidth = getWidth(projectionExtent);
          var worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);
          var offset = worldsAway * worldWidth;
          extent[0] -= offset;
          extent[2] -= offset;
      }
      return extent;
  }

  /**
   * @module ol/math
   */
  /**
   * Takes a number and clamps it to within the provided bounds.
   * @param {number} value The input number.
   * @param {number} min The minimum value to return.
   * @param {number} max The maximum value to return.
   * @return {number} The input number if it is within bounds, or the nearest
   *     number within the bounds.
   */
  function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
  }
  /**
   * Return the hyperbolic cosine of a given number. The method will use the
   * native `Math.cosh` function if it is available, otherwise the hyperbolic
   * cosine will be calculated via the reference implementation of the Mozilla
   * developer network.
   *
   * @param {number} x X.
   * @return {number} Hyperbolic cosine of x.
   */
  var cosh = (function () {
      // Wrapped in a iife, to save the overhead of checking for the native
      // implementation on every invocation.
      var cosh;
      if ('cosh' in Math) {
          // The environment supports the native Math.cosh function, use it…
          cosh = Math.cosh;
      }
      else {
          // … else, use the reference implementation of MDN:
          cosh = function (x) {
              var y = /** @type {Math} */ (Math).exp(x);
              return (y + 1 / y) / 2;
          };
      }
      return cosh;
  })();
  /**
   * Return the base 2 logarithm of a given number. The method will use the
   * native `Math.log2` function if it is available, otherwise the base 2
   * logarithm will be calculated via the reference implementation of the
   * Mozilla developer network.
   *
   * @param {number} x X.
   * @return {number} Base 2 logarithm of x.
   */
  var log2 = (function () {
      // Wrapped in a iife, to save the overhead of checking for the native
      // implementation on every invocation.
      var log2;
      if ('log2' in Math) {
          // The environment supports the native Math.log2 function, use it…
          log2 = Math.log2;
      }
      else {
          // … else, use the reference implementation of MDN:
          log2 = function (x) {
              return Math.log(x) * Math.LOG2E;
          };
      }
      return log2;
  })();
  /**
   * Returns the square of the closest distance between the point (x, y) and the
   * line segment (x1, y1) to (x2, y2).
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} x1 X1.
   * @param {number} y1 Y1.
   * @param {number} x2 X2.
   * @param {number} y2 Y2.
   * @return {number} Squared distance.
   */
  function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
      var dx = x2 - x1;
      var dy = y2 - y1;
      if (dx !== 0 || dy !== 0) {
          var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
          if (t > 1) {
              x1 = x2;
              y1 = y2;
          }
          else if (t > 0) {
              x1 += dx * t;
              y1 += dy * t;
          }
      }
      return squaredDistance(x, y, x1, y1);
  }
  /**
   * Returns the square of the distance between the points (x1, y1) and (x2, y2).
   * @param {number} x1 X1.
   * @param {number} y1 Y1.
   * @param {number} x2 X2.
   * @param {number} y2 Y2.
   * @return {number} Squared distance.
   */
  function squaredDistance(x1, y1, x2, y2) {
      var dx = x2 - x1;
      var dy = y2 - y1;
      return dx * dx + dy * dy;
  }
  /**
   * Solves system of linear equations using Gaussian elimination method.
   *
   * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)
   *                                     in row-major order.
   * @return {Array<number>} The resulting vector.
   */
  function solveLinearSystem(mat) {
      var n = mat.length;
      for (var i = 0; i < n; i++) {
          // Find max in the i-th column (ignoring i - 1 first rows)
          var maxRow = i;
          var maxEl = Math.abs(mat[i][i]);
          for (var r = i + 1; r < n; r++) {
              var absValue = Math.abs(mat[r][i]);
              if (absValue > maxEl) {
                  maxEl = absValue;
                  maxRow = r;
              }
          }
          if (maxEl === 0) {
              return null; // matrix is singular
          }
          // Swap max row with i-th (current) row
          var tmp = mat[maxRow];
          mat[maxRow] = mat[i];
          mat[i] = tmp;
          // Subtract the i-th row to make all the remaining rows 0 in the i-th column
          for (var j = i + 1; j < n; j++) {
              var coef = -mat[j][i] / mat[i][i];
              for (var k = i; k < n + 1; k++) {
                  if (i == k) {
                      mat[j][k] = 0;
                  }
                  else {
                      mat[j][k] += coef * mat[i][k];
                  }
              }
          }
      }
      // Solve Ax=b for upper triangular matrix A (mat)
      var x = new Array(n);
      for (var l = n - 1; l >= 0; l--) {
          x[l] = mat[l][n] / mat[l][l];
          for (var m = l - 1; m >= 0; m--) {
              mat[m][n] -= mat[m][l] * x[l];
          }
      }
      return x;
  }
  /**
   * Converts degrees to radians.
   *
   * @param {number} angleInDegrees Angle in degrees.
   * @return {number} Angle in radians.
   */
  function toRadians(angleInDegrees) {
      return (angleInDegrees * Math.PI) / 180;
  }
  /**
   * Returns the modulo of a / b, depending on the sign of b.
   *
   * @param {number} a Dividend.
   * @param {number} b Divisor.
   * @return {number} Modulo.
   */
  function modulo(a, b) {
      var r = a % b;
      return r * b < 0 ? r + b : r;
  }
  /**
   * Calculates the linearly interpolated value of x between a and b.
   *
   * @param {number} a Number
   * @param {number} b Number
   * @param {number} x Value to be interpolated.
   * @return {number} Interpolated value.
   */
  function lerp(a, b, x) {
      return a + x * (b - a);
  }

  /**
   * @module ol/color
   */
  /**
   * A color represented as a short array [red, green, blue, alpha].
   * red, green, and blue should be integers in the range 0..255 inclusive.
   * alpha should be a float in the range 0..1 inclusive. If no alpha value is
   * given then `1` will be used.
   * @typedef {Array<number>} Color
   * @api
   */
  /**
   * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.
   * @const
   * @type {RegExp}
   * @private
   */
  var HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;
  /**
   * Regular expression for matching potential named color style strings.
   * @const
   * @type {RegExp}
   * @private
   */
  var NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\(.*\)$/i;
  /**
   * Return the color as an rgba string.
   * @param {Color|string} color Color.
   * @return {string} Rgba string.
   * @api
   */
  function asString(color) {
      if (typeof color === 'string') {
          return color;
      }
      else {
          return toString$1(color);
      }
  }
  /**
   * Return named color as an rgba string.
   * @param {string} color Named color.
   * @return {string} Rgb string.
   */
  function fromNamed(color) {
      var el = document.createElement('div');
      el.style.color = color;
      if (el.style.color !== '') {
          document.body.appendChild(el);
          var rgb = getComputedStyle(el).color;
          document.body.removeChild(el);
          return rgb;
      }
      else {
          return '';
      }
  }
  /**
   * @param {string} s String.
   * @return {Color} Color.
   */
  var fromString = (function () {
      // We maintain a small cache of parsed strings.  To provide cheap LRU-like
      // semantics, whenever the cache grows too large we simply delete an
      // arbitrary 25% of the entries.
      /**
       * @const
       * @type {number}
       */
      var MAX_CACHE_SIZE = 1024;
      /**
       * @type {Object<string, Color>}
       */
      var cache = {};
      /**
       * @type {number}
       */
      var cacheSize = 0;
      return (
      /**
       * @param {string} s String.
       * @return {Color} Color.
       */
      function (s) {
          var color;
          if (cache.hasOwnProperty(s)) {
              color = cache[s];
          }
          else {
              if (cacheSize >= MAX_CACHE_SIZE) {
                  var i = 0;
                  for (var key in cache) {
                      if ((i++ & 3) === 0) {
                          delete cache[key];
                          --cacheSize;
                      }
                  }
              }
              color = fromStringInternal_(s);
              cache[s] = color;
              ++cacheSize;
          }
          return color;
      });
  })();
  /**
   * Return the color as an array. This function maintains a cache of calculated
   * arrays which means the result should not be modified.
   * @param {Color|string} color Color.
   * @return {Color} Color.
   * @api
   */
  function asArray(color) {
      if (Array.isArray(color)) {
          return color;
      }
      else {
          return fromString(color);
      }
  }
  /**
   * @param {string} s String.
   * @private
   * @return {Color} Color.
   */
  function fromStringInternal_(s) {
      var r, g, b, a, color;
      if (NAMED_COLOR_RE_.exec(s)) {
          s = fromNamed(s);
      }
      if (HEX_COLOR_RE_.exec(s)) {
          // hex
          var n = s.length - 1; // number of hex digits
          var d = // number of digits per channel
           void 0; // number of digits per channel
          if (n <= 4) {
              d = 1;
          }
          else {
              d = 2;
          }
          var hasAlpha = n === 4 || n === 8;
          r = parseInt(s.substr(1 + 0 * d, d), 16);
          g = parseInt(s.substr(1 + 1 * d, d), 16);
          b = parseInt(s.substr(1 + 2 * d, d), 16);
          if (hasAlpha) {
              a = parseInt(s.substr(1 + 3 * d, d), 16);
          }
          else {
              a = 255;
          }
          if (d == 1) {
              r = (r << 4) + r;
              g = (g << 4) + g;
              b = (b << 4) + b;
              if (hasAlpha) {
                  a = (a << 4) + a;
              }
          }
          color = [r, g, b, a / 255];
      }
      else if (s.indexOf('rgba(') == 0) {
          // rgba()
          color = s.slice(5, -1).split(',').map(Number);
          normalize(color);
      }
      else if (s.indexOf('rgb(') == 0) {
          // rgb()
          color = s.slice(4, -1).split(',').map(Number);
          color.push(1);
          normalize(color);
      }
      else {
          assert(false, 14); // Invalid color
      }
      return color;
  }
  /**
   * TODO this function is only used in the test, we probably shouldn't export it
   * @param {Color} color Color.
   * @return {Color} Clamped color.
   */
  function normalize(color) {
      color[0] = clamp((color[0] + 0.5) | 0, 0, 255);
      color[1] = clamp((color[1] + 0.5) | 0, 0, 255);
      color[2] = clamp((color[2] + 0.5) | 0, 0, 255);
      color[3] = clamp(color[3], 0, 1);
      return color;
  }
  /**
   * @param {Color} color Color.
   * @return {string} String.
   */
  function toString$1(color) {
      var r = color[0];
      if (r != (r | 0)) {
          r = (r + 0.5) | 0;
      }
      var g = color[1];
      if (g != (g | 0)) {
          g = (g + 0.5) | 0;
      }
      var b = color[2];
      if (b != (b | 0)) {
          b = (b + 0.5) | 0;
      }
      var a = color[3] === undefined ? 1 : color[3];
      return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
  }

  /**
   * @module ol/style/IconImageCache
   */
  /**
   * @classdesc
   * Singleton class. Available through {@link module:ol/style/IconImageCache~shared}.
   */
  var IconImageCache = /** @class */ (function () {
      function IconImageCache() {
          /**
           * @type {!Object<string, import("./IconImage.js").default>}
           * @private
           */
          this.cache_ = {};
          /**
           * @type {number}
           * @private
           */
          this.cacheSize_ = 0;
          /**
           * @type {number}
           * @private
           */
          this.maxCacheSize_ = 32;
      }
      /**
       * FIXME empty description for jsdoc
       */
      IconImageCache.prototype.clear = function () {
          this.cache_ = {};
          this.cacheSize_ = 0;
      };
      /**
       * @return {boolean} Can expire cache.
       */
      IconImageCache.prototype.canExpireCache = function () {
          return this.cacheSize_ > this.maxCacheSize_;
      };
      /**
       * FIXME empty description for jsdoc
       */
      IconImageCache.prototype.expire = function () {
          if (this.canExpireCache()) {
              var i = 0;
              for (var key in this.cache_) {
                  var iconImage = this.cache_[key];
                  if ((i++ & 3) === 0 && !iconImage.hasListener()) {
                      delete this.cache_[key];
                      --this.cacheSize_;
                  }
              }
          }
      };
      /**
       * @param {string} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../color.js").Color} color Color.
       * @return {import("./IconImage.js").default} Icon image.
       */
      IconImageCache.prototype.get = function (src, crossOrigin, color) {
          var key = getKey(src, crossOrigin, color);
          return key in this.cache_ ? this.cache_[key] : null;
      };
      /**
       * @param {string} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../color.js").Color} color Color.
       * @param {import("./IconImage.js").default} iconImage Icon image.
       */
      IconImageCache.prototype.set = function (src, crossOrigin, color, iconImage) {
          var key = getKey(src, crossOrigin, color);
          this.cache_[key] = iconImage;
          ++this.cacheSize_;
      };
      /**
       * Set the cache size of the icon cache. Default is `32`. Change this value when
       * your map uses more than 32 different icon images and you are not caching icon
       * styles on the application level.
       * @param {number} maxCacheSize Cache max size.
       * @api
       */
      IconImageCache.prototype.setSize = function (maxCacheSize) {
          this.maxCacheSize_ = maxCacheSize;
          this.expire();
      };
      return IconImageCache;
  }());
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color} color Color.
   * @return {string} Cache key.
   */
  function getKey(src, crossOrigin, color) {
      var colorString = color ? asString(color) : 'null';
      return crossOrigin + ':' + src + ':' + colorString;
  }
  /**
   * The {@link module:ol/style/IconImageCache~IconImageCache} for
   * {@link module:ol/style/Icon~Icon} images.
   * @api
   */
  var shared = new IconImageCache();

  /**
   * @module ol/events/Event
   */
  /**
   * @classdesc
   * Stripped down implementation of the W3C DOM Level 2 Event interface.
   * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.
   *
   * This implementation only provides `type` and `target` properties, and
   * `stopPropagation` and `preventDefault` methods. It is meant as base class
   * for higher level events defined in the library, and works with
   * {@link module:ol/events/Target~Target}.
   */
  var BaseEvent = /** @class */ (function () {
      /**
       * @param {string} type Type.
       */
      function BaseEvent(type) {
          /**
           * @type {boolean}
           */
          this.propagationStopped;
          /**
           * The event type.
           * @type {string}
           * @api
           */
          this.type = type;
          /**
           * The event target.
           * @type {Object}
           * @api
           */
          this.target = null;
      }
      /**
       * Stop event propagation.
       * @api
       */
      BaseEvent.prototype.preventDefault = function () {
          this.propagationStopped = true;
      };
      /**
       * Stop event propagation.
       * @api
       */
      BaseEvent.prototype.stopPropagation = function () {
          this.propagationStopped = true;
      };
      return BaseEvent;
  }());

  /**
   * @module ol/ObjectEventType
   */
  /**
   * @enum {string}
   */
  var ObjectEventType = {
      /**
       * Triggered when a property is changed.
       * @event module:ol/Object.ObjectEvent#propertychange
       * @api
       */
      PROPERTYCHANGE: 'propertychange',
  };

  /**
   * @module ol/obj
   */
  /**
   * Polyfill for Object.assign().  Assigns enumerable and own properties from
   * one or more source objects to a target object.
   * See https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign.
   *
   * @param {!Object} target The target object.
   * @param {...Object} var_sources The source object(s).
   * @return {!Object} The modified target object.
   */
  var assign = typeof Object.assign === 'function'
      ? Object.assign
      : function (target, var_sources) {
          if (target === undefined || target === null) {
              throw new TypeError('Cannot convert undefined or null to object');
          }
          var output = Object(target);
          for (var i = 1, ii = arguments.length; i < ii; ++i) {
              var source = arguments[i];
              if (source !== undefined && source !== null) {
                  for (var key in source) {
                      if (source.hasOwnProperty(key)) {
                          output[key] = source[key];
                      }
                  }
              }
          }
          return output;
      };
  /**
   * Removes all properties from an object.
   * @param {Object} object The object to clear.
   */
  function clear(object) {
      for (var property in object) {
          delete object[property];
      }
  }
  /**
   * Polyfill for Object.values().  Get an array of property values from an object.
   * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values
   *
   * @param {!Object<K,V>} object The object from which to get the values.
   * @return {!Array<V>} The property values.
   * @template K,V
   */
  var getValues = typeof Object.values === 'function'
      ? Object.values
      : function (object) {
          var values = [];
          for (var property in object) {
              values.push(object[property]);
          }
          return values;
      };
  /**
   * Determine if an object has any properties.
   * @param {Object} object The object to check.
   * @return {boolean} The object is empty.
   */
  function isEmpty$1(object) {
      var property;
      for (property in object) {
          return false;
      }
      return !property;
  }

  var __extends$1 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {EventTarget|Target} EventTargetLike
   */
  /**
   * @classdesc
   * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
   * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.
   *
   * There are two important simplifications compared to the specification:
   *
   * 1. The handling of `useCapture` in `addEventListener` and
   *    `removeEventListener`. There is no real capture model.
   * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
   *    There is no event target hierarchy. When a listener calls
   *    `stopPropagation` or `preventDefault` on an event object, it means that no
   *    more listeners after this one will be called. Same as when the listener
   *    returns false.
   */
  var Target = /** @class */ (function (_super) {
      __extends$1(Target, _super);
      /**
       * @param {*=} opt_target Default event target for dispatched events.
       */
      function Target(opt_target) {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {*}
           */
          _this.eventTarget_ = opt_target;
          /**
           * @private
           * @type {Object<string, number>}
           */
          _this.pendingRemovals_ = null;
          /**
           * @private
           * @type {Object<string, number>}
           */
          _this.dispatching_ = null;
          /**
           * @private
           * @type {Object<string, Array<import("../events.js").Listener>>}
           */
          _this.listeners_ = null;
          return _this;
      }
      /**
       * @param {string} type Type.
       * @param {import("../events.js").Listener} listener Listener.
       */
      Target.prototype.addEventListener = function (type, listener) {
          if (!type || !listener) {
              return;
          }
          var listeners = this.listeners_ || (this.listeners_ = {});
          var listenersForType = listeners[type] || (listeners[type] = []);
          if (listenersForType.indexOf(listener) === -1) {
              listenersForType.push(listener);
          }
      };
      /**
       * Dispatches an event and calls all listeners listening for events
       * of this type. The event parameter can either be a string or an
       * Object with a `type` property.
       *
       * @param {import("./Event.js").default|string} event Event object.
       * @return {boolean|undefined} `false` if anyone called preventDefault on the
       *     event object or if any of the listeners returned false.
       * @api
       */
      Target.prototype.dispatchEvent = function (event) {
          /** @type {import("./Event.js").default|Event} */
          var evt = typeof event === 'string' ? new BaseEvent(event) : event;
          var type = evt.type;
          if (!evt.target) {
              evt.target = this.eventTarget_ || this;
          }
          var listeners = this.listeners_ && this.listeners_[type];
          var propagate;
          if (listeners) {
              var dispatching = this.dispatching_ || (this.dispatching_ = {});
              var pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
              if (!(type in dispatching)) {
                  dispatching[type] = 0;
                  pendingRemovals[type] = 0;
              }
              ++dispatching[type];
              for (var i = 0, ii = listeners.length; i < ii; ++i) {
                  if ('handleEvent' in listeners[i]) {
                      propagate = /** @type {import("../events.js").ListenerObject} */ (listeners[i]).handleEvent(evt);
                  }
                  else {
                      propagate = /** @type {import("../events.js").ListenerFunction} */ (listeners[i]).call(this, evt);
                  }
                  if (propagate === false || evt.propagationStopped) {
                      propagate = false;
                      break;
                  }
              }
              --dispatching[type];
              if (dispatching[type] === 0) {
                  var pr = pendingRemovals[type];
                  delete pendingRemovals[type];
                  while (pr--) {
                      this.removeEventListener(type, VOID);
                  }
                  delete dispatching[type];
              }
              return propagate;
          }
      };
      /**
       * Clean up.
       */
      Target.prototype.disposeInternal = function () {
          this.listeners_ && clear(this.listeners_);
      };
      /**
       * Get the listeners for a specified event type. Listeners are returned in the
       * order that they will be called in.
       *
       * @param {string} type Type.
       * @return {Array<import("../events.js").Listener>|undefined} Listeners.
       */
      Target.prototype.getListeners = function (type) {
          return (this.listeners_ && this.listeners_[type]) || undefined;
      };
      /**
       * @param {string=} opt_type Type. If not provided,
       *     `true` will be returned if this event target has any listeners.
       * @return {boolean} Has listeners.
       */
      Target.prototype.hasListener = function (opt_type) {
          if (!this.listeners_) {
              return false;
          }
          return opt_type
              ? opt_type in this.listeners_
              : Object.keys(this.listeners_).length > 0;
      };
      /**
       * @param {string} type Type.
       * @param {import("../events.js").Listener} listener Listener.
       */
      Target.prototype.removeEventListener = function (type, listener) {
          var listeners = this.listeners_ && this.listeners_[type];
          if (listeners) {
              var index = listeners.indexOf(listener);
              if (index !== -1) {
                  if (this.pendingRemovals_ && type in this.pendingRemovals_) {
                      // make listener a no-op, and remove later in #dispatchEvent()
                      listeners[index] = VOID;
                      ++this.pendingRemovals_[type];
                  }
                  else {
                      listeners.splice(index, 1);
                      if (listeners.length === 0) {
                          delete this.listeners_[type];
                      }
                  }
              }
          }
      };
      return Target;
  }(Disposable));

  /**
   * @module ol/events/EventType
   */
  /**
   * @enum {string}
   * @const
   */
  var EventType = {
      /**
       * Generic change event. Triggered when the revision counter is increased.
       * @event module:ol/events/Event~BaseEvent#change
       * @api
       */
      CHANGE: 'change',
      /**
       * Generic error event. Triggered when an error occurs.
       * @event module:ol/events/Event~BaseEvent#error
       * @api
       */
      ERROR: 'error',
      BLUR: 'blur',
      CLEAR: 'clear',
      CONTEXTMENU: 'contextmenu',
      CLICK: 'click',
      DBLCLICK: 'dblclick',
      DRAGENTER: 'dragenter',
      DRAGOVER: 'dragover',
      DROP: 'drop',
      FOCUS: 'focus',
      KEYDOWN: 'keydown',
      KEYPRESS: 'keypress',
      LOAD: 'load',
      RESIZE: 'resize',
      TOUCHMOVE: 'touchmove',
      WHEEL: 'wheel',
  };

  /**
   * @module ol/events
   */
  /**
   * Key to use with {@link module:ol/Observable~Observable#unByKey}.
   * @typedef {Object} EventsKey
   * @property {ListenerFunction} listener
   * @property {import("./events/Target.js").EventTargetLike} target
   * @property {string} type
   * @api
   */
  /**
   * Listener function. This function is called with an event object as argument.
   * When the function returns `false`, event propagation will stop.
   *
   * @typedef {function((Event|import("./events/Event.js").default)): (void|boolean)} ListenerFunction
   * @api
   */
  /**
   * @typedef {Object} ListenerObject
   * @property {ListenerFunction} handleEvent
   */
  /**
   * @typedef {ListenerFunction|ListenerObject} Listener
   */
  /**
   * Registers an event listener on an event target. Inspired by
   * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
   *
   * This function efficiently binds a `listener` to a `this` object, and returns
   * a key for use with {@link module:ol/events~unlistenByKey}.
   *
   * @param {import("./events/Target.js").EventTargetLike} target Event target.
   * @param {string} type Event type.
   * @param {ListenerFunction} listener Listener.
   * @param {Object=} opt_this Object referenced by the `this` keyword in the
   *     listener. Default is the `target`.
   * @param {boolean=} opt_once If true, add the listener as one-off listener.
   * @return {EventsKey} Unique key for the listener.
   */
  function listen(target, type, listener, opt_this, opt_once) {
      if (opt_this && opt_this !== target) {
          listener = listener.bind(opt_this);
      }
      if (opt_once) {
          var originalListener_1 = listener;
          listener = function () {
              target.removeEventListener(type, listener);
              originalListener_1.apply(this, arguments);
          };
      }
      var eventsKey = {
          target: target,
          type: type,
          listener: listener,
      };
      target.addEventListener(type, listener);
      return eventsKey;
  }
  /**
   * Registers a one-off event listener on an event target. Inspired by
   * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
   *
   * This function efficiently binds a `listener` as self-unregistering listener
   * to a `this` object, and returns a key for use with
   * {@link module:ol/events~unlistenByKey} in case the listener needs to be
   * unregistered before it is called.
   *
   * When {@link module:ol/events~listen} is called with the same arguments after this
   * function, the self-unregistering listener will be turned into a permanent
   * listener.
   *
   * @param {import("./events/Target.js").EventTargetLike} target Event target.
   * @param {string} type Event type.
   * @param {ListenerFunction} listener Listener.
   * @param {Object=} opt_this Object referenced by the `this` keyword in the
   *     listener. Default is the `target`.
   * @return {EventsKey} Key for unlistenByKey.
   */
  function listenOnce(target, type, listener, opt_this) {
      return listen(target, type, listener, opt_this, true);
  }
  /**
   * Unregisters event listeners on an event target. Inspired by
   * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
   *
   * The argument passed to this function is the key returned from
   * {@link module:ol/events~listen} or {@link module:ol/events~listenOnce}.
   *
   * @param {EventsKey} key The key.
   */
  function unlistenByKey(key) {
      if (key && key.target) {
          key.target.removeEventListener(key.type, key.listener);
          clear(key);
      }
  }

  var __extends$2 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * An event target providing convenient methods for listener registration
   * and unregistration. A generic `change` event is always available through
   * {@link module:ol/Observable~Observable#changed}.
   *
   * @fires import("./events/Event.js").default
   * @api
   */
  var Observable = /** @class */ (function (_super) {
      __extends$2(Observable, _super);
      function Observable() {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {number}
           */
          _this.revision_ = 0;
          return _this;
      }
      /**
       * Increases the revision counter and dispatches a 'change' event.
       * @api
       */
      Observable.prototype.changed = function () {
          ++this.revision_;
          this.dispatchEvent(EventType.CHANGE);
      };
      /**
       * Get the version number for this object.  Each time the object is modified,
       * its version number will be incremented.
       * @return {number} Revision.
       * @api
       */
      Observable.prototype.getRevision = function () {
          return this.revision_;
      };
      /**
       * Listen for a certain type of event.
       * @param {string|Array<string>} type The event type or array of event types.
       * @param {function(?): ?} listener The listener function.
       * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
       *     called with an array of event types as the first argument, the return
       *     will be an array of keys.
       * @api
       */
      Observable.prototype.on = function (type, listener) {
          if (Array.isArray(type)) {
              var len = type.length;
              var keys = new Array(len);
              for (var i = 0; i < len; ++i) {
                  keys[i] = listen(this, type[i], listener);
              }
              return keys;
          }
          else {
              return listen(this, /** @type {string} */ (type), listener);
          }
      };
      /**
       * Listen once for a certain type of event.
       * @param {string|Array<string>} type The event type or array of event types.
       * @param {function(?): ?} listener The listener function.
       * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
       *     called with an array of event types as the first argument, the return
       *     will be an array of keys.
       * @api
       */
      Observable.prototype.once = function (type, listener) {
          var key;
          if (Array.isArray(type)) {
              var len = type.length;
              key = new Array(len);
              for (var i = 0; i < len; ++i) {
                  key[i] = listenOnce(this, type[i], listener);
              }
          }
          else {
              key = listenOnce(this, /** @type {string} */ (type), listener);
          }
          /** @type {Object} */ (listener).ol_key = key;
          return key;
      };
      /**
       * Unlisten for a certain type of event.
       * @param {string|Array<string>} type The event type or array of event types.
       * @param {function(?): ?} listener The listener function.
       * @api
       */
      Observable.prototype.un = function (type, listener) {
          var key = /** @type {Object} */ (listener).ol_key;
          if (key) {
              unByKey(key);
          }
          else if (Array.isArray(type)) {
              for (var i = 0, ii = type.length; i < ii; ++i) {
                  this.removeEventListener(type[i], listener);
              }
          }
          else {
              this.removeEventListener(type, listener);
          }
      };
      return Observable;
  }(Target));
  /**
   * Removes an event listener using the key returned by `on()` or `once()`.
   * @param {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} key The key returned by `on()`
   *     or `once()` (or an array of keys).
   * @api
   */
  function unByKey(key) {
      if (Array.isArray(key)) {
          for (var i = 0, ii = key.length; i < ii; ++i) {
              unlistenByKey(key[i]);
          }
      }
      else {
          unlistenByKey(/** @type {import("./events.js").EventsKey} */ (key));
      }
  }

  var __extends$3 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.
   */
  var ObjectEvent = /** @class */ (function (_super) {
      __extends$3(ObjectEvent, _super);
      /**
       * @param {string} type The event type.
       * @param {string} key The property name.
       * @param {*} oldValue The old value for `key`.
       */
      function ObjectEvent(type, key, oldValue) {
          var _this = _super.call(this, type) || this;
          /**
           * The name of the property whose value is changing.
           * @type {string}
           * @api
           */
          _this.key = key;
          /**
           * The old value. To get the new value use `e.target.get(e.key)` where
           * `e` is the event object.
           * @type {*}
           * @api
           */
          _this.oldValue = oldValue;
          return _this;
      }
      return ObjectEvent;
  }(BaseEvent));
  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * Most non-trivial classes inherit from this.
   *
   * This extends {@link module:ol/Observable} with observable
   * properties, where each property is observable as well as the object as a
   * whole.
   *
   * Classes that inherit from this have pre-defined properties, to which you can
   * add your owns. The pre-defined properties are listed in this documentation as
   * 'Observable Properties', and have their own accessors; for example,
   * {@link module:ol/Map~Map} has a `target` property, accessed with
   * `getTarget()` and changed with `setTarget()`. Not all properties are however
   * settable. There are also general-purpose accessors `get()` and `set()`. For
   * example, `get('target')` is equivalent to `getTarget()`.
   *
   * The `set` accessors trigger a change event, and you can monitor this by
   * registering a listener. For example, {@link module:ol/View~View} has a
   * `center` property, so `view.on('change:center', function(evt) {...});` would
   * call the function whenever the value of the center property changes. Within
   * the function, `evt.target` would be the view, so `evt.target.getCenter()`
   * would return the new center.
   *
   * You can add your own observable properties with
   * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
   * You can listen for changes on that property value with
   * `object.on('change:prop', listener)`. You can get a list of all
   * properties with {@link module:ol/Object~BaseObject#getProperties}.
   *
   * Note that the observable properties are separate from standard JS properties.
   * You can, for example, give your map object a title with
   * `map.title='New title'` and with `map.set('title', 'Another title')`. The
   * first will be a `hasOwnProperty`; the second will appear in
   * `getProperties()`. Only the second is observable.
   *
   * Properties can be deleted by using the unset method. E.g.
   * object.unset('foo').
   *
   * @fires ObjectEvent
   * @api
   */
  var BaseObject = /** @class */ (function (_super) {
      __extends$3(BaseObject, _super);
      /**
       * @param {Object<string, *>=} opt_values An object with key-value pairs.
       */
      function BaseObject(opt_values) {
          var _this = _super.call(this) || this;
          // Call {@link module:ol/util~getUid} to ensure that the order of objects' ids is
          // the same as the order in which they were created.  This also helps to
          // ensure that object properties are always added in the same order, which
          // helps many JavaScript engines generate faster code.
          getUid(_this);
          /**
           * @private
           * @type {Object<string, *>}
           */
          _this.values_ = null;
          if (opt_values !== undefined) {
              _this.setProperties(opt_values);
          }
          return _this;
      }
      /**
       * Gets a value.
       * @param {string} key Key name.
       * @return {*} Value.
       * @api
       */
      BaseObject.prototype.get = function (key) {
          var value;
          if (this.values_ && this.values_.hasOwnProperty(key)) {
              value = this.values_[key];
          }
          return value;
      };
      /**
       * Get a list of object property names.
       * @return {Array<string>} List of property names.
       * @api
       */
      BaseObject.prototype.getKeys = function () {
          return (this.values_ && Object.keys(this.values_)) || [];
      };
      /**
       * Get an object of all property names and values.
       * @return {Object<string, *>} Object.
       * @api
       */
      BaseObject.prototype.getProperties = function () {
          return (this.values_ && assign({}, this.values_)) || {};
      };
      /**
       * @return {boolean} The object has properties.
       */
      BaseObject.prototype.hasProperties = function () {
          return !!this.values_;
      };
      /**
       * @param {string} key Key name.
       * @param {*} oldValue Old value.
       */
      BaseObject.prototype.notify = function (key, oldValue) {
          var eventType;
          eventType = getChangeEventType(key);
          this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
          eventType = ObjectEventType.PROPERTYCHANGE;
          this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
      };
      /**
       * Sets a value.
       * @param {string} key Key name.
       * @param {*} value Value.
       * @param {boolean=} opt_silent Update without triggering an event.
       * @api
       */
      BaseObject.prototype.set = function (key, value, opt_silent) {
          var values = this.values_ || (this.values_ = {});
          if (opt_silent) {
              values[key] = value;
          }
          else {
              var oldValue = values[key];
              values[key] = value;
              if (oldValue !== value) {
                  this.notify(key, oldValue);
              }
          }
      };
      /**
       * Sets a collection of key-value pairs.  Note that this changes any existing
       * properties and adds new ones (it does not remove any existing properties).
       * @param {Object<string, *>} values Values.
       * @param {boolean=} opt_silent Update without triggering an event.
       * @api
       */
      BaseObject.prototype.setProperties = function (values, opt_silent) {
          for (var key in values) {
              this.set(key, values[key], opt_silent);
          }
      };
      /**
       * Unsets a property.
       * @param {string} key Key name.
       * @param {boolean=} opt_silent Unset without triggering an event.
       * @api
       */
      BaseObject.prototype.unset = function (key, opt_silent) {
          if (this.values_ && key in this.values_) {
              var oldValue = this.values_[key];
              delete this.values_[key];
              if (isEmpty$1(this.values_)) {
                  this.values_ = null;
              }
              if (!opt_silent) {
                  this.notify(key, oldValue);
              }
          }
      };
      return BaseObject;
  }(Observable));
  /**
   * @type {Object<string, string>}
   */
  var changeEventTypeCache = {};
  /**
   * @param {string} key Key name.
   * @return {string} Change name.
   */
  function getChangeEventType(key) {
      return changeEventTypeCache.hasOwnProperty(key)
          ? changeEventTypeCache[key]
          : (changeEventTypeCache[key] = 'change:' + key);
  }

  /**
   * @module ol/layer/Property
   */
  /**
   * @enum {string}
   */
  var LayerProperty = {
      OPACITY: 'opacity',
      VISIBLE: 'visible',
      EXTENT: 'extent',
      Z_INDEX: 'zIndex',
      MAX_RESOLUTION: 'maxResolution',
      MIN_RESOLUTION: 'minResolution',
      MAX_ZOOM: 'maxZoom',
      MIN_ZOOM: 'minZoom',
      SOURCE: 'source',
  };

  var __extends$4 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
   * @property {number} [opacity=1] Opacity (0, 1).
   * @property {boolean} [visible=true] Visibility.
   * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
   * rendered outside of this extent.
   * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
   * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
   * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
   * method was used.
   * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
   * visible.
   * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
   * be visible.
   * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
   * visible.
   * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
   * be visible.
   */
  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * Note that with {@link module:ol/layer/Base} and all its subclasses, any property set in
   * the options is set as a {@link module:ol/Object} property on the layer object, so
   * is observable, and has get/set accessors.
   *
   * @api
   */
  var BaseLayer = /** @class */ (function (_super) {
      __extends$4(BaseLayer, _super);
      /**
       * @param {Options} options Layer options.
       */
      function BaseLayer(options) {
          var _this = _super.call(this) || this;
          /**
           * @type {Object<string, *>}
           */
          var properties = assign({}, options);
          properties[LayerProperty.OPACITY] =
              options.opacity !== undefined ? options.opacity : 1;
          assert(typeof properties[LayerProperty.OPACITY] === 'number', 64); // Layer opacity must be a number
          properties[LayerProperty.VISIBLE] =
              options.visible !== undefined ? options.visible : true;
          properties[LayerProperty.Z_INDEX] = options.zIndex;
          properties[LayerProperty.MAX_RESOLUTION] =
              options.maxResolution !== undefined ? options.maxResolution : Infinity;
          properties[LayerProperty.MIN_RESOLUTION] =
              options.minResolution !== undefined ? options.minResolution : 0;
          properties[LayerProperty.MIN_ZOOM] =
              options.minZoom !== undefined ? options.minZoom : -Infinity;
          properties[LayerProperty.MAX_ZOOM] =
              options.maxZoom !== undefined ? options.maxZoom : Infinity;
          /**
           * @type {string}
           * @private
           */
          _this.className_ =
              properties.className !== undefined ? options.className : 'ol-layer';
          delete properties.className;
          _this.setProperties(properties);
          /**
           * @type {import("./Layer.js").State}
           * @private
           */
          _this.state_ = null;
          return _this;
      }
      /**
       * @return {string} CSS class name.
       */
      BaseLayer.prototype.getClassName = function () {
          return this.className_;
      };
      /**
       * This method is not meant to be called by layers or layer renderers because the state
       * is incorrect if the layer is included in a layer group.
       *
       * @param {boolean=} opt_managed Layer is managed.
       * @return {import("./Layer.js").State} Layer state.
       */
      BaseLayer.prototype.getLayerState = function (opt_managed) {
          /** @type {import("./Layer.js").State} */
          var state = this.state_ ||
              /** @type {?} */ ({
                  layer: this,
                  managed: opt_managed === undefined ? true : opt_managed,
              });
          var zIndex = this.getZIndex();
          state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);
          state.sourceState = this.getSourceState();
          state.visible = this.getVisible();
          state.extent = this.getExtent();
          state.zIndex =
              zIndex !== undefined ? zIndex : state.managed === false ? Infinity : 0;
          state.maxResolution = this.getMaxResolution();
          state.minResolution = Math.max(this.getMinResolution(), 0);
          state.minZoom = this.getMinZoom();
          state.maxZoom = this.getMaxZoom();
          this.state_ = state;
          return state;
      };
      /**
       * @abstract
       * @param {Array<import("./Layer.js").default>=} opt_array Array of layers (to be
       *     modified in place).
       * @return {Array<import("./Layer.js").default>} Array of layers.
       */
      BaseLayer.prototype.getLayersArray = function (opt_array) {
          return abstract();
      };
      /**
       * @abstract
       * @param {Array<import("./Layer.js").State>=} opt_states Optional list of layer
       *     states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       */
      BaseLayer.prototype.getLayerStatesArray = function (opt_states) {
          return abstract();
      };
      /**
       * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
       * will be visible regardless of extent.
       * @return {import("../extent.js").Extent|undefined} The layer extent.
       * @observable
       * @api
       */
      BaseLayer.prototype.getExtent = function () {
          return /** @type {import("../extent.js").Extent|undefined} */ (this.get(LayerProperty.EXTENT));
      };
      /**
       * Return the maximum resolution of the layer.
       * @return {number} The maximum resolution of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.getMaxResolution = function () {
          return /** @type {number} */ (this.get(LayerProperty.MAX_RESOLUTION));
      };
      /**
       * Return the minimum resolution of the layer.
       * @return {number} The minimum resolution of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.getMinResolution = function () {
          return /** @type {number} */ (this.get(LayerProperty.MIN_RESOLUTION));
      };
      /**
       * Return the minimum zoom level of the layer.
       * @return {number} The minimum zoom level of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.getMinZoom = function () {
          return /** @type {number} */ (this.get(LayerProperty.MIN_ZOOM));
      };
      /**
       * Return the maximum zoom level of the layer.
       * @return {number} The maximum zoom level of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.getMaxZoom = function () {
          return /** @type {number} */ (this.get(LayerProperty.MAX_ZOOM));
      };
      /**
       * Return the opacity of the layer (between 0 and 1).
       * @return {number} The opacity of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.getOpacity = function () {
          return /** @type {number} */ (this.get(LayerProperty.OPACITY));
      };
      /**
       * @abstract
       * @return {import("../source/State.js").default} Source state.
       */
      BaseLayer.prototype.getSourceState = function () {
          return abstract();
      };
      /**
       * Return the visibility of the layer (`true` or `false`).
       * @return {boolean} The visibility of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.getVisible = function () {
          return /** @type {boolean} */ (this.get(LayerProperty.VISIBLE));
      };
      /**
       * Return the Z-index of the layer, which is used to order layers before
       * rendering. The default Z-index is 0.
       * @return {number} The Z-index of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.getZIndex = function () {
          return /** @type {number} */ (this.get(LayerProperty.Z_INDEX));
      };
      /**
       * Set the extent at which the layer is visible.  If `undefined`, the layer
       * will be visible at all extents.
       * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.setExtent = function (extent) {
          this.set(LayerProperty.EXTENT, extent);
      };
      /**
       * Set the maximum resolution at which the layer is visible.
       * @param {number} maxResolution The maximum resolution of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.setMaxResolution = function (maxResolution) {
          this.set(LayerProperty.MAX_RESOLUTION, maxResolution);
      };
      /**
       * Set the minimum resolution at which the layer is visible.
       * @param {number} minResolution The minimum resolution of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.setMinResolution = function (minResolution) {
          this.set(LayerProperty.MIN_RESOLUTION, minResolution);
      };
      /**
       * Set the maximum zoom (exclusive) at which the layer is visible.
       * Note that the zoom levels for layer visibility are based on the
       * view zoom level, which may be different from a tile source zoom level.
       * @param {number} maxZoom The maximum zoom of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.setMaxZoom = function (maxZoom) {
          this.set(LayerProperty.MAX_ZOOM, maxZoom);
      };
      /**
       * Set the minimum zoom (inclusive) at which the layer is visible.
       * Note that the zoom levels for layer visibility are based on the
       * view zoom level, which may be different from a tile source zoom level.
       * @param {number} minZoom The minimum zoom of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.setMinZoom = function (minZoom) {
          this.set(LayerProperty.MIN_ZOOM, minZoom);
      };
      /**
       * Set the opacity of the layer, allowed values range from 0 to 1.
       * @param {number} opacity The opacity of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.setOpacity = function (opacity) {
          assert(typeof opacity === 'number', 64); // Layer opacity must be a number
          this.set(LayerProperty.OPACITY, opacity);
      };
      /**
       * Set the visibility of the layer (`true` or `false`).
       * @param {boolean} visible The visibility of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.setVisible = function (visible) {
          this.set(LayerProperty.VISIBLE, visible);
      };
      /**
       * Set Z-index of the layer, which is used to order layers before rendering.
       * The default Z-index is 0.
       * @param {number} zindex The z-index of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.setZIndex = function (zindex) {
          this.set(LayerProperty.Z_INDEX, zindex);
      };
      /**
       * Clean up.
       */
      BaseLayer.prototype.disposeInternal = function () {
          if (this.state_) {
              this.state_.layer = null;
              this.state_ = null;
          }
          _super.prototype.disposeInternal.call(this);
      };
      return BaseLayer;
  }(BaseObject));

  /**
   * @module ol/render/EventType
   */
  /**
   * @enum {string}
   */
  var EventType$1 = {
      /**
       * Triggered before a layer is rendered.
       * @event module:ol/render/Event~RenderEvent#prerender
       * @api
       */
      PRERENDER: 'prerender',
      /**
       * Triggered after a layer is rendered.
       * @event module:ol/render/Event~RenderEvent#postrender
       * @api
       */
      POSTRENDER: 'postrender',
      /**
       * Triggered before layers are rendered.
       * The event object will not have a `context` set.
       * @event module:ol/render/Event~RenderEvent#precompose
       * @api
       */
      PRECOMPOSE: 'precompose',
      /**
       * Triggered after all layers are rendered.
       * The event object will not have a `context` set.
       * @event module:ol/render/Event~RenderEvent#postcompose
       * @api
       */
      POSTCOMPOSE: 'postcompose',
      /**
       * Triggered when rendering is complete, i.e. all sources and tiles have
       * finished loading for the current viewport, and all tiles are faded in.
       * The event object will not have a `context` set.
       * @event module:ol/render/Event~RenderEvent#rendercomplete
       * @api
       */
      RENDERCOMPLETE: 'rendercomplete',
  };

  /**
   * @module ol/source/State
   */
  /**
   * @enum {string}
   * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
   */
  var SourceState = {
      UNDEFINED: 'undefined',
      LOADING: 'loading',
      READY: 'ready',
      ERROR: 'error',
  };

  var __extends$5 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {function(import("../PluggableMap.js").FrameState):HTMLElement} RenderFunction
   */
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
   * @property {number} [opacity=1] Opacity (0, 1).
   * @property {boolean} [visible=true] Visibility.
   * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
   * rendered outside of this extent.
   * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
   * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
   * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
   * method was used.
   * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
   * visible.
   * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
   * be visible.
   * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
   * visible.
   * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
   * be visible.
   * @property {import("../source/Source.js").default} [source] Source for this layer.  If not provided to the constructor,
   * the source can be set by calling {@link module:ol/layer/Layer#setSource layer.setSource(source)} after
   * construction.
   * @property {import("../PluggableMap.js").default} [map] Map.
   * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an
   * HTML element. Will overwrite the default rendering for the layer.
   */
  /**
   * @typedef {Object} State
   * @property {import("./Layer.js").default} layer
   * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.
   * @property {import("../source/State.js").default} sourceState
   * @property {boolean} visible
   * @property {boolean} managed
   * @property {import("../extent.js").Extent} [extent]
   * @property {number} zIndex
   * @property {number} maxResolution
   * @property {number} minResolution
   * @property {number} minZoom
   * @property {number} maxZoom
   */
  /**
   * @classdesc
   * Base class from which all layer types are derived. This should only be instantiated
   * in the case where a custom layer is be added to the map with a custom `render` function.
   * Such a function can be specified in the `options` object, and is expected to return an HTML element.
   *
   * A visual representation of raster or vector map data.
   * Layers group together those properties that pertain to how the data is to be
   * displayed, irrespective of the source of that data.
   *
   * Layers are usually added to a map with {@link module:ol/Map#addLayer}. Components
   * like {@link module:ol/interaction/Select~Select} use unmanaged layers
   * internally. These unmanaged layers are associated with the map using
   * {@link module:ol/layer/Layer~Layer#setMap} instead.
   *
   * A generic `change` event is fired when the state of the source changes.
   *
   * Please note that for performance reasons several layers might get rendered to
   * the same HTML element, which will cause {@link module:ol/Map~Map#forEachLayerAtPixel} to
   * give false positives. To avoid this, apply different `className` properties to the
   * layers at creation time.
   *
   * @fires import("../render/Event.js").RenderEvent#prerender
   * @fires import("../render/Event.js").RenderEvent#postrender
   *
   * @template {import("../source/Source.js").default} SourceType
   * @api
   */
  var Layer = /** @class */ (function (_super) {
      __extends$5(Layer, _super);
      /**
       * @param {Options} options Layer options.
       */
      function Layer(options) {
          var _this = this;
          var baseOptions = assign({}, options);
          delete baseOptions.source;
          _this = _super.call(this, baseOptions) || this;
          /**
           * @private
           * @type {?import("../events.js").EventsKey}
           */
          _this.mapPrecomposeKey_ = null;
          /**
           * @private
           * @type {?import("../events.js").EventsKey}
           */
          _this.mapRenderKey_ = null;
          /**
           * @private
           * @type {?import("../events.js").EventsKey}
           */
          _this.sourceChangeKey_ = null;
          /**
           * @private
           * @type {import("../renderer/Layer.js").default}
           */
          _this.renderer_ = null;
          // Overwrite default render method with a custom one
          if (options.render) {
              _this.render = options.render;
          }
          if (options.map) {
              _this.setMap(options.map);
          }
          _this.addEventListener(getChangeEventType(LayerProperty.SOURCE), _this.handleSourcePropertyChange_);
          var source = options.source
              ? /** @type {SourceType} */ (options.source)
              : null;
          _this.setSource(source);
          return _this;
      }
      /**
       * @param {Array<import("./Layer.js").default>=} opt_array Array of layers (to be modified in place).
       * @return {Array<import("./Layer.js").default>} Array of layers.
       */
      Layer.prototype.getLayersArray = function (opt_array) {
          var array = opt_array ? opt_array : [];
          array.push(this);
          return array;
      };
      /**
       * @param {Array<import("./Layer.js").State>=} opt_states Optional list of layer states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       */
      Layer.prototype.getLayerStatesArray = function (opt_states) {
          var states = opt_states ? opt_states : [];
          states.push(this.getLayerState());
          return states;
      };
      /**
       * Get the layer source.
       * @return {SourceType} The layer source (or `null` if not yet set).
       * @observable
       * @api
       */
      Layer.prototype.getSource = function () {
          return /** @type {SourceType} */ (this.get(LayerProperty.SOURCE)) || null;
      };
      /**
       * @return {import("../source/State.js").default} Source state.
       */
      Layer.prototype.getSourceState = function () {
          var source = this.getSource();
          return !source ? SourceState.UNDEFINED : source.getState();
      };
      /**
       * @private
       */
      Layer.prototype.handleSourceChange_ = function () {
          this.changed();
      };
      /**
       * @private
       */
      Layer.prototype.handleSourcePropertyChange_ = function () {
          if (this.sourceChangeKey_) {
              unlistenByKey(this.sourceChangeKey_);
              this.sourceChangeKey_ = null;
          }
          var source = this.getSource();
          if (source) {
              this.sourceChangeKey_ = listen(source, EventType.CHANGE, this.handleSourceChange_, this);
          }
          this.changed();
      };
      /**
       * @param {import("../pixel").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
       * an array of features.
       */
      Layer.prototype.getFeatures = function (pixel) {
          return this.renderer_.getFeatures(pixel);
      };
      /**
       * In charge to manage the rendering of the layer. One layer type is
       * bounded with one layer renderer.
       * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target which the renderer may (but need not) use
       * for rendering its content.
       * @return {HTMLElement} The rendered element.
       */
      Layer.prototype.render = function (frameState, target) {
          var layerRenderer = this.getRenderer();
          if (layerRenderer.prepareFrame(frameState)) {
              return layerRenderer.renderFrame(frameState, target);
          }
      };
      /**
       * Sets the layer to be rendered on top of other layers on a map. The map will
       * not manage this layer in its layers collection, and the callback in
       * {@link module:ol/Map#forEachLayerAtPixel} will receive `null` as layer. This
       * is useful for temporary layers. To remove an unmanaged layer from the map,
       * use `#setMap(null)`.
       *
       * To add the layer to a map and have it managed by the map, use
       * {@link module:ol/Map#addLayer} instead.
       * @param {import("../PluggableMap.js").default} map Map.
       * @api
       */
      Layer.prototype.setMap = function (map) {
          if (this.mapPrecomposeKey_) {
              unlistenByKey(this.mapPrecomposeKey_);
              this.mapPrecomposeKey_ = null;
          }
          if (!map) {
              this.changed();
          }
          if (this.mapRenderKey_) {
              unlistenByKey(this.mapRenderKey_);
              this.mapRenderKey_ = null;
          }
          if (map) {
              this.mapPrecomposeKey_ = listen(map, EventType$1.PRECOMPOSE, function (evt) {
                  var renderEvent = /** @type {import("../render/Event.js").default} */ (evt);
                  var layerStatesArray = renderEvent.frameState.layerStatesArray;
                  var layerState = this.getLayerState(false);
                  // A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.
                  assert(!layerStatesArray.some(function (arrayLayerState) {
                      return arrayLayerState.layer === layerState.layer;
                  }), 67);
                  layerStatesArray.push(layerState);
              }, this);
              this.mapRenderKey_ = listen(this, EventType.CHANGE, map.render, map);
              this.changed();
          }
      };
      /**
       * Set the layer source.
       * @param {SourceType} source The layer source.
       * @observable
       * @api
       */
      Layer.prototype.setSource = function (source) {
          this.set(LayerProperty.SOURCE, source);
      };
      /**
       * Get the renderer for this layer.
       * @return {import("../renderer/Layer.js").default} The layer renderer.
       */
      Layer.prototype.getRenderer = function () {
          if (!this.renderer_) {
              this.renderer_ = this.createRenderer();
          }
          return this.renderer_;
      };
      /**
       * @return {boolean} The layer has a renderer.
       */
      Layer.prototype.hasRenderer = function () {
          return !!this.renderer_;
      };
      /**
       * Create a renderer for this layer.
       * @return {import("../renderer/Layer.js").default} A layer renderer.
       * @protected
       */
      Layer.prototype.createRenderer = function () {
          return null;
      };
      /**
       * Clean up.
       */
      Layer.prototype.disposeInternal = function () {
          this.setSource(null);
          _super.prototype.disposeInternal.call(this);
      };
      return Layer;
  }(BaseLayer));
  /**
   * Return `true` if the layer is visible and if the provided view state
   * has resolution and zoom levels that are in range of the layer's min/max.
   * @param {State} layerState Layer state.
   * @param {import("../View.js").State} viewState View state.
   * @return {boolean} The layer is visible at the given view state.
   */
  function inView(layerState, viewState) {
      if (!layerState.visible) {
          return false;
      }
      var resolution = viewState.resolution;
      if (resolution < layerState.minResolution ||
          resolution >= layerState.maxResolution) {
          return false;
      }
      var zoom = viewState.zoom;
      return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
  }

  /**
   * @module ol/geom/GeometryType
   */
  /**
   * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,
   * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
   * `'GeometryCollection'`, `'Circle'`.
   * @enum {string}
   */
  var GeometryType = {
      POINT: 'Point',
      LINE_STRING: 'LineString',
      LINEAR_RING: 'LinearRing',
      POLYGON: 'Polygon',
      MULTI_POINT: 'MultiPoint',
      MULTI_LINE_STRING: 'MultiLineString',
      MULTI_POLYGON: 'MultiPolygon',
      GEOMETRY_COLLECTION: 'GeometryCollection',
      CIRCLE: 'Circle',
  };

  /**
   * @module ol/render/VectorContext
   */
  /**
   * @classdesc
   * Context for drawing geometries.  A vector context is available on render
   * events and does not need to be constructed directly.
   * @api
   */
  var VectorContext = /** @class */ (function () {
      function VectorContext() {
      }
      /**
       * Render a geometry with a custom renderer.
       *
       * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {Function} renderer Renderer.
       */
      VectorContext.prototype.drawCustom = function (geometry, feature, renderer) { };
      /**
       * Render a geometry.
       *
       * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
       */
      VectorContext.prototype.drawGeometry = function (geometry) { };
      /**
       * Set the rendering style.
       *
       * @param {import("../style/Style.js").default} style The rendering style.
       */
      VectorContext.prototype.setStyle = function (style) { };
      /**
       * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
       * @param {import("../Feature.js").default} feature Feature.
       */
      VectorContext.prototype.drawCircle = function (circleGeometry, feature) { };
      /**
       * @param {import("../Feature.js").default} feature Feature.
       * @param {import("../style/Style.js").default} style Style.
       */
      VectorContext.prototype.drawFeature = function (feature, style) { };
      /**
       * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
       * @param {import("../Feature.js").default} feature Feature.
       */
      VectorContext.prototype.drawGeometryCollection = function (geometryCollectionGeometry, feature) { };
      /**
       * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      VectorContext.prototype.drawLineString = function (lineStringGeometry, feature) { };
      /**
       * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      VectorContext.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) { };
      /**
       * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      VectorContext.prototype.drawMultiPoint = function (multiPointGeometry, feature) { };
      /**
       * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      VectorContext.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) { };
      /**
       * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      VectorContext.prototype.drawPoint = function (pointGeometry, feature) { };
      /**
       * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      VectorContext.prototype.drawPolygon = function (polygonGeometry, feature) { };
      /**
       * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      VectorContext.prototype.drawText = function (geometry, feature) { };
      /**
       * @param {import("../style/Fill.js").default} fillStyle Fill style.
       * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
       */
      VectorContext.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) { };
      /**
       * @param {import("../style/Image.js").default} imageStyle Image style.
       * @param {import("./canvas.js").DeclutterGroup=} opt_declutterGroup Declutter.
       */
      VectorContext.prototype.setImageStyle = function (imageStyle, opt_declutterGroup) { };
      /**
       * @param {import("../style/Text.js").default} textStyle Text style.
       * @param {import("./canvas.js").DeclutterGroups=} opt_declutterGroups Declutter.
       */
      VectorContext.prototype.setTextStyle = function (textStyle, opt_declutterGroups) { };
      return VectorContext;
  }());

  /**
   * @module ol/colorlike
   */
  /**
   * A type accepted by CanvasRenderingContext2D.fillStyle
   * or CanvasRenderingContext2D.strokeStyle.
   * Represents a color, pattern, or gradient. The origin for patterns and
   * gradients as fill style is an increment of 512 css pixels from map coordinate
   * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image
   * must be a factor of two (2, 4, 8, ..., 512).
   *
   * @typedef {string|CanvasPattern|CanvasGradient} ColorLike
   * @api
   */
  /**
   * @param {import("./color.js").Color|ColorLike} color Color.
   * @return {ColorLike} The color as an {@link ol/colorlike~ColorLike}.
   * @api
   */
  function asColorLike(color) {
      if (Array.isArray(color)) {
          return toString$1(color);
      }
      else {
          return color;
      }
  }

  /**
   * @module ol/has
   */
  var ua = typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined'
      ? navigator.userAgent.toLowerCase()
      : '';
  /**
   * User agent string says we are dealing with Firefox as browser.
   * @type {boolean}
   */
  var FIREFOX = ua.indexOf('firefox') !== -1;
  /**
   * User agent string says we are dealing with Safari as browser.
   * @type {boolean}
   */
  var SAFARI = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') == -1;
  /**
   * User agent string says we are dealing with a WebKit engine.
   * @type {boolean}
   */
  var WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1;
  /**
   * User agent string says we are dealing with a Mac as platform.
   * @type {boolean}
   */
  var MAC = ua.indexOf('macintosh') !== -1;
  /**
   * The ratio between physical pixels and device-independent pixels
   * (dips) on the device (`window.devicePixelRatio`).
   * @const
   * @type {number}
   * @api
   */
  var DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1;
  /**
   * The execution context is a worker with OffscreenCanvas available.
   * @const
   * @type {boolean}
   */
  var WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== 'undefined' &&
      typeof OffscreenCanvas !== 'undefined' &&
      self instanceof WorkerGlobalScope; //eslint-disable-line
  /**
   * Image.prototype.decode() is supported.
   * @type {boolean}
   */
  var IMAGE_DECODE = typeof Image !== 'undefined' && Image.prototype.decode;
  /**
   * @type {boolean}
   */
  var PASSIVE_EVENT_LISTENERS = (function () {
      var passive = false;
      try {
          var options = Object.defineProperty({}, 'passive', {
              get: function () {
                  passive = true;
              },
          });
          window.addEventListener('_', null, options);
          window.removeEventListener('_', null, options);
      }
      catch (error) {
          // passive not supported
      }
      return passive;
  })();

  /**
   * @module ol/dom
   */
  //FIXME Move this function to the canvas module
  /**
   * Create an html canvas element and returns its 2d context.
   * @param {number=} opt_width Canvas width.
   * @param {number=} opt_height Canvas height.
   * @param {Array<HTMLCanvasElement>=} opt_canvasPool Canvas pool to take existing canvas from.
   * @return {CanvasRenderingContext2D} The context.
   */
  function createCanvasContext2D(opt_width, opt_height, opt_canvasPool) {
      var canvas = opt_canvasPool && opt_canvasPool.length
          ? opt_canvasPool.shift()
          : WORKER_OFFSCREEN_CANVAS
              ? new OffscreenCanvas(opt_width || 300, opt_height || 300)
              : document.createElement('canvas');
      if (opt_width) {
          canvas.width = opt_width;
      }
      if (opt_height) {
          canvas.height = opt_height;
      }
      //FIXME Allow OffscreenCanvasRenderingContext2D as return type
      return /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
  }
  /**
   * Get the current computed width for the given element including margin,
   * padding and border.
   * Equivalent to jQuery's `$(el).outerWidth(true)`.
   * @param {!HTMLElement} element Element.
   * @return {number} The width.
   */
  function outerWidth(element) {
      var width = element.offsetWidth;
      var style = getComputedStyle(element);
      width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
      return width;
  }
  /**
   * Get the current computed height for the given element including margin,
   * padding and border.
   * Equivalent to jQuery's `$(el).outerHeight(true)`.
   * @param {!HTMLElement} element Element.
   * @return {number} The height.
   */
  function outerHeight(element) {
      var height = element.offsetHeight;
      var style = getComputedStyle(element);
      height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
      return height;
  }
  /**
   * @param {Node} newNode Node to replace old node
   * @param {Node} oldNode The node to be replaced
   */
  function replaceNode(newNode, oldNode) {
      var parent = oldNode.parentNode;
      if (parent) {
          parent.replaceChild(newNode, oldNode);
      }
  }
  /**
   * @param {Node} node The node to remove.
   * @returns {Node} The node that was removed or null.
   */
  function removeNode(node) {
      return node && node.parentNode ? node.parentNode.removeChild(node) : null;
  }
  /**
   * @param {Node} node The node to remove the children from.
   */
  function removeChildren(node) {
      while (node.lastChild) {
          node.removeChild(node.lastChild);
      }
  }
  /**
   * Transform the children of a parent node so they match the
   * provided list of children.  This function aims to efficiently
   * remove, add, and reorder child nodes while maintaining a simple
   * implementation (it is not guaranteed to minimize DOM operations).
   * @param {Node} node The parent node whose children need reworking.
   * @param {Array<Node>} children The desired children.
   */
  function replaceChildren(node, children) {
      var oldChildren = node.childNodes;
      for (var i = 0; true; ++i) {
          var oldChild = oldChildren[i];
          var newChild = children[i];
          // check if our work is done
          if (!oldChild && !newChild) {
              break;
          }
          // check if children match
          if (oldChild === newChild) {
              continue;
          }
          // check if a new child needs to be added
          if (!oldChild) {
              node.appendChild(newChild);
              continue;
          }
          // check if an old child needs to be removed
          if (!newChild) {
              node.removeChild(oldChild);
              --i;
              continue;
          }
          // reorder
          node.insertBefore(newChild, oldChild);
      }
  }

  /**
   * @module ol/css
   */
  /**
   * @typedef {Object} FontParameters
   * @property {string} style
   * @property {string} variant
   * @property {string} weight
   * @property {string} size
   * @property {string} lineHeight
   * @property {string} family
   * @property {Array<string>} families
   */
  /**
   * The CSS class for hidden feature.
   *
   * @const
   * @type {string}
   */
  var CLASS_HIDDEN = 'ol-hidden';
  /**
   * The CSS class that we'll give the DOM elements to have them selectable.
   *
   * @const
   * @type {string}
   */
  var CLASS_SELECTABLE = 'ol-selectable';
  /**
   * The CSS class that we'll give the DOM elements to have them unselectable.
   *
   * @const
   * @type {string}
   */
  var CLASS_UNSELECTABLE = 'ol-unselectable';
  /**
   * The CSS class for controls.
   *
   * @const
   * @type {string}
   */
  var CLASS_CONTROL = 'ol-control';
  /**
   * The CSS class that we'll give the DOM elements that are collapsed, i.e.
   * to those elements which usually can be expanded.
   *
   * @const
   * @type {string}
   */
  var CLASS_COLLAPSED = 'ol-collapsed';
  /**
   * From http://stackoverflow.com/questions/10135697/regex-to-parse-any-css-font
   * @type {RegExp}
   */
  var fontRegEx = new RegExp([
      '^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)',
      '(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)',
      '(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)',
      '(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?',
      '(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))',
      '(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))',
      '?\\s*([-,\\"\\\'\\sa-z]+?)\\s*$',
  ].join(''), 'i');
  var fontRegExMatchIndex = [
      'style',
      'variant',
      'weight',
      'size',
      'lineHeight',
      'family',
  ];
  /**
   * Get the list of font families from a font spec.  Note that this doesn't work
   * for font families that have commas in them.
   * @param {string} fontSpec The CSS font property.
   * @return {FontParameters} The font parameters (or null if the input spec is invalid).
   */
  var getFontParameters = function (fontSpec) {
      var match = fontSpec.match(fontRegEx);
      if (!match) {
          return null;
      }
      var style = /** @type {FontParameters} */ ({
          lineHeight: 'normal',
          size: '1.2em',
          style: 'normal',
          weight: 'normal',
          variant: 'normal',
      });
      for (var i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i) {
          var value = match[i + 1];
          if (value !== undefined) {
              style[fontRegExMatchIndex[i]] = value;
          }
      }
      style.families = style.family.split(/,\s?/);
      return style;
  };

  /**
   * @module ol/render/canvas
   */
  /**
   * @typedef {Object} FillState
   * @property {import("../colorlike.js").ColorLike} fillStyle
   */
  /**
   * @typedef Label
   * @property {number} width
   * @property {number} height
   * @property {Array<string|number>} contextInstructions
   */
  /**
   * @typedef {Object} FillStrokeState
   * @property {import("../colorlike.js").ColorLike} [currentFillStyle]
   * @property {import("../colorlike.js").ColorLike} [currentStrokeStyle]
   * @property {CanvasLineCap} [currentLineCap]
   * @property {Array<number>} currentLineDash
   * @property {number} [currentLineDashOffset]
   * @property {CanvasLineJoin} [currentLineJoin]
   * @property {number} [currentLineWidth]
   * @property {number} [currentMiterLimit]
   * @property {number} [lastStroke]
   * @property {import("../colorlike.js").ColorLike} [fillStyle]
   * @property {import("../colorlike.js").ColorLike} [strokeStyle]
   * @property {CanvasLineCap} [lineCap]
   * @property {Array<number>} lineDash
   * @property {number} [lineDashOffset]
   * @property {CanvasLineJoin} [lineJoin]
   * @property {number} [lineWidth]
   * @property {number} [miterLimit]
   */
  /**
   * @typedef {Object} StrokeState
   * @property {CanvasLineCap} lineCap
   * @property {Array<number>} lineDash
   * @property {number} lineDashOffset
   * @property {CanvasLineJoin} lineJoin
   * @property {number} lineWidth
   * @property {number} miterLimit
   * @property {import("../colorlike.js").ColorLike} strokeStyle
   */
  /**
   * @typedef {Object} TextState
   * @property {string} font
   * @property {string} [textAlign]
   * @property {string} textBaseline
   * @property {string} [placement]
   * @property {number} [maxAngle]
   * @property {boolean} [overflow]
   * @property {import("../style/Fill.js").default} [backgroundFill]
   * @property {import("../style/Stroke.js").default} [backgroundStroke]
   * @property {import("../size.js").Size} [scale]
   * @property {Array<number>} [padding]
   */
  /**
   * Container for decluttered replay instructions that need to be rendered or
   * omitted together, i.e. when styles render both an image and text, or for the
   * characters that form text along lines. The basic elements of this array are
   * `[minX, minY, maxX, maxY, count]`, where the first four entries are the
   * rendered extent of the group in pixel space. `count` is the number of styles
   * in the group, i.e. 2 when an image and a text are grouped, or 1 otherwise.
   * In addition to these four elements, declutter instruction arrays (i.e. the
   * arguments to {@link module:ol/render/canvas~drawImage} are appended to the array.
   * @typedef {Array<*>} DeclutterGroup
   */
  /**
   * Declutter groups for support of multi geometries.
   * @typedef {Array<DeclutterGroup>} DeclutterGroups
   */
  /**
   * @const
   * @type {string}
   */
  var defaultFont = '10px sans-serif';
  /**
   * @const
   * @type {import("../colorlike.js").ColorLike}
   */
  var defaultFillStyle = '#000';
  /**
   * @const
   * @type {CanvasLineCap}
   */
  var defaultLineCap = 'round';
  /**
   * @const
   * @type {Array<number>}
   */
  var defaultLineDash = [];
  /**
   * @const
   * @type {number}
   */
  var defaultLineDashOffset = 0;
  /**
   * @const
   * @type {CanvasLineJoin}
   */
  var defaultLineJoin = 'round';
  /**
   * @const
   * @type {number}
   */
  var defaultMiterLimit = 10;
  /**
   * @const
   * @type {import("../colorlike.js").ColorLike}
   */
  var defaultStrokeStyle = '#000';
  /**
   * @const
   * @type {string}
   */
  var defaultTextAlign = 'center';
  /**
   * @const
   * @type {string}
   */
  var defaultTextBaseline = 'middle';
  /**
   * @const
   * @type {Array<number>}
   */
  var defaultPadding = [0, 0, 0, 0];
  /**
   * @const
   * @type {number}
   */
  var defaultLineWidth = 1;
  /**
   * @type {BaseObject}
   */
  var checkedFonts = new BaseObject();
  /**
   * The label cache for text rendering. To change the default cache size of 2048
   * entries, use {@link module:ol/structs/LRUCache#setSize}.
   * Deprecated - there is no label cache any more.
   * @type {?}
   * @api
   * @deprecated
   */
  var labelCache = new Target();
  labelCache.setSize = function () {
      console.warn('labelCache is deprecated.'); //eslint-disable-line
  };
  /**
   * @type {CanvasRenderingContext2D}
   */
  var measureContext = null;
  /**
   * @type {string}
   */
  var measureFont;
  /**
   * @type {!Object<string, number>}
   */
  var textHeights = {};
  /**
   * Clears the label cache when a font becomes available.
   * @param {string} fontSpec CSS font spec.
   */
  var registerFont = (function () {
      var retries = 100;
      var size = '32px ';
      var referenceFonts = ['monospace', 'serif'];
      var len = referenceFonts.length;
      var text = 'wmytzilWMYTZIL@#/&?$%10\uF013';
      var interval, referenceWidth;
      /**
       * @param {string} fontStyle Css font-style
       * @param {string} fontWeight Css font-weight
       * @param {*} fontFamily Css font-family
       * @return {boolean} Font with style and weight is available
       */
      function isAvailable(fontStyle, fontWeight, fontFamily) {
          var available = true;
          for (var i = 0; i < len; ++i) {
              var referenceFont = referenceFonts[i];
              referenceWidth = measureTextWidth(fontStyle + ' ' + fontWeight + ' ' + size + referenceFont, text);
              if (fontFamily != referenceFont) {
                  var width = measureTextWidth(fontStyle +
                      ' ' +
                      fontWeight +
                      ' ' +
                      size +
                      fontFamily +
                      ',' +
                      referenceFont, text);
                  // If width and referenceWidth are the same, then the fallback was used
                  // instead of the font we wanted, so the font is not available.
                  available = available && width != referenceWidth;
              }
          }
          if (available) {
              return true;
          }
          return false;
      }
      function check() {
          var done = true;
          var fonts = checkedFonts.getKeys();
          for (var i = 0, ii = fonts.length; i < ii; ++i) {
              var font = fonts[i];
              if (checkedFonts.get(font) < retries) {
                  if (isAvailable.apply(this, font.split('\n'))) {
                      clear(textHeights);
                      // Make sure that loaded fonts are picked up by Safari
                      measureContext = null;
                      measureFont = undefined;
                      checkedFonts.set(font, retries);
                  }
                  else {
                      checkedFonts.set(font, checkedFonts.get(font) + 1, true);
                      done = false;
                  }
              }
          }
          if (done) {
              clearInterval(interval);
              interval = undefined;
          }
      }
      return function (fontSpec) {
          var font = getFontParameters(fontSpec);
          if (!font) {
              return;
          }
          var families = font.families;
          for (var i = 0, ii = families.length; i < ii; ++i) {
              var family = families[i];
              var key = font.style + '\n' + font.weight + '\n' + family;
              if (checkedFonts.get(key) === undefined) {
                  checkedFonts.set(key, retries, true);
                  if (!isAvailable(font.style, font.weight, family)) {
                      checkedFonts.set(key, 0, true);
                      if (interval === undefined) {
                          interval = setInterval(check, 32);
                      }
                  }
              }
          }
      };
  })();
  /**
   * @param {string} font Font to use for measuring.
   * @return {import("../size.js").Size} Measurement.
   */
  var measureTextHeight = (function () {
      /**
       * @type {HTMLDivElement}
       */
      var div;
      var heights = textHeights;
      return function (fontSpec) {
          var height = heights[fontSpec];
          if (height == undefined) {
              if (WORKER_OFFSCREEN_CANVAS) {
                  var font = getFontParameters(fontSpec);
                  var metrics = measureText(fontSpec, 'Žg');
                  var lineHeight = isNaN(Number(font.lineHeight))
                      ? 1.2
                      : Number(font.lineHeight);
                  textHeights[fontSpec] =
                      lineHeight *
                          (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
              }
              else {
                  if (!div) {
                      div = document.createElement('div');
                      div.innerHTML = 'M';
                      div.style.margin = '0 !important';
                      div.style.padding = '0 !important';
                      div.style.position = 'absolute !important';
                      div.style.left = '-99999px !important';
                  }
                  div.style.font = fontSpec;
                  document.body.appendChild(div);
                  height = div.offsetHeight;
                  heights[fontSpec] = height;
                  document.body.removeChild(div);
              }
          }
          return height;
      };
  })();
  /**
   * @param {string} font Font.
   * @param {string} text Text.
   * @return {TextMetrics} Text metrics.
   */
  function measureText(font, text) {
      if (!measureContext) {
          measureContext = createCanvasContext2D(1, 1);
      }
      if (font != measureFont) {
          measureContext.font = font;
          measureFont = measureContext.font;
      }
      return measureContext.measureText(text);
  }
  /**
   * @param {string} font Font.
   * @param {string} text Text.
   * @return {number} Width.
   */
  function measureTextWidth(font, text) {
      return measureText(font, text).width;
  }
  /**
   * Measure text width using a cache.
   * @param {string} font The font.
   * @param {string} text The text to measure.
   * @param {Object<string, number>} cache A lookup of cached widths by text.
   * @returns {number} The text width.
   */
  function measureAndCacheTextWidth(font, text, cache) {
      if (text in cache) {
          return cache[text];
      }
      var width = measureTextWidth(font, text);
      cache[text] = width;
      return width;
  }
  /**
   * @param {string} font Font to use for measuring.
   * @param {Array<string>} lines Lines to measure.
   * @param {Array<number>} widths Array will be populated with the widths of
   * each line.
   * @return {number} Width of the whole text.
   */
  function measureTextWidths(font, lines, widths) {
      var numLines = lines.length;
      var width = 0;
      for (var i = 0; i < numLines; ++i) {
          var currentWidth = measureTextWidth(font, lines[i]);
          width = Math.max(width, currentWidth);
          widths.push(currentWidth);
      }
      return width;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} rotation Rotation.
   * @param {number} offsetX X offset.
   * @param {number} offsetY Y offset.
   */
  function rotateAtOffset(context, rotation, offsetX, offsetY) {
      if (rotation !== 0) {
          context.translate(offsetX, offsetY);
          context.rotate(rotation);
          context.translate(-offsetX, -offsetY);
      }
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../transform.js").Transform|null} transform Transform.
   * @param {number} opacity Opacity.
   * @param {Label|HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} labelOrImage Label.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} w Width.
   * @param {number} h Height.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../size.js").Size} scale Scale.
   */
  function drawImageOrLabel(context, transform, opacity, labelOrImage, originX, originY, w, h, x, y, scale) {
      context.save();
      if (opacity !== 1) {
          context.globalAlpha *= opacity;
      }
      if (transform) {
          context.setTransform.apply(context, transform);
      }
      if ( /** @type {*} */(labelOrImage).contextInstructions) {
          // label
          context.translate(x, y);
          context.scale(scale[0], scale[1]);
          executeLabelInstructions(/** @type {Label} */ (labelOrImage), context);
      }
      else if (scale[0] < 0 || scale[1] < 0) {
          // flipped image
          context.translate(x, y);
          context.scale(scale[0], scale[1]);
          context.drawImage(
          /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */ (labelOrImage), originX, originY, w, h, 0, 0, w, h);
      }
      else {
          // if image not flipped translate and scale can be avoided
          context.drawImage(
          /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */ (labelOrImage), originX, originY, w, h, x, y, w * scale[0], h * scale[1]);
      }
      context.restore();
  }
  /**
   * @param {Label} label Label.
   * @param {CanvasRenderingContext2D} context Context.
   */
  function executeLabelInstructions(label, context) {
      var contextInstructions = label.contextInstructions;
      for (var i = 0, ii = contextInstructions.length; i < ii; i += 2) {
          if (Array.isArray(contextInstructions[i + 1])) {
              context[contextInstructions[i]].apply(context, contextInstructions[i + 1]);
          }
          else {
              context[contextInstructions[i]] = contextInstructions[i + 1];
          }
      }
  }
  /**
   * @type {HTMLCanvasElement}
   * @private
   */
  var createTransformStringCanvas = null;
  /**
   * @param {import("../transform.js").Transform} transform Transform.
   * @return {string} CSS transform.
   */
  function createTransformString(transform) {
      if (WORKER_OFFSCREEN_CANVAS) {
          return toString(transform);
      }
      else {
          if (!createTransformStringCanvas) {
              createTransformStringCanvas = createCanvasContext2D(1, 1).canvas;
          }
          createTransformStringCanvas.style.transform = toString(transform);
          return createTransformStringCanvas.style.transform;
      }
  }

  /**
   * @module ol/geom/flat/transform
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Array<number>=} opt_dest Destination.
   * @return {Array<number>} Transformed coordinates.
   */
  function transform2D(flatCoordinates, offset, end, stride, transform, opt_dest) {
      var dest = opt_dest ? opt_dest : [];
      var i = 0;
      for (var j = offset; j < end; j += stride) {
          var x = flatCoordinates[j];
          var y = flatCoordinates[j + 1];
          dest[i++] = transform[0] * x + transform[2] * y + transform[4];
          dest[i++] = transform[1] * x + transform[3] * y + transform[5];
      }
      if (opt_dest && dest.length != i) {
          dest.length = i;
      }
      return dest;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} angle Angle.
   * @param {Array<number>} anchor Rotation anchor point.
   * @param {Array<number>=} opt_dest Destination.
   * @return {Array<number>} Transformed coordinates.
   */
  function rotate(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {
      var dest = opt_dest ? opt_dest : [];
      var cos = Math.cos(angle);
      var sin = Math.sin(angle);
      var anchorX = anchor[0];
      var anchorY = anchor[1];
      var i = 0;
      for (var j = offset; j < end; j += stride) {
          var deltaX = flatCoordinates[j] - anchorX;
          var deltaY = flatCoordinates[j + 1] - anchorY;
          dest[i++] = anchorX + deltaX * cos - deltaY * sin;
          dest[i++] = anchorY + deltaX * sin + deltaY * cos;
          for (var k = j + 2; k < j + stride; ++k) {
              dest[i++] = flatCoordinates[k];
          }
      }
      if (opt_dest && dest.length != i) {
          dest.length = i;
      }
      return dest;
  }
  /**
   * Scale the coordinates.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} sx Scale factor in the x-direction.
   * @param {number} sy Scale factor in the y-direction.
   * @param {Array<number>} anchor Scale anchor point.
   * @param {Array<number>=} opt_dest Destination.
   * @return {Array<number>} Transformed coordinates.
   */
  function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {
      var dest = opt_dest ? opt_dest : [];
      var anchorX = anchor[0];
      var anchorY = anchor[1];
      var i = 0;
      for (var j = offset; j < end; j += stride) {
          var deltaX = flatCoordinates[j] - anchorX;
          var deltaY = flatCoordinates[j + 1] - anchorY;
          dest[i++] = anchorX + sx * deltaX;
          dest[i++] = anchorY + sy * deltaY;
          for (var k = j + 2; k < j + stride; ++k) {
              dest[i++] = flatCoordinates[k];
          }
      }
      if (opt_dest && dest.length != i) {
          dest.length = i;
      }
      return dest;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @param {Array<number>=} opt_dest Destination.
   * @return {Array<number>} Transformed coordinates.
   */
  function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {
      var dest = opt_dest ? opt_dest : [];
      var i = 0;
      for (var j = offset; j < end; j += stride) {
          dest[i++] = flatCoordinates[j] + deltaX;
          dest[i++] = flatCoordinates[j + 1] + deltaY;
          for (var k = j + 2; k < j + stride; ++k) {
              dest[i++] = flatCoordinates[k];
          }
      }
      if (opt_dest && dest.length != i) {
          dest.length = i;
      }
      return dest;
  }

  /**
   * @module ol/proj/Units
   */
  /**
   * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or
   * `'us-ft'`.
   * @enum {string}
   */
  var Units = {
      DEGREES: 'degrees',
      FEET: 'ft',
      METERS: 'm',
      PIXELS: 'pixels',
      TILE_PIXELS: 'tile-pixels',
      USFEET: 'us-ft',
  };
  /**
   * Meters per unit lookup table.
   * @const
   * @type {Object<Units, number>}
   * @api
   */
  var METERS_PER_UNIT = {};
  // use the radius of the Normal sphere
  METERS_PER_UNIT[Units.DEGREES] = (2 * Math.PI * 6370997) / 360;
  METERS_PER_UNIT[Units.FEET] = 0.3048;
  METERS_PER_UNIT[Units.METERS] = 1;
  METERS_PER_UNIT[Units.USFEET] = 1200 / 3937;

  /**
   * @module ol/proj/Projection
   */
  /**
   * @typedef {Object} Options
   * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
   * @property {import("./Units.js").default|string} [units] Units. Required unless a
   * proj4 projection is defined for `code`.
   * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.
   * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
   * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
   * @property {number} [metersPerUnit] The meters per unit for the SRS.
   * If not provided, the `units` are used to get the meters per unit from the {@link module:ol/proj/Units~METERS_PER_UNIT}
   * lookup table.
   * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.
   * @property {function(number, import("../coordinate.js").Coordinate):number} [getPointResolution]
   * Function to determine resolution at a point. The function is called with a
   * `{number}` view resolution and an `{import("../coordinate.js").Coordinate}` as arguments, and returns
   * the `{number}` resolution in projection units at the passed coordinate. If this is `undefined`,
   * the default {@link module:ol/proj#getPointResolution} function will be used.
   */
  /**
   * @classdesc
   * Projection definition class. One of these is created for each projection
   * supported in the application and stored in the {@link module:ol/proj} namespace.
   * You can use these in applications, but this is not required, as API params
   * and options use {@link module:ol/proj~ProjectionLike} which means the simple string
   * code will suffice.
   *
   * You can use {@link module:ol/proj~get} to retrieve the object for a particular
   * projection.
   *
   * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
   * with the following aliases:
   * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
   *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
   *     http://www.opengis.net/gml/srs/epsg.xml#4326,
   *     urn:x-ogc:def:crs:EPSG:4326
   * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
   *     urn:ogc:def:crs:EPSG:6.18:3:3857,
   *     http://www.opengis.net/gml/srs/epsg.xml#3857
   *
   * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can
   * be added using `proj4.defs()`. After all required projection definitions are
   * added, call the {@link module:ol/proj/proj4~register} function.
   *
   * @api
   */
  var Projection = /** @class */ (function () {
      /**
       * @param {Options} options Projection options.
       */
      function Projection(options) {
          /**
           * @private
           * @type {string}
           */
          this.code_ = options.code;
          /**
           * Units of projected coordinates. When set to `TILE_PIXELS`, a
           * `this.extent_` and `this.worldExtent_` must be configured properly for each
           * tile.
           * @private
           * @type {import("./Units.js").default}
           */
          this.units_ = /** @type {import("./Units.js").default} */ (options.units);
          /**
           * Validity extent of the projection in projected coordinates. For projections
           * with `TILE_PIXELS` units, this is the extent of the tile in
           * tile pixel space.
           * @private
           * @type {import("../extent.js").Extent}
           */
          this.extent_ = options.extent !== undefined ? options.extent : null;
          /**
           * Extent of the world in EPSG:4326. For projections with
           * `TILE_PIXELS` units, this is the extent of the tile in
           * projected coordinate space.
           * @private
           * @type {import("../extent.js").Extent}
           */
          this.worldExtent_ =
              options.worldExtent !== undefined ? options.worldExtent : null;
          /**
           * @private
           * @type {string}
           */
          this.axisOrientation_ =
              options.axisOrientation !== undefined ? options.axisOrientation : 'enu';
          /**
           * @private
           * @type {boolean}
           */
          this.global_ = options.global !== undefined ? options.global : false;
          /**
           * @private
           * @type {boolean}
           */
          this.canWrapX_ = !!(this.global_ && this.extent_);
          /**
           * @private
           * @type {function(number, import("../coordinate.js").Coordinate):number|undefined}
           */
          this.getPointResolutionFunc_ = options.getPointResolution;
          /**
           * @private
           * @type {import("../tilegrid/TileGrid.js").default}
           */
          this.defaultTileGrid_ = null;
          /**
           * @private
           * @type {number|undefined}
           */
          this.metersPerUnit_ = options.metersPerUnit;
      }
      /**
       * @return {boolean} The projection is suitable for wrapping the x-axis
       */
      Projection.prototype.canWrapX = function () {
          return this.canWrapX_;
      };
      /**
       * Get the code for this projection, e.g. 'EPSG:4326'.
       * @return {string} Code.
       * @api
       */
      Projection.prototype.getCode = function () {
          return this.code_;
      };
      /**
       * Get the validity extent for this projection.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      Projection.prototype.getExtent = function () {
          return this.extent_;
      };
      /**
       * Get the units of this projection.
       * @return {import("./Units.js").default} Units.
       * @api
       */
      Projection.prototype.getUnits = function () {
          return this.units_;
      };
      /**
       * Get the amount of meters per unit of this projection.  If the projection is
       * not configured with `metersPerUnit` or a units identifier, the return is
       * `undefined`.
       * @return {number|undefined} Meters.
       * @api
       */
      Projection.prototype.getMetersPerUnit = function () {
          return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];
      };
      /**
       * Get the world extent for this projection.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      Projection.prototype.getWorldExtent = function () {
          return this.worldExtent_;
      };
      /**
       * Get the axis orientation of this projection.
       * Example values are:
       * enu - the default easting, northing, elevation.
       * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
       *     or south orientated transverse mercator.
       * wnu - westing, northing, up - some planetary coordinate systems have
       *     "west positive" coordinate systems
       * @return {string} Axis orientation.
       * @api
       */
      Projection.prototype.getAxisOrientation = function () {
          return this.axisOrientation_;
      };
      /**
       * Is this projection a global projection which spans the whole world?
       * @return {boolean} Whether the projection is global.
       * @api
       */
      Projection.prototype.isGlobal = function () {
          return this.global_;
      };
      /**
       * Set if the projection is a global projection which spans the whole world
       * @param {boolean} global Whether the projection is global.
       * @api
       */
      Projection.prototype.setGlobal = function (global) {
          this.global_ = global;
          this.canWrapX_ = !!(global && this.extent_);
      };
      /**
       * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
       */
      Projection.prototype.getDefaultTileGrid = function () {
          return this.defaultTileGrid_;
      };
      /**
       * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
       */
      Projection.prototype.setDefaultTileGrid = function (tileGrid) {
          this.defaultTileGrid_ = tileGrid;
      };
      /**
       * Set the validity extent for this projection.
       * @param {import("../extent.js").Extent} extent Extent.
       * @api
       */
      Projection.prototype.setExtent = function (extent) {
          this.extent_ = extent;
          this.canWrapX_ = !!(this.global_ && extent);
      };
      /**
       * Set the world extent for this projection.
       * @param {import("../extent.js").Extent} worldExtent World extent
       *     [minlon, minlat, maxlon, maxlat].
       * @api
       */
      Projection.prototype.setWorldExtent = function (worldExtent) {
          this.worldExtent_ = worldExtent;
      };
      /**
       * Set the getPointResolution function (see {@link module:ol/proj~getPointResolution}
       * for this projection.
       * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
       * @api
       */
      Projection.prototype.setGetPointResolution = function (func) {
          this.getPointResolutionFunc_ = func;
      };
      /**
       * Get the custom point resolution function for this projection (if set).
       * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
       * resolution function (if set).
       */
      Projection.prototype.getPointResolutionFunc = function () {
          return this.getPointResolutionFunc_;
      };
      return Projection;
  }());

  var __extends$6 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * Radius of WGS84 sphere
   *
   * @const
   * @type {number}
   */
  var RADIUS = 6378137;
  /**
   * @const
   * @type {number}
   */
  var HALF_SIZE = Math.PI * RADIUS;
  /**
   * @const
   * @type {import("../extent.js").Extent}
   */
  var EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
  /**
   * @const
   * @type {import("../extent.js").Extent}
   */
  var WORLD_EXTENT = [-180, -85, 180, 85];
  /**
   * @classdesc
   * Projection object for web/spherical Mercator (EPSG:3857).
   */
  var EPSG3857Projection = /** @class */ (function (_super) {
      __extends$6(EPSG3857Projection, _super);
      /**
       * @param {string} code Code.
       */
      function EPSG3857Projection(code) {
          return _super.call(this, {
              code: code,
              units: Units.METERS,
              extent: EXTENT,
              global: true,
              worldExtent: WORLD_EXTENT,
              getPointResolution: function (resolution, point) {
                  return resolution / cosh(point[1] / RADIUS);
              },
          }) || this;
      }
      return EPSG3857Projection;
  }(Projection));
  /**
   * Projections equal to EPSG:3857.
   *
   * @const
   * @type {Array<import("./Projection.js").default>}
   */
  var PROJECTIONS = [
      new EPSG3857Projection('EPSG:3857'),
      new EPSG3857Projection('EPSG:102100'),
      new EPSG3857Projection('EPSG:102113'),
      new EPSG3857Projection('EPSG:900913'),
      new EPSG3857Projection('urn:ogc:def:crs:EPSG:6.18:3:3857'),
      new EPSG3857Projection('urn:ogc:def:crs:EPSG::3857'),
      new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857'),
  ];
  /**
   * Transformation from EPSG:4326 to EPSG:3857.
   *
   * @param {Array<number>} input Input array of coordinate values.
   * @param {Array<number>=} opt_output Output array of coordinate values.
   * @param {number=} opt_dimension Dimension (default is `2`).
   * @return {Array<number>} Output array of coordinate values.
   */
  function fromEPSG4326(input, opt_output, opt_dimension) {
      var length = input.length;
      var dimension = opt_dimension > 1 ? opt_dimension : 2;
      var output = opt_output;
      if (output === undefined) {
          if (dimension > 2) {
              // preserve values beyond second dimension
              output = input.slice();
          }
          else {
              output = new Array(length);
          }
      }
      var halfSize = HALF_SIZE;
      for (var i = 0; i < length; i += dimension) {
          output[i] = (halfSize * input[i]) / 180;
          var y = RADIUS * Math.log(Math.tan((Math.PI * (+input[i + 1] + 90)) / 360));
          if (y > halfSize) {
              y = halfSize;
          }
          else if (y < -halfSize) {
              y = -halfSize;
          }
          output[i + 1] = y;
      }
      return output;
  }
  /**
   * Transformation from EPSG:3857 to EPSG:4326.
   *
   * @param {Array<number>} input Input array of coordinate values.
   * @param {Array<number>=} opt_output Output array of coordinate values.
   * @param {number=} opt_dimension Dimension (default is `2`).
   * @return {Array<number>} Output array of coordinate values.
   */
  function toEPSG4326(input, opt_output, opt_dimension) {
      var length = input.length;
      var dimension = opt_dimension > 1 ? opt_dimension : 2;
      var output = opt_output;
      if (output === undefined) {
          if (dimension > 2) {
              // preserve values beyond second dimension
              output = input.slice();
          }
          else {
              output = new Array(length);
          }
      }
      for (var i = 0; i < length; i += dimension) {
          output[i] = (180 * input[i]) / HALF_SIZE;
          output[i + 1] =
              (360 * Math.atan(Math.exp(input[i + 1] / RADIUS))) / Math.PI - 90;
      }
      return output;
  }

  var __extends$7 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * Semi-major radius of the WGS84 ellipsoid.
   *
   * @const
   * @type {number}
   */
  var RADIUS$1 = 6378137;
  /**
   * Extent of the EPSG:4326 projection which is the whole world.
   *
   * @const
   * @type {import("../extent.js").Extent}
   */
  var EXTENT$1 = [-180, -90, 180, 90];
  /**
   * @const
   * @type {number}
   */
  var METERS_PER_UNIT$1 = (Math.PI * RADIUS$1) / 180;
  /**
   * @classdesc
   * Projection object for WGS84 geographic coordinates (EPSG:4326).
   *
   * Note that OpenLayers does not strictly comply with the EPSG definition.
   * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
   * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
   */
  var EPSG4326Projection = /** @class */ (function (_super) {
      __extends$7(EPSG4326Projection, _super);
      /**
       * @param {string} code Code.
       * @param {string=} opt_axisOrientation Axis orientation.
       */
      function EPSG4326Projection(code, opt_axisOrientation) {
          return _super.call(this, {
              code: code,
              units: Units.DEGREES,
              extent: EXTENT$1,
              axisOrientation: opt_axisOrientation,
              global: true,
              metersPerUnit: METERS_PER_UNIT$1,
              worldExtent: EXTENT$1,
          }) || this;
      }
      return EPSG4326Projection;
  }(Projection));
  /**
   * Projections equal to EPSG:4326.
   *
   * @const
   * @type {Array<import("./Projection.js").default>}
   */
  var PROJECTIONS$1 = [
      new EPSG4326Projection('CRS:84'),
      new EPSG4326Projection('EPSG:4326', 'neu'),
      new EPSG4326Projection('urn:ogc:def:crs:EPSG::4326', 'neu'),
      new EPSG4326Projection('urn:ogc:def:crs:EPSG:6.6:4326', 'neu'),
      new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),
      new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),
      new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),
      new EPSG4326Projection('urn:x-ogc:def:crs:EPSG:4326', 'neu'),
  ];

  /**
   * @module ol/proj/projections
   */
  /**
   * @type {Object<string, import("./Projection.js").default>}
   */
  var cache = {};
  /**
   * Get a cached projection by code.
   * @param {string} code The code for the projection.
   * @return {import("./Projection.js").default} The projection (if cached).
   */
  function get(code) {
      return cache[code] || null;
  }
  /**
   * Add a projection to the cache.
   * @param {string} code The projection code.
   * @param {import("./Projection.js").default} projection The projection to cache.
   */
  function add(code, projection) {
      cache[code] = projection;
  }

  /**
   * @module ol/proj/transforms
   */
  /**
   * @private
   * @type {!Object<string, Object<string, import("../proj.js").TransformFunction>>}
   */
  var transforms = {};
  /**
   * Registers a conversion function to convert coordinates from the source
   * projection to the destination projection.
   *
   * @param {import("./Projection.js").default} source Source.
   * @param {import("./Projection.js").default} destination Destination.
   * @param {import("../proj.js").TransformFunction} transformFn Transform.
   */
  function add$1(source, destination, transformFn) {
      var sourceCode = source.getCode();
      var destinationCode = destination.getCode();
      if (!(sourceCode in transforms)) {
          transforms[sourceCode] = {};
      }
      transforms[sourceCode][destinationCode] = transformFn;
  }
  /**
   * Get a transform given a source code and a destination code.
   * @param {string} sourceCode The code for the source projection.
   * @param {string} destinationCode The code for the destination projection.
   * @return {import("../proj.js").TransformFunction|undefined} The transform function (if found).
   */
  function get$1(sourceCode, destinationCode) {
      var transform;
      if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
          transform = transforms[sourceCode][destinationCode];
      }
      return transform;
  }

  /**
   * @module ol/sphere
   */
  /**
   * Object literal with options for the {@link getLength} or {@link getArea}
   * functions.
   * @typedef {Object} SphereMetricOptions
   * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857']
   * Projection of the  geometry.  By default, the geometry is assumed to be in
   * Web Mercator.
   * @property {number} [radius=6371008.8] Sphere radius.  By default, the
   * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)
   * for the WGS84 ellipsoid is used.
   */
  /**
   * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
   * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
   * @type {number}
   */
  var DEFAULT_RADIUS = 6371008.8;
  /**
   * Get the great circle distance (in meters) between two geographic coordinates.
   * @param {Array} c1 Starting coordinate.
   * @param {Array} c2 Ending coordinate.
   * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's
   *     mean radius using the WGS84 ellipsoid.
   * @return {number} The great circle distance between the points (in meters).
   * @api
   */
  function getDistance(c1, c2, opt_radius) {
      var radius = opt_radius || DEFAULT_RADIUS;
      var lat1 = toRadians(c1[1]);
      var lat2 = toRadians(c2[1]);
      var deltaLatBy2 = (lat2 - lat1) / 2;
      var deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;
      var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +
          Math.sin(deltaLonBy2) *
              Math.sin(deltaLonBy2) *
              Math.cos(lat1) *
              Math.cos(lat2);
      return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  }

  /**
   * @module ol/string
   */
  /**
   * @param {number} number Number to be formatted
   * @param {number} width The desired width
   * @param {number=} opt_precision Precision of the output string (i.e. number of decimal places)
   * @returns {string} Formatted string
   */
  function padNumber(number, width, opt_precision) {
      var numberString = opt_precision !== undefined ? number.toFixed(opt_precision) : '' + number;
      var decimal = numberString.indexOf('.');
      decimal = decimal === -1 ? numberString.length : decimal;
      return decimal > width
          ? numberString
          : new Array(1 + width - decimal).join('0') + numberString;
  }
  /**
   * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
   * @param {string|number} v1 First version
   * @param {string|number} v2 Second version
   * @returns {number} Value
   */
  function compareVersions(v1, v2) {
      var s1 = ('' + v1).split('.');
      var s2 = ('' + v2).split('.');
      for (var i = 0; i < Math.max(s1.length, s2.length); i++) {
          var n1 = parseInt(s1[i] || '0', 10);
          var n2 = parseInt(s2[i] || '0', 10);
          if (n1 > n2) {
              return 1;
          }
          if (n2 > n1) {
              return -1;
          }
      }
      return 0;
  }

  /**
   * @module ol/coordinate
   */
  /**
   * An array of numbers representing an xy coordinate. Example: `[16, 48]`.
   * @typedef {Array<number>} Coordinate
   * @api
   */
  /**
   * A function that takes a {@link module:ol/coordinate~Coordinate} and
   * transforms it into a `{string}`.
   *
   * @typedef {function((Coordinate|undefined)): string} CoordinateFormat
   * @api
   */
  /**
   * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
   * by the function.
   *
   * Example:
   *
   *     import {add} from 'ol/coordinate';
   *
   *     var coord = [7.85, 47.983333];
   *     add(coord, [-2, 4]);
   *     // coord is now [5.85, 51.983333]
   *
   * @param {Coordinate} coordinate Coordinate.
   * @param {Coordinate} delta Delta.
   * @return {Coordinate} The input coordinate adjusted by
   * the given delta.
   * @api
   */
  function add$2(coordinate, delta) {
      coordinate[0] += +delta[0];
      coordinate[1] += +delta[1];
      return coordinate;
  }
  /**
   * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be
   * used to format
   * a {Coordinate} to a string.
   *
   * Example without specifying the fractional digits:
   *
   *     import {createStringXY} from 'ol/coordinate';
   *
   *     var coord = [7.85, 47.983333];
   *     var stringifyFunc = createStringXY();
   *     var out = stringifyFunc(coord);
   *     // out is now '8, 48'
   *
   * Example with explicitly specifying 2 fractional digits:
   *
   *     import {createStringXY} from 'ol/coordinate';
   *
   *     var coord = [7.85, 47.983333];
   *     var stringifyFunc = createStringXY(2);
   *     var out = stringifyFunc(coord);
   *     // out is now '7.85, 47.98'
   *
   * @param {number=} opt_fractionDigits The number of digits to include
   *    after the decimal point. Default is `0`.
   * @return {CoordinateFormat} Coordinate format.
   * @api
   */
  function createStringXY(opt_fractionDigits) {
      return (
      /**
       * @param {Coordinate} coordinate Coordinate.
       * @return {string} String XY.
       */
      function (coordinate) {
          return toStringXY(coordinate, opt_fractionDigits);
      });
  }
  /**
   * @param {string} hemispheres Hemispheres.
   * @param {number} degrees Degrees.
   * @param {number=} opt_fractionDigits The number of digits to include
   *    after the decimal point. Default is `0`.
   * @return {string} String.
   */
  function degreesToStringHDMS(hemispheres, degrees, opt_fractionDigits) {
      var normalizedDegrees = modulo(degrees + 180, 360) - 180;
      var x = Math.abs(3600 * normalizedDegrees);
      var dflPrecision = opt_fractionDigits || 0;
      var precision = Math.pow(10, dflPrecision);
      var deg = Math.floor(x / 3600);
      var min = Math.floor((x - deg * 3600) / 60);
      var sec = x - deg * 3600 - min * 60;
      sec = Math.ceil(sec * precision) / precision;
      if (sec >= 60) {
          sec = 0;
          min += 1;
      }
      if (min >= 60) {
          min = 0;
          deg += 1;
      }
      return (deg +
          '\u00b0 ' +
          padNumber(min, 2) +
          '\u2032 ' +
          padNumber(sec, 2, dflPrecision) +
          '\u2033' +
          (normalizedDegrees == 0
              ? ''
              : ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0)));
  }
  /**
   * Transforms the given {@link module:ol/coordinate~Coordinate} to a string
   * using the given string template. The strings `{x}` and `{y}` in the template
   * will be replaced with the first and second coordinate values respectively.
   *
   * Example without specifying the fractional digits:
   *
   *     import {format} from 'ol/coordinate';
   *
   *     var coord = [7.85, 47.983333];
   *     var template = 'Coordinate is ({x}|{y}).';
   *     var out = format(coord, template);
   *     // out is now 'Coordinate is (8|48).'
   *
   * Example explicitly specifying the fractional digits:
   *
   *     import {format} from 'ol/coordinate';
   *
   *     var coord = [7.85, 47.983333];
   *     var template = 'Coordinate is ({x}|{y}).';
   *     var out = format(coord, template, 2);
   *     // out is now 'Coordinate is (7.85|47.98).'
   *
   * @param {Coordinate} coordinate Coordinate.
   * @param {string} template A template string with `{x}` and `{y}` placeholders
   *     that will be replaced by first and second coordinate values.
   * @param {number=} opt_fractionDigits The number of digits to include
   *    after the decimal point. Default is `0`.
   * @return {string} Formatted coordinate.
   * @api
   */
  function format(coordinate, template, opt_fractionDigits) {
      if (coordinate) {
          return template
              .replace('{x}', coordinate[0].toFixed(opt_fractionDigits))
              .replace('{y}', coordinate[1].toFixed(opt_fractionDigits));
      }
      else {
          return '';
      }
  }
  /**
   * @param {Coordinate} coordinate1 First coordinate.
   * @param {Coordinate} coordinate2 Second coordinate.
   * @return {boolean} The two coordinates are equal.
   */
  function equals$2(coordinate1, coordinate2) {
      var equals = true;
      for (var i = coordinate1.length - 1; i >= 0; --i) {
          if (coordinate1[i] != coordinate2[i]) {
              equals = false;
              break;
          }
      }
      return equals;
  }
  /**
   * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
   * returned by the function.
   *
   * Example:
   *
   *     import {rotate} from 'ol/coordinate';
   *
   *     var coord = [7.85, 47.983333];
   *     var rotateRadians = Math.PI / 2; // 90 degrees
   *     rotate(coord, rotateRadians);
   *     // coord is now [-47.983333, 7.85]
   *
   * @param {Coordinate} coordinate Coordinate.
   * @param {number} angle Angle in radian.
   * @return {Coordinate} Coordinate.
   * @api
   */
  function rotate$1(coordinate, angle) {
      var cosAngle = Math.cos(angle);
      var sinAngle = Math.sin(angle);
      var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
      var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
      coordinate[0] = x;
      coordinate[1] = y;
      return coordinate;
  }
  /**
   * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
   * by the function.
   *
   * Example:
   *
   *     import {scale as scaleCoordinate} from 'ol/coordinate';
   *
   *     var coord = [7.85, 47.983333];
   *     var scale = 1.2;
   *     scaleCoordinate(coord, scale);
   *     // coord is now [9.42, 57.5799996]
   *
   * @param {Coordinate} coordinate Coordinate.
   * @param {number} scale Scale factor.
   * @return {Coordinate} Coordinate.
   */
  function scale$1(coordinate, scale) {
      coordinate[0] *= scale;
      coordinate[1] *= scale;
      return coordinate;
  }
  /**
   * Format a geographic coordinate with the hemisphere, degrees, minutes, and
   * seconds.
   *
   * Example without specifying fractional digits:
   *
   *     import {toStringHDMS} from 'ol/coordinate';
   *
   *     var coord = [7.85, 47.983333];
   *     var out = toStringHDMS(coord);
   *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'
   *
   * Example explicitly specifying 1 fractional digit:
   *
   *     import {toStringHDMS} from 'ol/coordinate';
   *
   *     var coord = [7.85, 47.983333];
   *     var out = toStringHDMS(coord, 1);
   *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'
   *
   * @param {Coordinate} coordinate Coordinate.
   * @param {number=} opt_fractionDigits The number of digits to include
   *    after the decimal point. Default is `0`.
   * @return {string} Hemisphere, degrees, minutes and seconds.
   * @api
   */
  function toStringHDMS(coordinate, opt_fractionDigits) {
      if (coordinate) {
          return (degreesToStringHDMS('NS', coordinate[1], opt_fractionDigits) +
              ' ' +
              degreesToStringHDMS('EW', coordinate[0], opt_fractionDigits));
      }
      else {
          return '';
      }
  }
  /**
   * Format a coordinate as a comma delimited string.
   *
   * Example without specifying fractional digits:
   *
   *     import {toStringXY} from 'ol/coordinate';
   *
   *     var coord = [7.85, 47.983333];
   *     var out = toStringXY(coord);
   *     // out is now '8, 48'
   *
   * Example explicitly specifying 1 fractional digit:
   *
   *     import {toStringXY} from 'ol/coordinate';
   *
   *     var coord = [7.85, 47.983333];
   *     var out = toStringXY(coord, 1);
   *     // out is now '7.8, 48.0'
   *
   * @param {Coordinate} coordinate Coordinate.
   * @param {number=} opt_fractionDigits The number of digits to include
   *    after the decimal point. Default is `0`.
   * @return {string} XY.
   * @api
   */
  function toStringXY(coordinate, opt_fractionDigits) {
      return format(coordinate, '{x}, {y}', opt_fractionDigits);
  }
  /**
   * Modifies the provided coordinate in-place to be within the real world
   * extent. The lower projection extent boundary is inclusive, the upper one
   * exclusive.
   *
   * @param {Coordinate} coordinate Coordinate.
   * @param {import("./proj/Projection.js").default} projection Projection.
   * @return {Coordinate} The coordinate within the real world extent.
   */
  function wrapX$1(coordinate, projection) {
      if (projection.canWrapX()) {
          var worldWidth = getWidth(projection.getExtent());
          var worldsAway = getWorldsAway(coordinate, projection, worldWidth);
          if (worldsAway) {
              coordinate[0] -= worldsAway * worldWidth;
          }
      }
      return coordinate;
  }
  /**
   * @param {Coordinate} coordinate Coordinate.
   * @param {import("./proj/Projection.js").default} projection Projection.
   * @param {number=} opt_sourceExtentWidth Width of the source extent.
   * @return {number} Offset in world widths.
   */
  function getWorldsAway(coordinate, projection, opt_sourceExtentWidth) {
      var projectionExtent = projection.getExtent();
      var worldsAway = 0;
      if (projection.canWrapX() &&
          (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
          var sourceExtentWidth = opt_sourceExtentWidth || getWidth(projectionExtent);
          worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);
      }
      return worldsAway;
  }

  /**
   * @module ol/proj
   */
  /**
   * @param {Array<number>} input Input coordinate array.
   * @param {Array<number>=} opt_output Output array of coordinate values.
   * @param {number=} opt_dimension Dimension.
   * @return {Array<number>} Output coordinate array (new array, same coordinate
   *     values).
   */
  function cloneTransform(input, opt_output, opt_dimension) {
      var output;
      if (opt_output !== undefined) {
          for (var i = 0, ii = input.length; i < ii; ++i) {
              opt_output[i] = input[i];
          }
          output = opt_output;
      }
      else {
          output = input.slice();
      }
      return output;
  }
  /**
   * @param {Array<number>} input Input coordinate array.
   * @param {Array<number>=} opt_output Output array of coordinate values.
   * @param {number=} opt_dimension Dimension.
   * @return {Array<number>} Input coordinate array (same array as input).
   */
  function identityTransform(input, opt_output, opt_dimension) {
      if (opt_output !== undefined && input !== opt_output) {
          for (var i = 0, ii = input.length; i < ii; ++i) {
              opt_output[i] = input[i];
          }
          input = opt_output;
      }
      return input;
  }
  /**
   * Add a Projection object to the list of supported projections that can be
   * looked up by their code.
   *
   * @param {Projection} projection Projection instance.
   * @api
   */
  function addProjection(projection) {
      add(projection.getCode(), projection);
      add$1(projection, projection, cloneTransform);
  }
  /**
   * @param {Array<Projection>} projections Projections.
   */
  function addProjections(projections) {
      projections.forEach(addProjection);
  }
  /**
   * Fetches a Projection object for the code specified.
   *
   * @param {ProjectionLike} projectionLike Either a code string which is
   *     a combination of authority and identifier such as "EPSG:4326", or an
   *     existing projection object, or undefined.
   * @return {Projection} Projection object, or null if not in list.
   * @api
   */
  function get$2(projectionLike) {
      return typeof projectionLike === 'string'
          ? get(/** @type {string} */ (projectionLike))
          : /** @type {Projection} */ (projectionLike) || null;
  }
  /**
   * Get the resolution of the point in degrees or distance units.
   * For projections with degrees as the unit this will simply return the
   * provided resolution. For other projections the point resolution is
   * by default estimated by transforming the 'point' pixel to EPSG:4326,
   * measuring its width and height on the normal sphere,
   * and taking the average of the width and height.
   * A custom function can be provided for a specific projection, either
   * by setting the `getPointResolution` option in the
   * {@link module:ol/proj/Projection~Projection} constructor or by using
   * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing
   * projection object.
   * @param {ProjectionLike} projection The projection.
   * @param {number} resolution Nominal resolution in projection units.
   * @param {import("./coordinate.js").Coordinate} point Point to find adjusted resolution at.
   * @param {import("./proj/Units.js").default=} opt_units Units to get the point resolution in.
   * Default is the projection's units.
   * @return {number} Point resolution.
   * @api
   */
  function getPointResolution(projection, resolution, point, opt_units) {
      projection = get$2(projection);
      var pointResolution;
      var getter = projection.getPointResolutionFunc();
      if (getter) {
          pointResolution = getter(resolution, point);
          if (opt_units && opt_units !== projection.getUnits()) {
              var metersPerUnit = projection.getMetersPerUnit();
              if (metersPerUnit) {
                  pointResolution =
                      (pointResolution * metersPerUnit) / METERS_PER_UNIT[opt_units];
              }
          }
      }
      else {
          var units = projection.getUnits();
          if ((units == Units.DEGREES && !opt_units) || opt_units == Units.DEGREES) {
              pointResolution = resolution;
          }
          else {
              // Estimate point resolution by transforming the center pixel to EPSG:4326,
              // measuring its width and height on the normal sphere, and taking the
              // average of the width and height.
              var toEPSG4326_1 = getTransformFromProjections(projection, get$2('EPSG:4326'));
              var vertices = [
                  point[0] - resolution / 2,
                  point[1],
                  point[0] + resolution / 2,
                  point[1],
                  point[0],
                  point[1] - resolution / 2,
                  point[0],
                  point[1] + resolution / 2,
              ];
              vertices = toEPSG4326_1(vertices, vertices, 2);
              var width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));
              var height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));
              pointResolution = (width + height) / 2;
              var metersPerUnit = opt_units
                  ? METERS_PER_UNIT[opt_units]
                  : projection.getMetersPerUnit();
              if (metersPerUnit !== undefined) {
                  pointResolution /= metersPerUnit;
              }
          }
      }
      return pointResolution;
  }
  /**
   * Registers transformation functions that don't alter coordinates. Those allow
   * to transform between projections with equal meaning.
   *
   * @param {Array<Projection>} projections Projections.
   * @api
   */
  function addEquivalentProjections(projections) {
      addProjections(projections);
      projections.forEach(function (source) {
          projections.forEach(function (destination) {
              if (source !== destination) {
                  add$1(source, destination, cloneTransform);
              }
          });
      });
  }
  /**
   * Registers transformation functions to convert coordinates in any projection
   * in projection1 to any projection in projection2.
   *
   * @param {Array<Projection>} projections1 Projections with equal
   *     meaning.
   * @param {Array<Projection>} projections2 Projections with equal
   *     meaning.
   * @param {TransformFunction} forwardTransform Transformation from any
   *   projection in projection1 to any projection in projection2.
   * @param {TransformFunction} inverseTransform Transform from any projection
   *   in projection2 to any projection in projection1..
   */
  function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
      projections1.forEach(function (projection1) {
          projections2.forEach(function (projection2) {
              add$1(projection1, projection2, forwardTransform);
              add$1(projection2, projection1, inverseTransform);
          });
      });
  }
  /**
   * @param {Projection|string|undefined} projection Projection.
   * @param {string} defaultCode Default code.
   * @return {Projection} Projection.
   */
  function createProjection(projection, defaultCode) {
      if (!projection) {
          return get$2(defaultCode);
      }
      else if (typeof projection === 'string') {
          return get$2(projection);
      }
      else {
          return /** @type {Projection} */ (projection);
      }
  }
  /**
   * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform
   * function.
   * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} coordTransform Coordinate
   *     transform.
   * @return {TransformFunction} Transform function.
   */
  function createTransformFromCoordinateTransform(coordTransform) {
      return (
      /**
       * @param {Array<number>} input Input.
       * @param {Array<number>=} opt_output Output.
       * @param {number=} opt_dimension Dimension.
       * @return {Array<number>} Output.
       */
      function (input, opt_output, opt_dimension) {
          var length = input.length;
          var dimension = opt_dimension !== undefined ? opt_dimension : 2;
          var output = opt_output !== undefined ? opt_output : new Array(length);
          for (var i = 0; i < length; i += dimension) {
              var point = coordTransform([input[i], input[i + 1]]);
              output[i] = point[0];
              output[i + 1] = point[1];
              for (var j = dimension - 1; j >= 2; --j) {
                  output[i + j] = input[i + j];
              }
          }
          return output;
      });
  }
  /**
   * Registers coordinate transform functions to convert coordinates between the
   * source projection and the destination projection.
   * The forward and inverse functions convert coordinate pairs; this function
   * converts these into the functions used internally which also handle
   * extents and coordinate arrays.
   *
   * @param {ProjectionLike} source Source projection.
   * @param {ProjectionLike} destination Destination projection.
   * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} forward The forward transform
   *     function (that is, from the source projection to the destination
   *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
   *     the transformed {@link module:ol/coordinate~Coordinate}.
   * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} inverse The inverse transform
   *     function (that is, from the destination projection to the source
   *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
   *     the transformed {@link module:ol/coordinate~Coordinate}.
   * @api
   */
  function addCoordinateTransforms(source, destination, forward, inverse) {
      var sourceProj = get$2(source);
      var destProj = get$2(destination);
      add$1(sourceProj, destProj, createTransformFromCoordinateTransform(forward));
      add$1(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));
  }
  /**
   * Transforms a coordinate to longitude/latitude.
   * @param {import("./coordinate.js").Coordinate} coordinate Projected coordinate.
   * @param {ProjectionLike=} opt_projection Projection of the coordinate.
   *     The default is Web Mercator, i.e. 'EPSG:3857'.
   * @return {import("./coordinate.js").Coordinate} Coordinate as longitude and latitude, i.e. an array
   *     with longitude as 1st and latitude as 2nd element.
   * @api
   */
  function toLonLat(coordinate, opt_projection) {
      var lonLat = transform(coordinate, opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');
      var lon = lonLat[0];
      if (lon < -180 || lon > 180) {
          lonLat[0] = modulo(lon + 180, 360) - 180;
      }
      return lonLat;
  }
  /**
   * Checks if two projections are the same, that is every coordinate in one
   * projection does represent the same geographic point as the same coordinate in
   * the other projection.
   *
   * @param {Projection} projection1 Projection 1.
   * @param {Projection} projection2 Projection 2.
   * @return {boolean} Equivalent.
   * @api
   */
  function equivalent(projection1, projection2) {
      if (projection1 === projection2) {
          return true;
      }
      var equalUnits = projection1.getUnits() === projection2.getUnits();
      if (projection1.getCode() === projection2.getCode()) {
          return equalUnits;
      }
      else {
          var transformFunc = getTransformFromProjections(projection1, projection2);
          return transformFunc === cloneTransform && equalUnits;
      }
  }
  /**
   * Searches in the list of transform functions for the function for converting
   * coordinates from the source projection to the destination projection.
   *
   * @param {Projection} sourceProjection Source Projection object.
   * @param {Projection} destinationProjection Destination Projection
   *     object.
   * @return {TransformFunction} Transform function.
   */
  function getTransformFromProjections(sourceProjection, destinationProjection) {
      var sourceCode = sourceProjection.getCode();
      var destinationCode = destinationProjection.getCode();
      var transformFunc = get$1(sourceCode, destinationCode);
      if (!transformFunc) {
          transformFunc = identityTransform;
      }
      return transformFunc;
  }
  /**
   * Given the projection-like objects, searches for a transformation
   * function to convert a coordinates array from the source projection to the
   * destination projection.
   *
   * @param {ProjectionLike} source Source.
   * @param {ProjectionLike} destination Destination.
   * @return {TransformFunction} Transform function.
   * @api
   */
  function getTransform(source, destination) {
      var sourceProjection = get$2(source);
      var destinationProjection = get$2(destination);
      return getTransformFromProjections(sourceProjection, destinationProjection);
  }
  /**
   * Transforms a coordinate from source projection to destination projection.
   * This returns a new coordinate (and does not modify the original).
   *
   * See {@link module:ol/proj~transformExtent} for extent transformation.
   * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
   * subclasses for geometry transforms.
   *
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {ProjectionLike} source Source projection-like.
   * @param {ProjectionLike} destination Destination projection-like.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */
  function transform(coordinate, source, destination) {
      var transformFunc = getTransform(source, destination);
      return transformFunc(coordinate, undefined, coordinate.length);
  }
  /**
   * Transforms an extent from source projection to destination projection.  This
   * returns a new extent (and does not modify the original).
   *
   * @param {import("./extent.js").Extent} extent The extent to transform.
   * @param {ProjectionLike} source Source projection-like.
   * @param {ProjectionLike} destination Destination projection-like.
   * @param {number=} opt_stops Number of stops per side used for the transform.
   * By default only the corners are used.
   * @return {import("./extent.js").Extent} The transformed extent.
   * @api
   */
  function transformExtent(extent, source, destination, opt_stops) {
      var transformFunc = getTransform(source, destination);
      return applyTransform(extent, transformFunc, undefined, opt_stops);
  }
  /**
   * @type {?Projection}
   */
  var userProjection = null;
  /**
   * Get the projection for coordinates supplied from and returned by API methods.
   * Note that this method is not yet a part of the stable API.  Support for user
   * projections is not yet complete and should be considered experimental.
   * @returns {?Projection} The user projection (or null if not set).
   */
  function getUserProjection() {
      return userProjection;
  }
  /**
   * Return a coordinate transformed into the user projection.  If no user projection
   * is set, the original coordinate is returned.
   * @param {Array<number>} coordinate Input coordinate.
   * @param {ProjectionLike} sourceProjection The input coordinate projection.
   * @returns {Array<number>} The input coordinate in the user projection.
   */
  function toUserCoordinate(coordinate, sourceProjection) {
      {
          return coordinate;
      }
  }
  /**
   * Return a coordinate transformed from the user projection.  If no user projection
   * is set, the original coordinate is returned.
   * @param {Array<number>} coordinate Input coordinate.
   * @param {ProjectionLike} destProjection The destination projection.
   * @returns {Array<number>} The input coordinate transformed.
   */
  function fromUserCoordinate(coordinate, destProjection) {
      {
          return coordinate;
      }
  }
  /**
   * Return an extent transformed into the user projection.  If no user projection
   * is set, the original extent is returned.
   * @param {import("./extent.js").Extent} extent Input extent.
   * @param {ProjectionLike} sourceProjection The input extent projection.
   * @returns {import("./extent.js").Extent} The input extent in the user projection.
   */
  function toUserExtent(extent, sourceProjection) {
      {
          return extent;
      }
  }
  /**
   * Return an extent transformed from the user projection.  If no user projection
   * is set, the original extent is returned.
   * @param {import("./extent.js").Extent} extent Input extent.
   * @param {ProjectionLike} destProjection The destination projection.
   * @returns {import("./extent.js").Extent} The input extent transformed.
   */
  function fromUserExtent(extent, destProjection) {
      {
          return extent;
      }
  }
  /**
   * Creates a safe coordinate transform function from a coordinate transform function.
   * "Safe" means that it can handle wrapping of x-coordinates for global projections,
   * and that coordinates exceeding the source projection validity extent's range will be
   * clamped to the validity range.
   * @param {Projection} sourceProj Source projection.
   * @param {Projection} destProj Destination projection.
   * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} transform Transform function (source to destiation).
   * @return {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} Safe transform function (source to destiation).
   */
  function createSafeCoordinateTransform(sourceProj, destProj, transform) {
      return function (coord) {
          var sourceX = coord[0];
          var sourceY = coord[1];
          var transformed, worldsAway;
          if (sourceProj.canWrapX()) {
              var sourceExtent = sourceProj.getExtent();
              var sourceExtentWidth = getWidth(sourceExtent);
              worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);
              if (worldsAway) {
                  // Move x to the real world
                  sourceX = sourceX - worldsAway * sourceExtentWidth;
              }
              sourceX = clamp(sourceX, sourceExtent[0], sourceExtent[2]);
              sourceY = clamp(sourceY, sourceExtent[1], sourceExtent[3]);
              transformed = transform([sourceX, sourceY]);
          }
          else {
              transformed = transform(coord);
          }
          if (worldsAway && destProj.canWrapX()) {
              // Move transformed coordinate back to the offset world
              transformed[0] += worldsAway * getWidth(destProj.getExtent());
          }
          return transformed;
      };
  }
  /**
   * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
   * by when this module is executed and should only need to be called again after
   * `clearAllProjections()` is called (e.g. in tests).
   */
  function addCommon() {
      // Add transformations that don't alter coordinates to convert within set of
      // projections with equal meaning.
      addEquivalentProjections(PROJECTIONS);
      addEquivalentProjections(PROJECTIONS$1);
      // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
      // coordinates and back.
      addEquivalentTransforms(PROJECTIONS$1, PROJECTIONS, fromEPSG4326, toEPSG4326);
  }
  addCommon();

  var __extends$8 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @type {import("../transform.js").Transform}
   */
  var tmpTransform = create();
  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * Base class for vector geometries.
   *
   * To get notified of changes to the geometry, register a listener for the
   * generic `change` event on your geometry instance.
   *
   * @abstract
   * @api
   */
  var Geometry = /** @class */ (function (_super) {
      __extends$8(Geometry, _super);
      function Geometry() {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {import("../extent.js").Extent}
           */
          _this.extent_ = createEmpty();
          /**
           * @private
           * @type {number}
           */
          _this.extentRevision_ = -1;
          /**
           * @protected
           * @type {number}
           */
          _this.simplifiedGeometryMaxMinSquaredTolerance = 0;
          /**
           * @protected
           * @type {number}
           */
          _this.simplifiedGeometryRevision = 0;
          /**
           * Get a transformed and simplified version of the geometry.
           * @abstract
           * @param {number} revision The geometry revision.
           * @param {number} squaredTolerance Squared tolerance.
           * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
           * @return {Geometry} Simplified geometry.
           */
          _this.simplifyTransformedInternal = memoizeOne(function (revision, squaredTolerance, opt_transform) {
              if (!opt_transform) {
                  return this.getSimplifiedGeometry(squaredTolerance);
              }
              var clone = this.clone();
              clone.applyTransform(opt_transform);
              return clone.getSimplifiedGeometry(squaredTolerance);
          });
          return _this;
      }
      /**
       * Get a transformed and simplified version of the geometry.
       * @abstract
       * @param {number} squaredTolerance Squared tolerance.
       * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
       * @return {Geometry} Simplified geometry.
       */
      Geometry.prototype.simplifyTransformed = function (squaredTolerance, opt_transform) {
          return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, opt_transform);
      };
      /**
       * Make a complete copy of the geometry.
       * @abstract
       * @return {!Geometry} Clone.
       */
      Geometry.prototype.clone = function () {
          return abstract();
      };
      /**
       * @abstract
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      Geometry.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
          return abstract();
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */
      Geometry.prototype.containsXY = function (x, y) {
          var coord = this.getClosestPoint([x, y]);
          return coord[0] === x && coord[1] === y;
      };
      /**
       * Return the closest point of the geometry to the passed point as
       * {@link module:ol/coordinate~Coordinate coordinate}.
       * @param {import("../coordinate.js").Coordinate} point Point.
       * @param {import("../coordinate.js").Coordinate=} opt_closestPoint Closest point.
       * @return {import("../coordinate.js").Coordinate} Closest point.
       * @api
       */
      Geometry.prototype.getClosestPoint = function (point, opt_closestPoint) {
          var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];
          this.closestPointXY(point[0], point[1], closestPoint, Infinity);
          return closestPoint;
      };
      /**
       * Returns true if this geometry includes the specified coordinate. If the
       * coordinate is on the boundary of the geometry, returns false.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @return {boolean} Contains coordinate.
       * @api
       */
      Geometry.prototype.intersectsCoordinate = function (coordinate) {
          return this.containsXY(coordinate[0], coordinate[1]);
      };
      /**
       * @abstract
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */
      Geometry.prototype.computeExtent = function (extent) {
          return abstract();
      };
      /**
       * Get the extent of the geometry.
       * @param {import("../extent.js").Extent=} opt_extent Extent.
       * @return {import("../extent.js").Extent} extent Extent.
       * @api
       */
      Geometry.prototype.getExtent = function (opt_extent) {
          if (this.extentRevision_ != this.getRevision()) {
              var extent = this.computeExtent(this.extent_);
              if (isNaN(extent[0]) || isNaN(extent[1])) {
                  createOrUpdateEmpty(extent);
              }
              this.extentRevision_ = this.getRevision();
          }
          return returnOrUpdate(this.extent_, opt_extent);
      };
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} angle Rotation angle in radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       */
      Geometry.prototype.rotate = function (angle, anchor) {
          abstract();
      };
      /**
       * Scale the geometry (with an optional origin).  This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} sx The scaling factor in the x-direction.
       * @param {number=} opt_sy The scaling factor in the y-direction (defaults to sx).
       * @param {import("../coordinate.js").Coordinate=} opt_anchor The scale origin (defaults to the center
       *     of the geometry extent).
       * @api
       */
      Geometry.prototype.scale = function (sx, opt_sy, opt_anchor) {
          abstract();
      };
      /**
       * Create a simplified version of this geometry.  For linestrings, this uses
       * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
       * algorithm.  For polygons, a quantization-based
       * simplification is used to preserve topology.
       * @param {number} tolerance The tolerance distance for simplification.
       * @return {Geometry} A new, simplified version of the original geometry.
       * @api
       */
      Geometry.prototype.simplify = function (tolerance) {
          return this.getSimplifiedGeometry(tolerance * tolerance);
      };
      /**
       * Create a simplified version of this geometry using the Douglas Peucker
       * algorithm.
       * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
       * @abstract
       * @param {number} squaredTolerance Squared tolerance.
       * @return {Geometry} Simplified geometry.
       */
      Geometry.prototype.getSimplifiedGeometry = function (squaredTolerance) {
          return abstract();
      };
      /**
       * Get the type of this geometry.
       * @abstract
       * @return {import("./GeometryType.js").default} Geometry type.
       */
      Geometry.prototype.getType = function () {
          return abstract();
      };
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @abstract
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       * Called with a flat array of geometry coordinates.
       */
      Geometry.prototype.applyTransform = function (transformFn) {
          abstract();
      };
      /**
       * Test if the geometry and the passed extent intersect.
       * @abstract
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       */
      Geometry.prototype.intersectsExtent = function (extent) {
          return abstract();
      };
      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @abstract
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       */
      Geometry.prototype.translate = function (deltaX, deltaY) {
          abstract();
      };
      /**
       * Transform each coordinate of the geometry from one coordinate reference
       * system to another. The geometry is modified in place.
       * For example, a line will be transformed to a line and a circle to a circle.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       *
       * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
       *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
       * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
       *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
       * @return {Geometry} This geometry.  Note that original geometry is
       *     modified in place.
       * @api
       */
      Geometry.prototype.transform = function (source, destination) {
          /** @type {import("../proj/Projection.js").default} */
          var sourceProj = get$2(source);
          var transformFn = sourceProj.getUnits() == Units.TILE_PIXELS
              ? function (inCoordinates, outCoordinates, stride) {
                  var pixelExtent = sourceProj.getExtent();
                  var projectedExtent = sourceProj.getWorldExtent();
                  var scale = getHeight(projectedExtent) / getHeight(pixelExtent);
                  compose(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
                  transform2D(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);
                  return getTransform(sourceProj, destination)(inCoordinates, outCoordinates, stride);
              }
              : getTransform(sourceProj, destination);
          this.applyTransform(transformFn);
          return this;
      };
      return Geometry;
  }(BaseObject));

  /**
   * @module ol/geom/GeometryLayout
   */
  /**
   * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
   * or measure ('M') coordinate is available. Supported values are `'XY'`,
   * `'XYZ'`, `'XYM'`, `'XYZM'`.
   * @enum {string}
   */
  var GeometryLayout = {
      XY: 'XY',
      XYZ: 'XYZ',
      XYM: 'XYM',
      XYZM: 'XYZM',
  };

  var __extends$9 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Abstract base class; only used for creating subclasses; do not instantiate
   * in apps, as cannot be rendered.
   *
   * @abstract
   * @api
   */
  var SimpleGeometry = /** @class */ (function (_super) {
      __extends$9(SimpleGeometry, _super);
      function SimpleGeometry() {
          var _this = _super.call(this) || this;
          /**
           * @protected
           * @type {import("./GeometryLayout.js").default}
           */
          _this.layout = GeometryLayout.XY;
          /**
           * @protected
           * @type {number}
           */
          _this.stride = 2;
          /**
           * @protected
           * @type {Array<number>}
           */
          _this.flatCoordinates = null;
          return _this;
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */
      SimpleGeometry.prototype.computeExtent = function (extent) {
          return createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
      };
      /**
       * @abstract
       * @return {Array<*>} Coordinates.
       */
      SimpleGeometry.prototype.getCoordinates = function () {
          return abstract();
      };
      /**
       * Return the first coordinate of the geometry.
       * @return {import("../coordinate.js").Coordinate} First coordinate.
       * @api
       */
      SimpleGeometry.prototype.getFirstCoordinate = function () {
          return this.flatCoordinates.slice(0, this.stride);
      };
      /**
       * @return {Array<number>} Flat coordinates.
       */
      SimpleGeometry.prototype.getFlatCoordinates = function () {
          return this.flatCoordinates;
      };
      /**
       * Return the last coordinate of the geometry.
       * @return {import("../coordinate.js").Coordinate} Last point.
       * @api
       */
      SimpleGeometry.prototype.getLastCoordinate = function () {
          return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
      };
      /**
       * Return the {@link module:ol/geom/GeometryLayout layout} of the geometry.
       * @return {import("./GeometryLayout.js").default} Layout.
       * @api
       */
      SimpleGeometry.prototype.getLayout = function () {
          return this.layout;
      };
      /**
       * Create a simplified version of this geometry using the Douglas Peucker algorithm.
       * @param {number} squaredTolerance Squared tolerance.
       * @return {SimpleGeometry} Simplified geometry.
       */
      SimpleGeometry.prototype.getSimplifiedGeometry = function (squaredTolerance) {
          if (this.simplifiedGeometryRevision !== this.getRevision()) {
              this.simplifiedGeometryMaxMinSquaredTolerance = 0;
              this.simplifiedGeometryRevision = this.getRevision();
          }
          // If squaredTolerance is negative or if we know that simplification will not
          // have any effect then just return this.
          if (squaredTolerance < 0 ||
              (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&
                  squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)) {
              return this;
          }
          var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
          var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
          if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
              return simplifiedGeometry;
          }
          else {
              // Simplification did not actually remove any coordinates.  We now know
              // that any calls to getSimplifiedGeometry with a squaredTolerance less
              // than or equal to the current squaredTolerance will also not have any
              // effect.  This allows us to short circuit simplification (saving CPU
              // cycles) and prevents the cache of simplified geometries from filling
              // up with useless identical copies of this geometry (saving memory).
              this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
              return this;
          }
      };
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {SimpleGeometry} Simplified geometry.
       * @protected
       */
      SimpleGeometry.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
          return this;
      };
      /**
       * @return {number} Stride.
       */
      SimpleGeometry.prototype.getStride = function () {
          return this.stride;
      };
      /**
       * @param {import("./GeometryLayout.js").default} layout Layout.
       * @param {Array<number>} flatCoordinates Flat coordinates.
       */
      SimpleGeometry.prototype.setFlatCoordinates = function (layout, flatCoordinates) {
          this.stride = getStrideForLayout(layout);
          this.layout = layout;
          this.flatCoordinates = flatCoordinates;
      };
      /**
       * @abstract
       * @param {!Array<*>} coordinates Coordinates.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       */
      SimpleGeometry.prototype.setCoordinates = function (coordinates, opt_layout) {
          abstract();
      };
      /**
       * @param {import("./GeometryLayout.js").default|undefined} layout Layout.
       * @param {Array<*>} coordinates Coordinates.
       * @param {number} nesting Nesting.
       * @protected
       */
      SimpleGeometry.prototype.setLayout = function (layout, coordinates, nesting) {
          /** @type {number} */
          var stride;
          if (layout) {
              stride = getStrideForLayout(layout);
          }
          else {
              for (var i = 0; i < nesting; ++i) {
                  if (coordinates.length === 0) {
                      this.layout = GeometryLayout.XY;
                      this.stride = 2;
                      return;
                  }
                  else {
                      coordinates = /** @type {Array} */ (coordinates[0]);
                  }
              }
              stride = coordinates.length;
              layout = getLayoutForStride(stride);
          }
          this.layout = layout;
          this.stride = stride;
      };
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       * Called with a flat array of geometry coordinates.
       * @api
       */
      SimpleGeometry.prototype.applyTransform = function (transformFn) {
          if (this.flatCoordinates) {
              transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
              this.changed();
          }
      };
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @param {number} angle Rotation angle in radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       */
      SimpleGeometry.prototype.rotate = function (angle, anchor) {
          var flatCoordinates = this.getFlatCoordinates();
          if (flatCoordinates) {
              var stride = this.getStride();
              rotate(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);
              this.changed();
          }
      };
      /**
       * Scale the geometry (with an optional origin).  This modifies the geometry
       * coordinates in place.
       * @param {number} sx The scaling factor in the x-direction.
       * @param {number=} opt_sy The scaling factor in the y-direction (defaults to sx).
       * @param {import("../coordinate.js").Coordinate=} opt_anchor The scale origin (defaults to the center
       *     of the geometry extent).
       * @api
       */
      SimpleGeometry.prototype.scale = function (sx, opt_sy, opt_anchor) {
          var sy = opt_sy;
          if (sy === undefined) {
              sy = sx;
          }
          var anchor = opt_anchor;
          if (!anchor) {
              anchor = getCenter(this.getExtent());
          }
          var flatCoordinates = this.getFlatCoordinates();
          if (flatCoordinates) {
              var stride = this.getStride();
              scale(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);
              this.changed();
          }
      };
      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       */
      SimpleGeometry.prototype.translate = function (deltaX, deltaY) {
          var flatCoordinates = this.getFlatCoordinates();
          if (flatCoordinates) {
              var stride = this.getStride();
              translate(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);
              this.changed();
          }
      };
      return SimpleGeometry;
  }(Geometry));
  /**
   * @param {number} stride Stride.
   * @return {import("./GeometryLayout.js").default} layout Layout.
   */
  function getLayoutForStride(stride) {
      var layout;
      if (stride == 2) {
          layout = GeometryLayout.XY;
      }
      else if (stride == 3) {
          layout = GeometryLayout.XYZ;
      }
      else if (stride == 4) {
          layout = GeometryLayout.XYZM;
      }
      return /** @type {import("./GeometryLayout.js").default} */ (layout);
  }
  /**
   * @param {import("./GeometryLayout.js").default} layout Layout.
   * @return {number} Stride.
   */
  function getStrideForLayout(layout) {
      var stride;
      if (layout == GeometryLayout.XY) {
          stride = 2;
      }
      else if (layout == GeometryLayout.XYZ || layout == GeometryLayout.XYM) {
          stride = 3;
      }
      else if (layout == GeometryLayout.XYZM) {
          stride = 4;
      }
      return /** @type {number} */ (stride);
  }
  /**
   * @param {SimpleGeometry} simpleGeometry Simple geometry.
   * @param {import("../transform.js").Transform} transform Transform.
   * @param {Array<number>=} opt_dest Destination.
   * @return {Array<number>} Transformed flat coordinates.
   */
  function transformGeom2D(simpleGeometry, transform, opt_dest) {
      var flatCoordinates = simpleGeometry.getFlatCoordinates();
      if (!flatCoordinates) {
          return null;
      }
      else {
          var stride = simpleGeometry.getStride();
          return transform2D(flatCoordinates, 0, flatCoordinates.length, stride, transform, opt_dest);
      }
  }

  /**
   * @module ol/render/canvas/Immediate
   */
  // FIXME test, especially polygons with holes and multipolygons
  // FIXME need to handle large thick features (where pixel size matters)
  // FIXME add offset and end to ol/geom/flat/transform~transform2D?
  var __extends$a = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * A concrete subclass of {@link module:ol/render/VectorContext} that implements
   * direct rendering of features and geometries to an HTML5 Canvas context.
   * Instances of this class are created internally by the library and
   * provided to application code as vectorContext member of the
   * {@link module:ol/render/Event~RenderEvent} object associated with postcompose, precompose and
   * render events emitted by layers and maps.
   */
  var CanvasImmediateRenderer = /** @class */ (function (_super) {
      __extends$a(CanvasImmediateRenderer, _super);
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../../extent.js").Extent} extent Extent.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {number=} opt_squaredTolerance Optional squared tolerance for simplification.
       * @param {import("../../proj.js").TransformFunction=} opt_userTransform Transform from user to view projection.
       */
      function CanvasImmediateRenderer(context, pixelRatio, extent, transform, viewRotation, opt_squaredTolerance, opt_userTransform) {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {CanvasRenderingContext2D}
           */
          _this.context_ = context;
          /**
           * @private
           * @type {number}
           */
          _this.pixelRatio_ = pixelRatio;
          /**
           * @private
           * @type {import("../../extent.js").Extent}
           */
          _this.extent_ = extent;
          /**
           * @private
           * @type {import("../../transform.js").Transform}
           */
          _this.transform_ = transform;
          /**
           * @private
           * @type {number}
           */
          _this.viewRotation_ = viewRotation;
          /**
           * @private
           * @type {number}
           */
          _this.squaredTolerance_ = opt_squaredTolerance;
          /**
           * @private
           * @type {import("../../proj.js").TransformFunction}
           */
          _this.userTransform_ = opt_userTransform;
          /**
           * @private
           * @type {?import("../canvas.js").FillState}
           */
          _this.contextFillState_ = null;
          /**
           * @private
           * @type {?import("../canvas.js").StrokeState}
           */
          _this.contextStrokeState_ = null;
          /**
           * @private
           * @type {?import("../canvas.js").TextState}
           */
          _this.contextTextState_ = null;
          /**
           * @private
           * @type {?import("../canvas.js").FillState}
           */
          _this.fillState_ = null;
          /**
           * @private
           * @type {?import("../canvas.js").StrokeState}
           */
          _this.strokeState_ = null;
          /**
           * @private
           * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
           */
          _this.image_ = null;
          /**
           * @private
           * @type {number}
           */
          _this.imageAnchorX_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.imageAnchorY_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.imageHeight_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.imageOpacity_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.imageOriginX_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.imageOriginY_ = 0;
          /**
           * @private
           * @type {boolean}
           */
          _this.imageRotateWithView_ = false;
          /**
           * @private
           * @type {number}
           */
          _this.imageRotation_ = 0;
          /**
           * @private
           * @type {import("../../size.js").Size}
           */
          _this.imageScale_ = [0, 0];
          /**
           * @private
           * @type {number}
           */
          _this.imageWidth_ = 0;
          /**
           * @private
           * @type {string}
           */
          _this.text_ = '';
          /**
           * @private
           * @type {number}
           */
          _this.textOffsetX_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.textOffsetY_ = 0;
          /**
           * @private
           * @type {boolean}
           */
          _this.textRotateWithView_ = false;
          /**
           * @private
           * @type {number}
           */
          _this.textRotation_ = 0;
          /**
           * @private
           * @type {import("../../size.js").Size}
           */
          _this.textScale_ = [0, 0];
          /**
           * @private
           * @type {?import("../canvas.js").FillState}
           */
          _this.textFillState_ = null;
          /**
           * @private
           * @type {?import("../canvas.js").StrokeState}
           */
          _this.textStrokeState_ = null;
          /**
           * @private
           * @type {?import("../canvas.js").TextState}
           */
          _this.textState_ = null;
          /**
           * @private
           * @type {Array<number>}
           */
          _this.pixelCoordinates_ = [];
          /**
           * @private
           * @type {import("../../transform.js").Transform}
           */
          _this.tmpLocalTransform_ = create();
          return _this;
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       */
      CanvasImmediateRenderer.prototype.drawImages_ = function (flatCoordinates, offset, end, stride) {
          if (!this.image_) {
              return;
          }
          var pixelCoordinates = transform2D(flatCoordinates, offset, end, 2, this.transform_, this.pixelCoordinates_);
          var context = this.context_;
          var localTransform = this.tmpLocalTransform_;
          var alpha = context.globalAlpha;
          if (this.imageOpacity_ != 1) {
              context.globalAlpha = alpha * this.imageOpacity_;
          }
          var rotation = this.imageRotation_;
          if (this.imageRotateWithView_) {
              rotation += this.viewRotation_;
          }
          for (var i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
              var x = pixelCoordinates[i] - this.imageAnchorX_;
              var y = pixelCoordinates[i + 1] - this.imageAnchorY_;
              if (rotation !== 0 ||
                  this.imageScale_[0] != 1 ||
                  this.imageScale_[1] != 1) {
                  var centerX = x + this.imageAnchorX_;
                  var centerY = y + this.imageAnchorY_;
                  compose(localTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);
                  context.setTransform.apply(context, localTransform);
                  context.translate(centerX, centerY);
                  context.scale(this.imageScale_[0], this.imageScale_[1]);
                  context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_);
                  context.setTransform(1, 0, 0, 1, 0, 0);
              }
              else {
                  context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x, y, this.imageWidth_, this.imageHeight_);
              }
          }
          if (this.imageOpacity_ != 1) {
              context.globalAlpha = alpha;
          }
      };
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       */
      CanvasImmediateRenderer.prototype.drawText_ = function (flatCoordinates, offset, end, stride) {
          if (!this.textState_ || this.text_ === '') {
              return;
          }
          if (this.textFillState_) {
              this.setContextFillState_(this.textFillState_);
          }
          if (this.textStrokeState_) {
              this.setContextStrokeState_(this.textStrokeState_);
          }
          this.setContextTextState_(this.textState_);
          var pixelCoordinates = transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
          var context = this.context_;
          var rotation = this.textRotation_;
          if (this.textRotateWithView_) {
              rotation += this.viewRotation_;
          }
          for (; offset < end; offset += stride) {
              var x = pixelCoordinates[offset] + this.textOffsetX_;
              var y = pixelCoordinates[offset + 1] + this.textOffsetY_;
              if (rotation !== 0 ||
                  this.textScale_[0] != 1 ||
                  this.textScale_[1] != 1) {
                  var localTransform = compose(this.tmpLocalTransform_, x, y, 1, 1, rotation, -x, -y);
                  context.setTransform.apply(context, localTransform);
                  context.translate(x, y);
                  context.scale(this.textScale_[0], this.textScale_[1]);
                  if (this.textStrokeState_) {
                      context.strokeText(this.text_, 0, 0);
                  }
                  if (this.textFillState_) {
                      context.fillText(this.text_, 0, 0);
                  }
                  context.setTransform(1, 0, 0, 1, 0, 0);
              }
              else {
                  if (this.textStrokeState_) {
                      context.strokeText(this.text_, x, y);
                  }
                  if (this.textFillState_) {
                      context.fillText(this.text_, x, y);
                  }
              }
          }
      };
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @param {boolean} close Close.
       * @private
       * @return {number} end End.
       */
      CanvasImmediateRenderer.prototype.moveToLineTo_ = function (flatCoordinates, offset, end, stride, close) {
          var context = this.context_;
          var pixelCoordinates = transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
          context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
          var length = pixelCoordinates.length;
          if (close) {
              length -= 2;
          }
          for (var i = 2; i < length; i += 2) {
              context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
          }
          if (close) {
              context.closePath();
          }
          return end;
      };
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @private
       * @return {number} End.
       */
      CanvasImmediateRenderer.prototype.drawRings_ = function (flatCoordinates, offset, ends, stride) {
          for (var i = 0, ii = ends.length; i < ii; ++i) {
              offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
          }
          return offset;
      };
      /**
       * Render a circle geometry into the canvas.  Rendering is immediate and uses
       * the current fill and stroke styles.
       *
       * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
       * @api
       */
      CanvasImmediateRenderer.prototype.drawCircle = function (geometry) {
          if (!intersects(this.extent_, geometry.getExtent())) {
              return;
          }
          if (this.fillState_ || this.strokeState_) {
              if (this.fillState_) {
                  this.setContextFillState_(this.fillState_);
              }
              if (this.strokeState_) {
                  this.setContextStrokeState_(this.strokeState_);
              }
              var pixelCoordinates = transformGeom2D(geometry, this.transform_, this.pixelCoordinates_);
              var dx = pixelCoordinates[2] - pixelCoordinates[0];
              var dy = pixelCoordinates[3] - pixelCoordinates[1];
              var radius = Math.sqrt(dx * dx + dy * dy);
              var context = this.context_;
              context.beginPath();
              context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);
              if (this.fillState_) {
                  context.fill();
              }
              if (this.strokeState_) {
                  context.stroke();
              }
          }
          if (this.text_ !== '') {
              this.drawText_(geometry.getCenter(), 0, 2, 2);
          }
      };
      /**
       * Set the rendering style.  Note that since this is an immediate rendering API,
       * any `zIndex` on the provided style will be ignored.
       *
       * @param {import("../../style/Style.js").default} style The rendering style.
       * @api
       */
      CanvasImmediateRenderer.prototype.setStyle = function (style) {
          this.setFillStrokeStyle(style.getFill(), style.getStroke());
          this.setImageStyle(style.getImage());
          this.setTextStyle(style.getText());
      };
      /**
       * @param {import("../../transform.js").Transform} transform Transform.
       */
      CanvasImmediateRenderer.prototype.setTransform = function (transform) {
          this.transform_ = transform;
      };
      /**
       * Render a geometry into the canvas.  Call
       * {@link module:ol/render/canvas/Immediate#setStyle} first to set the rendering style.
       *
       * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
       * @api
       */
      CanvasImmediateRenderer.prototype.drawGeometry = function (geometry) {
          var type = geometry.getType();
          switch (type) {
              case GeometryType.POINT:
                  this.drawPoint(
                  /** @type {import("../../geom/Point.js").default} */ (geometry));
                  break;
              case GeometryType.LINE_STRING:
                  this.drawLineString(
                  /** @type {import("../../geom/LineString.js").default} */ (geometry));
                  break;
              case GeometryType.POLYGON:
                  this.drawPolygon(
                  /** @type {import("../../geom/Polygon.js").default} */ (geometry));
                  break;
              case GeometryType.MULTI_POINT:
                  this.drawMultiPoint(
                  /** @type {import("../../geom/MultiPoint.js").default} */ (geometry));
                  break;
              case GeometryType.MULTI_LINE_STRING:
                  this.drawMultiLineString(
                  /** @type {import("../../geom/MultiLineString.js").default} */ (geometry));
                  break;
              case GeometryType.MULTI_POLYGON:
                  this.drawMultiPolygon(
                  /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry));
                  break;
              case GeometryType.GEOMETRY_COLLECTION:
                  this.drawGeometryCollection(
                  /** @type {import("../../geom/GeometryCollection.js").default} */ (geometry));
                  break;
              case GeometryType.CIRCLE:
                  this.drawCircle(
                  /** @type {import("../../geom/Circle.js").default} */ (geometry));
                  break;
          }
      };
      /**
       * Render a feature into the canvas.  Note that any `zIndex` on the provided
       * style will be ignored - features are rendered immediately in the order that
       * this method is called.  If you need `zIndex` support, you should be using an
       * {@link module:ol/layer/Vector~VectorLayer} instead.
       *
       * @param {import("../../Feature.js").default} feature Feature.
       * @param {import("../../style/Style.js").default} style Style.
       * @api
       */
      CanvasImmediateRenderer.prototype.drawFeature = function (feature, style) {
          var geometry = style.getGeometryFunction()(feature);
          if (!geometry || !intersects(this.extent_, geometry.getExtent())) {
              return;
          }
          this.setStyle(style);
          this.drawGeometry(geometry);
      };
      /**
       * Render a GeometryCollection to the canvas.  Rendering is immediate and
       * uses the current styles appropriate for each geometry in the collection.
       *
       * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
       */
      CanvasImmediateRenderer.prototype.drawGeometryCollection = function (geometry) {
          var geometries = geometry.getGeometriesArray();
          for (var i = 0, ii = geometries.length; i < ii; ++i) {
              this.drawGeometry(geometries[i]);
          }
      };
      /**
       * Render a Point geometry into the canvas.  Rendering is immediate and uses
       * the current style.
       *
       * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
       */
      CanvasImmediateRenderer.prototype.drawPoint = function (geometry) {
          if (this.squaredTolerance_) {
              geometry = /** @type {import("../../geom/Point.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          }
          var flatCoordinates = geometry.getFlatCoordinates();
          var stride = geometry.getStride();
          if (this.image_) {
              this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
          }
          if (this.text_ !== '') {
              this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
          }
      };
      /**
       * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
       * uses the current style.
       *
       * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
       */
      CanvasImmediateRenderer.prototype.drawMultiPoint = function (geometry) {
          if (this.squaredTolerance_) {
              geometry = /** @type {import("../../geom/MultiPoint.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          }
          var flatCoordinates = geometry.getFlatCoordinates();
          var stride = geometry.getStride();
          if (this.image_) {
              this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
          }
          if (this.text_ !== '') {
              this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
          }
      };
      /**
       * Render a LineString into the canvas.  Rendering is immediate and uses
       * the current style.
       *
       * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
       */
      CanvasImmediateRenderer.prototype.drawLineString = function (geometry) {
          if (this.squaredTolerance_) {
              geometry = /** @type {import("../../geom/LineString.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          }
          if (!intersects(this.extent_, geometry.getExtent())) {
              return;
          }
          if (this.strokeState_) {
              this.setContextStrokeState_(this.strokeState_);
              var context = this.context_;
              var flatCoordinates = geometry.getFlatCoordinates();
              context.beginPath();
              this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);
              context.stroke();
          }
          if (this.text_ !== '') {
              var flatMidpoint = geometry.getFlatMidpoint();
              this.drawText_(flatMidpoint, 0, 2, 2);
          }
      };
      /**
       * Render a MultiLineString geometry into the canvas.  Rendering is immediate
       * and uses the current style.
       *
       * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
       */
      CanvasImmediateRenderer.prototype.drawMultiLineString = function (geometry) {
          if (this.squaredTolerance_) {
              geometry = /** @type {import("../../geom/MultiLineString.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          }
          var geometryExtent = geometry.getExtent();
          if (!intersects(this.extent_, geometryExtent)) {
              return;
          }
          if (this.strokeState_) {
              this.setContextStrokeState_(this.strokeState_);
              var context = this.context_;
              var flatCoordinates = geometry.getFlatCoordinates();
              var offset = 0;
              var ends = /** @type {Array<number>} */ (geometry.getEnds());
              var stride = geometry.getStride();
              context.beginPath();
              for (var i = 0, ii = ends.length; i < ii; ++i) {
                  offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
              }
              context.stroke();
          }
          if (this.text_ !== '') {
              var flatMidpoints = geometry.getFlatMidpoints();
              this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
          }
      };
      /**
       * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
       * the current style.
       *
       * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
       */
      CanvasImmediateRenderer.prototype.drawPolygon = function (geometry) {
          if (this.squaredTolerance_) {
              geometry = /** @type {import("../../geom/Polygon.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          }
          if (!intersects(this.extent_, geometry.getExtent())) {
              return;
          }
          if (this.strokeState_ || this.fillState_) {
              if (this.fillState_) {
                  this.setContextFillState_(this.fillState_);
              }
              if (this.strokeState_) {
                  this.setContextStrokeState_(this.strokeState_);
              }
              var context = this.context_;
              context.beginPath();
              this.drawRings_(geometry.getOrientedFlatCoordinates(), 0, 
              /** @type {Array<number>} */ (geometry.getEnds()), geometry.getStride());
              if (this.fillState_) {
                  context.fill();
              }
              if (this.strokeState_) {
                  context.stroke();
              }
          }
          if (this.text_ !== '') {
              var flatInteriorPoint = geometry.getFlatInteriorPoint();
              this.drawText_(flatInteriorPoint, 0, 2, 2);
          }
      };
      /**
       * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
       * uses the current style.
       * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
       */
      CanvasImmediateRenderer.prototype.drawMultiPolygon = function (geometry) {
          if (this.squaredTolerance_) {
              geometry = /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          }
          if (!intersects(this.extent_, geometry.getExtent())) {
              return;
          }
          if (this.strokeState_ || this.fillState_) {
              if (this.fillState_) {
                  this.setContextFillState_(this.fillState_);
              }
              if (this.strokeState_) {
                  this.setContextStrokeState_(this.strokeState_);
              }
              var context = this.context_;
              var flatCoordinates = geometry.getOrientedFlatCoordinates();
              var offset = 0;
              var endss = geometry.getEndss();
              var stride = geometry.getStride();
              context.beginPath();
              for (var i = 0, ii = endss.length; i < ii; ++i) {
                  var ends = endss[i];
                  offset = this.drawRings_(flatCoordinates, offset, ends, stride);
              }
              if (this.fillState_) {
                  context.fill();
              }
              if (this.strokeState_) {
                  context.stroke();
              }
          }
          if (this.text_ !== '') {
              var flatInteriorPoints = geometry.getFlatInteriorPoints();
              this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
          }
      };
      /**
       * @param {import("../canvas.js").FillState} fillState Fill state.
       * @private
       */
      CanvasImmediateRenderer.prototype.setContextFillState_ = function (fillState) {
          var context = this.context_;
          var contextFillState = this.contextFillState_;
          if (!contextFillState) {
              context.fillStyle = fillState.fillStyle;
              this.contextFillState_ = {
                  fillStyle: fillState.fillStyle,
              };
          }
          else {
              if (contextFillState.fillStyle != fillState.fillStyle) {
                  contextFillState.fillStyle = fillState.fillStyle;
                  context.fillStyle = fillState.fillStyle;
              }
          }
      };
      /**
       * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
       * @private
       */
      CanvasImmediateRenderer.prototype.setContextStrokeState_ = function (strokeState) {
          var context = this.context_;
          var contextStrokeState = this.contextStrokeState_;
          if (!contextStrokeState) {
              context.lineCap = strokeState.lineCap;
              if (context.setLineDash) {
                  context.setLineDash(strokeState.lineDash);
                  context.lineDashOffset = strokeState.lineDashOffset;
              }
              context.lineJoin = strokeState.lineJoin;
              context.lineWidth = strokeState.lineWidth;
              context.miterLimit = strokeState.miterLimit;
              context.strokeStyle = strokeState.strokeStyle;
              this.contextStrokeState_ = {
                  lineCap: strokeState.lineCap,
                  lineDash: strokeState.lineDash,
                  lineDashOffset: strokeState.lineDashOffset,
                  lineJoin: strokeState.lineJoin,
                  lineWidth: strokeState.lineWidth,
                  miterLimit: strokeState.miterLimit,
                  strokeStyle: strokeState.strokeStyle,
              };
          }
          else {
              if (contextStrokeState.lineCap != strokeState.lineCap) {
                  contextStrokeState.lineCap = strokeState.lineCap;
                  context.lineCap = strokeState.lineCap;
              }
              if (context.setLineDash) {
                  if (!equals(contextStrokeState.lineDash, strokeState.lineDash)) {
                      context.setLineDash((contextStrokeState.lineDash = strokeState.lineDash));
                  }
                  if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
                      contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
                      context.lineDashOffset = strokeState.lineDashOffset;
                  }
              }
              if (contextStrokeState.lineJoin != strokeState.lineJoin) {
                  contextStrokeState.lineJoin = strokeState.lineJoin;
                  context.lineJoin = strokeState.lineJoin;
              }
              if (contextStrokeState.lineWidth != strokeState.lineWidth) {
                  contextStrokeState.lineWidth = strokeState.lineWidth;
                  context.lineWidth = strokeState.lineWidth;
              }
              if (contextStrokeState.miterLimit != strokeState.miterLimit) {
                  contextStrokeState.miterLimit = strokeState.miterLimit;
                  context.miterLimit = strokeState.miterLimit;
              }
              if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
                  contextStrokeState.strokeStyle = strokeState.strokeStyle;
                  context.strokeStyle = strokeState.strokeStyle;
              }
          }
      };
      /**
       * @param {import("../canvas.js").TextState} textState Text state.
       * @private
       */
      CanvasImmediateRenderer.prototype.setContextTextState_ = function (textState) {
          var context = this.context_;
          var contextTextState = this.contextTextState_;
          var textAlign = textState.textAlign
              ? textState.textAlign
              : defaultTextAlign;
          if (!contextTextState) {
              context.font = textState.font;
              context.textAlign = /** @type {CanvasTextAlign} */ (textAlign);
              context.textBaseline = /** @type {CanvasTextBaseline} */ (textState.textBaseline);
              this.contextTextState_ = {
                  font: textState.font,
                  textAlign: textAlign,
                  textBaseline: textState.textBaseline,
              };
          }
          else {
              if (contextTextState.font != textState.font) {
                  contextTextState.font = textState.font;
                  context.font = textState.font;
              }
              if (contextTextState.textAlign != textAlign) {
                  contextTextState.textAlign = /** @type {CanvasTextAlign} */ (textAlign);
                  context.textAlign = /** @type {CanvasTextAlign} */ (textAlign);
              }
              if (contextTextState.textBaseline != textState.textBaseline) {
                  contextTextState.textBaseline = /** @type {CanvasTextBaseline} */ (textState.textBaseline);
                  context.textBaseline = /** @type {CanvasTextBaseline} */ (textState.textBaseline);
              }
          }
      };
      /**
       * Set the fill and stroke style for subsequent draw operations.  To clear
       * either fill or stroke styles, pass null for the appropriate parameter.
       *
       * @param {import("../../style/Fill.js").default} fillStyle Fill style.
       * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
       */
      CanvasImmediateRenderer.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
          if (!fillStyle) {
              this.fillState_ = null;
          }
          else {
              var fillStyleColor = fillStyle.getColor();
              this.fillState_ = {
                  fillStyle: asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle),
              };
          }
          if (!strokeStyle) {
              this.strokeState_ = null;
          }
          else {
              var strokeStyleColor = strokeStyle.getColor();
              var strokeStyleLineCap = strokeStyle.getLineCap();
              var strokeStyleLineDash = strokeStyle.getLineDash();
              var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
              var strokeStyleLineJoin = strokeStyle.getLineJoin();
              var strokeStyleWidth = strokeStyle.getWidth();
              var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
              this.strokeState_ = {
                  lineCap: strokeStyleLineCap !== undefined
                      ? strokeStyleLineCap
                      : defaultLineCap,
                  lineDash: strokeStyleLineDash ? strokeStyleLineDash : defaultLineDash,
                  lineDashOffset: strokeStyleLineDashOffset
                      ? strokeStyleLineDashOffset
                      : defaultLineDashOffset,
                  lineJoin: strokeStyleLineJoin !== undefined
                      ? strokeStyleLineJoin
                      : defaultLineJoin,
                  lineWidth: this.pixelRatio_ *
                      (strokeStyleWidth !== undefined
                          ? strokeStyleWidth
                          : defaultLineWidth),
                  miterLimit: strokeStyleMiterLimit !== undefined
                      ? strokeStyleMiterLimit
                      : defaultMiterLimit,
                  strokeStyle: asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle),
              };
          }
      };
      /**
       * Set the image style for subsequent draw operations.  Pass null to remove
       * the image style.
       *
       * @param {import("../../style/Image.js").default} imageStyle Image style.
       */
      CanvasImmediateRenderer.prototype.setImageStyle = function (imageStyle) {
          if (!imageStyle) {
              this.image_ = null;
          }
          else {
              var imageSize = imageStyle.getSize();
              if (!imageSize) {
                  this.image_ = null;
              }
              else {
                  var imageAnchor = imageStyle.getAnchor();
                  // FIXME pixel ratio
                  var imageImage = imageStyle.getImage(1);
                  var imageOrigin = imageStyle.getOrigin();
                  var imageScale = imageStyle.getScaleArray();
                  this.imageAnchorX_ = imageAnchor[0];
                  this.imageAnchorY_ = imageAnchor[1];
                  this.imageHeight_ = imageSize[1];
                  this.image_ = imageImage;
                  this.imageOpacity_ = imageStyle.getOpacity();
                  this.imageOriginX_ = imageOrigin[0];
                  this.imageOriginY_ = imageOrigin[1];
                  this.imageRotateWithView_ = imageStyle.getRotateWithView();
                  this.imageRotation_ = imageStyle.getRotation();
                  this.imageScale_ = [
                      this.pixelRatio_ * imageScale[0],
                      this.pixelRatio_ * imageScale[1],
                  ];
                  this.imageWidth_ = imageSize[0];
              }
          }
      };
      /**
       * Set the text style for subsequent draw operations.  Pass null to
       * remove the text style.
       *
       * @param {import("../../style/Text.js").default} textStyle Text style.
       */
      CanvasImmediateRenderer.prototype.setTextStyle = function (textStyle) {
          if (!textStyle) {
              this.text_ = '';
          }
          else {
              var textFillStyle = textStyle.getFill();
              if (!textFillStyle) {
                  this.textFillState_ = null;
              }
              else {
                  var textFillStyleColor = textFillStyle.getColor();
                  this.textFillState_ = {
                      fillStyle: asColorLike(textFillStyleColor ? textFillStyleColor : defaultFillStyle),
                  };
              }
              var textStrokeStyle = textStyle.getStroke();
              if (!textStrokeStyle) {
                  this.textStrokeState_ = null;
              }
              else {
                  var textStrokeStyleColor = textStrokeStyle.getColor();
                  var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
                  var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
                  var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
                  var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
                  var textStrokeStyleWidth = textStrokeStyle.getWidth();
                  var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
                  this.textStrokeState_ = {
                      lineCap: textStrokeStyleLineCap !== undefined
                          ? textStrokeStyleLineCap
                          : defaultLineCap,
                      lineDash: textStrokeStyleLineDash
                          ? textStrokeStyleLineDash
                          : defaultLineDash,
                      lineDashOffset: textStrokeStyleLineDashOffset
                          ? textStrokeStyleLineDashOffset
                          : defaultLineDashOffset,
                      lineJoin: textStrokeStyleLineJoin !== undefined
                          ? textStrokeStyleLineJoin
                          : defaultLineJoin,
                      lineWidth: textStrokeStyleWidth !== undefined
                          ? textStrokeStyleWidth
                          : defaultLineWidth,
                      miterLimit: textStrokeStyleMiterLimit !== undefined
                          ? textStrokeStyleMiterLimit
                          : defaultMiterLimit,
                      strokeStyle: asColorLike(textStrokeStyleColor ? textStrokeStyleColor : defaultStrokeStyle),
                  };
              }
              var textFont = textStyle.getFont();
              var textOffsetX = textStyle.getOffsetX();
              var textOffsetY = textStyle.getOffsetY();
              var textRotateWithView = textStyle.getRotateWithView();
              var textRotation = textStyle.getRotation();
              var textScale = textStyle.getScaleArray();
              var textText = textStyle.getText();
              var textTextAlign = textStyle.getTextAlign();
              var textTextBaseline = textStyle.getTextBaseline();
              this.textState_ = {
                  font: textFont !== undefined ? textFont : defaultFont,
                  textAlign: textTextAlign !== undefined ? textTextAlign : defaultTextAlign,
                  textBaseline: textTextBaseline !== undefined
                      ? textTextBaseline
                      : defaultTextBaseline,
              };
              this.text_ = textText !== undefined ? textText : '';
              this.textOffsetX_ =
                  textOffsetX !== undefined ? this.pixelRatio_ * textOffsetX : 0;
              this.textOffsetY_ =
                  textOffsetY !== undefined ? this.pixelRatio_ * textOffsetY : 0;
              this.textRotateWithView_ =
                  textRotateWithView !== undefined ? textRotateWithView : false;
              this.textRotation_ = textRotation !== undefined ? textRotation : 0;
              this.textScale_ = [
                  this.pixelRatio_ * textScale[0],
                  this.pixelRatio_ * textScale[1],
              ];
          }
      };
      return CanvasImmediateRenderer;
  }(VectorContext));

  /**
   * @module ol/render/canvas/BuilderType
   */
  /**
   * @enum {string}
   */
  var ReplayType = {
      CIRCLE: 'Circle',
      DEFAULT: 'Default',
      IMAGE: 'Image',
      LINE_STRING: 'LineString',
      POLYGON: 'Polygon',
      TEXT: 'Text',
  };

  /**
   * @module ol/ImageState
   */
  /**
   * @enum {number}
   */
  var ImageState = {
      IDLE: 0,
      LOADING: 1,
      LOADED: 2,
      ERROR: 3,
      EMPTY: 4,
  };

  /**
   * @module ol/renderer/vector
   */
  /**
   * Tolerance for geometry simplification in device pixels.
   * @type {number}
   */
  var SIMPLIFY_TOLERANCE = 0.5;
  /**
   * @const
   * @type {Object<import("../geom/GeometryType.js").default,
   *                function(import("../render/canvas/BuilderGroup.js").default, import("../geom/Geometry.js").default,
   *                         import("../style/Style.js").default, Object): void>}
   */
  var GEOMETRY_RENDERERS = {
      'Point': renderPointGeometry,
      'LineString': renderLineStringGeometry,
      'Polygon': renderPolygonGeometry,
      'MultiPoint': renderMultiPointGeometry,
      'MultiLineString': renderMultiLineStringGeometry,
      'MultiPolygon': renderMultiPolygonGeometry,
      'GeometryCollection': renderGeometryCollectionGeometry,
      'Circle': renderCircleGeometry,
  };
  /**
   * @param {import("../Feature.js").FeatureLike} feature1 Feature 1.
   * @param {import("../Feature.js").FeatureLike} feature2 Feature 2.
   * @return {number} Order.
   */
  function defaultOrder(feature1, feature2) {
      return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);
  }
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Squared pixel tolerance.
   */
  function getSquaredTolerance(resolution, pixelRatio) {
      var tolerance = getTolerance(resolution, pixelRatio);
      return tolerance * tolerance;
  }
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel tolerance.
   */
  function getTolerance(resolution, pixelRatio) {
      return (SIMPLIFY_TOLERANCE * resolution) / pixelRatio;
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").default} feature Feature.
   */
  function renderCircleGeometry(builderGroup, geometry, style, feature) {
      var fillStyle = style.getFill();
      var strokeStyle = style.getStroke();
      if (fillStyle || strokeStyle) {
          var circleReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.CIRCLE);
          circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
          circleReplay.drawCircle(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
          var textReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.TEXT);
          textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(false));
          textReplay.drawText(geometry, feature);
      }
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @param {import("../proj.js").TransformFunction} [opt_transform] Transform from user to view projection.
   * @return {boolean} `true` if style is loading.
   * @template T
   */
  function renderFeature(replayGroup, feature, style, squaredTolerance, listener, opt_transform) {
      var loading = false;
      var imageStyle = style.getImage();
      if (imageStyle) {
          var imageState = imageStyle.getImageState();
          if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {
              imageStyle.unlistenImageChange(listener);
          }
          else {
              if (imageState == ImageState.IDLE) {
                  imageStyle.load();
              }
              imageState = imageStyle.getImageState();
              imageStyle.listenImageChange(listener);
              loading = true;
          }
      }
      renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform);
      return loading;
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
   */
  function renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform) {
      var geometry = style.getGeometryFunction()(feature);
      if (!geometry) {
          return;
      }
      var simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, opt_transform);
      var renderer = style.getRenderer();
      if (renderer) {
          renderGeometry(replayGroup, simplifiedGeometry, style, feature);
      }
      else {
          var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
          geometryRenderer(replayGroup, simplifiedGeometry, style, feature);
      }
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
   * @param {import("../geom/Geometry.js").default|import("../render/Feature.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  function renderGeometry(replayGroup, geometry, style, feature) {
      if (geometry.getType() == GeometryType.GEOMETRY_COLLECTION) {
          var geometries = /** @type {import("../geom/GeometryCollection.js").default} */ (geometry).getGeometries();
          for (var i = 0, ii = geometries.length; i < ii; ++i) {
              renderGeometry(replayGroup, geometries[i], style, feature);
          }
          return;
      }
      var replay = replayGroup.getBuilder(style.getZIndex(), ReplayType.DEFAULT);
      replay.drawCustom(
      /** @type {import("../geom/SimpleGeometry.js").default} */ (geometry), feature, style.getRenderer());
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").default} feature Feature.
   */
  function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature) {
      var geometries = geometry.getGeometriesArray();
      var i, ii;
      for (i = 0, ii = geometries.length; i < ii; ++i) {
          var geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];
          geometryRenderer(replayGroup, geometries[i], style, feature);
      }
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {import("../geom/LineString.js").default|import("../render/Feature.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  function renderLineStringGeometry(builderGroup, geometry, style, feature) {
      var strokeStyle = style.getStroke();
      if (strokeStyle) {
          var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.LINE_STRING);
          lineStringReplay.setFillStrokeStyle(null, strokeStyle);
          lineStringReplay.drawLineString(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
          var textReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.TEXT);
          textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(false));
          textReplay.drawText(geometry, feature);
      }
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {import("../geom/MultiLineString.js").default|import("../render/Feature.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  function renderMultiLineStringGeometry(builderGroup, geometry, style, feature) {
      var strokeStyle = style.getStroke();
      if (strokeStyle) {
          var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.LINE_STRING);
          lineStringReplay.setFillStrokeStyle(null, strokeStyle);
          lineStringReplay.drawMultiLineString(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
          var textReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.TEXT);
          textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(false));
          textReplay.drawText(geometry, feature);
      }
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").default} feature Feature.
   */
  function renderMultiPolygonGeometry(builderGroup, geometry, style, feature) {
      var fillStyle = style.getFill();
      var strokeStyle = style.getStroke();
      if (strokeStyle || fillStyle) {
          var polygonReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.POLYGON);
          polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
          polygonReplay.drawMultiPolygon(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
          var textReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.TEXT);
          textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(false));
          textReplay.drawText(geometry, feature);
      }
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {import("../geom/Point.js").default|import("../render/Feature.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  function renderPointGeometry(builderGroup, geometry, style, feature) {
      var imageStyle = style.getImage();
      if (imageStyle) {
          if (imageStyle.getImageState() != ImageState.LOADED) {
              return;
          }
          var imageReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.IMAGE);
          imageReplay.setImageStyle(imageStyle, builderGroup.addDeclutter(false));
          imageReplay.drawPoint(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
          var textReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.TEXT);
          textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(!!imageStyle));
          textReplay.drawText(geometry, feature);
      }
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {import("../geom/MultiPoint.js").default|import("../render/Feature.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  function renderMultiPointGeometry(builderGroup, geometry, style, feature) {
      var imageStyle = style.getImage();
      if (imageStyle) {
          if (imageStyle.getImageState() != ImageState.LOADED) {
              return;
          }
          var imageReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.IMAGE);
          imageReplay.setImageStyle(imageStyle, builderGroup.addDeclutter(false));
          imageReplay.drawMultiPoint(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
          var textReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.TEXT);
          textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(!!imageStyle));
          textReplay.drawText(geometry, feature);
      }
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {import("../geom/Polygon.js").default|import("../render/Feature.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  function renderPolygonGeometry(builderGroup, geometry, style, feature) {
      var fillStyle = style.getFill();
      var strokeStyle = style.getStroke();
      if (fillStyle || strokeStyle) {
          var polygonReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.POLYGON);
          polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
          polygonReplay.drawPolygon(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
          var textReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.TEXT);
          textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(false));
          textReplay.drawText(geometry, feature);
      }
  }

  /**
   * @module ol/render
   */
  /**
   * @param {import("./PluggableMap.js").FrameState} frameState Frame state.
   * @param {?} declutterTree Declutter tree.
   * @returns {?} Declutter tree.
   */
  function renderDeclutterItems(frameState, declutterTree) {
      if (declutterTree) {
          declutterTree.clear();
      }
      var items = frameState.declutterItems;
      for (var z = items.length - 1; z >= 0; --z) {
          var item = items[z];
          var zIndexItems = item.items;
          for (var i = 0, ii = zIndexItems.length; i < ii; i += 3) {
              declutterTree = zIndexItems[i].renderDeclutter(zIndexItems[i + 1], zIndexItems[i + 2], item.opacity, declutterTree);
          }
      }
      items.length = 0;
      return declutterTree;
  }

  var __extends$b = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @abstract
   */
  var MapRenderer = /** @class */ (function (_super) {
      __extends$b(MapRenderer, _super);
      /**
       * @param {import("../PluggableMap.js").default} map Map.
       */
      function MapRenderer(map) {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {import("../PluggableMap.js").default}
           */
          _this.map_ = map;
          /**
           * @private
           */
          _this.declutterTree_ = null;
          return _this;
      }
      /**
       * @abstract
       * @param {import("../render/EventType.js").default} type Event type.
       * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
       */
      MapRenderer.prototype.dispatchRenderEvent = function (type, frameState) {
          abstract();
      };
      /**
       * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
       * @protected
       */
      MapRenderer.prototype.calculateMatrices2D = function (frameState) {
          var viewState = frameState.viewState;
          var coordinateToPixelTransform = frameState.coordinateToPixelTransform;
          var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
          compose(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);
          makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);
      };
      /**
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {boolean} checkWrapped Check for wrapped geometries.
       * @param {function(this: S, import("../Feature.js").FeatureLike,
       *     import("../layer/Layer.js").default): T} callback Feature callback.
       * @param {S} thisArg Value to use as `this` when executing `callback`.
       * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
       *     function, only layers which are visible and for which this function
       *     returns `true` will be tested for features.  By default, all visible
       *     layers will be tested.
       * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
       * @return {T|undefined} Callback result.
       * @template S,T,U
       */
      MapRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
          var result;
          var viewState = frameState.viewState;
          /**
           * @param {boolean} managed Managed layer.
           * @param {import("../Feature.js").FeatureLike} feature Feature.
           * @param {import("../layer/Layer.js").default} layer Layer.
           * @return {?} Callback result.
           */
          function forEachFeatureAtCoordinate(managed, feature, layer) {
              return callback.call(thisArg, feature, managed ? layer : null);
          }
          var projection = viewState.projection;
          var translatedCoordinate = wrapX$1(coordinate.slice(), projection);
          var offsets = [[0, 0]];
          if (projection.canWrapX() && checkWrapped) {
              var projectionExtent = projection.getExtent();
              var worldWidth = getWidth(projectionExtent);
              offsets.push([-worldWidth, 0], [worldWidth, 0]);
          }
          var layerStates = frameState.layerStatesArray;
          var numLayers = layerStates.length;
          var declutteredFeatures;
          if (this.declutterTree_) {
              declutteredFeatures = this.declutterTree_.all().map(function (entry) {
                  return entry.value;
              });
          }
          var tmpCoord = [];
          for (var i = 0; i < offsets.length; i++) {
              for (var j = numLayers - 1; j >= 0; --j) {
                  var layerState = layerStates[j];
                  var layer = /** @type {import("../layer/Layer.js").default} */ (layerState.layer);
                  if (layer.hasRenderer() &&
                      inView(layerState, viewState) &&
                      layerFilter.call(thisArg2, layer)) {
                      var layerRenderer = layer.getRenderer();
                      var source = layer.getSource();
                      if (layerRenderer && source) {
                          var coordinates = source.getWrapX()
                              ? translatedCoordinate
                              : coordinate;
                          var callback_1 = forEachFeatureAtCoordinate.bind(null, layerState.managed);
                          tmpCoord[0] = coordinates[0] + offsets[i][0];
                          tmpCoord[1] = coordinates[1] + offsets[i][1];
                          result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, callback_1, declutteredFeatures);
                      }
                      if (result) {
                          return result;
                      }
                  }
              }
          }
          return undefined;
      };
      /**
       * @abstract
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {function(import("../layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback Layer
       *     callback.
       * @param {function(import("../layer/Layer.js").default): boolean} layerFilter Layer filter
       *     function, only layers which are visible and for which this function
       *     returns `true` will be tested for features.  By default, all visible
       *     layers will be tested.
       * @return {T|undefined} Callback result.
       * @template T
       */
      MapRenderer.prototype.forEachLayerAtPixel = function (pixel, frameState, hitTolerance, callback, layerFilter) {
          return abstract();
      };
      /**
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {boolean} checkWrapped Check for wrapped geometries.
       * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
       *     function, only layers which are visible and for which this function
       *     returns `true` will be tested for features.  By default, all visible
       *     layers will be tested.
       * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
       * @return {boolean} Is there a feature at the given coordinate?
       * @template U
       */
      MapRenderer.prototype.hasFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
          var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, TRUE, this, layerFilter, thisArg);
          return hasFeature !== undefined;
      };
      /**
       * @return {import("../PluggableMap.js").default} Map.
       */
      MapRenderer.prototype.getMap = function () {
          return this.map_;
      };
      /**
       * Render.
       * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
       */
      MapRenderer.prototype.renderFrame = function (frameState) {
          this.declutterTree_ = renderDeclutterItems(frameState, this.declutterTree_);
      };
      /**
       * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
       * @protected
       */
      MapRenderer.prototype.scheduleExpireIconCache = function (frameState) {
          if (shared.canExpireCache()) {
              frameState.postRenderFunctions.push(expireIconCache);
          }
      };
      return MapRenderer;
  }(Disposable));
  /**
   * @param {import("../PluggableMap.js").default} map Map.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   */
  function expireIconCache(map, frameState) {
      shared.expire();
  }

  /**
   * @module ol/render/Event
   */
  var __extends$c = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var RenderEvent = /** @class */ (function (_super) {
      __extends$c(RenderEvent, _super);
      /**
       * @param {import("./EventType.js").default} type Type.
       * @param {import("../transform.js").Transform=} opt_inversePixelTransform Transform for
       *     CSS pixels to rendered pixels.
       * @param {import("../PluggableMap.js").FrameState=} opt_frameState Frame state.
       * @param {?CanvasRenderingContext2D=} opt_context Context.
       */
      function RenderEvent(type, opt_inversePixelTransform, opt_frameState, opt_context) {
          var _this = _super.call(this, type) || this;
          /**
           * Transform from CSS pixels (relative to the top-left corner of the map viewport)
           * to rendered pixels on this event's `context`.
           * @type {import("../transform.js").Transform|undefined}
           * @api
           */
          _this.inversePixelTransform = opt_inversePixelTransform;
          /**
           * An object representing the current render frame state.
           * @type {import("../PluggableMap.js").FrameState|undefined}
           * @api
           */
          _this.frameState = opt_frameState;
          /**
           * Canvas context. Not available when the event is dispatched by the map. Only available
           * when a Canvas renderer is used, null otherwise.
           * @type {CanvasRenderingContext2D|null|undefined}
           * @api
           */
          _this.context = opt_context;
          return _this;
      }
      return RenderEvent;
  }(BaseEvent));

  var __extends$d = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Canvas map renderer.
   * @api
   */
  var CompositeMapRenderer = /** @class */ (function (_super) {
      __extends$d(CompositeMapRenderer, _super);
      /**
       * @param {import("../PluggableMap.js").default} map Map.
       */
      function CompositeMapRenderer(map) {
          var _this = _super.call(this, map) || this;
          /**
           * @type {import("../events.js").EventsKey}
           */
          _this.fontChangeListenerKey_ = listen(checkedFonts, ObjectEventType.PROPERTYCHANGE, map.redrawText.bind(map));
          /**
           * @private
           * @type {HTMLDivElement}
           */
          _this.element_ = document.createElement('div');
          var style = _this.element_.style;
          style.position = 'absolute';
          style.width = '100%';
          style.height = '100%';
          style.zIndex = '0';
          _this.element_.className = CLASS_UNSELECTABLE + ' ol-layers';
          var container = map.getViewport();
          container.insertBefore(_this.element_, container.firstChild || null);
          /**
           * @private
           * @type {Array<HTMLElement>}
           */
          _this.children_ = [];
          /**
           * @private
           * @type {boolean}
           */
          _this.renderedVisible_ = true;
          return _this;
      }
      /**
       * @param {import("../render/EventType.js").default} type Event type.
       * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
       */
      CompositeMapRenderer.prototype.dispatchRenderEvent = function (type, frameState) {
          var map = this.getMap();
          if (map.hasListener(type)) {
              var event_1 = new RenderEvent(type, undefined, frameState);
              map.dispatchEvent(event_1);
          }
      };
      CompositeMapRenderer.prototype.disposeInternal = function () {
          unlistenByKey(this.fontChangeListenerKey_);
          this.element_.parentNode.removeChild(this.element_);
          _super.prototype.disposeInternal.call(this);
      };
      /**
       * Render.
       * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
       */
      CompositeMapRenderer.prototype.renderFrame = function (frameState) {
          if (!frameState) {
              if (this.renderedVisible_) {
                  this.element_.style.display = 'none';
                  this.renderedVisible_ = false;
              }
              return;
          }
          this.calculateMatrices2D(frameState);
          this.dispatchRenderEvent(EventType$1.PRECOMPOSE, frameState);
          var layerStatesArray = frameState.layerStatesArray.sort(function (a, b) {
              return a.zIndex - b.zIndex;
          });
          var viewState = frameState.viewState;
          this.children_.length = 0;
          var previousElement = null;
          for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
              var layerState = layerStatesArray[i];
              frameState.layerIndex = i;
              if (!inView(layerState, viewState) ||
                  (layerState.sourceState != SourceState.READY &&
                      layerState.sourceState != SourceState.UNDEFINED)) {
                  continue;
              }
              var layer = layerState.layer;
              var element = layer.render(frameState, previousElement);
              if (!element) {
                  continue;
              }
              if (element !== previousElement) {
                  this.children_.push(element);
                  previousElement = element;
              }
          }
          _super.prototype.renderFrame.call(this, frameState);
          replaceChildren(this.element_, this.children_);
          this.dispatchRenderEvent(EventType$1.POSTCOMPOSE, frameState);
          if (!this.renderedVisible_) {
              this.element_.style.display = '';
              this.renderedVisible_ = true;
          }
          this.scheduleExpireIconCache(frameState);
      };
      /**
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {function(import("../layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback Layer
       *     callback.
       * @param {function(import("../layer/Layer.js").default): boolean} layerFilter Layer filter
       *     function, only layers which are visible and for which this function
       *     returns `true` will be tested for features.  By default, all visible
       *     layers will be tested.
       * @return {T|undefined} Callback result.
       * @template T
       */
      CompositeMapRenderer.prototype.forEachLayerAtPixel = function (pixel, frameState, hitTolerance, callback, layerFilter) {
          var viewState = frameState.viewState;
          var layerStates = frameState.layerStatesArray;
          var numLayers = layerStates.length;
          for (var i = numLayers - 1; i >= 0; --i) {
              var layerState = layerStates[i];
              var layer = layerState.layer;
              if (layer.hasRenderer() &&
                  inView(layerState, viewState) &&
                  layerFilter(layer)) {
                  var layerRenderer = layer.getRenderer();
                  var data = layerRenderer.getDataAtPixel(pixel, frameState, hitTolerance);
                  if (data) {
                      var result = callback(layer, data);
                      if (result) {
                          return result;
                      }
                  }
              }
          }
          return undefined;
      };
      return CompositeMapRenderer;
  }(MapRenderer));

  /**
   * @module ol/CollectionEventType
   */
  /**
   * @enum {string}
   */
  var CollectionEventType = {
      /**
       * Triggered when an item is added to the collection.
       * @event module:ol/Collection.CollectionEvent#add
       * @api
       */
      ADD: 'add',
      /**
       * Triggered when an item is removed from the collection.
       * @event module:ol/Collection.CollectionEvent#remove
       * @api
       */
      REMOVE: 'remove',
  };

  var __extends$e = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @enum {string}
   * @private
   */
  var Property = {
      LENGTH: 'length',
  };
  /**
   * @classdesc
   * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this
   * type.
   */
  var CollectionEvent = /** @class */ (function (_super) {
      __extends$e(CollectionEvent, _super);
      /**
       * @param {import("./CollectionEventType.js").default} type Type.
       * @param {*=} opt_element Element.
       * @param {number=} opt_index The index of the added or removed element.
       */
      function CollectionEvent(type, opt_element, opt_index) {
          var _this = _super.call(this, type) || this;
          /**
           * The element that is added to or removed from the collection.
           * @type {*}
           * @api
           */
          _this.element = opt_element;
          /**
           * The index of the added or removed element.
           * @type {number}
           * @api
           */
          _this.index = opt_index;
          return _this;
      }
      return CollectionEvent;
  }(BaseEvent));
  /**
   * @typedef {Object} Options
   * @property {boolean} [unique=false] Disallow the same item from being added to
   * the collection twice.
   */
  /**
   * @classdesc
   * An expanded version of standard JS Array, adding convenience methods for
   * manipulation. Add and remove changes to the Collection trigger a Collection
   * event. Note that this does not cover changes to the objects _within_ the
   * Collection; they trigger events on the appropriate object, not on the
   * Collection as a whole.
   *
   * @fires CollectionEvent
   *
   * @template T
   * @api
   */
  var Collection = /** @class */ (function (_super) {
      __extends$e(Collection, _super);
      /**
       * @param {Array<T>=} opt_array Array.
       * @param {Options=} opt_options Collection options.
       */
      function Collection(opt_array, opt_options) {
          var _this = _super.call(this) || this;
          var options = opt_options || {};
          /**
           * @private
           * @type {boolean}
           */
          _this.unique_ = !!options.unique;
          /**
           * @private
           * @type {!Array<T>}
           */
          _this.array_ = opt_array ? opt_array : [];
          if (_this.unique_) {
              for (var i = 0, ii = _this.array_.length; i < ii; ++i) {
                  _this.assertUnique_(_this.array_[i], i);
              }
          }
          _this.updateLength_();
          return _this;
      }
      /**
       * Remove all elements from the collection.
       * @api
       */
      Collection.prototype.clear = function () {
          while (this.getLength() > 0) {
              this.pop();
          }
      };
      /**
       * Add elements to the collection.  This pushes each item in the provided array
       * to the end of the collection.
       * @param {!Array<T>} arr Array.
       * @return {Collection<T>} This collection.
       * @api
       */
      Collection.prototype.extend = function (arr) {
          for (var i = 0, ii = arr.length; i < ii; ++i) {
              this.push(arr[i]);
          }
          return this;
      };
      /**
       * Iterate over each element, calling the provided callback.
       * @param {function(T, number, Array<T>): *} f The function to call
       *     for every element. This function takes 3 arguments (the element, the
       *     index and the array). The return value is ignored.
       * @api
       */
      Collection.prototype.forEach = function (f) {
          var array = this.array_;
          for (var i = 0, ii = array.length; i < ii; ++i) {
              f(array[i], i, array);
          }
      };
      /**
       * Get a reference to the underlying Array object. Warning: if the array
       * is mutated, no events will be dispatched by the collection, and the
       * collection's "length" property won't be in sync with the actual length
       * of the array.
       * @return {!Array<T>} Array.
       * @api
       */
      Collection.prototype.getArray = function () {
          return this.array_;
      };
      /**
       * Get the element at the provided index.
       * @param {number} index Index.
       * @return {T} Element.
       * @api
       */
      Collection.prototype.item = function (index) {
          return this.array_[index];
      };
      /**
       * Get the length of this collection.
       * @return {number} The length of the array.
       * @observable
       * @api
       */
      Collection.prototype.getLength = function () {
          return this.get(Property.LENGTH);
      };
      /**
       * Insert an element at the provided index.
       * @param {number} index Index.
       * @param {T} elem Element.
       * @api
       */
      Collection.prototype.insertAt = function (index, elem) {
          if (this.unique_) {
              this.assertUnique_(elem);
          }
          this.array_.splice(index, 0, elem);
          this.updateLength_();
          this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem, index));
      };
      /**
       * Remove the last element of the collection and return it.
       * Return `undefined` if the collection is empty.
       * @return {T|undefined} Element.
       * @api
       */
      Collection.prototype.pop = function () {
          return this.removeAt(this.getLength() - 1);
      };
      /**
       * Insert the provided element at the end of the collection.
       * @param {T} elem Element.
       * @return {number} New length of the collection.
       * @api
       */
      Collection.prototype.push = function (elem) {
          if (this.unique_) {
              this.assertUnique_(elem);
          }
          var n = this.getLength();
          this.insertAt(n, elem);
          return this.getLength();
      };
      /**
       * Remove the first occurrence of an element from the collection.
       * @param {T} elem Element.
       * @return {T|undefined} The removed element or undefined if none found.
       * @api
       */
      Collection.prototype.remove = function (elem) {
          var arr = this.array_;
          for (var i = 0, ii = arr.length; i < ii; ++i) {
              if (arr[i] === elem) {
                  return this.removeAt(i);
              }
          }
          return undefined;
      };
      /**
       * Remove the element at the provided index and return it.
       * Return `undefined` if the collection does not contain this index.
       * @param {number} index Index.
       * @return {T|undefined} Value.
       * @api
       */
      Collection.prototype.removeAt = function (index) {
          var prev = this.array_[index];
          this.array_.splice(index, 1);
          this.updateLength_();
          this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev, index));
          return prev;
      };
      /**
       * Set the element at the provided index.
       * @param {number} index Index.
       * @param {T} elem Element.
       * @api
       */
      Collection.prototype.setAt = function (index, elem) {
          var n = this.getLength();
          if (index < n) {
              if (this.unique_) {
                  this.assertUnique_(elem, index);
              }
              var prev = this.array_[index];
              this.array_[index] = elem;
              this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev, index));
              this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem, index));
          }
          else {
              for (var j = n; j < index; ++j) {
                  this.insertAt(j, undefined);
              }
              this.insertAt(index, elem);
          }
      };
      /**
       * @private
       */
      Collection.prototype.updateLength_ = function () {
          this.set(Property.LENGTH, this.array_.length);
      };
      /**
       * @private
       * @param {T} elem Element.
       * @param {number=} opt_except Optional index to ignore.
       */
      Collection.prototype.assertUnique_ = function (elem, opt_except) {
          for (var i = 0, ii = this.array_.length; i < ii; ++i) {
              if (this.array_[i] === elem && i !== opt_except) {
                  throw new AssertionError(58);
              }
          }
      };
      return Collection;
  }(BaseObject));

  var __extends$f = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {number} [opacity=1] Opacity (0, 1).
   * @property {boolean} [visible=true] Visibility.
   * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
   * rendered outside of this extent.
   * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
   * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
   * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
   * method was used.
   * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
   * visible.
   * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
   * be visible.
   * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
   * visible.
   * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
   * be visible.
   * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
   * visible.
   * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
   * be visible.
   * @property {Array<import("./Base.js").default>|import("../Collection.js").default<import("./Base.js").default>} [layers] Child layers.
   */
  /**
   * @enum {string}
   * @private
   */
  var Property$1 = {
      LAYERS: 'layers',
  };
  /**
   * @classdesc
   * A {@link module:ol/Collection~Collection} of layers that are handled together.
   *
   * A generic `change` event is triggered when the group/Collection changes.
   *
   * @api
   */
  var LayerGroup = /** @class */ (function (_super) {
      __extends$f(LayerGroup, _super);
      /**
       * @param {Options=} opt_options Layer options.
       */
      function LayerGroup(opt_options) {
          var _this = this;
          var options = opt_options || {};
          var baseOptions = /** @type {Options} */ (assign({}, options));
          delete baseOptions.layers;
          var layers = options.layers;
          _this = _super.call(this, baseOptions) || this;
          /**
           * @private
           * @type {Array<import("../events.js").EventsKey>}
           */
          _this.layersListenerKeys_ = [];
          /**
           * @private
           * @type {Object<string, Array<import("../events.js").EventsKey>>}
           */
          _this.listenerKeys_ = {};
          _this.addEventListener(getChangeEventType(Property$1.LAYERS), _this.handleLayersChanged_);
          if (layers) {
              if (Array.isArray(layers)) {
                  layers = new Collection(layers.slice(), { unique: true });
              }
              else {
                  assert(typeof ( /** @type {?} */(layers).getArray) === 'function', 43); // Expected `layers` to be an array or a `Collection`
              }
          }
          else {
              layers = new Collection(undefined, { unique: true });
          }
          _this.setLayers(layers);
          return _this;
      }
      /**
       * @private
       */
      LayerGroup.prototype.handleLayerChange_ = function () {
          this.changed();
      };
      /**
       * @private
       */
      LayerGroup.prototype.handleLayersChanged_ = function () {
          this.layersListenerKeys_.forEach(unlistenByKey);
          this.layersListenerKeys_.length = 0;
          var layers = this.getLayers();
          this.layersListenerKeys_.push(listen(layers, CollectionEventType.ADD, this.handleLayersAdd_, this), listen(layers, CollectionEventType.REMOVE, this.handleLayersRemove_, this));
          for (var id in this.listenerKeys_) {
              this.listenerKeys_[id].forEach(unlistenByKey);
          }
          clear(this.listenerKeys_);
          var layersArray = layers.getArray();
          for (var i = 0, ii = layersArray.length; i < ii; i++) {
              var layer = layersArray[i];
              this.listenerKeys_[getUid(layer)] = [
                  listen(layer, ObjectEventType.PROPERTYCHANGE, this.handleLayerChange_, this),
                  listen(layer, EventType.CHANGE, this.handleLayerChange_, this),
              ];
          }
          this.changed();
      };
      /**
       * @param {import("../Collection.js").CollectionEvent} collectionEvent CollectionEvent.
       * @private
       */
      LayerGroup.prototype.handleLayersAdd_ = function (collectionEvent) {
          var layer = /** @type {import("./Base.js").default} */ (collectionEvent.element);
          this.listenerKeys_[getUid(layer)] = [
              listen(layer, ObjectEventType.PROPERTYCHANGE, this.handleLayerChange_, this),
              listen(layer, EventType.CHANGE, this.handleLayerChange_, this),
          ];
          this.changed();
      };
      /**
       * @param {import("../Collection.js").CollectionEvent} collectionEvent CollectionEvent.
       * @private
       */
      LayerGroup.prototype.handleLayersRemove_ = function (collectionEvent) {
          var layer = /** @type {import("./Base.js").default} */ (collectionEvent.element);
          var key = getUid(layer);
          this.listenerKeys_[key].forEach(unlistenByKey);
          delete this.listenerKeys_[key];
          this.changed();
      };
      /**
       * Returns the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}
       * in this group.
       * @return {!import("../Collection.js").default<import("./Base.js").default>} Collection of
       *   {@link module:ol/layer/Base layers} that are part of this group.
       * @observable
       * @api
       */
      LayerGroup.prototype.getLayers = function () {
          return /** @type {!import("../Collection.js").default<import("./Base.js").default>} */ (this.get(Property$1.LAYERS));
      };
      /**
       * Set the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}
       * in this group.
       * @param {!import("../Collection.js").default<import("./Base.js").default>} layers Collection of
       *   {@link module:ol/layer/Base layers} that are part of this group.
       * @observable
       * @api
       */
      LayerGroup.prototype.setLayers = function (layers) {
          this.set(Property$1.LAYERS, layers);
      };
      /**
       * @param {Array<import("./Layer.js").default>=} opt_array Array of layers (to be modified in place).
       * @return {Array<import("./Layer.js").default>} Array of layers.
       */
      LayerGroup.prototype.getLayersArray = function (opt_array) {
          var array = opt_array !== undefined ? opt_array : [];
          this.getLayers().forEach(function (layer) {
              layer.getLayersArray(array);
          });
          return array;
      };
      /**
       * @param {Array<import("./Layer.js").State>=} opt_states Optional list of layer states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       */
      LayerGroup.prototype.getLayerStatesArray = function (opt_states) {
          var states = opt_states !== undefined ? opt_states : [];
          var pos = states.length;
          this.getLayers().forEach(function (layer) {
              layer.getLayerStatesArray(states);
          });
          var ownLayerState = this.getLayerState();
          for (var i = pos, ii = states.length; i < ii; i++) {
              var layerState = states[i];
              layerState.opacity *= ownLayerState.opacity;
              layerState.visible = layerState.visible && ownLayerState.visible;
              layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);
              layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);
              layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
              layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);
              if (ownLayerState.extent !== undefined) {
                  if (layerState.extent !== undefined) {
                      layerState.extent = getIntersection(layerState.extent, ownLayerState.extent);
                  }
                  else {
                      layerState.extent = ownLayerState.extent;
                  }
              }
          }
          return states;
      };
      /**
       * @return {import("../source/State.js").default} Source state.
       */
      LayerGroup.prototype.getSourceState = function () {
          return SourceState.READY;
      };
      return LayerGroup;
  }(BaseLayer));

  var __extends$g = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Events emitted as map events are instances of this type.
   * See {@link module:ol/PluggableMap~PluggableMap} for which events trigger a map event.
   */
  var MapEvent = /** @class */ (function (_super) {
      __extends$g(MapEvent, _super);
      /**
       * @param {string} type Event type.
       * @param {import("./PluggableMap.js").default} map Map.
       * @param {?import("./PluggableMap.js").FrameState=} opt_frameState Frame state.
       */
      function MapEvent(type, map, opt_frameState) {
          var _this = _super.call(this, type) || this;
          /**
           * The map where the event occurred.
           * @type {import("./PluggableMap.js").default}
           * @api
           */
          _this.map = map;
          /**
           * The frame state at the time of the event.
           * @type {?import("./PluggableMap.js").FrameState}
           * @api
           */
          _this.frameState = opt_frameState !== undefined ? opt_frameState : null;
          return _this;
      }
      return MapEvent;
  }(BaseEvent));

  var __extends$h = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Events emitted as map browser events are instances of this type.
   * See {@link module:ol/PluggableMap~PluggableMap} for which events trigger a map browser event.
   * @template {UIEvent} EVENT
   */
  var MapBrowserEvent = /** @class */ (function (_super) {
      __extends$h(MapBrowserEvent, _super);
      /**
       * @param {string} type Event type.
       * @param {import("./PluggableMap.js").default} map Map.
       * @param {EVENT} originalEvent Original event.
       * @param {boolean=} opt_dragging Is the map currently being dragged?
       * @param {?import("./PluggableMap.js").FrameState=} opt_frameState Frame state.
       */
      function MapBrowserEvent(type, map, originalEvent, opt_dragging, opt_frameState) {
          var _this = _super.call(this, type, map, opt_frameState) || this;
          /**
           * The original browser event.
           * @const
           * @type {EVENT}
           * @api
           */
          _this.originalEvent = originalEvent;
          /**
           * The map pixel relative to the viewport corresponding to the original browser event.
           * @type {?import("./pixel.js").Pixel}
           */
          _this.pixel_ = null;
          /**
           * The coordinate in the user projection corresponding to the original browser event.
           * @type {?import("./coordinate.js").Coordinate}
           */
          _this.coordinate_ = null;
          /**
           * Indicates if the map is currently being dragged. Only set for
           * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
           *
           * @type {boolean}
           * @api
           */
          _this.dragging = opt_dragging !== undefined ? opt_dragging : false;
          return _this;
      }
      Object.defineProperty(MapBrowserEvent.prototype, "pixel", {
          /**
           * The map pixel relative to the viewport corresponding to the original event.
           * @type {import("./pixel.js").Pixel}
           * @api
           */
          get: function () {
              if (!this.pixel_) {
                  this.pixel_ = this.map.getEventPixel(this.originalEvent);
              }
              return this.pixel_;
          },
          set: function (pixel) {
              this.pixel_ = pixel;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(MapBrowserEvent.prototype, "coordinate", {
          /**
           * The coordinate corresponding to the original browser event.  This will be in the user
           * projection if one is set.  Otherwise it will be in the view projection.
           * @type {import("./coordinate.js").Coordinate}
           * @api
           */
          get: function () {
              if (!this.coordinate_) {
                  this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
              }
              return this.coordinate_;
          },
          set: function (coordinate) {
              this.coordinate_ = coordinate;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * Prevents the default browser action.
       * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
       * @api
       */
      MapBrowserEvent.prototype.preventDefault = function () {
          _super.prototype.preventDefault.call(this);
          this.originalEvent.preventDefault();
      };
      /**
       * Prevents further propagation of the current event.
       * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
       * @api
       */
      MapBrowserEvent.prototype.stopPropagation = function () {
          _super.prototype.stopPropagation.call(this);
          this.originalEvent.stopPropagation();
      };
      return MapBrowserEvent;
  }(MapEvent));

  /**
   * @module ol/MapBrowserEventType
   */
  /**
   * Constants for event names.
   * @enum {string}
   */
  var MapBrowserEventType = {
      /**
       * A true single click with no dragging and no double click. Note that this
       * event is delayed by 250 ms to ensure that it is not a double click.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
       * @api
       */
      SINGLECLICK: 'singleclick',
      /**
       * A click with no dragging. A double click will fire two of this.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
       * @api
       */
      CLICK: EventType.CLICK,
      /**
       * A true double click, with no dragging.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
       * @api
       */
      DBLCLICK: EventType.DBLCLICK,
      /**
       * Triggered when a pointer is dragged.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
       * @api
       */
      POINTERDRAG: 'pointerdrag',
      /**
       * Triggered when a pointer is moved. Note that on touch devices this is
       * triggered when the map is panned, so is not the same as mousemove.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
       * @api
       */
      POINTERMOVE: 'pointermove',
      POINTERDOWN: 'pointerdown',
      POINTERUP: 'pointerup',
      POINTEROVER: 'pointerover',
      POINTEROUT: 'pointerout',
      POINTERENTER: 'pointerenter',
      POINTERLEAVE: 'pointerleave',
      POINTERCANCEL: 'pointercancel',
  };

  /**
   * @module ol/pointer/EventType
   */
  /**
   * Constants for event names.
   * @enum {string}
   */
  var PointerEventType = {
      POINTERMOVE: 'pointermove',
      POINTERDOWN: 'pointerdown',
      POINTERUP: 'pointerup',
      POINTEROVER: 'pointerover',
      POINTEROUT: 'pointerout',
      POINTERENTER: 'pointerenter',
      POINTERLEAVE: 'pointerleave',
      POINTERCANCEL: 'pointercancel',
  };

  /**
   * @module ol/MapBrowserEventHandler
   */
  var __extends$i = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var MapBrowserEventHandler = /** @class */ (function (_super) {
      __extends$i(MapBrowserEventHandler, _super);
      /**
       * @param {import("./PluggableMap.js").default} map The map with the viewport to listen to events on.
       * @param {number=} moveTolerance The minimal distance the pointer must travel to trigger a move.
       */
      function MapBrowserEventHandler(map, moveTolerance) {
          var _this = _super.call(this, map) || this;
          /**
           * This is the element that we will listen to the real events on.
           * @type {import("./PluggableMap.js").default}
           * @private
           */
          _this.map_ = map;
          /**
           * @type {any}
           * @private
           */
          _this.clickTimeoutId_;
          /**
           * @type {boolean}
           * @private
           */
          _this.dragging_ = false;
          /**
           * @type {!Array<import("./events.js").EventsKey>}
           * @private
           */
          _this.dragListenerKeys_ = [];
          /**
           * @type {number}
           * @private
           */
          _this.moveTolerance_ = moveTolerance
              ? moveTolerance * DEVICE_PIXEL_RATIO
              : DEVICE_PIXEL_RATIO;
          /**
           * The most recent "down" type event (or null if none have occurred).
           * Set on pointerdown.
           * @type {PointerEvent}
           * @private
           */
          _this.down_ = null;
          var element = _this.map_.getViewport();
          /**
           * @type {number}
           * @private
           */
          _this.activePointers_ = 0;
          /**
           * @type {!Object<number, boolean>}
           * @private
           */
          _this.trackedTouches_ = {};
          _this.element_ = element;
          /**
           * @type {?import("./events.js").EventsKey}
           * @private
           */
          _this.pointerdownListenerKey_ = listen(element, PointerEventType.POINTERDOWN, _this.handlePointerDown_, _this);
          /**
           * @type {PointerEvent}
           * @private
           */
          _this.originalPointerMoveEvent_;
          /**
           * @type {?import("./events.js").EventsKey}
           * @private
           */
          _this.relayedListenerKey_ = listen(element, PointerEventType.POINTERMOVE, _this.relayEvent_, _this);
          /**
           * @private
           */
          _this.boundHandleTouchMove_ = _this.handleTouchMove_.bind(_this);
          _this.element_.addEventListener(EventType.TOUCHMOVE, _this.boundHandleTouchMove_, PASSIVE_EVENT_LISTENERS ? { passive: false } : false);
          return _this;
      }
      /**
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */
      MapBrowserEventHandler.prototype.emulateClick_ = function (pointerEvent) {
          var newEvent = new MapBrowserEvent(MapBrowserEventType.CLICK, this.map_, pointerEvent);
          this.dispatchEvent(newEvent);
          if (this.clickTimeoutId_ !== undefined) {
              // double-click
              clearTimeout(this.clickTimeoutId_);
              this.clickTimeoutId_ = undefined;
              newEvent = new MapBrowserEvent(MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);
              this.dispatchEvent(newEvent);
          }
          else {
              // click
              this.clickTimeoutId_ = setTimeout(function () {
                  this.clickTimeoutId_ = undefined;
                  var newEvent = new MapBrowserEvent(MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);
                  this.dispatchEvent(newEvent);
              }.bind(this), 250);
          }
      };
      /**
       * Keeps track on how many pointers are currently active.
       *
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */
      MapBrowserEventHandler.prototype.updateActivePointers_ = function (pointerEvent) {
          var event = pointerEvent;
          if (event.type == MapBrowserEventType.POINTERUP ||
              event.type == MapBrowserEventType.POINTERCANCEL) {
              delete this.trackedTouches_[event.pointerId];
          }
          else if (event.type == MapBrowserEventType.POINTERDOWN) {
              this.trackedTouches_[event.pointerId] = true;
          }
          this.activePointers_ = Object.keys(this.trackedTouches_).length;
      };
      /**
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */
      MapBrowserEventHandler.prototype.handlePointerUp_ = function (pointerEvent) {
          this.updateActivePointers_(pointerEvent);
          var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERUP, this.map_, pointerEvent);
          this.dispatchEvent(newEvent);
          // We emulate click events on left mouse button click, touch contact, and pen
          // contact. isMouseActionButton returns true in these cases (evt.button is set
          // to 0).
          // See http://www.w3.org/TR/pointerevents/#button-states
          // We only fire click, singleclick, and doubleclick if nobody has called
          // event.stopPropagation() or event.preventDefault().
          if (!newEvent.propagationStopped &&
              !this.dragging_ &&
              this.isMouseActionButton_(pointerEvent)) {
              this.emulateClick_(this.down_);
          }
          if (this.activePointers_ === 0) {
              this.dragListenerKeys_.forEach(unlistenByKey);
              this.dragListenerKeys_.length = 0;
              this.dragging_ = false;
              this.down_ = null;
          }
      };
      /**
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @return {boolean} If the left mouse button was pressed.
       * @private
       */
      MapBrowserEventHandler.prototype.isMouseActionButton_ = function (pointerEvent) {
          return pointerEvent.button === 0;
      };
      /**
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */
      MapBrowserEventHandler.prototype.handlePointerDown_ = function (pointerEvent) {
          this.updateActivePointers_(pointerEvent);
          var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent);
          this.dispatchEvent(newEvent);
          this.down_ = pointerEvent;
          if (this.dragListenerKeys_.length === 0) {
              this.dragListenerKeys_.push(listen(document, MapBrowserEventType.POINTERMOVE, this.handlePointerMove_, this), listen(document, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this), 
              /* Note that the listener for `pointercancel is set up on
               * `pointerEventHandler_` and not `documentPointerEventHandler_` like
               * the `pointerup` and `pointermove` listeners.
               *
               * The reason for this is the following: `TouchSource.vacuumTouches_()`
               * issues `pointercancel` events, when there was no `touchend` for a
               * `touchstart`. Now, let's say a first `touchstart` is registered on
               * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
               * But `documentPointerEventHandler_` doesn't know about the first
               * `touchstart`. If there is no `touchend` for the `touchstart`, we can
               * only receive a `touchcancel` from `pointerEventHandler_`, because it is
               * only registered there.
               */
              listen(this.element_, MapBrowserEventType.POINTERCANCEL, this.handlePointerUp_, this));
              if (this.element_.getRootNode &&
                  this.element_.getRootNode() !== document) {
                  this.dragListenerKeys_.push(listen(this.element_.getRootNode(), MapBrowserEventType.POINTERUP, this.handlePointerUp_, this));
              }
          }
      };
      /**
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */
      MapBrowserEventHandler.prototype.handlePointerMove_ = function (pointerEvent) {
          // Between pointerdown and pointerup, pointermove events are triggered.
          // To avoid a 'false' touchmove event to be dispatched, we test if the pointer
          // moved a significant distance.
          if (this.isMoving_(pointerEvent)) {
              this.dragging_ = true;
              var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent, this.dragging_);
              this.dispatchEvent(newEvent);
          }
      };
      /**
       * Wrap and relay a pointer event.  Note that this requires that the type
       * string for the MapBrowserEvent matches the PointerEvent type.
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */
      MapBrowserEventHandler.prototype.relayEvent_ = function (pointerEvent) {
          this.originalPointerMoveEvent_ = pointerEvent;
          var dragging = !!(this.down_ && this.isMoving_(pointerEvent));
          this.dispatchEvent(new MapBrowserEvent(pointerEvent.type, this.map_, pointerEvent, dragging));
      };
      /**
       * Flexible handling of a `touch-action: none` css equivalent: because calling
       * `preventDefault()` on a `pointermove` event does not stop native page scrolling
       * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
       * when an interaction (currently `DragPan` handles the event.
       * @param {TouchEvent} event Event.
       * @private
       */
      MapBrowserEventHandler.prototype.handleTouchMove_ = function (event) {
          // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`
          // may not be initialized yet when we get here on a platform without native pointer events.
          if (!this.originalPointerMoveEvent_ ||
              this.originalPointerMoveEvent_.defaultPrevented) {
              event.preventDefault();
          }
      };
      /**
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @return {boolean} Is moving.
       * @private
       */
      MapBrowserEventHandler.prototype.isMoving_ = function (pointerEvent) {
          return (this.dragging_ ||
              Math.abs(pointerEvent.clientX - this.down_.clientX) >
                  this.moveTolerance_ ||
              Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_);
      };
      /**
       * Clean up.
       */
      MapBrowserEventHandler.prototype.disposeInternal = function () {
          if (this.relayedListenerKey_) {
              unlistenByKey(this.relayedListenerKey_);
              this.relayedListenerKey_ = null;
          }
          this.element_.removeEventListener(EventType.TOUCHMOVE, this.boundHandleTouchMove_);
          if (this.pointerdownListenerKey_) {
              unlistenByKey(this.pointerdownListenerKey_);
              this.pointerdownListenerKey_ = null;
          }
          this.dragListenerKeys_.forEach(unlistenByKey);
          this.dragListenerKeys_.length = 0;
          this.element_ = null;
          _super.prototype.disposeInternal.call(this);
      };
      return MapBrowserEventHandler;
  }(Target));

  /**
   * @module ol/MapEventType
   */
  /**
   * @enum {string}
   */
  var MapEventType = {
      /**
       * Triggered after a map frame is rendered.
       * @event module:ol/MapEvent~MapEvent#postrender
       * @api
       */
      POSTRENDER: 'postrender',
      /**
       * Triggered when the map starts moving.
       * @event module:ol/MapEvent~MapEvent#movestart
       * @api
       */
      MOVESTART: 'movestart',
      /**
       * Triggered after the map is moved.
       * @event module:ol/MapEvent~MapEvent#moveend
       * @api
       */
      MOVEEND: 'moveend',
  };

  /**
   * @module ol/MapProperty
   */
  /**
   * @enum {string}
   */
  var MapProperty = {
      LAYERGROUP: 'layergroup',
      SIZE: 'size',
      TARGET: 'target',
      VIEW: 'view',
  };

  /**
   * @module ol/structs/PriorityQueue
   */
  /**
   * @type {number}
   */
  var DROP = Infinity;
  /**
   * @classdesc
   * Priority queue.
   *
   * The implementation is inspired from the Closure Library's Heap class and
   * Python's heapq module.
   *
   * See http://closure-library.googlecode.com/svn/docs/closure_goog_structs_heap.js.source.html
   * and http://hg.python.org/cpython/file/2.7/Lib/heapq.py.
   *
   * @template T
   */
  var PriorityQueue = /** @class */ (function () {
      /**
       * @param {function(T): number} priorityFunction Priority function.
       * @param {function(T): string} keyFunction Key function.
       */
      function PriorityQueue(priorityFunction, keyFunction) {
          /**
           * @type {function(T): number}
           * @private
           */
          this.priorityFunction_ = priorityFunction;
          /**
           * @type {function(T): string}
           * @private
           */
          this.keyFunction_ = keyFunction;
          /**
           * @type {Array<T>}
           * @private
           */
          this.elements_ = [];
          /**
           * @type {Array<number>}
           * @private
           */
          this.priorities_ = [];
          /**
           * @type {!Object<string, boolean>}
           * @private
           */
          this.queuedElements_ = {};
      }
      /**
       * FIXME empty description for jsdoc
       */
      PriorityQueue.prototype.clear = function () {
          this.elements_.length = 0;
          this.priorities_.length = 0;
          clear(this.queuedElements_);
      };
      /**
       * Remove and return the highest-priority element. O(log N).
       * @return {T} Element.
       */
      PriorityQueue.prototype.dequeue = function () {
          var elements = this.elements_;
          var priorities = this.priorities_;
          var element = elements[0];
          if (elements.length == 1) {
              elements.length = 0;
              priorities.length = 0;
          }
          else {
              elements[0] = elements.pop();
              priorities[0] = priorities.pop();
              this.siftUp_(0);
          }
          var elementKey = this.keyFunction_(element);
          delete this.queuedElements_[elementKey];
          return element;
      };
      /**
       * Enqueue an element. O(log N).
       * @param {T} element Element.
       * @return {boolean} The element was added to the queue.
       */
      PriorityQueue.prototype.enqueue = function (element) {
          assert(!(this.keyFunction_(element) in this.queuedElements_), 31); // Tried to enqueue an `element` that was already added to the queue
          var priority = this.priorityFunction_(element);
          if (priority != DROP) {
              this.elements_.push(element);
              this.priorities_.push(priority);
              this.queuedElements_[this.keyFunction_(element)] = true;
              this.siftDown_(0, this.elements_.length - 1);
              return true;
          }
          return false;
      };
      /**
       * @return {number} Count.
       */
      PriorityQueue.prototype.getCount = function () {
          return this.elements_.length;
      };
      /**
       * Gets the index of the left child of the node at the given index.
       * @param {number} index The index of the node to get the left child for.
       * @return {number} The index of the left child.
       * @private
       */
      PriorityQueue.prototype.getLeftChildIndex_ = function (index) {
          return index * 2 + 1;
      };
      /**
       * Gets the index of the right child of the node at the given index.
       * @param {number} index The index of the node to get the right child for.
       * @return {number} The index of the right child.
       * @private
       */
      PriorityQueue.prototype.getRightChildIndex_ = function (index) {
          return index * 2 + 2;
      };
      /**
       * Gets the index of the parent of the node at the given index.
       * @param {number} index The index of the node to get the parent for.
       * @return {number} The index of the parent.
       * @private
       */
      PriorityQueue.prototype.getParentIndex_ = function (index) {
          return (index - 1) >> 1;
      };
      /**
       * Make this a heap. O(N).
       * @private
       */
      PriorityQueue.prototype.heapify_ = function () {
          var i;
          for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
              this.siftUp_(i);
          }
      };
      /**
       * @return {boolean} Is empty.
       */
      PriorityQueue.prototype.isEmpty = function () {
          return this.elements_.length === 0;
      };
      /**
       * @param {string} key Key.
       * @return {boolean} Is key queued.
       */
      PriorityQueue.prototype.isKeyQueued = function (key) {
          return key in this.queuedElements_;
      };
      /**
       * @param {T} element Element.
       * @return {boolean} Is queued.
       */
      PriorityQueue.prototype.isQueued = function (element) {
          return this.isKeyQueued(this.keyFunction_(element));
      };
      /**
       * @param {number} index The index of the node to move down.
       * @private
       */
      PriorityQueue.prototype.siftUp_ = function (index) {
          var elements = this.elements_;
          var priorities = this.priorities_;
          var count = elements.length;
          var element = elements[index];
          var priority = priorities[index];
          var startIndex = index;
          while (index < count >> 1) {
              var lIndex = this.getLeftChildIndex_(index);
              var rIndex = this.getRightChildIndex_(index);
              var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex]
                  ? rIndex
                  : lIndex;
              elements[index] = elements[smallerChildIndex];
              priorities[index] = priorities[smallerChildIndex];
              index = smallerChildIndex;
          }
          elements[index] = element;
          priorities[index] = priority;
          this.siftDown_(startIndex, index);
      };
      /**
       * @param {number} startIndex The index of the root.
       * @param {number} index The index of the node to move up.
       * @private
       */
      PriorityQueue.prototype.siftDown_ = function (startIndex, index) {
          var elements = this.elements_;
          var priorities = this.priorities_;
          var element = elements[index];
          var priority = priorities[index];
          while (index > startIndex) {
              var parentIndex = this.getParentIndex_(index);
              if (priorities[parentIndex] > priority) {
                  elements[index] = elements[parentIndex];
                  priorities[index] = priorities[parentIndex];
                  index = parentIndex;
              }
              else {
                  break;
              }
          }
          elements[index] = element;
          priorities[index] = priority;
      };
      /**
       * FIXME empty description for jsdoc
       */
      PriorityQueue.prototype.reprioritize = function () {
          var priorityFunction = this.priorityFunction_;
          var elements = this.elements_;
          var priorities = this.priorities_;
          var index = 0;
          var n = elements.length;
          var element, i, priority;
          for (i = 0; i < n; ++i) {
              element = elements[i];
              priority = priorityFunction(element);
              if (priority == DROP) {
                  delete this.queuedElements_[this.keyFunction_(element)];
              }
              else {
                  priorities[index] = priority;
                  elements[index++] = element;
              }
          }
          elements.length = index;
          priorities.length = index;
          this.heapify_();
      };
      return PriorityQueue;
  }());

  /**
   * @module ol/TileState
   */
  /**
   * @enum {number}
   */
  var TileState = {
      IDLE: 0,
      LOADING: 1,
      LOADED: 2,
      /**
       * Indicates that tile loading failed
       * @type {number}
       */
      ERROR: 3,
      EMPTY: 4,
  };

  var __extends$j = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {function(import("./Tile.js").default, string, import("./coordinate.js").Coordinate, number): number} PriorityFunction
   */
  var TileQueue = /** @class */ (function (_super) {
      __extends$j(TileQueue, _super);
      /**
       * @param {PriorityFunction} tilePriorityFunction Tile priority function.
       * @param {function(): ?} tileChangeCallback Function called on each tile change event.
       */
      function TileQueue(tilePriorityFunction, tileChangeCallback) {
          var _this = _super.call(this, 
          /**
           * @param {Array} element Element.
           * @return {number} Priority.
           */
          function (element) {
              return tilePriorityFunction.apply(null, element);
          }, 
          /**
           * @param {Array} element Element.
           * @return {string} Key.
           */
          function (element) {
              return /** @type {import("./Tile.js").default} */ (element[0]).getKey();
          }) || this;
          /** @private */
          _this.boundHandleTileChange_ = _this.handleTileChange.bind(_this);
          /**
           * @private
           * @type {function(): ?}
           */
          _this.tileChangeCallback_ = tileChangeCallback;
          /**
           * @private
           * @type {number}
           */
          _this.tilesLoading_ = 0;
          /**
           * @private
           * @type {!Object<string,boolean>}
           */
          _this.tilesLoadingKeys_ = {};
          return _this;
      }
      /**
       * @param {Array} element Element.
       * @return {boolean} The element was added to the queue.
       */
      TileQueue.prototype.enqueue = function (element) {
          var added = _super.prototype.enqueue.call(this, element);
          if (added) {
              var tile = element[0];
              tile.addEventListener(EventType.CHANGE, this.boundHandleTileChange_);
          }
          return added;
      };
      /**
       * @return {number} Number of tiles loading.
       */
      TileQueue.prototype.getTilesLoading = function () {
          return this.tilesLoading_;
      };
      /**
       * @param {import("./events/Event.js").default} event Event.
       * @protected
       */
      TileQueue.prototype.handleTileChange = function (event) {
          var tile = /** @type {import("./Tile.js").default} */ (event.target);
          var state = tile.getState();
          if ((tile.hifi && state === TileState.LOADED) ||
              state === TileState.ERROR ||
              state === TileState.EMPTY) {
              tile.removeEventListener(EventType.CHANGE, this.boundHandleTileChange_);
              var tileKey = tile.getKey();
              if (tileKey in this.tilesLoadingKeys_) {
                  delete this.tilesLoadingKeys_[tileKey];
                  --this.tilesLoading_;
              }
              this.tileChangeCallback_();
          }
      };
      /**
       * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
       * @param {number} maxNewLoads Maximum number of new tiles to load.
       */
      TileQueue.prototype.loadMoreTiles = function (maxTotalLoading, maxNewLoads) {
          var newLoads = 0;
          var state, tile, tileKey;
          while (this.tilesLoading_ < maxTotalLoading &&
              newLoads < maxNewLoads &&
              this.getCount() > 0) {
              tile = /** @type {import("./Tile.js").default} */ (this.dequeue()[0]);
              tileKey = tile.getKey();
              state = tile.getState();
              if (state === TileState.IDLE && !(tileKey in this.tilesLoadingKeys_)) {
                  this.tilesLoadingKeys_[tileKey] = true;
                  ++this.tilesLoading_;
                  ++newLoads;
                  tile.load();
              }
          }
      };
      return TileQueue;
  }(PriorityQueue));
  /**
   * @param {import('./PluggableMap.js').FrameState} frameState Frame state.
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */
  function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {
      // Filter out tiles at higher zoom levels than the current zoom level, or that
      // are outside the visible extent.
      if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
          return DROP;
      }
      if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
          return DROP;
      }
      // Prioritize the highest zoom level tiles closest to the focus.
      // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).
      // Within a zoom level, tiles are prioritized by the distance in pixels between
      // the center of the tile and the center of the viewport.  The factor of 65536
      // means that the prioritization should behave as desired for tiles up to
      // 65536 * Math.log(2) = 45426 pixels from the focus.
      var center = frameState.viewState.center;
      var deltaX = tileCenter[0] - center[0];
      var deltaY = tileCenter[1] - center[1];
      return (65536 * Math.log(tileResolution) +
          Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution);
  }

  /**
   * @module ol/ViewHint
   */
  /**
   * @enum {number}
   */
  var ViewHint = {
      ANIMATING: 0,
      INTERACTING: 1,
  };

  /**
   * @module ol/ViewProperty
   */
  /**
   * @enum {string}
   */
  var ViewProperty = {
      CENTER: 'center',
      RESOLUTION: 'resolution',
      ROTATION: 'rotation',
  };

  /**
   * @module ol/tilegrid/common
   */
  /**
   * Default maximum zoom for default tile grids.
   * @type {number}
   */
  var DEFAULT_MAX_ZOOM = 42;
  /**
   * Default tile size.
   * @type {number}
   */
  var DEFAULT_TILE_SIZE = 256;

  /**
   * @module ol/centerconstraint
   */
  /**
   * @typedef {function((import("./coordinate.js").Coordinate|undefined), number, import("./size.js").Size, boolean=): (import("./coordinate.js").Coordinate|undefined)} Type
   */
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {boolean} onlyCenter If true, the constraint will only apply to the view center.
   * @param {boolean} smooth If true, the view will be able to go slightly out of the given extent
   * (only during interaction and animation).
   * @return {Type} The constraint.
   */
  function createExtent(extent, onlyCenter, smooth) {
      return (
      /**
       * @param {import("./coordinate.js").Coordinate|undefined} center Center.
       * @param {number} resolution Resolution.
       * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
       * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
       * @return {import("./coordinate.js").Coordinate|undefined} Center.
       */
      function (center, resolution, size, opt_isMoving) {
          if (center) {
              var viewWidth = onlyCenter ? 0 : size[0] * resolution;
              var viewHeight = onlyCenter ? 0 : size[1] * resolution;
              var minX = extent[0] + viewWidth / 2;
              var maxX = extent[2] - viewWidth / 2;
              var minY = extent[1] + viewHeight / 2;
              var maxY = extent[3] - viewHeight / 2;
              // note: when zooming out of bounds, min and max values for x and y may
              // end up inverted (min > max); this has to be accounted for
              if (minX > maxX) {
                  minX = (maxX + minX) / 2;
                  maxX = minX;
              }
              if (minY > maxY) {
                  minY = (maxY + minY) / 2;
                  maxY = minY;
              }
              var x = clamp(center[0], minX, maxX);
              var y = clamp(center[1], minY, maxY);
              var ratio = 30 * resolution;
              // during an interaction, allow some overscroll
              if (opt_isMoving && smooth) {
                  x +=
                      -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) +
                          ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
                  y +=
                      -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) +
                          ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
              }
              return [x, y];
          }
          else {
              return undefined;
          }
      });
  }
  /**
   * @param {import("./coordinate.js").Coordinate=} center Center.
   * @return {import("./coordinate.js").Coordinate|undefined} Center.
   */
  function none(center) {
      return center;
  }

  /**
   * @module ol/resolutionconstraint
   */
  /**
   * @typedef {function((number|undefined), number, import("./size.js").Size, boolean=): (number|undefined)} Type
   */
  /**
   * Returns a modified resolution taking into account the viewport size and maximum
   * allowed extent.
   * @param {number} resolution Resolution
   * @param {import("./extent.js").Extent=} maxExtent Maximum allowed extent.
   * @param {import("./size.js").Size} viewportSize Viewport size.
   * @param {boolean} showFullExtent Whether to show the full extent.
   * @return {number} Capped resolution.
   */
  function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
      var xResolution = getWidth(maxExtent) / viewportSize[0];
      var yResolution = getHeight(maxExtent) / viewportSize[1];
      if (showFullExtent) {
          return Math.min(resolution, Math.max(xResolution, yResolution));
      }
      return Math.min(resolution, Math.min(xResolution, yResolution));
  }
  /**
   * Returns a modified resolution to be between maxResolution and minResolution while
   * still allowing the value to be slightly out of bounds.
   * Note: the computation is based on the logarithm function (ln):
   *  - at 1, ln(x) is 0
   *  - above 1, ln(x) keeps increasing but at a much slower pace than x
   * The final result is clamped to prevent getting too far away from bounds.
   * @param {number} resolution Resolution.
   * @param {number} maxResolution Max resolution.
   * @param {number} minResolution Min resolution.
   * @return {number} Smoothed resolution.
   */
  function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
      var result = Math.min(resolution, maxResolution);
      var ratio = 50;
      result *=
          Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio +
              1;
      if (minResolution) {
          result = Math.max(result, minResolution);
          result /=
              Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) /
                  ratio +
                  1;
      }
      return clamp(result, minResolution / 2, maxResolution * 2);
  }
  /**
   * @param {Array<number>} resolutions Resolutions.
   * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.
   * @param {import("./extent.js").Extent=} opt_maxExtent Maximum allowed extent.
   * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.
   * @return {Type} Zoom function.
   */
  function createSnapToResolutions(resolutions, opt_smooth, opt_maxExtent, opt_showFullExtent) {
      return (
      /**
       * @param {number|undefined} resolution Resolution.
       * @param {number} direction Direction.
       * @param {import("./size.js").Size} size Viewport size.
       * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
       * @return {number|undefined} Resolution.
       */
      function (resolution, direction, size, opt_isMoving) {
          if (resolution !== undefined) {
              var maxResolution = resolutions[0];
              var minResolution = resolutions[resolutions.length - 1];
              var cappedMaxRes = opt_maxExtent
                  ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)
                  : maxResolution;
              // during interacting or animating, allow intermediary values
              if (opt_isMoving) {
                  var smooth = opt_smooth !== undefined ? opt_smooth : true;
                  if (!smooth) {
                      return clamp(resolution, minResolution, cappedMaxRes);
                  }
                  return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
              }
              var capped = Math.min(cappedMaxRes, resolution);
              var z = Math.floor(linearFindNearest(resolutions, capped, direction));
              if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
                  return resolutions[z + 1];
              }
              return resolutions[z];
          }
          else {
              return undefined;
          }
      });
  }
  /**
   * @param {number} power Power.
   * @param {number} maxResolution Maximum resolution.
   * @param {number=} opt_minResolution Minimum resolution.
   * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.
   * @param {import("./extent.js").Extent=} opt_maxExtent Maximum allowed extent.
   * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.
   * @return {Type} Zoom function.
   */
  function createSnapToPower(power, maxResolution, opt_minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
      return (
      /**
       * @param {number|undefined} resolution Resolution.
       * @param {number} direction Direction.
       * @param {import("./size.js").Size} size Viewport size.
       * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
       * @return {number|undefined} Resolution.
       */
      function (resolution, direction, size, opt_isMoving) {
          if (resolution !== undefined) {
              var cappedMaxRes = opt_maxExtent
                  ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)
                  : maxResolution;
              var minResolution = opt_minResolution !== undefined ? opt_minResolution : 0;
              // during interacting or animating, allow intermediary values
              if (opt_isMoving) {
                  var smooth = opt_smooth !== undefined ? opt_smooth : true;
                  if (!smooth) {
                      return clamp(resolution, minResolution, cappedMaxRes);
                  }
                  return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
              }
              var tolerance = 1e-9;
              var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);
              var offset = -direction * (0.5 - tolerance) + 0.5;
              var capped = Math.min(cappedMaxRes, resolution);
              var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);
              var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
              var newResolution = maxResolution / Math.pow(power, zoomLevel);
              return clamp(newResolution, minResolution, cappedMaxRes);
          }
          else {
              return undefined;
          }
      });
  }
  /**
   * @param {number} maxResolution Max resolution.
   * @param {number} minResolution Min resolution.
   * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.
   * @param {import("./extent.js").Extent=} opt_maxExtent Maximum allowed extent.
   * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.
   * @return {Type} Zoom function.
   */
  function createMinMaxResolution(maxResolution, minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
      return (
      /**
       * @param {number|undefined} resolution Resolution.
       * @param {number} direction Direction.
       * @param {import("./size.js").Size} size Viewport size.
       * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
       * @return {number|undefined} Resolution.
       */
      function (resolution, direction, size, opt_isMoving) {
          if (resolution !== undefined) {
              var cappedMaxRes = opt_maxExtent
                  ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)
                  : maxResolution;
              var smooth = opt_smooth !== undefined ? opt_smooth : true;
              if (!smooth || !opt_isMoving) {
                  return clamp(resolution, minResolution, cappedMaxRes);
              }
              return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
          }
          else {
              return undefined;
          }
      });
  }

  /**
   * @module ol/rotationconstraint
   */
  /**
   * @typedef {function((number|undefined), boolean=): (number|undefined)} Type
   */
  /**
   * @param {number|undefined} rotation Rotation.
   * @return {number|undefined} Rotation.
   */
  function disable(rotation) {
      if (rotation !== undefined) {
          return 0;
      }
      else {
          return undefined;
      }
  }
  /**
   * @param {number|undefined} rotation Rotation.
   * @return {number|undefined} Rotation.
   */
  function none$1(rotation) {
      if (rotation !== undefined) {
          return rotation;
      }
      else {
          return undefined;
      }
  }
  /**
   * @param {number} n N.
   * @return {Type} Rotation constraint.
   */
  function createSnapToN(n) {
      var theta = (2 * Math.PI) / n;
      return (
      /**
       * @param {number|undefined} rotation Rotation.
       * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
       * @return {number|undefined} Rotation.
       */
      function (rotation, opt_isMoving) {
          if (opt_isMoving) {
              return rotation;
          }
          if (rotation !== undefined) {
              rotation = Math.floor(rotation / theta + 0.5) * theta;
              return rotation;
          }
          else {
              return undefined;
          }
      });
  }
  /**
   * @param {number=} opt_tolerance Tolerance.
   * @return {Type} Rotation constraint.
   */
  function createSnapToZero(opt_tolerance) {
      var tolerance = opt_tolerance || toRadians(5);
      return (
      /**
       * @param {number|undefined} rotation Rotation.
       * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
       * @return {number|undefined} Rotation.
       */
      function (rotation, opt_isMoving) {
          if (opt_isMoving) {
              return rotation;
          }
          if (rotation !== undefined) {
              if (Math.abs(rotation) <= tolerance) {
                  return 0;
              }
              else {
                  return rotation;
              }
          }
          else {
              return undefined;
          }
      });
  }

  /**
   * @module ol/easing
   */
  /**
   * Start slow and speed up.
   * @param {number} t Input between 0 and 1.
   * @return {number} Output between 0 and 1.
   * @api
   */
  function easeIn(t) {
      return Math.pow(t, 3);
  }
  /**
   * Start fast and slow down.
   * @param {number} t Input between 0 and 1.
   * @return {number} Output between 0 and 1.
   * @api
   */
  function easeOut(t) {
      return 1 - easeIn(1 - t);
  }
  /**
   * Start slow, speed up, and then slow down again.
   * @param {number} t Input between 0 and 1.
   * @return {number} Output between 0 and 1.
   * @api
   */
  function inAndOut(t) {
      return 3 * t * t - 2 * t * t * t;
  }
  /**
   * Maintain a constant speed over time.
   * @param {number} t Input between 0 and 1.
   * @return {number} Output between 0 and 1.
   * @api
   */
  function linear(t) {
      return t;
  }

  /**
   * @module ol/geom/flat/closest
   */
  /**
   * Returns the point on the 2D line segment flatCoordinates[offset1] to
   * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
   * dimensions are linearly interpolated.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset1 Offset 1.
   * @param {number} offset2 Offset 2.
   * @param {number} stride Stride.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {Array<number>} closestPoint Closest point.
   */
  function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
      var x1 = flatCoordinates[offset1];
      var y1 = flatCoordinates[offset1 + 1];
      var dx = flatCoordinates[offset2] - x1;
      var dy = flatCoordinates[offset2 + 1] - y1;
      var offset;
      if (dx === 0 && dy === 0) {
          offset = offset1;
      }
      else {
          var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
          if (t > 1) {
              offset = offset2;
          }
          else if (t > 0) {
              for (var i = 0; i < stride; ++i) {
                  closestPoint[i] = lerp(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);
              }
              closestPoint.length = stride;
              return;
          }
          else {
              offset = offset1;
          }
      }
      for (var i = 0; i < stride; ++i) {
          closestPoint[i] = flatCoordinates[offset + i];
      }
      closestPoint.length = stride;
  }
  /**
   * Return the squared of the largest distance between any pair of consecutive
   * coordinates.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} max Max squared delta.
   * @return {number} Max squared delta.
   */
  function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
      var x1 = flatCoordinates[offset];
      var y1 = flatCoordinates[offset + 1];
      for (offset += stride; offset < end; offset += stride) {
          var x2 = flatCoordinates[offset];
          var y2 = flatCoordinates[offset + 1];
          var squaredDelta = squaredDistance(x1, y1, x2, y2);
          if (squaredDelta > max) {
              max = squaredDelta;
          }
          x1 = x2;
          y1 = y2;
      }
      return max;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {number} max Max squared delta.
   * @return {number} Max squared delta.
   */
  function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
          offset = end;
      }
      return max;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {number} max Max squared delta.
   * @return {number} Max squared delta.
   */
  function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);
          offset = ends[ends.length - 1];
      }
      return max;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} maxDelta Max delta.
   * @param {boolean} isRing Is ring.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {Array<number>} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @param {Array<number>=} opt_tmpPoint Temporary point object.
   * @return {number} Minimum squared distance.
   */
  function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
      if (offset == end) {
          return minSquaredDistance;
      }
      var i, squaredDistance$1;
      if (maxDelta === 0) {
          // All points are identical, so just test the first point.
          squaredDistance$1 = squaredDistance(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);
          if (squaredDistance$1 < minSquaredDistance) {
              for (i = 0; i < stride; ++i) {
                  closestPoint[i] = flatCoordinates[offset + i];
              }
              closestPoint.length = stride;
              return squaredDistance$1;
          }
          else {
              return minSquaredDistance;
          }
      }
      var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
      var index = offset + stride;
      while (index < end) {
          assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);
          squaredDistance$1 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
          if (squaredDistance$1 < minSquaredDistance) {
              minSquaredDistance = squaredDistance$1;
              for (i = 0; i < stride; ++i) {
                  closestPoint[i] = tmpPoint[i];
              }
              closestPoint.length = stride;
              index += stride;
          }
          else {
              // Skip ahead multiple points, because we know that all the skipped
              // points cannot be any closer than the closest point we have found so
              // far.  We know this because we know how close the current point is, how
              // close the closest point we have found so far is, and the maximum
              // distance between consecutive points.  For example, if we're currently
              // at distance 10, the best we've found so far is 3, and that the maximum
              // distance between consecutive points is 2, then we'll need to skip at
              // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
              // finding a closer point.  We use Math.max(..., 1) to ensure that we
              // always advance at least one point, to avoid an infinite loop.
              index +=
                  stride *
                      Math.max(((Math.sqrt(squaredDistance$1) - Math.sqrt(minSquaredDistance)) /
                          maxDelta) |
                          0, 1);
          }
      }
      if (isRing) {
          // Check the closing segment.
          assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);
          squaredDistance$1 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
          if (squaredDistance$1 < minSquaredDistance) {
              minSquaredDistance = squaredDistance$1;
              for (i = 0; i < stride; ++i) {
                  closestPoint[i] = tmpPoint[i];
              }
              closestPoint.length = stride;
          }
      }
      return minSquaredDistance;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {number} maxDelta Max delta.
   * @param {boolean} isRing Is ring.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {Array<number>} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @param {Array<number>=} opt_tmpPoint Temporary point object.
   * @return {number} Minimum squared distance.
   */
  function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
      var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
          offset = end;
      }
      return minSquaredDistance;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {number} maxDelta Max delta.
   * @param {boolean} isRing Is ring.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {Array<number>} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @param {Array<number>=} opt_tmpPoint Temporary point object.
   * @return {number} Minimum squared distance.
   */
  function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
      var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
          offset = ends[ends.length - 1];
      }
      return minSquaredDistance;
  }

  /**
   * @module ol/geom/flat/deflate
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} stride Stride.
   * @return {number} offset Offset.
   */
  function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
      for (var i = 0, ii = coordinate.length; i < ii; ++i) {
          flatCoordinates[offset++] = coordinate[i];
      }
      return offset;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<import("../../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {number} stride Stride.
   * @return {number} offset Offset.
   */
  function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
          var coordinate = coordinates[i];
          for (var j = 0; j < stride; ++j) {
              flatCoordinates[offset++] = coordinate[j];
          }
      }
      return offset;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<import("../../coordinate.js").Coordinate>>} coordinatess Coordinatess.
   * @param {number} stride Stride.
   * @param {Array<number>=} opt_ends Ends.
   * @return {Array<number>} Ends.
   */
  function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, opt_ends) {
      var ends = opt_ends ? opt_ends : [];
      var i = 0;
      for (var j = 0, jj = coordinatess.length; j < jj; ++j) {
          var end = deflateCoordinates(flatCoordinates, offset, coordinatess[j], stride);
          ends[i++] = end;
          offset = end;
      }
      ends.length = i;
      return ends;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} coordinatesss Coordinatesss.
   * @param {number} stride Stride.
   * @param {Array<Array<number>>=} opt_endss Endss.
   * @return {Array<Array<number>>} Endss.
   */
  function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, opt_endss) {
      var endss = opt_endss ? opt_endss : [];
      var i = 0;
      for (var j = 0, jj = coordinatesss.length; j < jj; ++j) {
          var ends = deflateCoordinatesArray(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);
          endss[i++] = ends;
          offset = ends[ends.length - 1];
      }
      endss.length = i;
      return endss;
  }

  /**
   * @module ol/geom/flat/simplify
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
   *     coordinates.
   * @param {number} simplifiedOffset Simplified offset.
   * @return {number} Simplified offset.
   */
  function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
      var n = (end - offset) / stride;
      if (n < 3) {
          for (; offset < end; offset += stride) {
              simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
              simplifiedFlatCoordinates[simplifiedOffset++] =
                  flatCoordinates[offset + 1];
          }
          return simplifiedOffset;
      }
      /** @type {Array<number>} */
      var markers = new Array(n);
      markers[0] = 1;
      markers[n - 1] = 1;
      /** @type {Array<number>} */
      var stack = [offset, end - stride];
      var index = 0;
      while (stack.length > 0) {
          var last = stack.pop();
          var first = stack.pop();
          var maxSquaredDistance = 0;
          var x1 = flatCoordinates[first];
          var y1 = flatCoordinates[first + 1];
          var x2 = flatCoordinates[last];
          var y2 = flatCoordinates[last + 1];
          for (var i = first + stride; i < last; i += stride) {
              var x = flatCoordinates[i];
              var y = flatCoordinates[i + 1];
              var squaredDistance_1 = squaredSegmentDistance(x, y, x1, y1, x2, y2);
              if (squaredDistance_1 > maxSquaredDistance) {
                  index = i;
                  maxSquaredDistance = squaredDistance_1;
              }
          }
          if (maxSquaredDistance > squaredTolerance) {
              markers[(index - offset) / stride] = 1;
              if (first + stride < index) {
                  stack.push(first, index);
              }
              if (index + stride < last) {
                  stack.push(index, last);
              }
          }
      }
      for (var i = 0; i < n; ++i) {
          if (markers[i]) {
              simplifiedFlatCoordinates[simplifiedOffset++] =
                  flatCoordinates[offset + i * stride];
              simplifiedFlatCoordinates[simplifiedOffset++] =
                  flatCoordinates[offset + i * stride + 1];
          }
      }
      return simplifiedOffset;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
   *     coordinates.
   * @param {number} simplifiedOffset Simplified offset.
   * @param {Array<number>} simplifiedEnds Simplified ends.
   * @return {number} Simplified offset.
   */
  function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);
          simplifiedEnds.push(simplifiedOffset);
          offset = end;
      }
      return simplifiedOffset;
  }
  /**
   * @param {number} value Value.
   * @param {number} tolerance Tolerance.
   * @return {number} Rounded value.
   */
  function snap(value, tolerance) {
      return tolerance * Math.round(value / tolerance);
  }
  /**
   * Simplifies a line string using an algorithm designed by Tim Schaub.
   * Coordinates are snapped to the nearest value in a virtual grid and
   * consecutive duplicate coordinates are discarded.  This effectively preserves
   * topology as the simplification of any subsection of a line string is
   * independent of the rest of the line string.  This means that, for examples,
   * the common edge between two polygons will be simplified to the same line
   * string independently in both polygons.  This implementation uses a single
   * pass over the coordinates and eliminates intermediate collinear points.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} tolerance Tolerance.
   * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
   *     coordinates.
   * @param {number} simplifiedOffset Simplified offset.
   * @return {number} Simplified offset.
   */
  function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
      // do nothing if the line is empty
      if (offset == end) {
          return simplifiedOffset;
      }
      // snap the first coordinate (P1)
      var x1 = snap(flatCoordinates[offset], tolerance);
      var y1 = snap(flatCoordinates[offset + 1], tolerance);
      offset += stride;
      // add the first coordinate to the output
      simplifiedFlatCoordinates[simplifiedOffset++] = x1;
      simplifiedFlatCoordinates[simplifiedOffset++] = y1;
      // find the next coordinate that does not snap to the same value as the first
      // coordinate (P2)
      var x2, y2;
      do {
          x2 = snap(flatCoordinates[offset], tolerance);
          y2 = snap(flatCoordinates[offset + 1], tolerance);
          offset += stride;
          if (offset == end) {
              // all coordinates snap to the same value, the line collapses to a point
              // push the last snapped value anyway to ensure that the output contains
              // at least two points
              // FIXME should we really return at least two points anyway?
              simplifiedFlatCoordinates[simplifiedOffset++] = x2;
              simplifiedFlatCoordinates[simplifiedOffset++] = y2;
              return simplifiedOffset;
          }
      } while (x2 == x1 && y2 == y1);
      while (offset < end) {
          // snap the next coordinate (P3)
          var x3 = snap(flatCoordinates[offset], tolerance);
          var y3 = snap(flatCoordinates[offset + 1], tolerance);
          offset += stride;
          // skip P3 if it is equal to P2
          if (x3 == x2 && y3 == y2) {
              continue;
          }
          // calculate the delta between P1 and P2
          var dx1 = x2 - x1;
          var dy1 = y2 - y1;
          // calculate the delta between P3 and P1
          var dx2 = x3 - x1;
          var dy2 = y3 - y1;
          // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
          // P1 in the same direction then P2 is on the straight line between P1 and
          // P3
          if (dx1 * dy2 == dy1 * dx2 &&
              ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&
              ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))) {
              // discard P2 and set P2 = P3
              x2 = x3;
              y2 = y3;
              continue;
          }
          // either P1, P2, and P3 are not colinear, or they are colinear but P3 is
          // between P3 and P1 or on the opposite half of the line to P2.  add P2,
          // and continue with P1 = P2 and P2 = P3
          simplifiedFlatCoordinates[simplifiedOffset++] = x2;
          simplifiedFlatCoordinates[simplifiedOffset++] = y2;
          x1 = x2;
          y1 = y2;
          x2 = x3;
          y2 = y3;
      }
      // add the last point (P2)
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {number} tolerance Tolerance.
   * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
   *     coordinates.
   * @param {number} simplifiedOffset Simplified offset.
   * @param {Array<number>} simplifiedEnds Simplified ends.
   * @return {number} Simplified offset.
   */
  function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);
          simplifiedEnds.push(simplifiedOffset);
          offset = end;
      }
      return simplifiedOffset;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {number} tolerance Tolerance.
   * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
   *     coordinates.
   * @param {number} simplifiedOffset Simplified offset.
   * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
   * @return {number} Simplified offset.
   */
  function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          var simplifiedEnds = [];
          simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
          simplifiedEndss.push(simplifiedEnds);
          offset = ends[ends.length - 1];
      }
      return simplifiedOffset;
  }

  /**
   * @module ol/geom/flat/inflate
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {Array<import("../../coordinate.js").Coordinate>=} opt_coordinates Coordinates.
   * @return {Array<import("../../coordinate.js").Coordinate>} Coordinates.
   */
  function inflateCoordinates(flatCoordinates, offset, end, stride, opt_coordinates) {
      var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];
      var i = 0;
      for (var j = offset; j < end; j += stride) {
          coordinates[i++] = flatCoordinates.slice(j, j + stride);
      }
      coordinates.length = i;
      return coordinates;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<Array<import("../../coordinate.js").Coordinate>>=} opt_coordinatess Coordinatess.
   * @return {Array<Array<import("../../coordinate.js").Coordinate>>} Coordinatess.
   */
  function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, opt_coordinatess) {
      var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];
      var i = 0;
      for (var j = 0, jj = ends.length; j < jj; ++j) {
          var end = ends[j];
          coordinatess[i++] = inflateCoordinates(flatCoordinates, offset, end, stride, coordinatess[i]);
          offset = end;
      }
      coordinatess.length = i;
      return coordinatess;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>=} opt_coordinatesss
   *     Coordinatesss.
   * @return {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} Coordinatesss.
   */
  function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, opt_coordinatesss) {
      var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];
      var i = 0;
      for (var j = 0, jj = endss.length; j < jj; ++j) {
          var ends = endss[j];
          coordinatesss[i++] = inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatesss[i]);
          offset = ends[ends.length - 1];
      }
      coordinatesss.length = i;
      return coordinatesss;
  }

  /**
   * @module ol/geom/flat/area
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @return {number} Area.
   */
  function linearRing(flatCoordinates, offset, end, stride) {
      var twiceArea = 0;
      var x1 = flatCoordinates[end - stride];
      var y1 = flatCoordinates[end - stride + 1];
      for (; offset < end; offset += stride) {
          var x2 = flatCoordinates[offset];
          var y2 = flatCoordinates[offset + 1];
          twiceArea += y1 * x2 - x1 * y2;
          x1 = x2;
          y1 = y2;
      }
      return twiceArea / 2;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @return {number} Area.
   */
  function linearRings(flatCoordinates, offset, ends, stride) {
      var area = 0;
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          area += linearRing(flatCoordinates, offset, end, stride);
          offset = end;
      }
      return area;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @return {number} Area.
   */
  function linearRingss(flatCoordinates, offset, endss, stride) {
      var area = 0;
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          area += linearRings(flatCoordinates, offset, ends, stride);
          offset = ends[ends.length - 1];
      }
      return area;
  }

  var __extends$k = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Linear ring geometry. Only used as part of polygon; cannot be rendered
   * on its own.
   *
   * @api
   */
  var LinearRing = /** @class */ (function (_super) {
      __extends$k(LinearRing, _super);
      /**
       * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       */
      function LinearRing(coordinates, opt_layout) {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {number}
           */
          _this.maxDelta_ = -1;
          /**
           * @private
           * @type {number}
           */
          _this.maxDeltaRevision_ = -1;
          if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {
              _this.setFlatCoordinates(opt_layout, 
              /** @type {Array<number>} */ (coordinates));
          }
          else {
              _this.setCoordinates(
              /** @type {Array<import("../coordinate.js").Coordinate>} */ (coordinates), opt_layout);
          }
          return _this;
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!LinearRing} Clone.
       * @api
       */
      LinearRing.prototype.clone = function () {
          return new LinearRing(this.flatCoordinates.slice(), this.layout);
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      LinearRing.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
          if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
          }
          if (this.maxDeltaRevision_ != this.getRevision()) {
              this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
              this.maxDeltaRevision_ = this.getRevision();
          }
          return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
      };
      /**
       * Return the area of the linear ring on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      LinearRing.prototype.getArea = function () {
          return linearRing(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      };
      /**
       * Return the coordinates of the linear ring.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       */
      LinearRing.prototype.getCoordinates = function () {
          return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      };
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {LinearRing} Simplified LinearRing.
       * @protected
       */
      LinearRing.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
          var simplifiedFlatCoordinates = [];
          simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
          return new LinearRing(simplifiedFlatCoordinates, GeometryLayout.XY);
      };
      /**
       * Get the type of this geometry.
       * @return {import("./GeometryType.js").default} Geometry type.
       * @api
       */
      LinearRing.prototype.getType = function () {
          return GeometryType.LINEAR_RING;
      };
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      LinearRing.prototype.intersectsExtent = function (extent) {
          return false;
      };
      /**
       * Set the coordinates of the linear ring.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @api
       */
      LinearRing.prototype.setCoordinates = function (coordinates, opt_layout) {
          this.setLayout(opt_layout, coordinates, 1);
          if (!this.flatCoordinates) {
              this.flatCoordinates = [];
          }
          this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);
          this.changed();
      };
      return LinearRing;
  }(SimpleGeometry));

  var __extends$l = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Point geometry.
   *
   * @api
   */
  var Point = /** @class */ (function (_super) {
      __extends$l(Point, _super);
      /**
       * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       */
      function Point(coordinates, opt_layout) {
          var _this = _super.call(this) || this;
          _this.setCoordinates(coordinates, opt_layout);
          return _this;
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!Point} Clone.
       * @api
       */
      Point.prototype.clone = function () {
          var point = new Point(this.flatCoordinates.slice(), this.layout);
          return point;
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      Point.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
          var flatCoordinates = this.flatCoordinates;
          var squaredDistance$1 = squaredDistance(x, y, flatCoordinates[0], flatCoordinates[1]);
          if (squaredDistance$1 < minSquaredDistance) {
              var stride = this.stride;
              for (var i = 0; i < stride; ++i) {
                  closestPoint[i] = flatCoordinates[i];
              }
              closestPoint.length = stride;
              return squaredDistance$1;
          }
          else {
              return minSquaredDistance;
          }
      };
      /**
       * Return the coordinate of the point.
       * @return {import("../coordinate.js").Coordinate} Coordinates.
       * @api
       */
      Point.prototype.getCoordinates = function () {
          return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
      };
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */
      Point.prototype.computeExtent = function (extent) {
          return createOrUpdateFromCoordinate(this.flatCoordinates, extent);
      };
      /**
       * Get the type of this geometry.
       * @return {import("./GeometryType.js").default} Geometry type.
       * @api
       */
      Point.prototype.getType = function () {
          return GeometryType.POINT;
      };
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      Point.prototype.intersectsExtent = function (extent) {
          return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
      };
      /**
       * @param {!Array<*>} coordinates Coordinates.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @api
       */
      Point.prototype.setCoordinates = function (coordinates, opt_layout) {
          this.setLayout(opt_layout, coordinates, 0);
          if (!this.flatCoordinates) {
              this.flatCoordinates = [];
          }
          this.flatCoordinates.length = deflateCoordinate(this.flatCoordinates, 0, coordinates, this.stride);
          this.changed();
      };
      return Point;
  }(SimpleGeometry));

  /**
   * @module ol/geom/flat/contains
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @return {boolean} Contains extent.
   */
  function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
      var outside = forEachCorner(extent, 
      /**
       * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
       * @return {boolean} Contains (x, y).
       */
      function (coordinate) {
          return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
      });
      return !outside;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
      // http://geomalgorithms.com/a03-_inclusion.html
      // Copyright 2000 softSurfer, 2012 Dan Sunday
      // This code may be freely used and modified for any purpose
      // providing that this copyright notice is included with it.
      // SoftSurfer makes no warranty for this code, and cannot be held
      // liable for any real or imagined damage resulting from its use.
      // Users of this code must verify correctness for their application.
      var wn = 0;
      var x1 = flatCoordinates[end - stride];
      var y1 = flatCoordinates[end - stride + 1];
      for (; offset < end; offset += stride) {
          var x2 = flatCoordinates[offset];
          var y2 = flatCoordinates[offset + 1];
          if (y1 <= y) {
              if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
                  wn++;
              }
          }
          else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
              wn--;
          }
          x1 = x2;
          y1 = y2;
      }
      return wn !== 0;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
      if (ends.length === 0) {
          return false;
      }
      if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
          return false;
      }
      for (var i = 1, ii = ends.length; i < ii; ++i) {
          if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
              return false;
          }
      }
      return true;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {
      if (endss.length === 0) {
          return false;
      }
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
              return true;
          }
          offset = ends[ends.length - 1];
      }
      return false;
  }

  /**
   * @module ol/geom/flat/interiorpoint
   */
  /**
   * Calculates a point that is likely to lie in the interior of the linear rings.
   * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} flatCenters Flat centers.
   * @param {number} flatCentersOffset Flat center offset.
   * @param {Array<number>=} opt_dest Destination.
   * @return {Array<number>} Destination point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   */
  function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, opt_dest) {
      var i, ii, x, x1, x2, y1, y2;
      var y = flatCenters[flatCentersOffset + 1];
      /** @type {Array<number>} */
      var intersections = [];
      // Calculate intersections with the horizontal line
      for (var r = 0, rr = ends.length; r < rr; ++r) {
          var end = ends[r];
          x1 = flatCoordinates[end - stride];
          y1 = flatCoordinates[end - stride + 1];
          for (i = offset; i < end; i += stride) {
              x2 = flatCoordinates[i];
              y2 = flatCoordinates[i + 1];
              if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {
                  x = ((y - y1) / (y2 - y1)) * (x2 - x1) + x1;
                  intersections.push(x);
              }
              x1 = x2;
              y1 = y2;
          }
      }
      // Find the longest segment of the horizontal line that has its center point
      // inside the linear ring.
      var pointX = NaN;
      var maxSegmentLength = -Infinity;
      intersections.sort(numberSafeCompareFunction);
      x1 = intersections[0];
      for (i = 1, ii = intersections.length; i < ii; ++i) {
          x2 = intersections[i];
          var segmentLength = Math.abs(x2 - x1);
          if (segmentLength > maxSegmentLength) {
              x = (x1 + x2) / 2;
              if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
                  pointX = x;
                  maxSegmentLength = segmentLength;
              }
          }
          x1 = x2;
      }
      if (isNaN(pointX)) {
          // There is no horizontal line that has its center point inside the linear
          // ring.  Use the center of the the linear ring's extent.
          pointX = flatCenters[flatCentersOffset];
      }
      if (opt_dest) {
          opt_dest.push(pointX, y, maxSegmentLength);
          return opt_dest;
      }
      else {
          return [pointX, y, maxSegmentLength];
      }
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {Array<number>} flatCenters Flat centers.
   * @return {Array<number>} Interior points as XYM coordinates, where M is the
   * length of the horizontal intersection that the point belongs to.
   */
  function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
      var interiorPoints = [];
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          interiorPoints = getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);
          offset = ends[ends.length - 1];
      }
      return interiorPoints;
  }

  /**
   * @module ol/geom/flat/segments
   */
  /**
   * This function calls `callback` for each segment of the flat coordinates
   * array. If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {function(import("../../coordinate.js").Coordinate, import("../../coordinate.js").Coordinate): T} callback Function
   *     called for each segment.
   * @return {T|boolean} Value.
   * @template T
   */
  function forEach(flatCoordinates, offset, end, stride, callback) {
      var point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];
      var point2 = [];
      var ret;
      for (; offset + stride < end; offset += stride) {
          point2[0] = flatCoordinates[offset + stride];
          point2[1] = flatCoordinates[offset + stride + 1];
          ret = callback(point1, point2);
          if (ret) {
              return ret;
          }
          point1[0] = point2[0];
          point1[1] = point2[1];
      }
      return false;
  }

  /**
   * @module ol/geom/flat/intersectsextent
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @return {boolean} True if the geometry and the extent intersect.
   */
  function intersectsLineString(flatCoordinates, offset, end, stride, extent) {
      var coordinatesExtent = extendFlatCoordinates(createEmpty(), flatCoordinates, offset, end, stride);
      if (!intersects(extent, coordinatesExtent)) {
          return false;
      }
      if (containsExtent(extent, coordinatesExtent)) {
          return true;
      }
      if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
          return true;
      }
      if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
          return true;
      }
      return forEach(flatCoordinates, offset, end, stride, 
      /**
       * @param {import("../../coordinate.js").Coordinate} point1 Start point.
       * @param {import("../../coordinate.js").Coordinate} point2 End point.
       * @return {boolean} `true` if the segment and the extent intersect,
       *     `false` otherwise.
       */
      function (point1, point2) {
          return intersectsSegment(extent, point1, point2);
      });
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @return {boolean} True if the geometry and the extent intersect.
   */
  function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          if (intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)) {
              return true;
          }
          offset = ends[i];
      }
      return false;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @return {boolean} True if the geometry and the extent intersect.
   */
  function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
      if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {
          return true;
      }
      if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[1])) {
          return true;
      }
      if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[3])) {
          return true;
      }
      if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[1])) {
          return true;
      }
      if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[3])) {
          return true;
      }
      return false;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @return {boolean} True if the geometry and the extent intersect.
   */
  function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
      if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {
          return false;
      }
      if (ends.length === 1) {
          return true;
      }
      for (var i = 1, ii = ends.length; i < ii; ++i) {
          if (linearRingContainsExtent(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
              if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
                  return false;
              }
          }
      }
      return true;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @return {boolean} True if the geometry and the extent intersect.
   */
  function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          if (intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)) {
              return true;
          }
          offset = ends[ends.length - 1];
      }
      return false;
  }

  /**
   * @module ol/geom/flat/reverse
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   */
  function coordinates(flatCoordinates, offset, end, stride) {
      while (offset < end - stride) {
          for (var i = 0; i < stride; ++i) {
              var tmp = flatCoordinates[offset + i];
              flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
              flatCoordinates[end - stride + i] = tmp;
          }
          offset += stride;
          end -= stride;
      }
  }

  /**
   * @module ol/geom/flat/orient
   */
  /**
   * Is the linear ring oriented clockwise in a coordinate system with a bottom-left
   * coordinate origin? For a coordinate system with a top-left coordinate origin,
   * the ring's orientation is clockwise when this function returns false.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @return {boolean} Is clockwise.
   */
  function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
      // https://stackoverflow.com/a/1180256/2389327
      // https://en.wikipedia.org/wiki/Curve_orientation#Orientation_of_a_simple_polygon
      var firstVertexRepeated = true;
      for (var i = 0; i < stride; ++i) {
          if (flatCoordinates[offset + i] !== flatCoordinates[end - stride + i]) {
              firstVertexRepeated = false;
              break;
          }
      }
      if (firstVertexRepeated) {
          end -= stride;
      }
      var iMinVertex = findCornerVertex(flatCoordinates, offset, end, stride);
      // Orientation matrix:
      //     [ 1  xa  ya ]
      // O = | 1  xb  yb |
      //     [ 1  xc  yc ]
      var iPreviousVertex = iMinVertex - stride;
      if (iPreviousVertex < offset) {
          iPreviousVertex = end - stride;
      }
      var iNextVertex = iMinVertex + stride;
      if (iNextVertex >= end) {
          iNextVertex = offset;
      }
      var aX = flatCoordinates[iPreviousVertex];
      var aY = flatCoordinates[iPreviousVertex + 1];
      var bX = flatCoordinates[iMinVertex];
      var bY = flatCoordinates[iMinVertex + 1];
      var cX = flatCoordinates[iNextVertex];
      var cY = flatCoordinates[iNextVertex + 1];
      var determinant = bX * cY + aX * bY + aY * cX - (aY * bX + bY * cX + aX * cY);
      return determinant < 0;
  }
  // Find vertex along one edge of bounding box.
  // In this case, we find smallest y; in case of tie also smallest x.
  function findCornerVertex(flatCoordinates, offset, end, stride) {
      var iMinVertex = -1;
      var minY = Infinity;
      var minXAtMinY = Infinity;
      for (var i = offset; i < end; i += stride) {
          var x = flatCoordinates[i];
          var y = flatCoordinates[i + 1];
          if (y > minY) {
              continue;
          }
          if (y == minY) {
              if (x >= minXAtMinY) {
                  continue;
              }
          }
          // Minimum so far.
          iMinVertex = i;
          minY = y;
          minXAtMinY = x;
      }
      return iMinVertex;
  }
  /**
   * Determines if linear rings are oriented.  By default, left-hand orientation
   * is tested (first ring must be clockwise, remaining rings counter-clockwise).
   * To test for right-hand orientation, use the `opt_right` argument.
   *
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Array of end indexes.
   * @param {number} stride Stride.
   * @param {boolean=} opt_right Test for right-hand orientation
   *     (counter-clockwise exterior ring and clockwise interior rings).
   * @return {boolean} Rings are correctly oriented.
   */
  function linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right) {
      var right = opt_right !== undefined ? opt_right : false;
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
          if (i === 0) {
              if ((right && isClockwise) || (!right && !isClockwise)) {
                  return false;
              }
          }
          else {
              if ((right && !isClockwise) || (!right && isClockwise)) {
                  return false;
              }
          }
          offset = end;
      }
      return true;
  }
  /**
   * Determines if linear rings are oriented.  By default, left-hand orientation
   * is tested (first ring must be clockwise, remaining rings counter-clockwise).
   * To test for right-hand orientation, use the `opt_right` argument.
   *
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Array of array of end indexes.
   * @param {number} stride Stride.
   * @param {boolean=} opt_right Test for right-hand orientation
   *     (counter-clockwise exterior ring and clockwise interior rings).
   * @return {boolean} Rings are correctly oriented.
   */
  function linearRingssAreOriented(flatCoordinates, offset, endss, stride, opt_right) {
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right)) {
              return false;
          }
          if (ends.length) {
              offset = ends[ends.length - 1];
          }
      }
      return true;
  }
  /**
   * Orient coordinates in a flat array of linear rings.  By default, rings
   * are oriented following the left-hand rule (clockwise for exterior and
   * counter-clockwise for interior rings).  To orient according to the
   * right-hand rule, use the `opt_right` argument.
   *
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {boolean=} opt_right Follow the right-hand rule for orientation.
   * @return {number} End.
   */
  function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {
      var right = opt_right !== undefined ? opt_right : false;
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
          var reverse = i === 0
              ? (right && isClockwise) || (!right && !isClockwise)
              : (right && !isClockwise) || (!right && isClockwise);
          if (reverse) {
              coordinates(flatCoordinates, offset, end, stride);
          }
          offset = end;
      }
      return offset;
  }
  /**
   * Orient coordinates in a flat array of linear rings.  By default, rings
   * are oriented following the left-hand rule (clockwise for exterior and
   * counter-clockwise for interior rings).  To orient according to the
   * right-hand rule, use the `opt_right` argument.
   *
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Array of array of end indexes.
   * @param {number} stride Stride.
   * @param {boolean=} opt_right Follow the right-hand rule for orientation.
   * @return {number} End.
   */
  function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);
      }
      return offset;
  }

  var __extends$m = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Polygon geometry.
   *
   * @api
   */
  var Polygon = /** @class */ (function (_super) {
      __extends$m(Polygon, _super);
      /**
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
       *     Array of linear rings that define the polygon. The first linear ring of the
       *     array defines the outer-boundary or surface of the polygon. Each subsequent
       *     linear ring defines a hole in the surface of the polygon. A linear ring is
       *     an array of vertices' coordinates where the first coordinate and the last are
       *     equivalent. (For internal use, flat coordinates in combination with
       *     `opt_layout` and `opt_ends` are also accepted.)
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @param {Array<number>=} opt_ends Ends (for internal use with flat coordinates).
       */
      function Polygon(coordinates, opt_layout, opt_ends) {
          var _this = _super.call(this) || this;
          /**
           * @type {Array<number>}
           * @private
           */
          _this.ends_ = [];
          /**
           * @private
           * @type {number}
           */
          _this.flatInteriorPointRevision_ = -1;
          /**
           * @private
           * @type {import("../coordinate.js").Coordinate}
           */
          _this.flatInteriorPoint_ = null;
          /**
           * @private
           * @type {number}
           */
          _this.maxDelta_ = -1;
          /**
           * @private
           * @type {number}
           */
          _this.maxDeltaRevision_ = -1;
          /**
           * @private
           * @type {number}
           */
          _this.orientedRevision_ = -1;
          /**
           * @private
           * @type {Array<number>}
           */
          _this.orientedFlatCoordinates_ = null;
          if (opt_layout !== undefined && opt_ends) {
              _this.setFlatCoordinates(opt_layout, 
              /** @type {Array<number>} */ (coordinates));
              _this.ends_ = opt_ends;
          }
          else {
              _this.setCoordinates(
              /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */ (coordinates), opt_layout);
          }
          return _this;
      }
      /**
       * Append the passed linear ring to this polygon.
       * @param {LinearRing} linearRing Linear ring.
       * @api
       */
      Polygon.prototype.appendLinearRing = function (linearRing) {
          if (!this.flatCoordinates) {
              this.flatCoordinates = linearRing.getFlatCoordinates().slice();
          }
          else {
              extend(this.flatCoordinates, linearRing.getFlatCoordinates());
          }
          this.ends_.push(this.flatCoordinates.length);
          this.changed();
      };
      /**
       * Make a complete copy of the geometry.
       * @return {!Polygon} Clone.
       * @api
       */
      Polygon.prototype.clone = function () {
          return new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      Polygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
          if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
          }
          if (this.maxDeltaRevision_ != this.getRevision()) {
              this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
              this.maxDeltaRevision_ = this.getRevision();
          }
          return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */
      Polygon.prototype.containsXY = function (x, y) {
          return linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
      };
      /**
       * Return the area of the polygon on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      Polygon.prototype.getArea = function () {
          return linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
      };
      /**
       * Get the coordinate array for this geometry.  This array has the structure
       * of a GeoJSON coordinate array for polygons.
       *
       * @param {boolean=} opt_right Orient coordinates according to the right-hand
       *     rule (counter-clockwise for exterior and clockwise for interior rings).
       *     If `false`, coordinates will be oriented according to the left-hand rule
       *     (clockwise for exterior and counter-clockwise for interior rings).
       *     By default, coordinate orientation will depend on how the geometry was
       *     constructed.
       * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
       * @api
       */
      Polygon.prototype.getCoordinates = function (opt_right) {
          var flatCoordinates;
          if (opt_right !== undefined) {
              flatCoordinates = this.getOrientedFlatCoordinates().slice();
              orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, opt_right);
          }
          else {
              flatCoordinates = this.flatCoordinates;
          }
          return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);
      };
      /**
       * @return {Array<number>} Ends.
       */
      Polygon.prototype.getEnds = function () {
          return this.ends_;
      };
      /**
       * @return {Array<number>} Interior point.
       */
      Polygon.prototype.getFlatInteriorPoint = function () {
          if (this.flatInteriorPointRevision_ != this.getRevision()) {
              var flatCenter = getCenter(this.getExtent());
              this.flatInteriorPoint_ = getInteriorPointOfArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);
              this.flatInteriorPointRevision_ = this.getRevision();
          }
          return this.flatInteriorPoint_;
      };
      /**
       * Return an interior point of the polygon.
       * @return {Point} Interior point as XYM coordinate, where M is the
       * length of the horizontal intersection that the point belongs to.
       * @api
       */
      Polygon.prototype.getInteriorPoint = function () {
          return new Point(this.getFlatInteriorPoint(), GeometryLayout.XYM);
      };
      /**
       * Return the number of rings of the polygon,  this includes the exterior
       * ring and any interior rings.
       *
       * @return {number} Number of rings.
       * @api
       */
      Polygon.prototype.getLinearRingCount = function () {
          return this.ends_.length;
      };
      /**
       * Return the Nth linear ring of the polygon geometry. Return `null` if the
       * given index is out of range.
       * The exterior linear ring is available at index `0` and the interior rings
       * at index `1` and beyond.
       *
       * @param {number} index Index.
       * @return {LinearRing} Linear ring.
       * @api
       */
      Polygon.prototype.getLinearRing = function (index) {
          if (index < 0 || this.ends_.length <= index) {
              return null;
          }
          return new LinearRing(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
      };
      /**
       * Return the linear rings of the polygon.
       * @return {Array<LinearRing>} Linear rings.
       * @api
       */
      Polygon.prototype.getLinearRings = function () {
          var layout = this.layout;
          var flatCoordinates = this.flatCoordinates;
          var ends = this.ends_;
          var linearRings = [];
          var offset = 0;
          for (var i = 0, ii = ends.length; i < ii; ++i) {
              var end = ends[i];
              var linearRing = new LinearRing(flatCoordinates.slice(offset, end), layout);
              linearRings.push(linearRing);
              offset = end;
          }
          return linearRings;
      };
      /**
       * @return {Array<number>} Oriented flat coordinates.
       */
      Polygon.prototype.getOrientedFlatCoordinates = function () {
          if (this.orientedRevision_ != this.getRevision()) {
              var flatCoordinates = this.flatCoordinates;
              if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
                  this.orientedFlatCoordinates_ = flatCoordinates;
              }
              else {
                  this.orientedFlatCoordinates_ = flatCoordinates.slice();
                  this.orientedFlatCoordinates_.length = orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
              }
              this.orientedRevision_ = this.getRevision();
          }
          return this.orientedFlatCoordinates_;
      };
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {Polygon} Simplified Polygon.
       * @protected
       */
      Polygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
          var simplifiedFlatCoordinates = [];
          var simplifiedEnds = [];
          simplifiedFlatCoordinates.length = quantizeArray(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
          return new Polygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);
      };
      /**
       * Get the type of this geometry.
       * @return {import("./GeometryType.js").default} Geometry type.
       * @api
       */
      Polygon.prototype.getType = function () {
          return GeometryType.POLYGON;
      };
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      Polygon.prototype.intersectsExtent = function (extent) {
          return intersectsLinearRingArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
      };
      /**
       * Set the coordinates of the polygon.
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @api
       */
      Polygon.prototype.setCoordinates = function (coordinates, opt_layout) {
          this.setLayout(opt_layout, coordinates, 2);
          if (!this.flatCoordinates) {
              this.flatCoordinates = [];
          }
          var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
          this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
          this.changed();
      };
      return Polygon;
  }(SimpleGeometry));
  /**
   * Create a polygon from an extent. The layout used is `XY`.
   * @param {import("../extent.js").Extent} extent The extent.
   * @return {Polygon} The polygon.
   * @api
   */
  function fromExtent(extent) {
      var minX = extent[0];
      var minY = extent[1];
      var maxX = extent[2];
      var maxY = extent[3];
      var flatCoordinates = [
          minX,
          minY,
          minX,
          maxY,
          maxX,
          maxY,
          maxX,
          minY,
          minX,
          minY,
      ];
      return new Polygon(flatCoordinates, GeometryLayout.XY, [
          flatCoordinates.length,
      ]);
  }

  var __extends$n = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * An animation configuration
   *
   * @typedef {Object} Animation
   * @property {import("./coordinate.js").Coordinate} [sourceCenter]
   * @property {import("./coordinate.js").Coordinate} [targetCenter]
   * @property {number} [sourceResolution]
   * @property {number} [targetResolution]
   * @property {number} [sourceRotation]
   * @property {number} [targetRotation]
   * @property {import("./coordinate.js").Coordinate} [anchor]
   * @property {number} start
   * @property {number} duration
   * @property {boolean} complete
   * @property {function(number):number} easing
   * @property {function(boolean):void} callback
   */
  /**
   * @typedef {Object} Constraints
   * @property {import("./centerconstraint.js").Type} center
   * @property {import("./resolutionconstraint.js").Type} resolution
   * @property {import("./rotationconstraint.js").Type} rotation
   */
  /**
   * @typedef {Object} FitOptions
   * @property {import("./size.js").Size} [size] The size in pixels of the box to fit
   * the extent into. Default is the current size of the first map in the DOM that
   * uses this view, or `[100, 100]` if no such map is found.
   * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be
   * cleared inside the view. Values in the array are top, right, bottom and left
   * padding.
   * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,
   * get the nearest extent instead of the closest that actually fits the view.
   * @property {number} [minResolution=0] Minimum resolution that we zoom to.
   * @property {number} [maxZoom] Maximum zoom level that we zoom to. If
   * `minResolution` is given, this property is ignored.
   * @property {number} [duration] The duration of the animation in milliseconds.
   * By default, there is no animation to the target extent.
   * @property {function(number):number} [easing] The easing function used during
   * the animation (defaults to {@link module:ol/easing~inAndOut}).
   * The function will be called for each frame with a number representing a
   * fraction of the animation's duration.  The function should return a number
   * between 0 and 1 representing the progress toward the destination state.
   * @property {function(boolean):void} [callback] Function called when the view is in
   * its final position. The callback will be called with `true` if the animation
   * series completed on its own or `false` if it was cancelled.
   */
  /**
   * @typedef {Object} ViewOptions
   * @property {import("./coordinate.js").Coordinate} [center] The initial center for
   * the view. If a user projection is not set, the coordinate system for the center is
   * specified with the `projection` option. Layer sources will not be fetched if this
   * is not set, but the center can be set later with {@link #setCenter}.
   * @property {boolean|number} [constrainRotation=true] Rotation constraint.
   * `false` means no constraint. `true` means no constraint, but snap to zero
   * near zero. A number constrains the rotation to that number of values. For
   * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.
   * @property {boolean} [enableRotation=true] Enable rotation.
   * If `false`, a rotation constraint that always sets the rotation to zero is
   * used. The `constrainRotation` option has no effect if `enableRotation` is
   * `false`.
   * @property {import("./extent.js").Extent} [extent] The extent that constrains the
   * view, in other words, nothing outside of this extent can be visible on the map.
   * @property {boolean} [constrainOnlyCenter=false] If true, the extent
   * constraint will only apply to the view center and not the whole extent.
   * @property {boolean} [smoothExtentConstraint=true] If true, the extent
   * constraint will be applied smoothly, i.e. allow the view to go slightly outside
   * of the given `extent`.
   * @property {number} [maxResolution] The maximum resolution used to determine
   * the resolution constraint. It is used together with `minResolution` (or
   * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way
   * that the projection's validity extent fits in a 256x256 px tile. If the
   * projection is Spherical Mercator (the default) then `maxResolution` defaults
   * to `40075016.68557849 / 256 = 156543.03392804097`.
   * @property {number} [minResolution] The minimum resolution used to determine
   * the resolution constraint.  It is used together with `maxResolution` (or
   * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29
   * zoom levels (with a factor of 2). If the projection is Spherical Mercator
   * (the default) then `minResolution` defaults to
   * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.
   * @property {number} [maxZoom=28] The maximum zoom level used to determine the
   * resolution constraint. It is used together with `minZoom` (or
   * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also
   * provided, it is given precedence over `maxZoom`.
   * @property {number} [minZoom=0] The minimum zoom level used to determine the
   * resolution constraint. It is used together with `maxZoom` (or
   * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also
   * provided, it is given precedence over `minZoom`.
   * @property {boolean} [multiWorld=false] If `false` the view is constrained so
   * only one world is visible, and you cannot pan off the edge.  If `true` the map
   * may show multiple worlds at low zoom levels.  Only used if the `projection` is
   * global.  Note that if `extent` is also provided it is given precedence.
   * @property {boolean} [constrainResolution=false] If true, the view will always
   * animate to the closest zoom level after an interaction; false means
   * intermediary zoom levels are allowed.
   * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution
   * min/max values will be applied smoothly, i. e. allow the view to exceed slightly
   * the given resolution or zoom bounds.
   * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to
   * show the full configured extent. By default, when a view is configured with an
   * extent, users will not be able to zoom out so the viewport exceeds the extent in
   * either dimension. This means the full extent may not be visible if the viewport
   * is taller or wider than the aspect ratio of the configured extent. If
   * showFullExtent is true, the user will be able to zoom out so that the viewport
   * exceeds the height or width of the configured extent, but not both, allowing the
   * full extent to be shown.
   * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857'] The
   * projection. The default is Spherical Mercator.
   * @property {number} [resolution] The initial resolution for the view. The
   * units are `projection` units per pixel (e.g. meters per pixel). An
   * alternative to setting this is to set `zoom`. Layer sources will not be
   * fetched if neither this nor `zoom` are defined, but they can be set later
   * with {@link #setZoom} or {@link #setResolution}.
   * @property {Array<number>} [resolutions] Resolutions to determine the
   * resolution constraint. If set the `maxResolution`, `minResolution`,
   * `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.
   * @property {number} [rotation=0] The initial rotation for the view in radians
   * (positive rotation clockwise, 0 means North).
   * @property {number} [zoom] Only used if `resolution` is not defined. Zoom
   * level used to calculate the initial resolution for the view.
   * @property {number} [zoomFactor=2] The zoom factor used to compute the
   * corresponding resolution.
   */
  /**
   * @typedef {Object} AnimationOptions
   * @property {import("./coordinate.js").Coordinate} [center] The center of the view at the end of
   * the animation.
   * @property {number} [zoom] The zoom level of the view at the end of the
   * animation. This takes precedence over `resolution`.
   * @property {number} [resolution] The resolution of the view at the end
   * of the animation.  If `zoom` is also provided, this option will be ignored.
   * @property {number} [rotation] The rotation of the view at the end of
   * the animation.
   * @property {import("./coordinate.js").Coordinate} [anchor] Optional anchor to remain fixed
   * during a rotation or resolution animation.
   * @property {number} [duration=1000] The duration of the animation in milliseconds.
   * @property {function(number):number} [easing] The easing function used
   * during the animation (defaults to {@link module:ol/easing~inAndOut}).
   * The function will be called for each frame with a number representing a
   * fraction of the animation's duration.  The function should return a number
   * between 0 and 1 representing the progress toward the destination state.
   */
  /**
   * @typedef {Object} State
   * @property {import("./coordinate.js").Coordinate} center
   * @property {import("./proj/Projection.js").default} projection
   * @property {number} resolution
   * @property {number} rotation
   * @property {number} zoom
   */
  /**
   * Default min zoom level for the map view.
   * @type {number}
   */
  var DEFAULT_MIN_ZOOM = 0;
  /**
   * @classdesc
   * A View object represents a simple 2D view of the map.
   *
   * This is the object to act upon to change the center, resolution,
   * and rotation of the map.
   *
   * A View has a `projection`. The projection determines the
   * coordinate system of the center, and its units determine the units of the
   * resolution (projection units per pixel). The default projection is
   * Spherical Mercator (EPSG:3857).
   *
   * ### The view states
   *
   * A View is determined by three states: `center`, `resolution`,
   * and `rotation`. Each state has a corresponding getter and setter, e.g.
   * `getCenter` and `setCenter` for the `center` state.
   *
   * The `zoom` state is actually not saved on the view: all computations
   * internally use the `resolution` state. Still, the `setZoom` and `getZoom`
   * methods are available, as well as `getResolutionForZoom` and
   * `getZoomForResolution` to switch from one system to the other.
   *
   * ### The constraints
   *
   * `setCenter`, `setResolution` and `setRotation` can be used to change the
   * states of the view, but any constraint defined in the constructor will
   * be applied along the way.
   *
   * A View object can have a *resolution constraint*, a *rotation constraint*
   * and a *center constraint*.
   *
   * The *resolution constraint* typically restricts min/max values and
   * snaps to specific resolutions. It is determined by the following
   * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.
   * If `resolutions` is set, the other three options are ignored. See
   * documentation for each option for more information. By default, the view
   * only has a min/max restriction and allow intermediary zoom levels when
   * pinch-zooming for example.
   *
   * The *rotation constraint* snaps to specific angles. It is determined
   * by the following options: `enableRotation` and `constrainRotation`.
   * By default rotation is allowed and its value is snapped to zero when approaching the
   * horizontal.
   *
   * The *center constraint* is determined by the `extent` option. By
   * default the view center is not constrained at all.
   *
   * ### Changing the view state
   *
   * It is important to note that `setZoom`, `setResolution`, `setCenter` and
   * `setRotation` are subject to the above mentioned constraints. As such, it
   * may sometimes not be possible to know in advance the resulting state of the
   * View. For example, calling `setResolution(10)` does not guarantee that
   * `getResolution()` will return `10`.
   *
   * A consequence of this is that, when applying a delta on the view state, one
   * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`
   * rather than the corresponding setters. This will let view do its internal
   * computations. Besides, the `adjust*` methods also take an `opt_anchor`
   * argument which allows specifying an origin for the transformation.
   *
   * ### Interacting with the view
   *
   * View constraints are usually only applied when the view is *at rest*, meaning that
   * no interaction or animation is ongoing. As such, if the user puts the view in a
   * state that is not equivalent to a constrained one (e.g. rotating the view when
   * the snap angle is 0), an animation will be triggered at the interaction end to
   * put back the view to a stable state;
   *
   * @api
   */
  var View = /** @class */ (function (_super) {
      __extends$n(View, _super);
      /**
       * @param {ViewOptions=} opt_options View options.
       */
      function View(opt_options) {
          var _this = _super.call(this) || this;
          var options = assign({}, opt_options);
          /**
           * @private
           * @type {Array<number>}
           */
          _this.hints_ = [0, 0];
          /**
           * @private
           * @type {Array<Array<Animation>>}
           */
          _this.animations_ = [];
          /**
           * @private
           * @type {number|undefined}
           */
          _this.updateAnimationKey_;
          /**
           * @private
           * @const
           * @type {import("./proj/Projection.js").default}
           */
          _this.projection_ = createProjection(options.projection, 'EPSG:3857');
          /**
           * @private
           * @type {import("./size.js").Size}
           */
          _this.viewportSize_ = [100, 100];
          /**
           * @private
           * @type {import("./coordinate.js").Coordinate|undefined}
           */
          _this.targetCenter_ = null;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.targetResolution_;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.targetRotation_;
          /**
           * @private
           * @type {import("./coordinate.js").Coordinate|undefined}
           */
          _this.cancelAnchor_ = undefined;
          if (options.center) {
              options.center = fromUserCoordinate(options.center, _this.projection_);
          }
          if (options.extent) {
              options.extent = fromUserExtent(options.extent, _this.projection_);
          }
          _this.applyOptions_(options);
          return _this;
      }
      /**
       * Set up the view with the given options.
       * @param {ViewOptions} options View options.
       */
      View.prototype.applyOptions_ = function (options) {
          /**
           * @type {Object<string, *>}
           */
          var properties = {};
          var resolutionConstraintInfo = createResolutionConstraint(options);
          /**
           * @private
           * @type {number}
           */
          this.maxResolution_ = resolutionConstraintInfo.maxResolution;
          /**
           * @private
           * @type {number}
           */
          this.minResolution_ = resolutionConstraintInfo.minResolution;
          /**
           * @private
           * @type {number}
           */
          this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
          /**
           * @private
           * @type {Array<number>|undefined}
           */
          this.resolutions_ = options.resolutions;
          /**
           * @private
           * @type {number}
           */
          this.minZoom_ = resolutionConstraintInfo.minZoom;
          var centerConstraint = createCenterConstraint(options);
          var resolutionConstraint = resolutionConstraintInfo.constraint;
          var rotationConstraint = createRotationConstraint(options);
          /**
           * @private
           * @type {Constraints}
           */
          this.constraints_ = {
              center: centerConstraint,
              resolution: resolutionConstraint,
              rotation: rotationConstraint,
          };
          this.setRotation(options.rotation !== undefined ? options.rotation : 0);
          this.setCenterInternal(options.center !== undefined ? options.center : null);
          if (options.resolution !== undefined) {
              this.setResolution(options.resolution);
          }
          else if (options.zoom !== undefined) {
              this.setZoom(options.zoom);
          }
          this.setProperties(properties);
          /**
           * @private
           * @type {ViewOptions}
           */
          this.options_ = options;
      };
      /**
       * Get an updated version of the view options used to construct the view.  The
       * current resolution (or zoom), center, and rotation are applied to any stored
       * options.  The provided options can be used to apply new min/max zoom or
       * resolution limits.
       * @param {ViewOptions} newOptions New options to be applied.
       * @return {ViewOptions} New options updated with the current view state.
       */
      View.prototype.getUpdatedOptions_ = function (newOptions) {
          var options = assign({}, this.options_);
          // preserve resolution (or zoom)
          if (options.resolution !== undefined) {
              options.resolution = this.getResolution();
          }
          else {
              options.zoom = this.getZoom();
          }
          // preserve center
          options.center = this.getCenterInternal();
          // preserve rotation
          options.rotation = this.getRotation();
          return assign({}, options, newOptions);
      };
      /**
       * Animate the view.  The view's center, zoom (or resolution), and rotation
       * can be animated for smooth transitions between view states.  For example,
       * to animate the view to a new zoom level:
       *
       *     view.animate({zoom: view.getZoom() + 1});
       *
       * By default, the animation lasts one second and uses in-and-out easing.  You
       * can customize this behavior by including `duration` (in milliseconds) and
       * `easing` options (see {@link module:ol/easing}).
       *
       * To chain together multiple animations, call the method with multiple
       * animation objects.  For example, to first zoom and then pan:
       *
       *     view.animate({zoom: 10}, {center: [0, 0]});
       *
       * If you provide a function as the last argument to the animate method, it
       * will get called at the end of an animation series.  The callback will be
       * called with `true` if the animation series completed on its own or `false`
       * if it was cancelled.
       *
       * Animations are cancelled by user interactions (e.g. dragging the map) or by
       * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
       * (or another method that calls one of these).
       *
       * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
       *     options.  Multiple animations can be run in series by passing multiple
       *     options objects.  To run multiple animations in parallel, call the method
       *     multiple times.  An optional callback can be provided as a final
       *     argument.  The callback will be called with a boolean indicating whether
       *     the animation completed without being cancelled.
       * @api
       */
      View.prototype.animate = function (var_args) {
          if (this.isDef() && !this.getAnimating()) {
              this.resolveConstraints(0);
          }
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; ++i) {
              var options = arguments[i];
              if (options.center) {
                  options = assign({}, options);
                  options.center = fromUserCoordinate(options.center, this.getProjection());
              }
              if (options.anchor) {
                  options = assign({}, options);
                  options.anchor = fromUserCoordinate(options.anchor, this.getProjection());
              }
              args[i] = options;
          }
          this.animateInternal.apply(this, args);
      };
      /**
       * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
       */
      View.prototype.animateInternal = function (var_args) {
          var animationCount = arguments.length;
          var callback;
          if (animationCount > 1 &&
              typeof arguments[animationCount - 1] === 'function') {
              callback = arguments[animationCount - 1];
              --animationCount;
          }
          if (!this.isDef()) {
              // if view properties are not yet set, shortcut to the final state
              var state = arguments[animationCount - 1];
              if (state.center) {
                  this.setCenterInternal(state.center);
              }
              if (state.zoom !== undefined) {
                  this.setZoom(state.zoom);
              }
              if (state.rotation !== undefined) {
                  this.setRotation(state.rotation);
              }
              if (callback) {
                  animationCallback(callback, true);
              }
              return;
          }
          var start = Date.now();
          var center = this.targetCenter_.slice();
          var resolution = this.targetResolution_;
          var rotation = this.targetRotation_;
          var series = [];
          for (var i = 0; i < animationCount; ++i) {
              var options = /** @type {AnimationOptions} */ (arguments[i]);
              var animation = {
                  start: start,
                  complete: false,
                  anchor: options.anchor,
                  duration: options.duration !== undefined ? options.duration : 1000,
                  easing: options.easing || inAndOut,
                  callback: callback,
              };
              if (options.center) {
                  animation.sourceCenter = center;
                  animation.targetCenter = options.center.slice();
                  center = animation.targetCenter;
              }
              if (options.zoom !== undefined) {
                  animation.sourceResolution = resolution;
                  animation.targetResolution = this.getResolutionForZoom(options.zoom);
                  resolution = animation.targetResolution;
              }
              else if (options.resolution) {
                  animation.sourceResolution = resolution;
                  animation.targetResolution = options.resolution;
                  resolution = animation.targetResolution;
              }
              if (options.rotation !== undefined) {
                  animation.sourceRotation = rotation;
                  var delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
                  animation.targetRotation = rotation + delta;
                  rotation = animation.targetRotation;
              }
              // check if animation is a no-op
              if (isNoopAnimation(animation)) {
                  animation.complete = true;
                  // we still push it onto the series for callback handling
              }
              else {
                  start += animation.duration;
              }
              series.push(animation);
          }
          this.animations_.push(series);
          this.setHint(ViewHint.ANIMATING, 1);
          this.updateAnimations_();
      };
      /**
       * Determine if the view is being animated.
       * @return {boolean} The view is being animated.
       * @api
       */
      View.prototype.getAnimating = function () {
          return this.hints_[ViewHint.ANIMATING] > 0;
      };
      /**
       * Determine if the user is interacting with the view, such as panning or zooming.
       * @return {boolean} The view is being interacted with.
       * @api
       */
      View.prototype.getInteracting = function () {
          return this.hints_[ViewHint.INTERACTING] > 0;
      };
      /**
       * Cancel any ongoing animations.
       * @api
       */
      View.prototype.cancelAnimations = function () {
          this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);
          var anchor;
          for (var i = 0, ii = this.animations_.length; i < ii; ++i) {
              var series = this.animations_[i];
              if (series[0].callback) {
                  animationCallback(series[0].callback, false);
              }
              if (!anchor) {
                  for (var j = 0, jj = series.length; j < jj; ++j) {
                      var animation = series[j];
                      if (!animation.complete) {
                          anchor = animation.anchor;
                          break;
                      }
                  }
              }
          }
          this.animations_.length = 0;
          this.cancelAnchor_ = anchor;
      };
      /**
       * Update all animations.
       */
      View.prototype.updateAnimations_ = function () {
          if (this.updateAnimationKey_ !== undefined) {
              cancelAnimationFrame(this.updateAnimationKey_);
              this.updateAnimationKey_ = undefined;
          }
          if (!this.getAnimating()) {
              return;
          }
          var now = Date.now();
          var more = false;
          for (var i = this.animations_.length - 1; i >= 0; --i) {
              var series = this.animations_[i];
              var seriesComplete = true;
              for (var j = 0, jj = series.length; j < jj; ++j) {
                  var animation = series[j];
                  if (animation.complete) {
                      continue;
                  }
                  var elapsed = now - animation.start;
                  var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
                  if (fraction >= 1) {
                      animation.complete = true;
                      fraction = 1;
                  }
                  else {
                      seriesComplete = false;
                  }
                  var progress = animation.easing(fraction);
                  if (animation.sourceCenter) {
                      var x0 = animation.sourceCenter[0];
                      var y0 = animation.sourceCenter[1];
                      var x1 = animation.targetCenter[0];
                      var y1 = animation.targetCenter[1];
                      var x = x0 + progress * (x1 - x0);
                      var y = y0 + progress * (y1 - y0);
                      this.targetCenter_ = [x, y];
                  }
                  if (animation.sourceResolution && animation.targetResolution) {
                      var resolution = progress === 1
                          ? animation.targetResolution
                          : animation.sourceResolution +
                              progress *
                                  (animation.targetResolution - animation.sourceResolution);
                      if (animation.anchor) {
                          var size = this.getViewportSize_(this.getRotation());
                          var constrainedResolution = this.constraints_.resolution(resolution, 0, size, true);
                          this.targetCenter_ = this.calculateCenterZoom(constrainedResolution, animation.anchor);
                      }
                      this.targetResolution_ = resolution;
                      this.applyTargetState_(true);
                  }
                  if (animation.sourceRotation !== undefined &&
                      animation.targetRotation !== undefined) {
                      var rotation = progress === 1
                          ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) -
                              Math.PI
                          : animation.sourceRotation +
                              progress *
                                  (animation.targetRotation - animation.sourceRotation);
                      if (animation.anchor) {
                          var constrainedRotation = this.constraints_.rotation(rotation, true);
                          this.targetCenter_ = this.calculateCenterRotate(constrainedRotation, animation.anchor);
                      }
                      this.targetRotation_ = rotation;
                  }
                  this.applyTargetState_(true);
                  more = true;
                  if (!animation.complete) {
                      break;
                  }
              }
              if (seriesComplete) {
                  this.animations_[i] = null;
                  this.setHint(ViewHint.ANIMATING, -1);
                  var callback = series[0].callback;
                  if (callback) {
                      animationCallback(callback, true);
                  }
              }
          }
          // prune completed series
          this.animations_ = this.animations_.filter(Boolean);
          if (more && this.updateAnimationKey_ === undefined) {
              this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this));
          }
      };
      /**
       * @param {number} rotation Target rotation.
       * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
       * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
       */
      View.prototype.calculateCenterRotate = function (rotation, anchor) {
          var center;
          var currentCenter = this.getCenterInternal();
          if (currentCenter !== undefined) {
              center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
              rotate$1(center, rotation - this.getRotation());
              add$2(center, anchor);
          }
          return center;
      };
      /**
       * @param {number} resolution Target resolution.
       * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
       * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
       */
      View.prototype.calculateCenterZoom = function (resolution, anchor) {
          var center;
          var currentCenter = this.getCenterInternal();
          var currentResolution = this.getResolution();
          if (currentCenter !== undefined && currentResolution !== undefined) {
              var x = anchor[0] -
                  (resolution * (anchor[0] - currentCenter[0])) / currentResolution;
              var y = anchor[1] -
                  (resolution * (anchor[1] - currentCenter[1])) / currentResolution;
              center = [x, y];
          }
          return center;
      };
      /**
       * Returns the current viewport size.
       * @private
       * @param {number=} opt_rotation Take into account the rotation of the viewport when giving the size
       * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
       */
      View.prototype.getViewportSize_ = function (opt_rotation) {
          var size = this.viewportSize_;
          if (opt_rotation) {
              var w = size[0];
              var h = size[1];
              return [
                  Math.abs(w * Math.cos(opt_rotation)) +
                      Math.abs(h * Math.sin(opt_rotation)),
                  Math.abs(w * Math.sin(opt_rotation)) +
                      Math.abs(h * Math.cos(opt_rotation)),
              ];
          }
          else {
              return size;
          }
      };
      /**
       * Stores the viewport size on the view. The viewport size is not read every time from the DOM
       * to avoid performance hit and layout reflow.
       * This should be done on map size change.
       * Note: the constraints are not resolved during an animation to avoid stopping it
       * @param {import("./size.js").Size=} opt_size Viewport size; if undefined, [100, 100] is assumed
       */
      View.prototype.setViewportSize = function (opt_size) {
          this.viewportSize_ = Array.isArray(opt_size)
              ? opt_size.slice()
              : [100, 100];
          if (!this.getAnimating()) {
              this.resolveConstraints(0);
          }
      };
      /**
       * Get the view center.
       * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
       * @observable
       * @api
       */
      View.prototype.getCenter = function () {
          var center = this.getCenterInternal();
          if (!center) {
              return center;
          }
          return toUserCoordinate(center, this.getProjection());
      };
      /**
       * Get the view center without transforming to user projection.
       * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
       */
      View.prototype.getCenterInternal = function () {
          return /** @type {import("./coordinate.js").Coordinate|undefined} */ (this.get(ViewProperty.CENTER));
      };
      /**
       * @return {Constraints} Constraints.
       */
      View.prototype.getConstraints = function () {
          return this.constraints_;
      };
      /**
       * @return {boolean} Resolution constraint is set
       */
      View.prototype.getConstrainResolution = function () {
          return this.options_.constrainResolution;
      };
      /**
       * @param {Array<number>=} opt_hints Destination array.
       * @return {Array<number>} Hint.
       */
      View.prototype.getHints = function (opt_hints) {
          if (opt_hints !== undefined) {
              opt_hints[0] = this.hints_[0];
              opt_hints[1] = this.hints_[1];
              return opt_hints;
          }
          else {
              return this.hints_.slice();
          }
      };
      /**
       * Calculate the extent for the current view state and the passed size.
       * The size is the pixel dimensions of the box into which the calculated extent
       * should fit. In most cases you want to get the extent of the entire map,
       * that is `map.getSize()`.
       * @param {import("./size.js").Size=} opt_size Box pixel size. If not provided, the size
       * of the map that uses this view will be used.
       * @return {import("./extent.js").Extent} Extent.
       * @api
       */
      View.prototype.calculateExtent = function (opt_size) {
          var extent = this.calculateExtentInternal(opt_size);
          return toUserExtent(extent, this.getProjection());
      };
      /**
       * @param {import("./size.js").Size=} opt_size Box pixel size. If not provided, the size of the
       * first map that uses this view will be used.
       * @return {import("./extent.js").Extent} Extent.
       */
      View.prototype.calculateExtentInternal = function (opt_size) {
          var size = opt_size || this.getViewportSize_();
          var center = /** @type {!import("./coordinate.js").Coordinate} */ (this.getCenterInternal());
          assert(center, 1); // The view center is not defined
          var resolution = /** @type {!number} */ (this.getResolution());
          assert(resolution !== undefined, 2); // The view resolution is not defined
          var rotation = /** @type {!number} */ (this.getRotation());
          assert(rotation !== undefined, 3); // The view rotation is not defined
          return getForViewAndSize(center, resolution, rotation, size);
      };
      /**
       * Get the maximum resolution of the view.
       * @return {number} The maximum resolution of the view.
       * @api
       */
      View.prototype.getMaxResolution = function () {
          return this.maxResolution_;
      };
      /**
       * Get the minimum resolution of the view.
       * @return {number} The minimum resolution of the view.
       * @api
       */
      View.prototype.getMinResolution = function () {
          return this.minResolution_;
      };
      /**
       * Get the maximum zoom level for the view.
       * @return {number} The maximum zoom level.
       * @api
       */
      View.prototype.getMaxZoom = function () {
          return /** @type {number} */ (this.getZoomForResolution(this.minResolution_));
      };
      /**
       * Set a new maximum zoom level for the view.
       * @param {number} zoom The maximum zoom level.
       * @api
       */
      View.prototype.setMaxZoom = function (zoom) {
          this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));
      };
      /**
       * Get the minimum zoom level for the view.
       * @return {number} The minimum zoom level.
       * @api
       */
      View.prototype.getMinZoom = function () {
          return /** @type {number} */ (this.getZoomForResolution(this.maxResolution_));
      };
      /**
       * Set a new minimum zoom level for the view.
       * @param {number} zoom The minimum zoom level.
       * @api
       */
      View.prototype.setMinZoom = function (zoom) {
          this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));
      };
      /**
       * Set whether the view shoud allow intermediary zoom levels.
       * @param {boolean} enabled Whether the resolution is constrained.
       * @api
       */
      View.prototype.setConstrainResolution = function (enabled) {
          this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: enabled }));
      };
      /**
       * Get the view projection.
       * @return {import("./proj/Projection.js").default} The projection of the view.
       * @api
       */
      View.prototype.getProjection = function () {
          return this.projection_;
      };
      /**
       * Get the view resolution.
       * @return {number|undefined} The resolution of the view.
       * @observable
       * @api
       */
      View.prototype.getResolution = function () {
          return /** @type {number|undefined} */ (this.get(ViewProperty.RESOLUTION));
      };
      /**
       * Get the resolutions for the view. This returns the array of resolutions
       * passed to the constructor of the View, or undefined if none were given.
       * @return {Array<number>|undefined} The resolutions of the view.
       * @api
       */
      View.prototype.getResolutions = function () {
          return this.resolutions_;
      };
      /**
       * Get the resolution for a provided extent (in map units) and size (in pixels).
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {import("./size.js").Size=} opt_size Box pixel size.
       * @return {number} The resolution at which the provided extent will render at
       *     the given size.
       * @api
       */
      View.prototype.getResolutionForExtent = function (extent, opt_size) {
          return this.getResolutionForExtentInternal(fromUserExtent(extent, this.getProjection()), opt_size);
      };
      /**
       * Get the resolution for a provided extent (in map units) and size (in pixels).
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {import("./size.js").Size=} opt_size Box pixel size.
       * @return {number} The resolution at which the provided extent will render at
       *     the given size.
       */
      View.prototype.getResolutionForExtentInternal = function (extent, opt_size) {
          var size = opt_size || this.getViewportSize_();
          var xResolution = getWidth(extent) / size[0];
          var yResolution = getHeight(extent) / size[1];
          return Math.max(xResolution, yResolution);
      };
      /**
       * Return a function that returns a value between 0 and 1 for a
       * resolution. Exponential scaling is assumed.
       * @param {number=} opt_power Power.
       * @return {function(number): number} Resolution for value function.
       */
      View.prototype.getResolutionForValueFunction = function (opt_power) {
          var power = opt_power || 2;
          var maxResolution = this.getConstrainedResolution(this.maxResolution_);
          var minResolution = this.minResolution_;
          var max = Math.log(maxResolution / minResolution) / Math.log(power);
          return (
          /**
           * @param {number} value Value.
           * @return {number} Resolution.
           */
          function (value) {
              var resolution = maxResolution / Math.pow(power, value * max);
              return resolution;
          });
      };
      /**
       * Get the view rotation.
       * @return {number} The rotation of the view in radians.
       * @observable
       * @api
       */
      View.prototype.getRotation = function () {
          return /** @type {number} */ (this.get(ViewProperty.ROTATION));
      };
      /**
       * Return a function that returns a resolution for a value between
       * 0 and 1. Exponential scaling is assumed.
       * @param {number=} opt_power Power.
       * @return {function(number): number} Value for resolution function.
       */
      View.prototype.getValueForResolutionFunction = function (opt_power) {
          var logPower = Math.log(opt_power || 2);
          var maxResolution = this.getConstrainedResolution(this.maxResolution_);
          var minResolution = this.minResolution_;
          var max = Math.log(maxResolution / minResolution) / logPower;
          return (
          /**
           * @param {number} resolution Resolution.
           * @return {number} Value.
           */
          function (resolution) {
              var value = Math.log(maxResolution / resolution) / logPower / max;
              return value;
          });
      };
      /**
       * @return {State} View state.
       */
      View.prototype.getState = function () {
          var center = /** @type {import("./coordinate.js").Coordinate} */ (this.getCenterInternal());
          var projection = this.getProjection();
          var resolution = /** @type {number} */ (this.getResolution());
          var rotation = this.getRotation();
          return {
              center: center.slice(0),
              projection: projection !== undefined ? projection : null,
              resolution: resolution,
              rotation: rotation,
              zoom: this.getZoom(),
          };
      };
      /**
       * Get the current zoom level. This method may return non-integer zoom levels
       * if the view does not constrain the resolution, or if an interaction or
       * animation is underway.
       * @return {number|undefined} Zoom.
       * @api
       */
      View.prototype.getZoom = function () {
          var zoom;
          var resolution = this.getResolution();
          if (resolution !== undefined) {
              zoom = this.getZoomForResolution(resolution);
          }
          return zoom;
      };
      /**
       * Get the zoom level for a resolution.
       * @param {number} resolution The resolution.
       * @return {number|undefined} The zoom level for the provided resolution.
       * @api
       */
      View.prototype.getZoomForResolution = function (resolution) {
          var offset = this.minZoom_ || 0;
          var max, zoomFactor;
          if (this.resolutions_) {
              var nearest = linearFindNearest(this.resolutions_, resolution, 1);
              offset = nearest;
              max = this.resolutions_[nearest];
              if (nearest == this.resolutions_.length - 1) {
                  zoomFactor = 2;
              }
              else {
                  zoomFactor = max / this.resolutions_[nearest + 1];
              }
          }
          else {
              max = this.maxResolution_;
              zoomFactor = this.zoomFactor_;
          }
          return offset + Math.log(max / resolution) / Math.log(zoomFactor);
      };
      /**
       * Get the resolution for a zoom level.
       * @param {number} zoom Zoom level.
       * @return {number} The view resolution for the provided zoom level.
       * @api
       */
      View.prototype.getResolutionForZoom = function (zoom) {
          if (this.resolutions_) {
              if (this.resolutions_.length <= 1) {
                  return 0;
              }
              var baseLevel = clamp(Math.floor(zoom), 0, this.resolutions_.length - 2);
              var zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
              return (this.resolutions_[baseLevel] /
                  Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1)));
          }
          else {
              return (this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_));
          }
      };
      /**
       * Fit the given geometry or extent based on the given map size and border.
       * The size is pixel dimensions of the box to fit the extent into.
       * In most cases you will want to use the map size, that is `map.getSize()`.
       * Takes care of the map angle.
       * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
       *     extent to fit the view to.
       * @param {FitOptions=} opt_options Options.
       * @api
       */
      View.prototype.fit = function (geometryOrExtent, opt_options) {
          var options = assign({ size: this.getViewportSize_() }, opt_options || {});
          /** @type {import("./geom/SimpleGeometry.js").default} */
          var geometry;
          assert(Array.isArray(geometryOrExtent) ||
              typeof ( /** @type {?} */(geometryOrExtent).getSimplifiedGeometry) ===
                  'function', 24); // Invalid extent or geometry provided as `geometry`
          if (Array.isArray(geometryOrExtent)) {
              assert(!isEmpty(geometryOrExtent), 25); // Cannot fit empty extent provided as `geometry`
              var extent = fromUserExtent(geometryOrExtent, this.getProjection());
              geometry = fromExtent(extent);
          }
          else if (geometryOrExtent.getType() === GeometryType.CIRCLE) {
              var extent = fromUserExtent(geometryOrExtent.getExtent(), this.getProjection());
              geometry = fromExtent(extent);
              geometry.rotate(this.getRotation(), getCenter(extent));
          }
          else {
              var userProjection = getUserProjection();
              if (userProjection) {
                  geometry = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometryOrExtent
                      .clone()
                      .transform(userProjection, this.getProjection()));
              }
              else {
                  geometry = geometryOrExtent;
              }
          }
          this.fitInternal(geometry, options);
      };
      /**
       * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
       * @param {FitOptions=} opt_options Options.
       */
      View.prototype.fitInternal = function (geometry, opt_options) {
          var options = opt_options || {};
          var size = options.size;
          if (!size) {
              size = this.getViewportSize_();
          }
          var padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];
          var nearest = options.nearest !== undefined ? options.nearest : false;
          var minResolution;
          if (options.minResolution !== undefined) {
              minResolution = options.minResolution;
          }
          else if (options.maxZoom !== undefined) {
              minResolution = this.getResolutionForZoom(options.maxZoom);
          }
          else {
              minResolution = 0;
          }
          var coords = geometry.getFlatCoordinates();
          // calculate rotated extent
          var rotation = this.getRotation();
          var cosAngle = Math.cos(-rotation);
          var sinAngle = Math.sin(-rotation);
          var minRotX = +Infinity;
          var minRotY = +Infinity;
          var maxRotX = -Infinity;
          var maxRotY = -Infinity;
          var stride = geometry.getStride();
          for (var i = 0, ii = coords.length; i < ii; i += stride) {
              var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
              var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
              minRotX = Math.min(minRotX, rotX);
              minRotY = Math.min(minRotY, rotY);
              maxRotX = Math.max(maxRotX, rotX);
              maxRotY = Math.max(maxRotY, rotY);
          }
          // calculate resolution
          var resolution = this.getResolutionForExtentInternal([minRotX, minRotY, maxRotX, maxRotY], [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);
          resolution = isNaN(resolution)
              ? minResolution
              : Math.max(resolution, minResolution);
          resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
          // calculate center
          sinAngle = -sinAngle; // go back to original rotation
          var centerRotX = (minRotX + maxRotX) / 2;
          var centerRotY = (minRotY + maxRotY) / 2;
          centerRotX += ((padding[1] - padding[3]) / 2) * resolution;
          centerRotY += ((padding[0] - padding[2]) / 2) * resolution;
          var centerX = centerRotX * cosAngle - centerRotY * sinAngle;
          var centerY = centerRotY * cosAngle + centerRotX * sinAngle;
          var center = [centerX, centerY];
          var callback = options.callback ? options.callback : VOID;
          if (options.duration !== undefined) {
              this.animateInternal({
                  resolution: resolution,
                  center: this.getConstrainedCenter(center, resolution),
                  duration: options.duration,
                  easing: options.easing,
              }, callback);
          }
          else {
              this.targetResolution_ = resolution;
              this.targetCenter_ = center;
              this.applyTargetState_(false, true);
              animationCallback(callback, true);
          }
      };
      /**
       * Center on coordinate and view position.
       * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("./size.js").Size} size Box pixel size.
       * @param {import("./pixel.js").Pixel} position Position on the view to center on.
       * @api
       */
      View.prototype.centerOn = function (coordinate, size, position) {
          this.centerOnInternal(fromUserCoordinate(coordinate, this.getProjection()), size, position);
      };
      /**
       * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("./size.js").Size} size Box pixel size.
       * @param {import("./pixel.js").Pixel} position Position on the view to center on.
       */
      View.prototype.centerOnInternal = function (coordinate, size, position) {
          // calculate rotated position
          var rotation = this.getRotation();
          var cosAngle = Math.cos(-rotation);
          var sinAngle = Math.sin(-rotation);
          var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
          var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
          var resolution = this.getResolution();
          rotX += (size[0] / 2 - position[0]) * resolution;
          rotY += (position[1] - size[1] / 2) * resolution;
          // go back to original angle
          sinAngle = -sinAngle; // go back to original rotation
          var centerX = rotX * cosAngle - rotY * sinAngle;
          var centerY = rotY * cosAngle + rotX * sinAngle;
          this.setCenterInternal([centerX, centerY]);
      };
      /**
       * @return {boolean} Is defined.
       */
      View.prototype.isDef = function () {
          return !!this.getCenterInternal() && this.getResolution() !== undefined;
      };
      /**
       * Adds relative coordinates to the center of the view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
       * @api
       */
      View.prototype.adjustCenter = function (deltaCoordinates) {
          var center = toUserCoordinate(this.targetCenter_, this.getProjection());
          this.setCenter([
              center[0] + deltaCoordinates[0],
              center[1] + deltaCoordinates[1],
          ]);
      };
      /**
       * Adds relative coordinates to the center of the view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
       */
      View.prototype.adjustCenterInternal = function (deltaCoordinates) {
          var center = this.targetCenter_;
          this.setCenterInternal([
              center[0] + deltaCoordinates[0],
              center[1] + deltaCoordinates[1],
          ]);
      };
      /**
       * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} ratio The ratio to apply on the view resolution.
       * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
       * @api
       */
      View.prototype.adjustResolution = function (ratio, opt_anchor) {
          var anchor = opt_anchor && fromUserCoordinate(opt_anchor, this.getProjection());
          this.adjustResolutionInternal(ratio, anchor);
      };
      /**
       * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} ratio The ratio to apply on the view resolution.
       * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
       */
      View.prototype.adjustResolutionInternal = function (ratio, opt_anchor) {
          var isMoving = this.getAnimating() || this.getInteracting();
          var size = this.getViewportSize_(this.getRotation());
          var newResolution = this.constraints_.resolution(this.targetResolution_ * ratio, 0, size, isMoving);
          if (opt_anchor) {
              this.targetCenter_ = this.calculateCenterZoom(newResolution, opt_anchor);
          }
          this.targetResolution_ *= ratio;
          this.applyTargetState_();
      };
      /**
       * Adds a value to the view zoom level, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} delta Relative value to add to the zoom level.
       * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
       * @api
       */
      View.prototype.adjustZoom = function (delta, opt_anchor) {
          this.adjustResolution(Math.pow(this.zoomFactor_, -delta), opt_anchor);
      };
      /**
       * Adds a value to the view rotation, optionally using an anchor. Any rotation
       * constraint will apply.
       * @param {number} delta Relative value to add to the zoom rotation, in radians.
       * @param {import("./coordinate.js").Coordinate=} opt_anchor The rotation center.
       * @api
       */
      View.prototype.adjustRotation = function (delta, opt_anchor) {
          if (opt_anchor) {
              opt_anchor = fromUserCoordinate(opt_anchor, this.getProjection());
          }
          this.adjustRotationInternal(delta, opt_anchor);
      };
      /**
       * @param {number} delta Relative value to add to the zoom rotation, in radians.
       * @param {import("./coordinate.js").Coordinate=} opt_anchor The rotation center.
       */
      View.prototype.adjustRotationInternal = function (delta, opt_anchor) {
          var isMoving = this.getAnimating() || this.getInteracting();
          var newRotation = this.constraints_.rotation(this.targetRotation_ + delta, isMoving);
          if (opt_anchor) {
              this.targetCenter_ = this.calculateCenterRotate(newRotation, opt_anchor);
          }
          this.targetRotation_ += delta;
          this.applyTargetState_();
      };
      /**
       * Set the center of the current view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
       * @observable
       * @api
       */
      View.prototype.setCenter = function (center) {
          this.setCenterInternal(fromUserCoordinate(center, this.getProjection()));
      };
      /**
       * Set the center using the view projection (not the user projection).
       * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
       */
      View.prototype.setCenterInternal = function (center) {
          this.targetCenter_ = center;
          this.applyTargetState_();
      };
      /**
       * @param {import("./ViewHint.js").default} hint Hint.
       * @param {number} delta Delta.
       * @return {number} New value.
       */
      View.prototype.setHint = function (hint, delta) {
          this.hints_[hint] += delta;
          this.changed();
          return this.hints_[hint];
      };
      /**
       * Set the resolution for this view. Any resolution constraint will apply.
       * @param {number|undefined} resolution The resolution of the view.
       * @observable
       * @api
       */
      View.prototype.setResolution = function (resolution) {
          this.targetResolution_ = resolution;
          this.applyTargetState_();
      };
      /**
       * Set the rotation for this view. Any rotation constraint will apply.
       * @param {number} rotation The rotation of the view in radians.
       * @observable
       * @api
       */
      View.prototype.setRotation = function (rotation) {
          this.targetRotation_ = rotation;
          this.applyTargetState_();
      };
      /**
       * Zoom to a specific zoom level. Any resolution constrain will apply.
       * @param {number} zoom Zoom level.
       * @api
       */
      View.prototype.setZoom = function (zoom) {
          this.setResolution(this.getResolutionForZoom(zoom));
      };
      /**
       * Recompute rotation/resolution/center based on target values.
       * Note: we have to compute rotation first, then resolution and center considering that
       * parameters can influence one another in case a view extent constraint is present.
       * @param {boolean=} opt_doNotCancelAnims Do not cancel animations.
       * @param {boolean=} opt_forceMoving Apply constraints as if the view is moving.
       * @private
       */
      View.prototype.applyTargetState_ = function (opt_doNotCancelAnims, opt_forceMoving) {
          var isMoving = this.getAnimating() || this.getInteracting() || opt_forceMoving;
          // compute rotation
          var newRotation = this.constraints_.rotation(this.targetRotation_, isMoving);
          var size = this.getViewportSize_(newRotation);
          var newResolution = this.constraints_.resolution(this.targetResolution_, 0, size, isMoving);
          var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, isMoving);
          if (this.get(ViewProperty.ROTATION) !== newRotation) {
              this.set(ViewProperty.ROTATION, newRotation);
          }
          if (this.get(ViewProperty.RESOLUTION) !== newResolution) {
              this.set(ViewProperty.RESOLUTION, newResolution);
          }
          if (!this.get(ViewProperty.CENTER) ||
              !equals$2(this.get(ViewProperty.CENTER), newCenter)) {
              this.set(ViewProperty.CENTER, newCenter);
          }
          if (this.getAnimating() && !opt_doNotCancelAnims) {
              this.cancelAnimations();
          }
          this.cancelAnchor_ = undefined;
      };
      /**
       * If any constraints need to be applied, an animation will be triggered.
       * This is typically done on interaction end.
       * Note: calling this with a duration of 0 will apply the constrained values straight away,
       * without animation.
       * @param {number=} opt_duration The animation duration in ms.
       * @param {number=} opt_resolutionDirection Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
       */
      View.prototype.resolveConstraints = function (opt_duration, opt_resolutionDirection, opt_anchor) {
          var duration = opt_duration !== undefined ? opt_duration : 200;
          var direction = opt_resolutionDirection || 0;
          var newRotation = this.constraints_.rotation(this.targetRotation_);
          var size = this.getViewportSize_(newRotation);
          var newResolution = this.constraints_.resolution(this.targetResolution_, direction, size);
          var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size);
          if (duration === 0 && !this.cancelAnchor_) {
              this.targetResolution_ = newResolution;
              this.targetRotation_ = newRotation;
              this.targetCenter_ = newCenter;
              this.applyTargetState_();
              return;
          }
          var anchor = opt_anchor || (duration === 0 ? this.cancelAnchor_ : undefined);
          this.cancelAnchor_ = undefined;
          if (this.getResolution() !== newResolution ||
              this.getRotation() !== newRotation ||
              !this.getCenterInternal() ||
              !equals$2(this.getCenterInternal(), newCenter)) {
              if (this.getAnimating()) {
                  this.cancelAnimations();
              }
              this.animateInternal({
                  rotation: newRotation,
                  center: newCenter,
                  resolution: newResolution,
                  duration: duration,
                  easing: easeOut,
                  anchor: anchor,
              });
          }
      };
      /**
       * Notify the View that an interaction has started.
       * The view state will be resolved to a stable one if needed
       * (depending on its constraints).
       * @api
       */
      View.prototype.beginInteraction = function () {
          this.resolveConstraints(0);
          this.setHint(ViewHint.INTERACTING, 1);
      };
      /**
       * Notify the View that an interaction has ended. The view state will be resolved
       * to a stable one if needed (depending on its constraints).
       * @param {number=} opt_duration Animation duration in ms.
       * @param {number=} opt_resolutionDirection Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
       * @api
       */
      View.prototype.endInteraction = function (opt_duration, opt_resolutionDirection, opt_anchor) {
          var anchor = opt_anchor && fromUserCoordinate(opt_anchor, this.getProjection());
          this.endInteractionInternal(opt_duration, opt_resolutionDirection, anchor);
      };
      /**
       * Notify the View that an interaction has ended. The view state will be resolved
       * to a stable one if needed (depending on its constraints).
       * @param {number=} opt_duration Animation duration in ms.
       * @param {number=} opt_resolutionDirection Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
       */
      View.prototype.endInteractionInternal = function (opt_duration, opt_resolutionDirection, opt_anchor) {
          this.setHint(ViewHint.INTERACTING, -1);
          this.resolveConstraints(opt_duration, opt_resolutionDirection, opt_anchor);
      };
      /**
       * Get a valid position for the view center according to the current constraints.
       * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
       * @param {number=} opt_targetResolution Target resolution. If not supplied, the current one will be used.
       * This is useful to guess a valid center position at a different zoom level.
       * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
       */
      View.prototype.getConstrainedCenter = function (targetCenter, opt_targetResolution) {
          var size = this.getViewportSize_(this.getRotation());
          return this.constraints_.center(targetCenter, opt_targetResolution || this.getResolution(), size);
      };
      /**
       * Get a valid zoom level according to the current view constraints.
       * @param {number|undefined} targetZoom Target zoom.
       * @param {number=} [opt_direction=0] Indicate which resolution should be used
       * by a renderer if the view resolution does not match any resolution of the tile source.
       * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
       * will be used. If -1, the nearest higher resolution will be used.
       * @return {number|undefined} Valid zoom level.
       */
      View.prototype.getConstrainedZoom = function (targetZoom, opt_direction) {
          var targetRes = this.getResolutionForZoom(targetZoom);
          return this.getZoomForResolution(this.getConstrainedResolution(targetRes, opt_direction));
      };
      /**
       * Get a valid resolution according to the current view constraints.
       * @param {number|undefined} targetResolution Target resolution.
       * @param {number=} [opt_direction=0] Indicate which resolution should be used
       * by a renderer if the view resolution does not match any resolution of the tile source.
       * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
       * will be used. If -1, the nearest higher resolution will be used.
       * @return {number|undefined} Valid resolution.
       */
      View.prototype.getConstrainedResolution = function (targetResolution, opt_direction) {
          var direction = opt_direction || 0;
          var size = this.getViewportSize_(this.getRotation());
          return this.constraints_.resolution(targetResolution, direction, size);
      };
      return View;
  }(BaseObject));
  /**
   * @param {Function} callback Callback.
   * @param {*} returnValue Return value.
   */
  function animationCallback(callback, returnValue) {
      setTimeout(function () {
          callback(returnValue);
      }, 0);
  }
  /**
   * @param {ViewOptions} options View options.
   * @return {import("./centerconstraint.js").Type} The constraint.
   */
  function createCenterConstraint(options) {
      if (options.extent !== undefined) {
          var smooth = options.smoothExtentConstraint !== undefined
              ? options.smoothExtentConstraint
              : true;
          return createExtent(options.extent, options.constrainOnlyCenter, smooth);
      }
      var projection = createProjection(options.projection, 'EPSG:3857');
      if (options.multiWorld !== true && projection.isGlobal()) {
          var extent = projection.getExtent().slice();
          extent[0] = -Infinity;
          extent[2] = Infinity;
          return createExtent(extent, false, false);
      }
      return none;
  }
  /**
   * @param {ViewOptions} options View options.
   * @return {{constraint: import("./resolutionconstraint.js").Type, maxResolution: number,
   *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.
   */
  function createResolutionConstraint(options) {
      var resolutionConstraint;
      var maxResolution;
      var minResolution;
      // TODO: move these to be ol constants
      // see https://github.com/openlayers/openlayers/issues/2076
      var defaultMaxZoom = 28;
      var defaultZoomFactor = 2;
      var minZoom = options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;
      var maxZoom = options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;
      var zoomFactor = options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;
      var multiWorld = options.multiWorld !== undefined ? options.multiWorld : false;
      var smooth = options.smoothResolutionConstraint !== undefined
          ? options.smoothResolutionConstraint
          : true;
      var showFullExtent = options.showFullExtent !== undefined ? options.showFullExtent : false;
      var projection = createProjection(options.projection, 'EPSG:3857');
      var projExtent = projection.getExtent();
      var constrainOnlyCenter = options.constrainOnlyCenter;
      var extent = options.extent;
      if (!multiWorld && !extent && projection.isGlobal()) {
          constrainOnlyCenter = false;
          extent = projExtent;
      }
      if (options.resolutions !== undefined) {
          var resolutions = options.resolutions;
          maxResolution = resolutions[minZoom];
          minResolution =
              resolutions[maxZoom] !== undefined
                  ? resolutions[maxZoom]
                  : resolutions[resolutions.length - 1];
          if (options.constrainResolution) {
              resolutionConstraint = createSnapToResolutions(resolutions, smooth, !constrainOnlyCenter && extent, showFullExtent);
          }
          else {
              resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
          }
      }
      else {
          // calculate the default min and max resolution
          var size = !projExtent
              ? // use an extent that can fit the whole world if need be
                  (360 * METERS_PER_UNIT[Units.DEGREES]) / projection.getMetersPerUnit()
              : Math.max(getWidth(projExtent), getHeight(projExtent));
          var defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
          var defaultMinResolution = defaultMaxResolution /
              Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
          // user provided maxResolution takes precedence
          maxResolution = options.maxResolution;
          if (maxResolution !== undefined) {
              minZoom = 0;
          }
          else {
              maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
          }
          // user provided minResolution takes precedence
          minResolution = options.minResolution;
          if (minResolution === undefined) {
              if (options.maxZoom !== undefined) {
                  if (options.maxResolution !== undefined) {
                      minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
                  }
                  else {
                      minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
                  }
              }
              else {
                  minResolution = defaultMinResolution;
              }
          }
          // given discrete zoom levels, minResolution may be different than provided
          maxZoom =
              minZoom +
                  Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
          if (options.constrainResolution) {
              resolutionConstraint = createSnapToPower(zoomFactor, maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
          }
          else {
              resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
          }
      }
      return {
          constraint: resolutionConstraint,
          maxResolution: maxResolution,
          minResolution: minResolution,
          minZoom: minZoom,
          zoomFactor: zoomFactor,
      };
  }
  /**
   * @param {ViewOptions} options View options.
   * @return {import("./rotationconstraint.js").Type} Rotation constraint.
   */
  function createRotationConstraint(options) {
      var enableRotation = options.enableRotation !== undefined ? options.enableRotation : true;
      if (enableRotation) {
          var constrainRotation = options.constrainRotation;
          if (constrainRotation === undefined || constrainRotation === true) {
              return createSnapToZero();
          }
          else if (constrainRotation === false) {
              return none$1;
          }
          else if (typeof constrainRotation === 'number') {
              return createSnapToN(constrainRotation);
          }
          else {
              return none$1;
          }
      }
      else {
          return disable;
      }
  }
  /**
   * Determine if an animation involves no view change.
   * @param {Animation} animation The animation.
   * @return {boolean} The animation involves no view change.
   */
  function isNoopAnimation(animation) {
      if (animation.sourceCenter && animation.targetCenter) {
          if (!equals$2(animation.sourceCenter, animation.targetCenter)) {
              return false;
          }
      }
      if (animation.sourceResolution !== animation.targetResolution) {
          return false;
      }
      if (animation.sourceRotation !== animation.targetRotation) {
          return false;
      }
      return true;
  }

  /**
   * @module ol/size
   */
  /**
   * An array of numbers representing a size: `[width, height]`.
   * @typedef {Array<number>} Size
   * @api
   */
  /**
   * Returns a buffered size.
   * @param {Size} size Size.
   * @param {number} num The amount by which to buffer.
   * @param {Size=} opt_size Optional reusable size array.
   * @return {Size} The buffered size.
   */
  function buffer$1(size, num, opt_size) {
      if (opt_size === undefined) {
          opt_size = [0, 0];
      }
      opt_size[0] = size[0] + 2 * num;
      opt_size[1] = size[1] + 2 * num;
      return opt_size;
  }
  /**
   * Determines if a size has a positive area.
   * @param {Size} size The size to test.
   * @return {boolean} The size has a positive area.
   */
  function hasArea(size) {
      return size[0] > 0 && size[1] > 0;
  }
  /**
   * Returns a size scaled by a ratio. The result will be an array of integers.
   * @param {Size} size Size.
   * @param {number} ratio Ratio.
   * @param {Size=} opt_size Optional reusable size array.
   * @return {Size} The scaled size.
   */
  function scale$2(size, ratio, opt_size) {
      if (opt_size === undefined) {
          opt_size = [0, 0];
      }
      opt_size[0] = (size[0] * ratio + 0.5) | 0;
      opt_size[1] = (size[1] * ratio + 0.5) | 0;
      return opt_size;
  }
  /**
   * Returns an `Size` array for the passed in number (meaning: square) or
   * `Size` array.
   * (meaning: non-square),
   * @param {number|Size} size Width and height.
   * @param {Size=} opt_size Optional reusable size array.
   * @return {Size} Size.
   * @api
   */
  function toSize(size, opt_size) {
      if (Array.isArray(size)) {
          return size;
      }
      else {
          if (opt_size === undefined) {
              opt_size = [size, size];
          }
          else {
              opt_size[0] = size;
              opt_size[1] = size;
          }
          return opt_size;
      }
  }

  var __extends$o = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * State of the current frame. Only `pixelRatio`, `time` and `viewState` should
   * be used in applications.
   * @typedef {Object} FrameState
   * @property {number} pixelRatio The pixel ratio of the frame.
   * @property {number} time The time when rendering of the frame was requested.
   * @property {import("./View.js").State} viewState The state of the current view.
   * @property {boolean} animate
   * @property {import("./transform.js").Transform} coordinateToPixelTransform
   * @property {null|import("./extent.js").Extent} extent
   * @property {Array<DeclutterItems>} declutterItems
   * @property {number} index
   * @property {Array<import("./layer/Layer.js").State>} layerStatesArray
   * @property {number} layerIndex
   * @property {import("./transform.js").Transform} pixelToCoordinateTransform
   * @property {Array<PostRenderFunction>} postRenderFunctions
   * @property {import("./size.js").Size} size
   * @property {TileQueue} tileQueue
   * @property {!Object<string, Object<string, boolean>>} usedTiles
   * @property {Array<number>} viewHints
   * @property {!Object<string, Object<string, boolean>>} wantedTiles
   */
  /**
   * @typedef {Object} DeclutterItems
   * @property {Array<*>} items Declutter items of an executor.
   * @property {number} opacity Layer opacity.
   */
  /**
   * @typedef {function(PluggableMap, ?FrameState): any} PostRenderFunction
   */
  /**
   * @typedef {Object} AtPixelOptions
   * @property {undefined|function(import("./layer/Layer.js").default): boolean} [layerFilter] Layer filter
   * function. The filter function will receive one argument, the
   * {@link module:ol/layer/Layer layer-candidate} and it should return a boolean value.
   * Only layers which are visible and for which this function returns `true`
   * will be tested for features. By default, all visible layers will be tested.
   * @property {number} [hitTolerance=0] Hit-detection tolerance in pixels. Pixels
   * inside the radius around the given position will be checked for features.
   * @property {boolean} [checkWrapped=true] Check-Wrapped Will check for for wrapped geometries inside the range of
   *   +/- 1 world width. Works only if a projection is used that can be wrapped.
   */
  /**
   * @typedef {Object} MapOptionsInternal
   * @property {Collection<import("./control/Control.js").default>} [controls]
   * @property {Collection<import("./interaction/Interaction.js").default>} [interactions]
   * @property {HTMLElement|Document} keyboardEventTarget
   * @property {Collection<import("./Overlay.js").default>} overlays
   * @property {Object<string, *>} values
   */
  /**
   * Object literal with config options for the map.
   * @typedef {Object} MapOptions
   * @property {Collection<import("./control/Control.js").default>|Array<import("./control/Control.js").default>} [controls]
   * Controls initially added to the map. If not specified,
   * {@link module:ol/control~defaults} is used.
   * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between
   * physical pixels and device-independent pixels (dips) on the device.
   * @property {Collection<import("./interaction/Interaction.js").default>|Array<import("./interaction/Interaction.js").default>} [interactions]
   * Interactions that are initially added to the map. If not specified,
   * {@link module:ol/interaction~defaults} is used.
   * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to
   * listen to keyboard events on. This determines when the `KeyboardPan` and
   * `KeyboardZoom` interactions trigger. For example, if this option is set to
   * `document` the keyboard interactions will always trigger. If this option is
   * not specified, the element the library listens to keyboard events on is the
   * map target (i.e. the user-provided div for the map). If this is not
   * `document`, the target element needs to be focused for key events to be
   * emitted, requiring that the target element has a `tabindex` attribute.
   * @property {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>|LayerGroup} [layers]
   * Layers. If this is not defined, a map with no layers will be rendered. Note
   * that layers are rendered in the order supplied, so if you want, for example,
   * a vector layer to appear on top of a tile layer, it must come after the tile
   * layer.
   * @property {number} [maxTilesLoading=16] Maximum number tiles to load
   * simultaneously.
   * @property {number} [moveTolerance=1] The minimum distance in pixels the
   * cursor must move to be detected as a map move event instead of a click.
   * Increasing this value can make it easier to click on the map.
   * @property {Collection<import("./Overlay.js").default>|Array<import("./Overlay.js").default>} [overlays]
   * Overlays initially added to the map. By default, no overlays are added.
   * @property {HTMLElement|string} [target] The container for the map, either the
   * element itself or the `id` of the element. If not specified at construction
   * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be
   * rendered.
   * @property {View} [view] The map's view.  No layer sources will be
   * fetched unless this is specified at construction time or through
   * {@link module:ol/Map~Map#setView}.
   */
  /**
   * @fires import("./MapBrowserEvent.js").MapBrowserEvent
   * @fires import("./MapEvent.js").MapEvent
   * @fires import("./render/Event.js").default#precompose
   * @fires import("./render/Event.js").default#postcompose
   * @fires import("./render/Event.js").default#rendercomplete
   * @api
   */
  var PluggableMap = /** @class */ (function (_super) {
      __extends$o(PluggableMap, _super);
      /**
       * @param {MapOptions} options Map options.
       */
      function PluggableMap(options) {
          var _this = _super.call(this) || this;
          var optionsInternal = createOptionsInternal(options);
          /** @private */
          _this.boundHandleBrowserEvent_ = _this.handleBrowserEvent.bind(_this);
          /**
           * @type {number}
           * @private
           */
          _this.maxTilesLoading_ =
              options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;
          /**
           * @private
           * @type {number}
           */
          _this.pixelRatio_ =
              options.pixelRatio !== undefined
                  ? options.pixelRatio
                  : DEVICE_PIXEL_RATIO;
          /**
           * @private
           * @type {*}
           */
          _this.postRenderTimeoutHandle_;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.animationDelayKey_;
          /**
           * @private
           */
          _this.animationDelay_ = function () {
              this.animationDelayKey_ = undefined;
              this.renderFrame_(Date.now());
          }.bind(_this);
          /**
           * @private
           * @type {import("./transform.js").Transform}
           */
          _this.coordinateToPixelTransform_ = create();
          /**
           * @private
           * @type {import("./transform.js").Transform}
           */
          _this.pixelToCoordinateTransform_ = create();
          /**
           * @private
           * @type {number}
           */
          _this.frameIndex_ = 0;
          /**
           * @private
           * @type {?FrameState}
           */
          _this.frameState_ = null;
          /**
           * The extent at the previous 'moveend' event.
           * @private
           * @type {import("./extent.js").Extent}
           */
          _this.previousExtent_ = null;
          /**
           * @private
           * @type {?import("./events.js").EventsKey}
           */
          _this.viewPropertyListenerKey_ = null;
          /**
           * @private
           * @type {?import("./events.js").EventsKey}
           */
          _this.viewChangeListenerKey_ = null;
          /**
           * @private
           * @type {?Array<import("./events.js").EventsKey>}
           */
          _this.layerGroupPropertyListenerKeys_ = null;
          /**
           * @private
           * @type {!HTMLElement}
           */
          _this.viewport_ = document.createElement('div');
          _this.viewport_.className =
              'ol-viewport' + ('ontouchstart' in window ? ' ol-touch' : '');
          _this.viewport_.style.position = 'relative';
          _this.viewport_.style.overflow = 'hidden';
          _this.viewport_.style.width = '100%';
          _this.viewport_.style.height = '100%';
          /**
           * @private
           * @type {!HTMLElement}
           */
          _this.overlayContainer_ = document.createElement('div');
          _this.overlayContainer_.style.position = 'absolute';
          _this.overlayContainer_.style.zIndex = '0';
          _this.overlayContainer_.style.width = '100%';
          _this.overlayContainer_.style.height = '100%';
          _this.overlayContainer_.style.pointerEvents = 'none';
          _this.overlayContainer_.className = 'ol-overlaycontainer';
          _this.viewport_.appendChild(_this.overlayContainer_);
          /**
           * @private
           * @type {!HTMLElement}
           */
          _this.overlayContainerStopEvent_ = document.createElement('div');
          _this.overlayContainerStopEvent_.style.position = 'absolute';
          _this.overlayContainerStopEvent_.style.zIndex = '0';
          _this.overlayContainerStopEvent_.style.width = '100%';
          _this.overlayContainerStopEvent_.style.height = '100%';
          _this.overlayContainerStopEvent_.style.pointerEvents = 'none';
          _this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';
          _this.viewport_.appendChild(_this.overlayContainerStopEvent_);
          /**
           * @private
           * @type {MapBrowserEventHandler}
           */
          _this.mapBrowserEventHandler_ = null;
          /**
           * @private
           * @type {number}
           */
          _this.moveTolerance_ = options.moveTolerance;
          /**
           * @private
           * @type {HTMLElement|Document}
           */
          _this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
          /**
           * @private
           * @type {?Array<import("./events.js").EventsKey>}
           */
          _this.keyHandlerKeys_ = null;
          /**
           * @type {Collection<import("./control/Control.js").default>}
           * @protected
           */
          _this.controls = optionsInternal.controls || new Collection();
          /**
           * @type {Collection<import("./interaction/Interaction.js").default>}
           * @protected
           */
          _this.interactions = optionsInternal.interactions || new Collection();
          /**
           * @type {Collection<import("./Overlay.js").default>}
           * @private
           */
          _this.overlays_ = optionsInternal.overlays;
          /**
           * A lookup of overlays by id.
           * @private
           * @type {Object<string, import("./Overlay.js").default>}
           */
          _this.overlayIdIndex_ = {};
          /**
           * @type {import("./renderer/Map.js").default}
           * @private
           */
          _this.renderer_ = null;
          /**
           * @type {undefined|function(Event): void}
           * @private
           */
          _this.handleResize_;
          /**
           * @private
           * @type {!Array<PostRenderFunction>}
           */
          _this.postRenderFunctions_ = [];
          /**
           * @private
           * @type {TileQueue}
           */
          _this.tileQueue_ = new TileQueue(_this.getTilePriority.bind(_this), _this.handleTileChange_.bind(_this));
          _this.addEventListener(getChangeEventType(MapProperty.LAYERGROUP), _this.handleLayerGroupChanged_);
          _this.addEventListener(getChangeEventType(MapProperty.VIEW), _this.handleViewChanged_);
          _this.addEventListener(getChangeEventType(MapProperty.SIZE), _this.handleSizeChanged_);
          _this.addEventListener(getChangeEventType(MapProperty.TARGET), _this.handleTargetChanged_);
          // setProperties will trigger the rendering of the map if the map
          // is "defined" already.
          _this.setProperties(optionsInternal.values);
          _this.controls.forEach(
          /**
           * @param {import("./control/Control.js").default} control Control.
           * @this {PluggableMap}
           */
          function (control) {
              control.setMap(this);
          }.bind(_this));
          _this.controls.addEventListener(CollectionEventType.ADD, 
          /**
           * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
           */
          function (event) {
              event.element.setMap(this);
          }.bind(_this));
          _this.controls.addEventListener(CollectionEventType.REMOVE, 
          /**
           * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
           */
          function (event) {
              event.element.setMap(null);
          }.bind(_this));
          _this.interactions.forEach(
          /**
           * @param {import("./interaction/Interaction.js").default} interaction Interaction.
           * @this {PluggableMap}
           */
          function (interaction) {
              interaction.setMap(this);
          }.bind(_this));
          _this.interactions.addEventListener(CollectionEventType.ADD, 
          /**
           * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
           */
          function (event) {
              event.element.setMap(this);
          }.bind(_this));
          _this.interactions.addEventListener(CollectionEventType.REMOVE, 
          /**
           * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
           */
          function (event) {
              event.element.setMap(null);
          }.bind(_this));
          _this.overlays_.forEach(_this.addOverlayInternal_.bind(_this));
          _this.overlays_.addEventListener(CollectionEventType.ADD, 
          /**
           * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
           */
          function (event) {
              this.addOverlayInternal_(
              /** @type {import("./Overlay.js").default} */ (event.element));
          }.bind(_this));
          _this.overlays_.addEventListener(CollectionEventType.REMOVE, 
          /**
           * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
           */
          function (event) {
              var overlay = /** @type {import("./Overlay.js").default} */ (event.element);
              var id = overlay.getId();
              if (id !== undefined) {
                  delete this.overlayIdIndex_[id.toString()];
              }
              event.element.setMap(null);
          }.bind(_this));
          return _this;
      }
      /**
       * @abstract
       * @return {import("./renderer/Map.js").default} The map renderer
       */
      PluggableMap.prototype.createRenderer = function () {
          throw new Error('Use a map type that has a createRenderer method');
      };
      /**
       * Add the given control to the map.
       * @param {import("./control/Control.js").default} control Control.
       * @api
       */
      PluggableMap.prototype.addControl = function (control) {
          this.getControls().push(control);
      };
      /**
       * Add the given interaction to the map. If you want to add an interaction
       * at another point of the collection use `getInteraction()` and the methods
       * available on {@link module:ol/Collection~Collection}. This can be used to
       * stop the event propagation from the handleEvent function. The interactions
       * get to handle the events in the reverse order of this collection.
       * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
       * @api
       */
      PluggableMap.prototype.addInteraction = function (interaction) {
          this.getInteractions().push(interaction);
      };
      /**
       * Adds the given layer to the top of this map. If you want to add a layer
       * elsewhere in the stack, use `getLayers()` and the methods available on
       * {@link module:ol/Collection~Collection}.
       * @param {import("./layer/Base.js").default} layer Layer.
       * @api
       */
      PluggableMap.prototype.addLayer = function (layer) {
          var layers = this.getLayerGroup().getLayers();
          layers.push(layer);
      };
      /**
       * Add the given overlay to the map.
       * @param {import("./Overlay.js").default} overlay Overlay.
       * @api
       */
      PluggableMap.prototype.addOverlay = function (overlay) {
          this.getOverlays().push(overlay);
      };
      /**
       * This deals with map's overlay collection changes.
       * @param {import("./Overlay.js").default} overlay Overlay.
       * @private
       */
      PluggableMap.prototype.addOverlayInternal_ = function (overlay) {
          var id = overlay.getId();
          if (id !== undefined) {
              this.overlayIdIndex_[id.toString()] = overlay;
          }
          overlay.setMap(this);
      };
      /**
       *
       * Clean up.
       */
      PluggableMap.prototype.disposeInternal = function () {
          this.setTarget(null);
          _super.prototype.disposeInternal.call(this);
      };
      /**
       * Detect features that intersect a pixel on the viewport, and execute a
       * callback with each intersecting feature. Layers included in the detection can
       * be configured through the `layerFilter` option in `opt_options`.
       * @param {import("./pixel.js").Pixel} pixel Pixel.
       * @param {function(this: S, import("./Feature.js").FeatureLike,
       *     import("./layer/Layer.js").default): T} callback Feature callback. The callback will be
       *     called with two arguments. The first argument is one
       *     {@link module:ol/Feature feature} or
       *     {@link module:ol/render/Feature render feature} at the pixel, the second is
       *     the {@link module:ol/layer/Layer layer} of the feature and will be null for
       *     unmanaged layers. To stop detection, callback functions can return a
       *     truthy value.
       * @param {AtPixelOptions=} opt_options Optional options.
       * @return {T|undefined} Callback result, i.e. the return value of last
       * callback execution, or the first truthy callback return value.
       * @template S,T
       * @api
       */
      PluggableMap.prototype.forEachFeatureAtPixel = function (pixel, callback, opt_options) {
          if (!this.frameState_) {
              return;
          }
          var coordinate = this.getCoordinateFromPixelInternal(pixel);
          opt_options = opt_options !== undefined ? opt_options : {};
          var hitTolerance = opt_options.hitTolerance !== undefined
              ? opt_options.hitTolerance * this.frameState_.pixelRatio
              : 0;
          var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;
          var checkWrapped = opt_options.checkWrapped !== false;
          return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);
      };
      /**
       * Get all features that intersect a pixel on the viewport.
       * @param {import("./pixel.js").Pixel} pixel Pixel.
       * @param {AtPixelOptions=} opt_options Optional options.
       * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
       * an empty array if none were found.
       * @api
       */
      PluggableMap.prototype.getFeaturesAtPixel = function (pixel, opt_options) {
          var features = [];
          this.forEachFeatureAtPixel(pixel, function (feature) {
              features.push(feature);
          }, opt_options);
          return features;
      };
      /**
       * Detect layers that have a color value at a pixel on the viewport, and
       * execute a callback with each matching layer. Layers included in the
       * detection can be configured through `opt_layerFilter`.
       *
       * Note: this may give false positives unless the map layers have had different `className`
       * properties assigned to them.
       *
       * @param {import("./pixel.js").Pixel} pixel Pixel.
       * @param {function(this: S, import("./layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback
       *     Layer callback. This callback will receive two arguments: first is the
       *     {@link module:ol/layer/Layer layer}, second argument is an array representing
       *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types
       *     that do not currently support this argument. To stop detection, callback
       *     functions can return a truthy value.
       * @param {AtPixelOptions=} opt_options Configuration options.
       * @return {T|undefined} Callback result, i.e. the return value of last
       * callback execution, or the first truthy callback return value.
       * @template S,T
       * @api
       */
      PluggableMap.prototype.forEachLayerAtPixel = function (pixel, callback, opt_options) {
          if (!this.frameState_) {
              return;
          }
          var options = opt_options || {};
          var hitTolerance = options.hitTolerance !== undefined
              ? options.hitTolerance * this.frameState_.pixelRatio
              : 0;
          var layerFilter = options.layerFilter || TRUE;
          return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, hitTolerance, callback, layerFilter);
      };
      /**
       * Detect if features intersect a pixel on the viewport. Layers included in the
       * detection can be configured through `opt_layerFilter`.
       * @param {import("./pixel.js").Pixel} pixel Pixel.
       * @param {AtPixelOptions=} opt_options Optional options.
       * @return {boolean} Is there a feature at the given pixel?
       * @api
       */
      PluggableMap.prototype.hasFeatureAtPixel = function (pixel, opt_options) {
          if (!this.frameState_) {
              return false;
          }
          var coordinate = this.getCoordinateFromPixelInternal(pixel);
          opt_options = opt_options !== undefined ? opt_options : {};
          var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;
          var hitTolerance = opt_options.hitTolerance !== undefined
              ? opt_options.hitTolerance * this.frameState_.pixelRatio
              : 0;
          var checkWrapped = opt_options.checkWrapped !== false;
          return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);
      };
      /**
       * Returns the coordinate in user projection for a browser event.
       * @param {MouseEvent} event Event.
       * @return {import("./coordinate.js").Coordinate} Coordinate.
       * @api
       */
      PluggableMap.prototype.getEventCoordinate = function (event) {
          return this.getCoordinateFromPixel(this.getEventPixel(event));
      };
      /**
       * Returns the coordinate in view projection for a browser event.
       * @param {MouseEvent} event Event.
       * @return {import("./coordinate.js").Coordinate} Coordinate.
       */
      PluggableMap.prototype.getEventCoordinateInternal = function (event) {
          return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
      };
      /**
       * Returns the map pixel position for a browser event relative to the viewport.
       * @param {UIEvent} event Event.
       * @return {import("./pixel.js").Pixel} Pixel.
       * @api
       */
      PluggableMap.prototype.getEventPixel = function (event) {
          var viewportPosition = this.viewport_.getBoundingClientRect();
          var eventPosition = 
          //FIXME Are we really calling this with a TouchEvent anywhere?
          'changedTouches' in event
              ? /** @type {TouchEvent} */ (event).changedTouches[0]
              : /** @type {MouseEvent} */ (event);
          return [
              eventPosition.clientX - viewportPosition.left,
              eventPosition.clientY - viewportPosition.top,
          ];
      };
      /**
       * Get the target in which this map is rendered.
       * Note that this returns what is entered as an option or in setTarget:
       * if that was an element, it returns an element; if a string, it returns that.
       * @return {HTMLElement|string|undefined} The Element or id of the Element that the
       *     map is rendered in.
       * @observable
       * @api
       */
      PluggableMap.prototype.getTarget = function () {
          return /** @type {HTMLElement|string|undefined} */ (this.get(MapProperty.TARGET));
      };
      /**
       * Get the DOM element into which this map is rendered. In contrast to
       * `getTarget` this method always return an `Element`, or `null` if the
       * map has no target.
       * @return {HTMLElement} The element that the map is rendered in.
       * @api
       */
      PluggableMap.prototype.getTargetElement = function () {
          var target = this.getTarget();
          if (target !== undefined) {
              return typeof target === 'string'
                  ? document.getElementById(target)
                  : target;
          }
          else {
              return null;
          }
      };
      /**
       * Get the coordinate for a given pixel.  This returns a coordinate in the
       * user projection.
       * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
       * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
       * @api
       */
      PluggableMap.prototype.getCoordinateFromPixel = function (pixel) {
          return toUserCoordinate(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());
      };
      /**
       * Get the coordinate for a given pixel.  This returns a coordinate in the
       * map view projection.
       * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
       * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
       */
      PluggableMap.prototype.getCoordinateFromPixelInternal = function (pixel) {
          var frameState = this.frameState_;
          if (!frameState) {
              return null;
          }
          else {
              return apply(frameState.pixelToCoordinateTransform, pixel.slice());
          }
      };
      /**
       * Get the map controls. Modifying this collection changes the controls
       * associated with the map.
       * @return {Collection<import("./control/Control.js").default>} Controls.
       * @api
       */
      PluggableMap.prototype.getControls = function () {
          return this.controls;
      };
      /**
       * Get the map overlays. Modifying this collection changes the overlays
       * associated with the map.
       * @return {Collection<import("./Overlay.js").default>} Overlays.
       * @api
       */
      PluggableMap.prototype.getOverlays = function () {
          return this.overlays_;
      };
      /**
       * Get an overlay by its identifier (the value returned by overlay.getId()).
       * Note that the index treats string and numeric identifiers as the same. So
       * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
       * @param {string|number} id Overlay identifier.
       * @return {import("./Overlay.js").default} Overlay.
       * @api
       */
      PluggableMap.prototype.getOverlayById = function (id) {
          var overlay = this.overlayIdIndex_[id.toString()];
          return overlay !== undefined ? overlay : null;
      };
      /**
       * Get the map interactions. Modifying this collection changes the interactions
       * associated with the map.
       *
       * Interactions are used for e.g. pan, zoom and rotate.
       * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
       * @api
       */
      PluggableMap.prototype.getInteractions = function () {
          return this.interactions;
      };
      /**
       * Get the layergroup associated with this map.
       * @return {LayerGroup} A layer group containing the layers in this map.
       * @observable
       * @api
       */
      PluggableMap.prototype.getLayerGroup = function () {
          return /** @type {LayerGroup} */ (this.get(MapProperty.LAYERGROUP));
      };
      /**
       * Get the collection of layers associated with this map.
       * @return {!Collection<import("./layer/Base.js").default>} Layers.
       * @api
       */
      PluggableMap.prototype.getLayers = function () {
          var layers = this.getLayerGroup().getLayers();
          return layers;
      };
      /**
       * @return {boolean} Layers have sources that are still loading.
       */
      PluggableMap.prototype.getLoading = function () {
          var layerStatesArray = this.getLayerGroup().getLayerStatesArray();
          for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
              var layer = layerStatesArray[i].layer;
              var source = /** @type {import("./layer/Layer.js").default} */ (layer).getSource();
              if (source && source.loading) {
                  return true;
              }
          }
          return false;
      };
      /**
       * Get the pixel for a coordinate.  This takes a coordinate in the user
       * projection and returns the corresponding pixel.
       * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
       * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
       * @api
       */
      PluggableMap.prototype.getPixelFromCoordinate = function (coordinate) {
          var viewCoordinate = fromUserCoordinate(coordinate, this.getView().getProjection());
          return this.getPixelFromCoordinateInternal(viewCoordinate);
      };
      /**
       * Get the pixel for a coordinate.  This takes a coordinate in the map view
       * projection and returns the corresponding pixel.
       * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
       * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
       */
      PluggableMap.prototype.getPixelFromCoordinateInternal = function (coordinate) {
          var frameState = this.frameState_;
          if (!frameState) {
              return null;
          }
          else {
              return apply(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
          }
      };
      /**
       * Get the map renderer.
       * @return {import("./renderer/Map.js").default} Renderer
       */
      PluggableMap.prototype.getRenderer = function () {
          return this.renderer_;
      };
      /**
       * Get the size of this map.
       * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
       * @observable
       * @api
       */
      PluggableMap.prototype.getSize = function () {
          return /** @type {import("./size.js").Size|undefined} */ (this.get(MapProperty.SIZE));
      };
      /**
       * Get the view associated with this map. A view manages properties such as
       * center and resolution.
       * @return {View} The view that controls this map.
       * @observable
       * @api
       */
      PluggableMap.prototype.getView = function () {
          return /** @type {View} */ (this.get(MapProperty.VIEW));
      };
      /**
       * Get the element that serves as the map viewport.
       * @return {HTMLElement} Viewport.
       * @api
       */
      PluggableMap.prototype.getViewport = function () {
          return this.viewport_;
      };
      /**
       * Get the element that serves as the container for overlays.  Elements added to
       * this container will let mousedown and touchstart events through to the map,
       * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
       * events.
       * @return {!HTMLElement} The map's overlay container.
       */
      PluggableMap.prototype.getOverlayContainer = function () {
          return this.overlayContainer_;
      };
      /**
       * Get the element that serves as a container for overlays that don't allow
       * event propagation. Elements added to this container won't let mousedown and
       * touchstart events through to the map, so clicks and gestures on an overlay
       * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
       * @return {!HTMLElement} The map's overlay container that stops events.
       */
      PluggableMap.prototype.getOverlayContainerStopEvent = function () {
          return this.overlayContainerStopEvent_;
      };
      /**
       * @param {import("./Tile.js").default} tile Tile.
       * @param {string} tileSourceKey Tile source key.
       * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
       * @param {number} tileResolution Tile resolution.
       * @return {number} Tile priority.
       */
      PluggableMap.prototype.getTilePriority = function (tile, tileSourceKey, tileCenter, tileResolution) {
          return getTilePriority(this.frameState_, tile, tileSourceKey, tileCenter, tileResolution);
      };
      /**
       * @param {UIEvent} browserEvent Browser event.
       * @param {string=} opt_type Type.
       */
      PluggableMap.prototype.handleBrowserEvent = function (browserEvent, opt_type) {
          var type = opt_type || browserEvent.type;
          var mapBrowserEvent = new MapBrowserEvent(type, this, browserEvent);
          this.handleMapBrowserEvent(mapBrowserEvent);
      };
      /**
       * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
       */
      PluggableMap.prototype.handleMapBrowserEvent = function (mapBrowserEvent) {
          if (!this.frameState_) {
              // With no view defined, we cannot translate pixels into geographical
              // coordinates so interactions cannot be used.
              return;
          }
          var originalEvent = /** @type {PointerEvent} */ (mapBrowserEvent.originalEvent);
          var eventType = originalEvent.type;
          if (eventType === PointerEventType.POINTERDOWN ||
              eventType === EventType.WHEEL ||
              eventType === EventType.KEYDOWN) {
              var rootNode = this.viewport_.getRootNode
                  ? this.viewport_.getRootNode()
                  : document;
              var target = rootNode === document
                  ? /** @type {Node} */ (originalEvent.target)
                  : /** @type {ShadowRoot} */ (rootNode).elementFromPoint(originalEvent.clientX, originalEvent.clientY);
              if (
              // Abort if the target is a child of the container for elements whose events are not meant
              // to be handled by map interactions.
              this.overlayContainerStopEvent_.contains(target) ||
                  // Abort if the event target is a child of the container that is no longer in the page.
                  // It's possible for the target to no longer be in the page if it has been removed in an
                  // event listener, this might happen in a Control that recreates it's content based on
                  // user interaction either manually or via a render in something like https://reactjs.org/
                  !(rootNode === document ? document.documentElement : rootNode).contains(target)) {
                  return;
              }
          }
          mapBrowserEvent.frameState = this.frameState_;
          var interactionsArray = this.getInteractions().getArray();
          if (this.dispatchEvent(mapBrowserEvent) !== false) {
              for (var i = interactionsArray.length - 1; i >= 0; i--) {
                  var interaction = interactionsArray[i];
                  if (!interaction.getActive()) {
                      continue;
                  }
                  var cont = interaction.handleEvent(mapBrowserEvent);
                  if (!cont) {
                      break;
                  }
              }
          }
      };
      /**
       * @protected
       */
      PluggableMap.prototype.handlePostRender = function () {
          var frameState = this.frameState_;
          // Manage the tile queue
          // Image loads are expensive and a limited resource, so try to use them
          // efficiently:
          // * When the view is static we allow a large number of parallel tile loads
          //   to complete the frame as quickly as possible.
          // * When animating or interacting, image loads can cause janks, so we reduce
          //   the maximum number of loads per frame and limit the number of parallel
          //   tile loads to remain reactive to view changes and to reduce the chance of
          //   loading tiles that will quickly disappear from view.
          var tileQueue = this.tileQueue_;
          if (!tileQueue.isEmpty()) {
              var maxTotalLoading = this.maxTilesLoading_;
              var maxNewLoads = maxTotalLoading;
              if (frameState) {
                  var hints = frameState.viewHints;
                  if (hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING]) {
                      var lowOnFrameBudget = !IMAGE_DECODE && Date.now() - frameState.time > 8;
                      maxTotalLoading = lowOnFrameBudget ? 0 : 8;
                      maxNewLoads = lowOnFrameBudget ? 0 : 2;
                  }
              }
              if (tileQueue.getTilesLoading() < maxTotalLoading) {
                  tileQueue.reprioritize(); // FIXME only call if view has changed
                  tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
              }
          }
          if (frameState &&
              this.hasListener(EventType$1.RENDERCOMPLETE) &&
              !frameState.animate &&
              !this.tileQueue_.getTilesLoading() &&
              !this.getLoading()) {
              this.renderer_.dispatchRenderEvent(EventType$1.RENDERCOMPLETE, frameState);
          }
          var postRenderFunctions = this.postRenderFunctions_;
          for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
              postRenderFunctions[i](this, frameState);
          }
          postRenderFunctions.length = 0;
      };
      /**
       * @private
       */
      PluggableMap.prototype.handleSizeChanged_ = function () {
          if (this.getView() && !this.getView().getAnimating()) {
              this.getView().resolveConstraints(0);
          }
          this.render();
      };
      /**
       * @private
       */
      PluggableMap.prototype.handleTargetChanged_ = function () {
          // target may be undefined, null, a string or an Element.
          // If it's a string we convert it to an Element before proceeding.
          // If it's not now an Element we remove the viewport from the DOM.
          // If it's an Element we append the viewport element to it.
          var targetElement;
          if (this.getTarget()) {
              targetElement = this.getTargetElement();
          }
          if (this.mapBrowserEventHandler_) {
              for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {
                  unlistenByKey(this.keyHandlerKeys_[i]);
              }
              this.keyHandlerKeys_ = null;
              this.viewport_.removeEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_);
              this.viewport_.removeEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_);
              if (this.handleResize_ !== undefined) {
                  removeEventListener(EventType.RESIZE, this.handleResize_, false);
                  this.handleResize_ = undefined;
              }
              this.mapBrowserEventHandler_.dispose();
              this.mapBrowserEventHandler_ = null;
              removeNode(this.viewport_);
          }
          if (!targetElement) {
              if (this.renderer_) {
                  clearTimeout(this.postRenderTimeoutHandle_);
                  this.postRenderFunctions_.length = 0;
                  this.renderer_.dispose();
                  this.renderer_ = null;
              }
              if (this.animationDelayKey_) {
                  cancelAnimationFrame(this.animationDelayKey_);
                  this.animationDelayKey_ = undefined;
              }
          }
          else {
              targetElement.appendChild(this.viewport_);
              if (!this.renderer_) {
                  this.renderer_ = this.createRenderer();
              }
              this.mapBrowserEventHandler_ = new MapBrowserEventHandler(this, this.moveTolerance_);
              for (var key in MapBrowserEventType) {
                  this.mapBrowserEventHandler_.addEventListener(MapBrowserEventType[key], this.handleMapBrowserEvent.bind(this));
              }
              this.viewport_.addEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_, false);
              this.viewport_.addEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_, PASSIVE_EVENT_LISTENERS ? { passive: false } : false);
              var keyboardEventTarget = !this.keyboardEventTarget_
                  ? targetElement
                  : this.keyboardEventTarget_;
              this.keyHandlerKeys_ = [
                  listen(keyboardEventTarget, EventType.KEYDOWN, this.handleBrowserEvent, this),
                  listen(keyboardEventTarget, EventType.KEYPRESS, this.handleBrowserEvent, this),
              ];
              if (!this.handleResize_) {
                  this.handleResize_ = this.updateSize.bind(this);
                  window.addEventListener(EventType.RESIZE, this.handleResize_, false);
              }
          }
          this.updateSize();
          // updateSize calls setSize, so no need to call this.render
          // ourselves here.
      };
      /**
       * @private
       */
      PluggableMap.prototype.handleTileChange_ = function () {
          this.render();
      };
      /**
       * @private
       */
      PluggableMap.prototype.handleViewPropertyChanged_ = function () {
          this.render();
      };
      /**
       * @private
       */
      PluggableMap.prototype.handleViewChanged_ = function () {
          if (this.viewPropertyListenerKey_) {
              unlistenByKey(this.viewPropertyListenerKey_);
              this.viewPropertyListenerKey_ = null;
          }
          if (this.viewChangeListenerKey_) {
              unlistenByKey(this.viewChangeListenerKey_);
              this.viewChangeListenerKey_ = null;
          }
          var view = this.getView();
          if (view) {
              this.updateViewportSize_();
              this.viewPropertyListenerKey_ = listen(view, ObjectEventType.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);
              this.viewChangeListenerKey_ = listen(view, EventType.CHANGE, this.handleViewPropertyChanged_, this);
              view.resolveConstraints(0);
          }
          this.render();
      };
      /**
       * @private
       */
      PluggableMap.prototype.handleLayerGroupChanged_ = function () {
          if (this.layerGroupPropertyListenerKeys_) {
              this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);
              this.layerGroupPropertyListenerKeys_ = null;
          }
          var layerGroup = this.getLayerGroup();
          if (layerGroup) {
              this.layerGroupPropertyListenerKeys_ = [
                  listen(layerGroup, ObjectEventType.PROPERTYCHANGE, this.render, this),
                  listen(layerGroup, EventType.CHANGE, this.render, this),
              ];
          }
          this.render();
      };
      /**
       * @return {boolean} Is rendered.
       */
      PluggableMap.prototype.isRendered = function () {
          return !!this.frameState_;
      };
      /**
       * Requests an immediate render in a synchronous manner.
       * @api
       */
      PluggableMap.prototype.renderSync = function () {
          if (this.animationDelayKey_) {
              cancelAnimationFrame(this.animationDelayKey_);
          }
          this.animationDelay_();
      };
      /**
       * Redraws all text after new fonts have loaded
       */
      PluggableMap.prototype.redrawText = function () {
          var layerStates = this.getLayerGroup().getLayerStatesArray();
          for (var i = 0, ii = layerStates.length; i < ii; ++i) {
              var layer = layerStates[i].layer;
              if (layer.hasRenderer()) {
                  layer.getRenderer().handleFontsChanged();
              }
          }
      };
      /**
       * Request a map rendering (at the next animation frame).
       * @api
       */
      PluggableMap.prototype.render = function () {
          if (this.renderer_ && this.animationDelayKey_ === undefined) {
              this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
          }
      };
      /**
       * Remove the given control from the map.
       * @param {import("./control/Control.js").default} control Control.
       * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
       *     if the control was not found).
       * @api
       */
      PluggableMap.prototype.removeControl = function (control) {
          return this.getControls().remove(control);
      };
      /**
       * Remove the given interaction from the map.
       * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
       * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
       *     undefined if the interaction was not found).
       * @api
       */
      PluggableMap.prototype.removeInteraction = function (interaction) {
          return this.getInteractions().remove(interaction);
      };
      /**
       * Removes the given layer from the map.
       * @param {import("./layer/Base.js").default} layer Layer.
       * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
       *     layer was not found).
       * @api
       */
      PluggableMap.prototype.removeLayer = function (layer) {
          var layers = this.getLayerGroup().getLayers();
          return layers.remove(layer);
      };
      /**
       * Remove the given overlay from the map.
       * @param {import("./Overlay.js").default} overlay Overlay.
       * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
       *     if the overlay was not found).
       * @api
       */
      PluggableMap.prototype.removeOverlay = function (overlay) {
          return this.getOverlays().remove(overlay);
      };
      /**
       * @param {number} time Time.
       * @private
       */
      PluggableMap.prototype.renderFrame_ = function (time) {
          var size = this.getSize();
          var view = this.getView();
          var previousFrameState = this.frameState_;
          /** @type {?FrameState} */
          var frameState = null;
          if (size !== undefined && hasArea(size) && view && view.isDef()) {
              var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);
              var viewState = view.getState();
              frameState = {
                  animate: false,
                  coordinateToPixelTransform: this.coordinateToPixelTransform_,
                  declutterItems: previousFrameState
                      ? previousFrameState.declutterItems
                      : [],
                  extent: getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, size),
                  index: this.frameIndex_++,
                  layerIndex: 0,
                  layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
                  pixelRatio: this.pixelRatio_,
                  pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
                  postRenderFunctions: [],
                  size: size,
                  tileQueue: this.tileQueue_,
                  time: time,
                  usedTiles: {},
                  viewState: viewState,
                  viewHints: viewHints,
                  wantedTiles: {},
              };
          }
          this.frameState_ = frameState;
          this.renderer_.renderFrame(frameState);
          if (frameState) {
              if (frameState.animate) {
                  this.render();
              }
              Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);
              if (previousFrameState) {
                  var moveStart = !this.previousExtent_ ||
                      (!isEmpty(this.previousExtent_) &&
                          !equals$1(frameState.extent, this.previousExtent_));
                  if (moveStart) {
                      this.dispatchEvent(new MapEvent(MapEventType.MOVESTART, this, previousFrameState));
                      this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);
                  }
              }
              var idle = this.previousExtent_ &&
                  !frameState.viewHints[ViewHint.ANIMATING] &&
                  !frameState.viewHints[ViewHint.INTERACTING] &&
                  !equals$1(frameState.extent, this.previousExtent_);
              if (idle) {
                  this.dispatchEvent(new MapEvent(MapEventType.MOVEEND, this, frameState));
                  clone(frameState.extent, this.previousExtent_);
              }
          }
          this.dispatchEvent(new MapEvent(MapEventType.POSTRENDER, this, frameState));
          this.postRenderTimeoutHandle_ = setTimeout(this.handlePostRender.bind(this), 0);
      };
      /**
       * Sets the layergroup of this map.
       * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
       * @observable
       * @api
       */
      PluggableMap.prototype.setLayerGroup = function (layerGroup) {
          this.set(MapProperty.LAYERGROUP, layerGroup);
      };
      /**
       * Set the size of this map.
       * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
       * @observable
       * @api
       */
      PluggableMap.prototype.setSize = function (size) {
          this.set(MapProperty.SIZE, size);
      };
      /**
       * Set the target element to render this map into.
       * @param {HTMLElement|string|undefined} target The Element or id of the Element
       *     that the map is rendered in.
       * @observable
       * @api
       */
      PluggableMap.prototype.setTarget = function (target) {
          this.set(MapProperty.TARGET, target);
      };
      /**
       * Set the view for this map.
       * @param {View} view The view that controls this map.
       * @observable
       * @api
       */
      PluggableMap.prototype.setView = function (view) {
          this.set(MapProperty.VIEW, view);
      };
      /**
       * Force a recalculation of the map viewport size.  This should be called when
       * third-party code changes the size of the map viewport.
       * @api
       */
      PluggableMap.prototype.updateSize = function () {
          var targetElement = this.getTargetElement();
          if (!targetElement) {
              this.setSize(undefined);
          }
          else {
              var computedStyle = getComputedStyle(targetElement);
              this.setSize([
                  targetElement.offsetWidth -
                      parseFloat(computedStyle['borderLeftWidth']) -
                      parseFloat(computedStyle['paddingLeft']) -
                      parseFloat(computedStyle['paddingRight']) -
                      parseFloat(computedStyle['borderRightWidth']),
                  targetElement.offsetHeight -
                      parseFloat(computedStyle['borderTopWidth']) -
                      parseFloat(computedStyle['paddingTop']) -
                      parseFloat(computedStyle['paddingBottom']) -
                      parseFloat(computedStyle['borderBottomWidth']),
              ]);
          }
          this.updateViewportSize_();
      };
      /**
       * Recomputes the viewport size and save it on the view object (if any)
       * @private
       */
      PluggableMap.prototype.updateViewportSize_ = function () {
          var view = this.getView();
          if (view) {
              var size = undefined;
              var computedStyle = getComputedStyle(this.viewport_);
              if (computedStyle.width && computedStyle.height) {
                  size = [
                      parseInt(computedStyle.width, 10),
                      parseInt(computedStyle.height, 10),
                  ];
              }
              view.setViewportSize(size);
          }
      };
      return PluggableMap;
  }(BaseObject));
  /**
   * @param {MapOptions} options Map options.
   * @return {MapOptionsInternal} Internal map options.
   */
  function createOptionsInternal(options) {
      /**
       * @type {HTMLElement|Document}
       */
      var keyboardEventTarget = null;
      if (options.keyboardEventTarget !== undefined) {
          keyboardEventTarget =
              typeof options.keyboardEventTarget === 'string'
                  ? document.getElementById(options.keyboardEventTarget)
                  : options.keyboardEventTarget;
      }
      /**
       * @type {Object<string, *>}
       */
      var values = {};
      var layerGroup = options.layers &&
          typeof ( /** @type {?} */(options.layers).getLayers) === 'function'
          ? /** @type {LayerGroup} */ (options.layers)
          : new LayerGroup({ layers: /** @type {Collection} */ (options.layers) });
      values[MapProperty.LAYERGROUP] = layerGroup;
      values[MapProperty.TARGET] = options.target;
      values[MapProperty.VIEW] =
          options.view !== undefined ? options.view : new View();
      var controls;
      if (options.controls !== undefined) {
          if (Array.isArray(options.controls)) {
              controls = new Collection(options.controls.slice());
          }
          else {
              assert(typeof ( /** @type {?} */(options.controls).getArray) === 'function', 47); // Expected `controls` to be an array or an `import("./Collection.js").Collection`
              controls = /** @type {Collection} */ (options.controls);
          }
      }
      var interactions;
      if (options.interactions !== undefined) {
          if (Array.isArray(options.interactions)) {
              interactions = new Collection(options.interactions.slice());
          }
          else {
              assert(typeof ( /** @type {?} */(options.interactions).getArray) ===
                  'function', 48); // Expected `interactions` to be an array or an `import("./Collection.js").Collection`
              interactions = /** @type {Collection} */ (options.interactions);
          }
      }
      var overlays;
      if (options.overlays !== undefined) {
          if (Array.isArray(options.overlays)) {
              overlays = new Collection(options.overlays.slice());
          }
          else {
              assert(typeof ( /** @type {?} */(options.overlays).getArray) === 'function', 49); // Expected `overlays` to be an array or an `import("./Collection.js").Collection`
              overlays = options.overlays;
          }
      }
      else {
          overlays = new Collection();
      }
      return {
          controls: controls,
          interactions: interactions,
          keyboardEventTarget: keyboardEventTarget,
          overlays: overlays,
          values: values,
      };
  }

  var __extends$p = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {HTMLElement} [element] The element is the control's
   * container element. This only needs to be specified if you're developing
   * a custom control.
   * @property {function(import("../MapEvent.js").default):void} [render] Function called when
   * the control should be re-rendered. This is called in a `requestAnimationFrame`
   * callback.
   * @property {HTMLElement|string} [target] Specify a target if you want
   * the control to be rendered outside of the map's viewport.
   */
  /**
   * @classdesc
   * A control is a visible widget with a DOM element in a fixed position on the
   * screen. They can involve user input (buttons), or be informational only;
   * the position is determined using CSS. By default these are placed in the
   * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
   * any outside DOM element.
   *
   * This is the base class for controls. You can use it for simple custom
   * controls by creating the element with listeners, creating an instance:
   * ```js
   * var myControl = new Control({element: myElement});
   * ```
   * and then adding this to the map.
   *
   * The main advantage of having this as a control rather than a simple separate
   * DOM element is that preventing propagation is handled for you. Controls
   * will also be objects in a {@link module:ol/Collection~Collection}, so you can use their methods.
   *
   * You can also extend this base for your own control class. See
   * examples/custom-controls for an example of how to do this.
   *
   * @api
   */
  var Control = /** @class */ (function (_super) {
      __extends$p(Control, _super);
      /**
       * @param {Options} options Control options.
       */
      function Control(options) {
          var _this = _super.call(this) || this;
          var element = options.element;
          if (element && !options.target && !element.style.pointerEvents) {
              element.style.pointerEvents = 'auto';
          }
          /**
           * @protected
           * @type {HTMLElement}
           */
          _this.element = element ? element : null;
          /**
           * @private
           * @type {HTMLElement}
           */
          _this.target_ = null;
          /**
           * @private
           * @type {import("../PluggableMap.js").default}
           */
          _this.map_ = null;
          /**
           * @protected
           * @type {!Array<import("../events.js").EventsKey>}
           */
          _this.listenerKeys = [];
          if (options.render) {
              _this.render = options.render;
          }
          if (options.target) {
              _this.setTarget(options.target);
          }
          return _this;
      }
      /**
       * Clean up.
       */
      Control.prototype.disposeInternal = function () {
          removeNode(this.element);
          _super.prototype.disposeInternal.call(this);
      };
      /**
       * Get the map associated with this control.
       * @return {import("../PluggableMap.js").default} Map.
       * @api
       */
      Control.prototype.getMap = function () {
          return this.map_;
      };
      /**
       * Remove the control from its current map and attach it to the new map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../PluggableMap.js").default} map Map.
       * @api
       */
      Control.prototype.setMap = function (map) {
          if (this.map_) {
              removeNode(this.element);
          }
          for (var i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
              unlistenByKey(this.listenerKeys[i]);
          }
          this.listenerKeys.length = 0;
          this.map_ = map;
          if (this.map_) {
              var target = this.target_
                  ? this.target_
                  : map.getOverlayContainerStopEvent();
              target.appendChild(this.element);
              if (this.render !== VOID) {
                  this.listenerKeys.push(listen(map, MapEventType.POSTRENDER, this.render, this));
              }
              map.render();
          }
      };
      /**
       * Renders the control.
       * @param {import("../MapEvent.js").default} mapEvent Map event.
       * @api
       */
      Control.prototype.render = function (mapEvent) { };
      /**
       * This function is used to set a target element for the control. It has no
       * effect if it is called after the control has been added to the map (i.e.
       * after `setMap` is called on the control). If no `target` is set in the
       * options passed to the control constructor and if `setTarget` is not called
       * then the control is added to the map's overlay container.
       * @param {HTMLElement|string} target Target.
       * @api
       */
      Control.prototype.setTarget = function (target) {
          this.target_ =
              typeof target === 'string' ? document.getElementById(target) : target;
      };
      return Control;
  }(BaseObject));

  var __extends$q = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-attribution'] CSS class name.
   * @property {HTMLElement|string} [target] Specify a target if you
   * want the control to be rendered outside of the map's
   * viewport.
   * @property {boolean} [collapsible] Specify if attributions can
   * be collapsed. If not specified, sources control this behavior with their
   * `attributionsCollapsible` setting.
   * @property {boolean} [collapsed=true] Specify if attributions should
   * be collapsed at startup.
   * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.
   * @property {string} [label='i'] Text label to use for the
   * collapsed attributions button.
   * Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {string|HTMLElement} [collapseLabel='»'] Text label to use
   * for the expanded attributions button.
   * Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {function(import("../MapEvent.js").default):void} [render] Function called when
   * the control should be re-rendered. This is called in a `requestAnimationFrame`
   * callback.
   */
  /**
   * @classdesc
   * Control to show all the attributions associated with the layer sources
   * in the map. This control is one of the default controls included in maps.
   * By default it will show in the bottom right portion of the map, but this can
   * be changed by using a css selector for `.ol-attribution`.
   *
   * @api
   */
  var Attribution = /** @class */ (function (_super) {
      __extends$q(Attribution, _super);
      /**
       * @param {Options=} opt_options Attribution options.
       */
      function Attribution(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, {
              element: document.createElement('div'),
              render: options.render,
              target: options.target,
          }) || this;
          /**
           * @private
           * @type {HTMLElement}
           */
          _this.ulElement_ = document.createElement('ul');
          /**
           * @private
           * @type {boolean}
           */
          _this.collapsed_ =
              options.collapsed !== undefined ? options.collapsed : true;
          /**
           * @private
           * @type {boolean}
           */
          _this.overrideCollapsible_ = options.collapsible !== undefined;
          /**
           * @private
           * @type {boolean}
           */
          _this.collapsible_ =
              options.collapsible !== undefined ? options.collapsible : true;
          if (!_this.collapsible_) {
              _this.collapsed_ = false;
          }
          var className = options.className !== undefined ? options.className : 'ol-attribution';
          var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';
          var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\u00BB';
          if (typeof collapseLabel === 'string') {
              /**
               * @private
               * @type {HTMLElement}
               */
              _this.collapseLabel_ = document.createElement('span');
              _this.collapseLabel_.textContent = collapseLabel;
          }
          else {
              _this.collapseLabel_ = collapseLabel;
          }
          var label = options.label !== undefined ? options.label : 'i';
          if (typeof label === 'string') {
              /**
               * @private
               * @type {HTMLElement}
               */
              _this.label_ = document.createElement('span');
              _this.label_.textContent = label;
          }
          else {
              _this.label_ = label;
          }
          var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;
          var button = document.createElement('button');
          button.setAttribute('type', 'button');
          button.title = tipLabel;
          button.appendChild(activeLabel);
          button.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this), false);
          var cssClasses = className +
              ' ' +
              CLASS_UNSELECTABLE +
              ' ' +
              CLASS_CONTROL +
              (_this.collapsed_ && _this.collapsible_ ? ' ' + CLASS_COLLAPSED : '') +
              (_this.collapsible_ ? '' : ' ol-uncollapsible');
          var element = _this.element;
          element.className = cssClasses;
          element.appendChild(_this.ulElement_);
          element.appendChild(button);
          /**
           * A list of currently rendered resolutions.
           * @type {Array<string>}
           * @private
           */
          _this.renderedAttributions_ = [];
          /**
           * @private
           * @type {boolean}
           */
          _this.renderedVisible_ = true;
          return _this;
      }
      /**
       * Collect a list of visible attributions and set the collapsible state.
       * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
       * @return {Array<string>} Attributions.
       * @private
       */
      Attribution.prototype.collectSourceAttributions_ = function (frameState) {
          /**
           * Used to determine if an attribution already exists.
           * @type {!Object<string, boolean>}
           */
          var lookup = {};
          /**
           * A list of visible attributions.
           * @type {Array<string>}
           */
          var visibleAttributions = [];
          var layerStatesArray = frameState.layerStatesArray;
          for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
              var layerState = layerStatesArray[i];
              if (!inView(layerState, frameState.viewState)) {
                  continue;
              }
              var source = /** @type {import("../layer/Layer.js").default} */ (layerState.layer).getSource();
              if (!source) {
                  continue;
              }
              var attributionGetter = source.getAttributions();
              if (!attributionGetter) {
                  continue;
              }
              var attributions = attributionGetter(frameState);
              if (!attributions) {
                  continue;
              }
              if (!this.overrideCollapsible_ &&
                  source.getAttributionsCollapsible() === false) {
                  this.setCollapsible(false);
              }
              if (Array.isArray(attributions)) {
                  for (var j = 0, jj = attributions.length; j < jj; ++j) {
                      if (!(attributions[j] in lookup)) {
                          visibleAttributions.push(attributions[j]);
                          lookup[attributions[j]] = true;
                      }
                  }
              }
              else {
                  if (!(attributions in lookup)) {
                      visibleAttributions.push(attributions);
                      lookup[attributions] = true;
                  }
              }
          }
          return visibleAttributions;
      };
      /**
       * @private
       * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
       */
      Attribution.prototype.updateElement_ = function (frameState) {
          if (!frameState) {
              if (this.renderedVisible_) {
                  this.element.style.display = 'none';
                  this.renderedVisible_ = false;
              }
              return;
          }
          var attributions = this.collectSourceAttributions_(frameState);
          var visible = attributions.length > 0;
          if (this.renderedVisible_ != visible) {
              this.element.style.display = visible ? '' : 'none';
              this.renderedVisible_ = visible;
          }
          if (equals(attributions, this.renderedAttributions_)) {
              return;
          }
          removeChildren(this.ulElement_);
          // append the attributions
          for (var i = 0, ii = attributions.length; i < ii; ++i) {
              var element = document.createElement('li');
              element.innerHTML = attributions[i];
              this.ulElement_.appendChild(element);
          }
          this.renderedAttributions_ = attributions;
      };
      /**
       * @param {MouseEvent} event The event to handle
       * @private
       */
      Attribution.prototype.handleClick_ = function (event) {
          event.preventDefault();
          this.handleToggle_();
      };
      /**
       * @private
       */
      Attribution.prototype.handleToggle_ = function () {
          this.element.classList.toggle(CLASS_COLLAPSED);
          if (this.collapsed_) {
              replaceNode(this.collapseLabel_, this.label_);
          }
          else {
              replaceNode(this.label_, this.collapseLabel_);
          }
          this.collapsed_ = !this.collapsed_;
      };
      /**
       * Return `true` if the attribution is collapsible, `false` otherwise.
       * @return {boolean} True if the widget is collapsible.
       * @api
       */
      Attribution.prototype.getCollapsible = function () {
          return this.collapsible_;
      };
      /**
       * Set whether the attribution should be collapsible.
       * @param {boolean} collapsible True if the widget is collapsible.
       * @api
       */
      Attribution.prototype.setCollapsible = function (collapsible) {
          if (this.collapsible_ === collapsible) {
              return;
          }
          this.collapsible_ = collapsible;
          this.element.classList.toggle('ol-uncollapsible');
          if (!collapsible && this.collapsed_) {
              this.handleToggle_();
          }
      };
      /**
       * Collapse or expand the attribution according to the passed parameter. Will
       * not do anything if the attribution isn't collapsible or if the current
       * collapsed state is already the one requested.
       * @param {boolean} collapsed True if the widget is collapsed.
       * @api
       */
      Attribution.prototype.setCollapsed = function (collapsed) {
          if (!this.collapsible_ || this.collapsed_ === collapsed) {
              return;
          }
          this.handleToggle_();
      };
      /**
       * Return `true` when the attribution is currently collapsed or `false`
       * otherwise.
       * @return {boolean} True if the widget is collapsed.
       * @api
       */
      Attribution.prototype.getCollapsed = function () {
          return this.collapsed_;
      };
      /**
       * Update the attribution element.
       * @param {import("../MapEvent.js").default} mapEvent Map event.
       * @override
       */
      Attribution.prototype.render = function (mapEvent) {
          this.updateElement_(mapEvent.frameState);
      };
      return Attribution;
  }(Control));

  var __extends$r = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-rotate'] CSS class name.
   * @property {string|HTMLElement} [label='⇧'] Text label to use for the rotate button.
   * Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.
   * @property {number} [duration=250] Animation duration in milliseconds.
   * @property {boolean} [autoHide=true] Hide the control when rotation is 0.
   * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control should
   * be re-rendered. This is called in a `requestAnimationFrame` callback.
   * @property {function():void} [resetNorth] Function called when the control is clicked.
   * This will override the default `resetNorth`.
   * @property {HTMLElement|string} [target] Specify a target if you want the control to be
   * rendered outside of the map's viewport.
   */
  /**
   * @classdesc
   * A button control to reset rotation to 0.
   * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
   * selector is added to the button when the rotation is 0.
   *
   * @api
   */
  var Rotate = /** @class */ (function (_super) {
      __extends$r(Rotate, _super);
      /**
       * @param {Options=} opt_options Rotate options.
       */
      function Rotate(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, {
              element: document.createElement('div'),
              render: options.render,
              target: options.target,
          }) || this;
          var className = options.className !== undefined ? options.className : 'ol-rotate';
          var label = options.label !== undefined ? options.label : '\u21E7';
          /**
           * @type {HTMLElement}
           * @private
           */
          _this.label_ = null;
          if (typeof label === 'string') {
              _this.label_ = document.createElement('span');
              _this.label_.className = 'ol-compass';
              _this.label_.textContent = label;
          }
          else {
              _this.label_ = label;
              _this.label_.classList.add('ol-compass');
          }
          var tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';
          var button = document.createElement('button');
          button.className = className + '-reset';
          button.setAttribute('type', 'button');
          button.title = tipLabel;
          button.appendChild(_this.label_);
          button.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this), false);
          var cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;
          var element = _this.element;
          element.className = cssClasses;
          element.appendChild(button);
          _this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;
          /**
           * @type {number}
           * @private
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 250;
          /**
           * @type {boolean}
           * @private
           */
          _this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.rotation_ = undefined;
          if (_this.autoHide_) {
              _this.element.classList.add(CLASS_HIDDEN);
          }
          return _this;
      }
      /**
       * @param {MouseEvent} event The event to handle
       * @private
       */
      Rotate.prototype.handleClick_ = function (event) {
          event.preventDefault();
          if (this.callResetNorth_ !== undefined) {
              this.callResetNorth_();
          }
          else {
              this.resetNorth_();
          }
      };
      /**
       * @private
       */
      Rotate.prototype.resetNorth_ = function () {
          var map = this.getMap();
          var view = map.getView();
          if (!view) {
              // the map does not have a view, so we can't act
              // upon it
              return;
          }
          var rotation = view.getRotation();
          if (rotation !== undefined) {
              if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
                  view.animate({
                      rotation: 0,
                      duration: this.duration_,
                      easing: easeOut,
                  });
              }
              else {
                  view.setRotation(0);
              }
          }
      };
      /**
       * Update the rotate control element.
       * @param {import("../MapEvent.js").default} mapEvent Map event.
       * @override
       */
      Rotate.prototype.render = function (mapEvent) {
          var frameState = mapEvent.frameState;
          if (!frameState) {
              return;
          }
          var rotation = frameState.viewState.rotation;
          if (rotation != this.rotation_) {
              var transform = 'rotate(' + rotation + 'rad)';
              if (this.autoHide_) {
                  var contains = this.element.classList.contains(CLASS_HIDDEN);
                  if (!contains && rotation === 0) {
                      this.element.classList.add(CLASS_HIDDEN);
                  }
                  else if (contains && rotation !== 0) {
                      this.element.classList.remove(CLASS_HIDDEN);
                  }
              }
              this.label_.style.transform = transform;
          }
          this.rotation_ = rotation;
      };
      return Rotate;
  }(Control));

  var __extends$s = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {number} [duration=250] Animation duration in milliseconds.
   * @property {string} [className='ol-zoom'] CSS class name.
   * @property {string|HTMLElement} [zoomInLabel='+'] Text label to use for the zoom-in
   * button. Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {string|HTMLElement} [zoomOutLabel='-'] Text label to use for the zoom-out button.
   * Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.
   * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.
   * @property {number} [delta=1] The zoom delta applied on each click.
   * @property {HTMLElement|string} [target] Specify a target if you want the control to be
   * rendered outside of the map's viewport.
   */
  /**
   * @classdesc
   * A control with 2 buttons, one for zoom in and one for zoom out.
   * This control is one of the default controls of a map. To style this control
   * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
   *
   * @api
   */
  var Zoom = /** @class */ (function (_super) {
      __extends$s(Zoom, _super);
      /**
       * @param {Options=} opt_options Zoom options.
       */
      function Zoom(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, {
              element: document.createElement('div'),
              target: options.target,
          }) || this;
          var className = options.className !== undefined ? options.className : 'ol-zoom';
          var delta = options.delta !== undefined ? options.delta : 1;
          var zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';
          var zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : '\u2212';
          var zoomInTipLabel = options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : 'Zoom in';
          var zoomOutTipLabel = options.zoomOutTipLabel !== undefined
              ? options.zoomOutTipLabel
              : 'Zoom out';
          var inElement = document.createElement('button');
          inElement.className = className + '-in';
          inElement.setAttribute('type', 'button');
          inElement.title = zoomInTipLabel;
          inElement.appendChild(typeof zoomInLabel === 'string'
              ? document.createTextNode(zoomInLabel)
              : zoomInLabel);
          inElement.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this, delta), false);
          var outElement = document.createElement('button');
          outElement.className = className + '-out';
          outElement.setAttribute('type', 'button');
          outElement.title = zoomOutTipLabel;
          outElement.appendChild(typeof zoomOutLabel === 'string'
              ? document.createTextNode(zoomOutLabel)
              : zoomOutLabel);
          outElement.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this, -delta), false);
          var cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;
          var element = _this.element;
          element.className = cssClasses;
          element.appendChild(inElement);
          element.appendChild(outElement);
          /**
           * @type {number}
           * @private
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 250;
          return _this;
      }
      /**
       * @param {number} delta Zoom delta.
       * @param {MouseEvent} event The event to handle
       * @private
       */
      Zoom.prototype.handleClick_ = function (delta, event) {
          event.preventDefault();
          this.zoomByDelta_(delta);
      };
      /**
       * @param {number} delta Zoom delta.
       * @private
       */
      Zoom.prototype.zoomByDelta_ = function (delta) {
          var map = this.getMap();
          var view = map.getView();
          if (!view) {
              // the map does not have a view, so we can't act
              // upon it
              return;
          }
          var currentZoom = view.getZoom();
          if (currentZoom !== undefined) {
              var newZoom = view.getConstrainedZoom(currentZoom + delta);
              if (this.duration_ > 0) {
                  if (view.getAnimating()) {
                      view.cancelAnimations();
                  }
                  view.animate({
                      zoom: newZoom,
                      duration: this.duration_,
                      easing: easeOut,
                  });
              }
              else {
                  view.setZoom(newZoom);
              }
          }
      };
      return Zoom;
  }(Control));

  /**
   * @module ol/control/MousePosition
   */
  var __extends$t = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @type {string}
   */
  var PROJECTION = 'projection';
  /**
   * @type {string}
   */
  var COORDINATE_FORMAT = 'coordinateFormat';
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-mouse-position'] CSS class name.
   * @property {import("../coordinate.js").CoordinateFormat} [coordinateFormat] Coordinate format.
   * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
   * @property {function(import("../MapEvent.js").default):void} [render] Function called when the
   * control should be re-rendered. This is called in a `requestAnimationFrame`
   * callback.
   * @property {HTMLElement|string} [target] Specify a target if you want the
   * control to be rendered outside of the map's viewport.
   * @property {string} [undefinedHTML='&#160;'] Markup to show when coordinates are not
   * available (e.g. when the pointer leaves the map viewport).  By default, the last position
   * will be replaced with `'&#160;'` (`&nbsp;`) when the pointer leaves the viewport.  To
   * retain the last rendered position, set this option to something falsey (like an empty
   * string `''`).
   */
  /**
   * @classdesc
   * A control to show the 2D coordinates of the mouse cursor. By default, these
   * are in the view projection, but can be in any supported projection.
   * By default the control is shown in the top right corner of the map, but this
   * can be changed by using the css selector `.ol-mouse-position`.
   *
   * On touch devices, which usually do not have a mouse cursor, the coordinates
   * of the currently touched position are shown.
   *
   * @api
   */
  var MousePosition = /** @class */ (function (_super) {
      __extends$t(MousePosition, _super);
      /**
       * @param {Options=} opt_options Mouse position options.
       */
      function MousePosition(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          var element = document.createElement('div');
          element.className =
              options.className !== undefined ? options.className : 'ol-mouse-position';
          _this = _super.call(this, {
              element: element,
              render: options.render,
              target: options.target,
          }) || this;
          _this.addEventListener(getChangeEventType(PROJECTION), _this.handleProjectionChanged_);
          if (options.coordinateFormat) {
              _this.setCoordinateFormat(options.coordinateFormat);
          }
          if (options.projection) {
              _this.setProjection(options.projection);
          }
          /**
           * @private
           * @type {string}
           */
          _this.undefinedHTML_ =
              options.undefinedHTML !== undefined ? options.undefinedHTML : '&#160;';
          /**
           * @private
           * @type {boolean}
           */
          _this.renderOnMouseOut_ = !!_this.undefinedHTML_;
          /**
           * @private
           * @type {string}
           */
          _this.renderedHTML_ = element.innerHTML;
          /**
           * @private
           * @type {?import("../proj/Projection.js").default}
           */
          _this.mapProjection_ = null;
          /**
           * @private
           * @type {?import("../proj.js").TransformFunction}
           */
          _this.transform_ = null;
          return _this;
      }
      /**
       * @private
       */
      MousePosition.prototype.handleProjectionChanged_ = function () {
          this.transform_ = null;
      };
      /**
       * Return the coordinate format type used to render the current position or
       * undefined.
       * @return {import("../coordinate.js").CoordinateFormat|undefined} The format to render the current
       *     position in.
       * @observable
       * @api
       */
      MousePosition.prototype.getCoordinateFormat = function () {
          return /** @type {import("../coordinate.js").CoordinateFormat|undefined} */ (this.get(COORDINATE_FORMAT));
      };
      /**
       * Return the projection that is used to report the mouse position.
       * @return {import("../proj/Projection.js").default|undefined} The projection to report mouse
       *     position in.
       * @observable
       * @api
       */
      MousePosition.prototype.getProjection = function () {
          return /** @type {import("../proj/Projection.js").default|undefined} */ (this.get(PROJECTION));
      };
      /**
       * @param {MouseEvent} event Browser event.
       * @protected
       */
      MousePosition.prototype.handleMouseMove = function (event) {
          var map = this.getMap();
          this.updateHTML_(map.getEventPixel(event));
      };
      /**
       * @param {Event} event Browser event.
       * @protected
       */
      MousePosition.prototype.handleMouseOut = function (event) {
          this.updateHTML_(null);
      };
      /**
       * Remove the control from its current map and attach it to the new map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../PluggableMap.js").default} map Map.
       * @api
       */
      MousePosition.prototype.setMap = function (map) {
          _super.prototype.setMap.call(this, map);
          if (map) {
              var viewport = map.getViewport();
              this.listenerKeys.push(listen(viewport, PointerEventType.POINTERMOVE, this.handleMouseMove, this));
              if (this.renderOnMouseOut_) {
                  this.listenerKeys.push(listen(viewport, PointerEventType.POINTEROUT, this.handleMouseOut, this));
              }
          }
      };
      /**
       * Set the coordinate format type used to render the current position.
       * @param {import("../coordinate.js").CoordinateFormat} format The format to render the current
       *     position in.
       * @observable
       * @api
       */
      MousePosition.prototype.setCoordinateFormat = function (format) {
          this.set(COORDINATE_FORMAT, format);
      };
      /**
       * Set the projection that is used to report the mouse position.
       * @param {import("../proj.js").ProjectionLike} projection The projection to report mouse
       *     position in.
       * @observable
       * @api
       */
      MousePosition.prototype.setProjection = function (projection) {
          this.set(PROJECTION, get$2(projection));
      };
      /**
       * @param {?import("../pixel.js").Pixel} pixel Pixel.
       * @private
       */
      MousePosition.prototype.updateHTML_ = function (pixel) {
          var html = this.undefinedHTML_;
          if (pixel && this.mapProjection_) {
              if (!this.transform_) {
                  var projection = this.getProjection();
                  if (projection) {
                      this.transform_ = getTransformFromProjections(this.mapProjection_, projection);
                  }
                  else {
                      this.transform_ = identityTransform;
                  }
              }
              var map = this.getMap();
              var coordinate = map.getCoordinateFromPixelInternal(pixel);
              if (coordinate) {
                  var userProjection = getUserProjection();
                  if (userProjection) {
                      this.transform_ = getTransformFromProjections(this.mapProjection_, userProjection);
                  }
                  this.transform_(coordinate, coordinate);
                  var coordinateFormat = this.getCoordinateFormat();
                  if (coordinateFormat) {
                      html = coordinateFormat(coordinate);
                  }
                  else {
                      html = coordinate.toString();
                  }
              }
          }
          if (!this.renderedHTML_ || html !== this.renderedHTML_) {
              this.element.innerHTML = html;
              this.renderedHTML_ = html;
          }
      };
      /**
       * Update the projection. Rendering of the coordinates is done in
       * `handleMouseMove` and `handleMouseUp`.
       * @param {import("../MapEvent.js").default} mapEvent Map event.
       * @override
       */
      MousePosition.prototype.render = function (mapEvent) {
          var frameState = mapEvent.frameState;
          if (!frameState) {
              this.mapProjection_ = null;
          }
          else {
              if (this.mapProjection_ != frameState.viewState.projection) {
                  this.mapProjection_ = frameState.viewState.projection;
                  this.transform_ = null;
              }
          }
      };
      return MousePosition;
  }(Control));

  /**
   * @module ol/OverlayPositioning
   */
  /**
   * Overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,
   * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
   * `'top-center'`, `'top-right'`
   * @enum {string}
   */
  var OverlayPositioning = {
      BOTTOM_LEFT: 'bottom-left',
      BOTTOM_CENTER: 'bottom-center',
      BOTTOM_RIGHT: 'bottom-right',
      CENTER_LEFT: 'center-left',
      CENTER_CENTER: 'center-center',
      CENTER_RIGHT: 'center-right',
      TOP_LEFT: 'top-left',
      TOP_CENTER: 'top-center',
      TOP_RIGHT: 'top-right',
  };

  var __extends$u = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {number|string} [id] Set the overlay id. The overlay id can be used
   * with the {@link module:ol/Map~Map#getOverlayById} method.
   * @property {HTMLElement} [element] The overlay element.
   * @property {Array<number>} [offset=[0, 0]] Offsets in pixels used when positioning
   * the overlay. The first element in the
   * array is the horizontal offset. A positive value shifts the overlay right.
   * The second element in the array is the vertical offset. A positive value
   * shifts the overlay down.
   * @property {import("./coordinate.js").Coordinate} [position] The overlay position
   * in map projection.
   * @property {import("./OverlayPositioning.js").default} [positioning='top-left'] Defines how
   * the overlay is actually positioned with respect to its `position` property.
   * Possible values are `'bottom-left'`, `'bottom-center'`, `'bottom-right'`,
   * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
   * `'top-center'`, and `'top-right'`.
   * @property {boolean} [stopEvent=true] Whether event propagation to the map
   * viewport should be stopped. If `true` the overlay is placed in the same
   * container as that of the controls (CSS class name
   * `ol-overlaycontainer-stopevent`); if `false` it is placed in the container
   * with CSS class name specified by the `className` property.
   * @property {boolean} [insertFirst=true] Whether the overlay is inserted first
   * in the overlay container, or appended. If the overlay is placed in the same
   * container as that of the controls (see the `stopEvent` option) you will
   * probably set `insertFirst` to `true` so the overlay is displayed below the
   * controls.
   * @property {PanIntoViewOptions|boolean} [autoPan=false] Pan the map when calling
   * `setPosition`, so that the overlay is entirely visible in the current viewport?
   * If `true` (deprecated), then `autoPanAnimation` and `autoPanMargin` will be
   * used to determine the panning parameters; if an object is supplied then other
   * parameters are ignored.
   * @property {PanOptions} [autoPanAnimation] The animation options used to pan
   * the overlay into view. This animation is only used when `autoPan` is enabled.
   * A `duration` and `easing` may be provided to customize the animation.
   * Deprecated and ignored if `autoPan` is supplied as an object.
   * @property {number} [autoPanMargin=20] The margin (in pixels) between the
   * overlay and the borders of the map when autopanning. Deprecated and ignored
   * if `autoPan` is supplied as an object.
   * @property {PanIntoViewOptions} [autoPanOptions] The options to use for the
   * autoPan. This is only used when `autoPan` is enabled and has preference over
   * the individual `autoPanMargin` and `autoPanOptions`.
   * @property {string} [className='ol-overlay-container ol-selectable'] CSS class
   * name.
   */
  /**
   * @typedef {Object} PanOptions
   * @property {number} [duration=1000] The duration of the animation in
   * milliseconds.
   * @property {function(number):number} [easing] The easing function to use. Can
   * be one from {@link module:ol/easing} or a custom function.
   * Default is {@link module:ol/easing~inAndOut}.
   */
  /**
   * @typedef {Object} PanIntoViewOptions
   * @property {PanOptions} [animation={}] The animation parameters for the pan
   * @property {number} [margin=20] The margin (in pixels) between the
   * overlay and the borders of the map when panning into view.
   */
  /**
   * @enum {string}
   * @protected
   */
  var Property$2 = {
      ELEMENT: 'element',
      MAP: 'map',
      OFFSET: 'offset',
      POSITION: 'position',
      POSITIONING: 'positioning',
  };
  /**
   * @classdesc
   * An element to be displayed over the map and attached to a single map
   * location.  Like {@link module:ol/control/Control~Control}, Overlays are
   * visible widgets. Unlike Controls, they are not in a fixed position on the
   * screen, but are tied to a geographical coordinate, so panning the map will
   * move an Overlay but not a Control.
   *
   * Example:
   *
   *     import Overlay from 'ol/Overlay';
   *
   *     var popup = new Overlay({
   *       element: document.getElementById('popup')
   *     });
   *     popup.setPosition(coordinate);
   *     map.addOverlay(popup);
   *
   * @api
   */
  var Overlay = /** @class */ (function (_super) {
      __extends$u(Overlay, _super);
      /**
       * @param {Options} options Overlay options.
       */
      function Overlay(options) {
          var _this = _super.call(this) || this;
          /**
           * @protected
           * @type {Options}
           */
          _this.options = options;
          /**
           * @protected
           * @type {number|string|undefined}
           */
          _this.id = options.id;
          /**
           * @protected
           * @type {boolean}
           */
          _this.insertFirst =
              options.insertFirst !== undefined ? options.insertFirst : true;
          /**
           * @protected
           * @type {boolean}
           */
          _this.stopEvent = options.stopEvent !== undefined ? options.stopEvent : true;
          /**
           * @protected
           * @type {HTMLElement}
           */
          _this.element = document.createElement('div');
          _this.element.className =
              options.className !== undefined
                  ? options.className
                  : 'ol-overlay-container ' + CLASS_SELECTABLE;
          _this.element.style.position = 'absolute';
          _this.element.style.pointerEvents = 'auto';
          var autoPan = options.autoPan;
          if (autoPan && 'object' !== typeof autoPan) {
              autoPan = {
                  animation: options.autoPanAnimation,
                  margin: options.autoPanMargin,
              };
          }
          /**
           * @protected
           * @type {PanIntoViewOptions|false}
           */
          _this.autoPan = /** @type {PanIntoViewOptions} */ (autoPan) || false;
          /**
           * @protected
           * @type {{transform_: string,
           *         visible: boolean}}
           */
          _this.rendered = {
              transform_: '',
              visible: true,
          };
          /**
           * @protected
           * @type {?import("./events.js").EventsKey}
           */
          _this.mapPostrenderListenerKey = null;
          _this.addEventListener(getChangeEventType(Property$2.ELEMENT), _this.handleElementChanged);
          _this.addEventListener(getChangeEventType(Property$2.MAP), _this.handleMapChanged);
          _this.addEventListener(getChangeEventType(Property$2.OFFSET), _this.handleOffsetChanged);
          _this.addEventListener(getChangeEventType(Property$2.POSITION), _this.handlePositionChanged);
          _this.addEventListener(getChangeEventType(Property$2.POSITIONING), _this.handlePositioningChanged);
          if (options.element !== undefined) {
              _this.setElement(options.element);
          }
          _this.setOffset(options.offset !== undefined ? options.offset : [0, 0]);
          _this.setPositioning(options.positioning !== undefined
              ? /** @type {import("./OverlayPositioning.js").default} */ (options.positioning)
              : OverlayPositioning.TOP_LEFT);
          if (options.position !== undefined) {
              _this.setPosition(options.position);
          }
          return _this;
      }
      /**
       * Get the DOM element of this overlay.
       * @return {HTMLElement|undefined} The Element containing the overlay.
       * @observable
       * @api
       */
      Overlay.prototype.getElement = function () {
          return /** @type {HTMLElement|undefined} */ (this.get(Property$2.ELEMENT));
      };
      /**
       * Get the overlay identifier which is set on constructor.
       * @return {number|string|undefined} Id.
       * @api
       */
      Overlay.prototype.getId = function () {
          return this.id;
      };
      /**
       * Get the map associated with this overlay.
       * @return {import("./PluggableMap.js").default|undefined} The map that the
       * overlay is part of.
       * @observable
       * @api
       */
      Overlay.prototype.getMap = function () {
          return /** @type {import("./PluggableMap.js").default|undefined} */ (this.get(Property$2.MAP));
      };
      /**
       * Get the offset of this overlay.
       * @return {Array<number>} The offset.
       * @observable
       * @api
       */
      Overlay.prototype.getOffset = function () {
          return /** @type {Array<number>} */ (this.get(Property$2.OFFSET));
      };
      /**
       * Get the current position of this overlay.
       * @return {import("./coordinate.js").Coordinate|undefined} The spatial point that the overlay is
       *     anchored at.
       * @observable
       * @api
       */
      Overlay.prototype.getPosition = function () {
          return /** @type {import("./coordinate.js").Coordinate|undefined} */ (this.get(Property$2.POSITION));
      };
      /**
       * Get the current positioning of this overlay.
       * @return {import("./OverlayPositioning.js").default} How the overlay is positioned
       *     relative to its point on the map.
       * @observable
       * @api
       */
      Overlay.prototype.getPositioning = function () {
          return /** @type {import("./OverlayPositioning.js").default} */ (this.get(Property$2.POSITIONING));
      };
      /**
       * @protected
       */
      Overlay.prototype.handleElementChanged = function () {
          removeChildren(this.element);
          var element = this.getElement();
          if (element) {
              this.element.appendChild(element);
          }
      };
      /**
       * @protected
       */
      Overlay.prototype.handleMapChanged = function () {
          if (this.mapPostrenderListenerKey) {
              removeNode(this.element);
              unlistenByKey(this.mapPostrenderListenerKey);
              this.mapPostrenderListenerKey = null;
          }
          var map = this.getMap();
          if (map) {
              this.mapPostrenderListenerKey = listen(map, MapEventType.POSTRENDER, this.render, this);
              this.updatePixelPosition();
              var container = this.stopEvent
                  ? map.getOverlayContainerStopEvent()
                  : map.getOverlayContainer();
              if (this.insertFirst) {
                  container.insertBefore(this.element, container.childNodes[0] || null);
              }
              else {
                  container.appendChild(this.element);
              }
              this.performAutoPan();
          }
      };
      /**
       * @protected
       */
      Overlay.prototype.render = function () {
          this.updatePixelPosition();
      };
      /**
       * @protected
       */
      Overlay.prototype.handleOffsetChanged = function () {
          this.updatePixelPosition();
      };
      /**
       * @protected
       */
      Overlay.prototype.handlePositionChanged = function () {
          this.updatePixelPosition();
          this.performAutoPan();
      };
      /**
       * @protected
       */
      Overlay.prototype.handlePositioningChanged = function () {
          this.updatePixelPosition();
      };
      /**
       * Set the DOM element to be associated with this overlay.
       * @param {HTMLElement|undefined} element The Element containing the overlay.
       * @observable
       * @api
       */
      Overlay.prototype.setElement = function (element) {
          this.set(Property$2.ELEMENT, element);
      };
      /**
       * Set the map to be associated with this overlay.
       * @param {import("./PluggableMap.js").default|undefined} map The map that the
       * overlay is part of.
       * @observable
       * @api
       */
      Overlay.prototype.setMap = function (map) {
          this.set(Property$2.MAP, map);
      };
      /**
       * Set the offset for this overlay.
       * @param {Array<number>} offset Offset.
       * @observable
       * @api
       */
      Overlay.prototype.setOffset = function (offset) {
          this.set(Property$2.OFFSET, offset);
      };
      /**
       * Set the position for this overlay. If the position is `undefined` the
       * overlay is hidden.
       * @param {import("./coordinate.js").Coordinate|undefined} position The spatial point that the overlay
       *     is anchored at.
       * @observable
       * @api
       */
      Overlay.prototype.setPosition = function (position) {
          this.set(Property$2.POSITION, position);
      };
      /**
       * Pan the map so that the overlay is entirely visisble in the current viewport
       * (if necessary) using the configured autoPan parameters
       * @protected
       */
      Overlay.prototype.performAutoPan = function () {
          if (this.autoPan) {
              this.panIntoView(this.autoPan);
          }
      };
      /**
       * Pan the map so that the overlay is entirely visible in the current viewport
       * (if necessary).
       * @param {PanIntoViewOptions=} opt_panIntoViewOptions Options for the pan action
       * @api
       */
      Overlay.prototype.panIntoView = function (opt_panIntoViewOptions) {
          var map = this.getMap();
          if (!map || !map.getTargetElement() || !this.get(Property$2.POSITION)) {
              return;
          }
          var mapRect = this.getRect(map.getTargetElement(), map.getSize());
          var element = this.getElement();
          var overlayRect = this.getRect(element, [
              outerWidth(element),
              outerHeight(element),
          ]);
          var panIntoViewOptions = opt_panIntoViewOptions || {};
          var myMargin = panIntoViewOptions.margin === undefined ? 20 : panIntoViewOptions.margin;
          if (!containsExtent(mapRect, overlayRect)) {
              // the overlay is not completely inside the viewport, so pan the map
              var offsetLeft = overlayRect[0] - mapRect[0];
              var offsetRight = mapRect[2] - overlayRect[2];
              var offsetTop = overlayRect[1] - mapRect[1];
              var offsetBottom = mapRect[3] - overlayRect[3];
              var delta = [0, 0];
              if (offsetLeft < 0) {
                  // move map to the left
                  delta[0] = offsetLeft - myMargin;
              }
              else if (offsetRight < 0) {
                  // move map to the right
                  delta[0] = Math.abs(offsetRight) + myMargin;
              }
              if (offsetTop < 0) {
                  // move map up
                  delta[1] = offsetTop - myMargin;
              }
              else if (offsetBottom < 0) {
                  // move map down
                  delta[1] = Math.abs(offsetBottom) + myMargin;
              }
              if (delta[0] !== 0 || delta[1] !== 0) {
                  var center = /** @type {import("./coordinate.js").Coordinate} */ (map
                      .getView()
                      .getCenterInternal());
                  var centerPx = map.getPixelFromCoordinateInternal(center);
                  var newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];
                  var panOptions = panIntoViewOptions.animation || {};
                  map.getView().animateInternal({
                      center: map.getCoordinateFromPixelInternal(newCenterPx),
                      duration: panOptions.duration,
                      easing: panOptions.easing,
                  });
              }
          }
      };
      /**
       * Get the extent of an element relative to the document
       * @param {HTMLElement} element The element.
       * @param {import("./size.js").Size} size The size of the element.
       * @return {import("./extent.js").Extent} The extent.
       * @protected
       */
      Overlay.prototype.getRect = function (element, size) {
          var box = element.getBoundingClientRect();
          var offsetX = box.left + window.pageXOffset;
          var offsetY = box.top + window.pageYOffset;
          return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];
      };
      /**
       * Set the positioning for this overlay.
       * @param {import("./OverlayPositioning.js").default} positioning how the overlay is
       *     positioned relative to its point on the map.
       * @observable
       * @api
       */
      Overlay.prototype.setPositioning = function (positioning) {
          this.set(Property$2.POSITIONING, positioning);
      };
      /**
       * Modify the visibility of the element.
       * @param {boolean} visible Element visibility.
       * @protected
       */
      Overlay.prototype.setVisible = function (visible) {
          if (this.rendered.visible !== visible) {
              this.element.style.display = visible ? '' : 'none';
              this.rendered.visible = visible;
          }
      };
      /**
       * Update pixel position.
       * @protected
       */
      Overlay.prototype.updatePixelPosition = function () {
          var map = this.getMap();
          var position = this.getPosition();
          if (!map || !map.isRendered() || !position) {
              this.setVisible(false);
              return;
          }
          var pixel = map.getPixelFromCoordinate(position);
          var mapSize = map.getSize();
          this.updateRenderedPosition(pixel, mapSize);
      };
      /**
       * @param {import("./pixel.js").Pixel} pixel The pixel location.
       * @param {import("./size.js").Size|undefined} mapSize The map size.
       * @protected
       */
      Overlay.prototype.updateRenderedPosition = function (pixel, mapSize) {
          var style = this.element.style;
          var offset = this.getOffset();
          var positioning = this.getPositioning();
          this.setVisible(true);
          var x = Math.round(pixel[0] + offset[0]) + 'px';
          var y = Math.round(pixel[1] + offset[1]) + 'px';
          var posX = '0%';
          var posY = '0%';
          if (positioning == OverlayPositioning.BOTTOM_RIGHT ||
              positioning == OverlayPositioning.CENTER_RIGHT ||
              positioning == OverlayPositioning.TOP_RIGHT) {
              posX = '-100%';
          }
          else if (positioning == OverlayPositioning.BOTTOM_CENTER ||
              positioning == OverlayPositioning.CENTER_CENTER ||
              positioning == OverlayPositioning.TOP_CENTER) {
              posX = '-50%';
          }
          if (positioning == OverlayPositioning.BOTTOM_LEFT ||
              positioning == OverlayPositioning.BOTTOM_CENTER ||
              positioning == OverlayPositioning.BOTTOM_RIGHT) {
              posY = '-100%';
          }
          else if (positioning == OverlayPositioning.CENTER_LEFT ||
              positioning == OverlayPositioning.CENTER_CENTER ||
              positioning == OverlayPositioning.CENTER_RIGHT) {
              posY = '-50%';
          }
          var transform = "translate(" + posX + ", " + posY + ") translate(" + x + ", " + y + ")";
          if (this.rendered.transform_ != transform) {
              this.rendered.transform_ = transform;
              style.transform = transform;
              // @ts-ignore IE9
              style.msTransform = transform;
          }
      };
      /**
       * returns the options this Overlay has been created with
       * @return {Options} overlay options
       */
      Overlay.prototype.getOptions = function () {
          return this.options;
      };
      return Overlay;
  }(BaseObject));

  var __extends$v = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * Maximum width and/or height extent ratio that determines when the overview
   * map should be zoomed out.
   * @type {number}
   */
  var MAX_RATIO = 0.75;
  /**
   * Minimum width and/or height extent ratio that determines when the overview
   * map should be zoomed in.
   * @type {number}
   */
  var MIN_RATIO = 0.1;
  var ControlledMap = /** @class */ (function (_super) {
      __extends$v(ControlledMap, _super);
      function ControlledMap() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      ControlledMap.prototype.createRenderer = function () {
          return new CompositeMapRenderer(this);
      };
      return ControlledMap;
  }(PluggableMap));
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-overviewmap'] CSS class name.
   * @property {boolean} [collapsed=true] Whether the control should start collapsed or not (expanded).
   * @property {string|HTMLElement} [collapseLabel='«'] Text label to use for the
   * expanded overviewmap button. Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {boolean} [collapsible=true] Whether the control can be collapsed or not.
   * @property {string|HTMLElement} [label='»'] Text label to use for the collapsed
   * overviewmap button. Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {Array<import("../layer/Layer.js").default>|import("../Collection.js").default<import("../layer/Layer.js").default>} [layers]
   * Layers for the overview map.
   * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control
   * should be re-rendered. This is called in a `requestAnimationFrame` callback.
   * @property {boolean} [rotateWithView=false] Whether the control view should rotate with the main map view.
   * @property {HTMLElement|string} [target] Specify a target if you want the control
   * to be rendered outside of the map's viewport.
   * @property {string} [tipLabel='Overview map'] Text label to use for the button tip.
   * @property {View} [view] Custom view for the overview map (should use same projection as main map). If not provided,
   * a default view with the same projection as the main map will be used.
   */
  /**
   * Create a new control with a map acting as an overview map for another
   * defined map.
   *
   * @api
   */
  var OverviewMap = /** @class */ (function (_super) {
      __extends$v(OverviewMap, _super);
      /**
       * @param {Options=} opt_options OverviewMap options.
       */
      function OverviewMap(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, {
              element: document.createElement('div'),
              render: options.render,
              target: options.target,
          }) || this;
          /**
           * @private
           */
          _this.boundHandleRotationChanged_ = _this.handleRotationChanged_.bind(_this);
          /**
           * @type {boolean}
           * @private
           */
          _this.collapsed_ =
              options.collapsed !== undefined ? options.collapsed : true;
          /**
           * @private
           * @type {boolean}
           */
          _this.collapsible_ =
              options.collapsible !== undefined ? options.collapsible : true;
          if (!_this.collapsible_) {
              _this.collapsed_ = false;
          }
          /**
           * @private
           * @type {boolean}
           */
          _this.rotateWithView_ =
              options.rotateWithView !== undefined ? options.rotateWithView : false;
          /**
           * @private
           * @type {import("../extent.js").Extent|undefined}
           */
          _this.viewExtent_ = undefined;
          var className = options.className !== undefined ? options.className : 'ol-overviewmap';
          var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Overview map';
          var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\u00AB';
          if (typeof collapseLabel === 'string') {
              /**
               * @private
               * @type {HTMLElement}
               */
              _this.collapseLabel_ = document.createElement('span');
              _this.collapseLabel_.textContent = collapseLabel;
          }
          else {
              _this.collapseLabel_ = collapseLabel;
          }
          var label = options.label !== undefined ? options.label : '\u00BB';
          if (typeof label === 'string') {
              /**
               * @private
               * @type {HTMLElement}
               */
              _this.label_ = document.createElement('span');
              _this.label_.textContent = label;
          }
          else {
              _this.label_ = label;
          }
          var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;
          var button = document.createElement('button');
          button.setAttribute('type', 'button');
          button.title = tipLabel;
          button.appendChild(activeLabel);
          button.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this), false);
          /**
           * @type {HTMLElement}
           * @private
           */
          _this.ovmapDiv_ = document.createElement('div');
          _this.ovmapDiv_.className = 'ol-overviewmap-map';
          /**
           * Explicitly given view to be used instead of a view derived from the main map.
           * @type {View}
           * @private
           */
          _this.view_ = options.view;
          /**
           * @type {ControlledMap}
           * @private
           */
          _this.ovmap_ = new ControlledMap({
              view: options.view,
          });
          var ovmap = _this.ovmap_;
          if (options.layers) {
              options.layers.forEach(function (layer) {
                  ovmap.addLayer(layer);
              });
          }
          var box = document.createElement('div');
          box.className = 'ol-overviewmap-box';
          box.style.boxSizing = 'border-box';
          /**
           * @type {import("../Overlay.js").default}
           * @private
           */
          _this.boxOverlay_ = new Overlay({
              position: [0, 0],
              positioning: OverlayPositioning.CENTER_CENTER,
              element: box,
          });
          _this.ovmap_.addOverlay(_this.boxOverlay_);
          var cssClasses = className +
              ' ' +
              CLASS_UNSELECTABLE +
              ' ' +
              CLASS_CONTROL +
              (_this.collapsed_ && _this.collapsible_ ? ' ' + CLASS_COLLAPSED : '') +
              (_this.collapsible_ ? '' : ' ol-uncollapsible');
          var element = _this.element;
          element.className = cssClasses;
          element.appendChild(_this.ovmapDiv_);
          element.appendChild(button);
          /* Interactive map */
          var scope = _this;
          var overlay = _this.boxOverlay_;
          var overlayBox = _this.boxOverlay_.getElement();
          /* Functions definition */
          var computeDesiredMousePosition = function (mousePosition) {
              return {
                  clientX: mousePosition.clientX,
                  clientY: mousePosition.clientY,
              };
          };
          var move = function (event) {
              var position = /** @type {?} */ (computeDesiredMousePosition(event));
              var coordinates = ovmap.getEventCoordinateInternal(
              /** @type {MouseEvent} */ (position));
              overlay.setPosition(coordinates);
          };
          var endMoving = function (event) {
              var coordinates = ovmap.getEventCoordinateInternal(event);
              scope.getMap().getView().setCenterInternal(coordinates);
              window.removeEventListener('mousemove', move);
              window.removeEventListener('mouseup', endMoving);
          };
          /* Binding */
          overlayBox.addEventListener('mousedown', function () {
              window.addEventListener('mousemove', move);
              window.addEventListener('mouseup', endMoving);
          });
          return _this;
      }
      /**
       * Remove the control from its current map and attach it to the new map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../PluggableMap.js").default} map Map.
       * @api
       */
      OverviewMap.prototype.setMap = function (map) {
          var oldMap = this.getMap();
          if (map === oldMap) {
              return;
          }
          if (oldMap) {
              var oldView = oldMap.getView();
              if (oldView) {
                  this.unbindView_(oldView);
              }
              this.ovmap_.setTarget(null);
          }
          _super.prototype.setMap.call(this, map);
          if (map) {
              this.ovmap_.setTarget(this.ovmapDiv_);
              this.listenerKeys.push(listen(map, ObjectEventType.PROPERTYCHANGE, this.handleMapPropertyChange_, this));
              var view = map.getView();
              if (view) {
                  this.bindView_(view);
                  if (view.isDef()) {
                      this.ovmap_.updateSize();
                      this.resetExtent_();
                  }
              }
          }
      };
      /**
       * Handle map property changes.  This only deals with changes to the map's view.
       * @param {import("../Object.js").ObjectEvent} event The propertychange event.
       * @private
       */
      OverviewMap.prototype.handleMapPropertyChange_ = function (event) {
          if (event.key === MapProperty.VIEW) {
              var oldView = /** @type {import("../View.js").default} */ (event.oldValue);
              if (oldView) {
                  this.unbindView_(oldView);
              }
              var newView = this.getMap().getView();
              this.bindView_(newView);
          }
      };
      /**
       * Register listeners for view property changes.
       * @param {import("../View.js").default} view The view.
       * @private
       */
      OverviewMap.prototype.bindView_ = function (view) {
          if (!this.view_) {
              // Unless an explicit view definition was given, derive default from whatever main map uses.
              var newView = new View({
                  projection: view.getProjection(),
              });
              this.ovmap_.setView(newView);
          }
          view.addEventListener(getChangeEventType(ViewProperty.ROTATION), this.boundHandleRotationChanged_);
          // Sync once with the new view
          this.handleRotationChanged_();
      };
      /**
       * Unregister listeners for view property changes.
       * @param {import("../View.js").default} view The view.
       * @private
       */
      OverviewMap.prototype.unbindView_ = function (view) {
          view.removeEventListener(getChangeEventType(ViewProperty.ROTATION), this.boundHandleRotationChanged_);
      };
      /**
       * Handle rotation changes to the main map.
       * @private
       */
      OverviewMap.prototype.handleRotationChanged_ = function () {
          if (this.rotateWithView_) {
              this.ovmap_.getView().setRotation(this.getMap().getView().getRotation());
          }
      };
      /**
       * Reset the overview map extent if the box size (width or
       * height) is less than the size of the overview map size times minRatio
       * or is greater than the size of the overview size times maxRatio.
       *
       * If the map extent was not reset, the box size can fits in the defined
       * ratio sizes. This method then checks if is contained inside the overview
       * map current extent. If not, recenter the overview map to the current
       * main map center location.
       * @private
       */
      OverviewMap.prototype.validateExtent_ = function () {
          var map = this.getMap();
          var ovmap = this.ovmap_;
          if (!map.isRendered() || !ovmap.isRendered()) {
              return;
          }
          var mapSize = /** @type {import("../size.js").Size} */ (map.getSize());
          var view = map.getView();
          var extent = view.calculateExtentInternal(mapSize);
          if (this.viewExtent_ && equals$1(extent, this.viewExtent_)) {
              // repeats of the same extent may indicate constraint conflicts leading to an endless cycle
              return;
          }
          this.viewExtent_ = extent;
          var ovmapSize = /** @type {import("../size.js").Size} */ (ovmap.getSize());
          var ovview = ovmap.getView();
          var ovextent = ovview.calculateExtentInternal(ovmapSize);
          var topLeftPixel = ovmap.getPixelFromCoordinateInternal(getTopLeft(extent));
          var bottomRightPixel = ovmap.getPixelFromCoordinateInternal(getBottomRight(extent));
          var boxWidth = Math.abs(topLeftPixel[0] - bottomRightPixel[0]);
          var boxHeight = Math.abs(topLeftPixel[1] - bottomRightPixel[1]);
          var ovmapWidth = ovmapSize[0];
          var ovmapHeight = ovmapSize[1];
          if (boxWidth < ovmapWidth * MIN_RATIO ||
              boxHeight < ovmapHeight * MIN_RATIO ||
              boxWidth > ovmapWidth * MAX_RATIO ||
              boxHeight > ovmapHeight * MAX_RATIO) {
              this.resetExtent_();
          }
          else if (!containsExtent(ovextent, extent)) {
              this.recenter_();
          }
      };
      /**
       * Reset the overview map extent to half calculated min and max ratio times
       * the extent of the main map.
       * @private
       */
      OverviewMap.prototype.resetExtent_ = function () {
          var map = this.getMap();
          var ovmap = this.ovmap_;
          var mapSize = /** @type {import("../size.js").Size} */ (map.getSize());
          var view = map.getView();
          var extent = view.calculateExtentInternal(mapSize);
          var ovview = ovmap.getView();
          // get how many times the current map overview could hold different
          // box sizes using the min and max ratio, pick the step in the middle used
          // to calculate the extent from the main map to set it to the overview map,
          var steps = Math.log(MAX_RATIO / MIN_RATIO) / Math.LN2;
          var ratio = 1 / (Math.pow(2, steps / 2) * MIN_RATIO);
          scaleFromCenter(extent, ratio);
          ovview.fitInternal(fromExtent(extent));
      };
      /**
       * Set the center of the overview map to the map center without changing its
       * resolution.
       * @private
       */
      OverviewMap.prototype.recenter_ = function () {
          var map = this.getMap();
          var ovmap = this.ovmap_;
          var view = map.getView();
          var ovview = ovmap.getView();
          ovview.setCenterInternal(view.getCenterInternal());
      };
      /**
       * Update the box using the main map extent
       * @private
       */
      OverviewMap.prototype.updateBox_ = function () {
          var map = this.getMap();
          var ovmap = this.ovmap_;
          if (!map.isRendered() || !ovmap.isRendered()) {
              return;
          }
          var mapSize = /** @type {import("../size.js").Size} */ (map.getSize());
          var view = map.getView();
          var ovview = ovmap.getView();
          var rotation = this.rotateWithView_ ? 0 : -view.getRotation();
          var overlay = this.boxOverlay_;
          var box = this.boxOverlay_.getElement();
          var center = view.getCenterInternal();
          var resolution = view.getResolution();
          var ovresolution = ovview.getResolution();
          var width = (mapSize[0] * resolution) / ovresolution;
          var height = (mapSize[1] * resolution) / ovresolution;
          // set position using center coordinates
          overlay.setPosition(center);
          // set box size calculated from map extent size and overview map resolution
          if (box) {
              box.style.width = width + 'px';
              box.style.height = height + 'px';
              var transform = 'rotate(' + rotation + 'rad)';
              box.style.transform = transform;
          }
      };
      /**
       * @param {MouseEvent} event The event to handle
       * @private
       */
      OverviewMap.prototype.handleClick_ = function (event) {
          event.preventDefault();
          this.handleToggle_();
      };
      /**
       * @private
       */
      OverviewMap.prototype.handleToggle_ = function () {
          this.element.classList.toggle(CLASS_COLLAPSED);
          if (this.collapsed_) {
              replaceNode(this.collapseLabel_, this.label_);
          }
          else {
              replaceNode(this.label_, this.collapseLabel_);
          }
          this.collapsed_ = !this.collapsed_;
          // manage overview map if it had not been rendered before and control
          // is expanded
          var ovmap = this.ovmap_;
          if (!this.collapsed_) {
              if (ovmap.isRendered()) {
                  this.viewExtent_ = undefined;
                  ovmap.render();
                  return;
              }
              ovmap.updateSize();
              this.resetExtent_();
              listenOnce(ovmap, MapEventType.POSTRENDER, function (event) {
                  this.updateBox_();
              }, this);
          }
      };
      /**
       * Return `true` if the overview map is collapsible, `false` otherwise.
       * @return {boolean} True if the widget is collapsible.
       * @api
       */
      OverviewMap.prototype.getCollapsible = function () {
          return this.collapsible_;
      };
      /**
       * Set whether the overview map should be collapsible.
       * @param {boolean} collapsible True if the widget is collapsible.
       * @api
       */
      OverviewMap.prototype.setCollapsible = function (collapsible) {
          if (this.collapsible_ === collapsible) {
              return;
          }
          this.collapsible_ = collapsible;
          this.element.classList.toggle('ol-uncollapsible');
          if (!collapsible && this.collapsed_) {
              this.handleToggle_();
          }
      };
      /**
       * Collapse or expand the overview map according to the passed parameter. Will
       * not do anything if the overview map isn't collapsible or if the current
       * collapsed state is already the one requested.
       * @param {boolean} collapsed True if the widget is collapsed.
       * @api
       */
      OverviewMap.prototype.setCollapsed = function (collapsed) {
          if (!this.collapsible_ || this.collapsed_ === collapsed) {
              return;
          }
          this.handleToggle_();
      };
      /**
       * Determine if the overview map is collapsed.
       * @return {boolean} The overview map is collapsed.
       * @api
       */
      OverviewMap.prototype.getCollapsed = function () {
          return this.collapsed_;
      };
      /**
       * Return `true` if the overview map view can rotate, `false` otherwise.
       * @return {boolean} True if the control view can rotate.
       * @api
       */
      OverviewMap.prototype.getRotateWithView = function () {
          return this.rotateWithView_;
      };
      /**
       * Set whether the overview map view should rotate with the main map view.
       * @param {boolean} rotateWithView True if the control view should rotate.
       * @api
       */
      OverviewMap.prototype.setRotateWithView = function (rotateWithView) {
          if (this.rotateWithView_ === rotateWithView) {
              return;
          }
          this.rotateWithView_ = rotateWithView;
          if (this.getMap().getView().getRotation() !== 0) {
              if (this.rotateWithView_) {
                  this.handleRotationChanged_();
              }
              else {
                  this.ovmap_.getView().setRotation(0);
              }
              this.viewExtent_ = undefined;
              this.validateExtent_();
              this.updateBox_();
          }
      };
      /**
       * Return the overview map.
       * @return {import("../PluggableMap.js").default} Overview map.
       * @api
       */
      OverviewMap.prototype.getOverviewMap = function () {
          return this.ovmap_;
      };
      /**
       * Update the overview map element.
       * @param {import("../MapEvent.js").default} mapEvent Map event.
       * @override
       */
      OverviewMap.prototype.render = function (mapEvent) {
          this.validateExtent_();
          this.updateBox_();
      };
      return OverviewMap;
  }(Control));

  /**
   * @module ol/control
   */
  /**
   * @typedef {Object} DefaultsOptions
   * @property {boolean} [attribution=true] Include
   * {@link module:ol/control/Attribution~Attribution}.
   * @property {import("./control/Attribution.js").Options} [attributionOptions]
   * Options for {@link module:ol/control/Attribution~Attribution}.
   * @property {boolean} [rotate=true] Include
   * {@link module:ol/control/Rotate~Rotate}.
   * @property {import("./control/Rotate.js").Options} [rotateOptions] Options
   * for {@link module:ol/control/Rotate~Rotate}.
   * @property {boolean} [zoom] Include {@link module:ol/control/Zoom~Zoom}.
   * @property {import("./control/Zoom.js").Options} [zoomOptions] Options for
   * {@link module:ol/control/Zoom~Zoom}.
   * @api
   */
  /**
   * Set of controls included in maps by default. Unless configured otherwise,
   * this returns a collection containing an instance of each of the following
   * controls:
   * * {@link module:ol/control/Zoom~Zoom}
   * * {@link module:ol/control/Rotate~Rotate}
   * * {@link module:ol/control/Attribution~Attribution}
   *
   * @param {DefaultsOptions=} opt_options
   * Defaults options.
   * @return {Collection<import("./control/Control.js").default>}
   * Controls.
   * @api
   */
  function defaults(opt_options) {
      var options = opt_options ? opt_options : {};
      var controls = new Collection();
      var zoomControl = options.zoom !== undefined ? options.zoom : true;
      if (zoomControl) {
          controls.push(new Zoom(options.zoomOptions));
      }
      var rotateControl = options.rotate !== undefined ? options.rotate : true;
      if (rotateControl) {
          controls.push(new Rotate(options.rotateOptions));
      }
      var attributionControl = options.attribution !== undefined ? options.attribution : true;
      if (attributionControl) {
          controls.push(new Attribution(options.attributionOptions));
      }
      return controls;
  }

  /**
   * @module ol/interaction/Property
   */
  /**
   * @enum {string}
   */
  var InteractionProperty = {
      ACTIVE: 'active',
  };

  var __extends$w = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * Object literal with config options for interactions.
   * @typedef {Object} InteractionOptions
   * @property {function(import("../MapBrowserEvent.js").default):boolean} handleEvent
   * Method called by the map to notify the interaction that a browser event was
   * dispatched to the map. If the function returns a falsy value, propagation of
   * the event to other interactions in the map's interactions chain will be
   * prevented (this includes functions with no explicit return). The interactions
   * are traversed in reverse order of the interactions collection of the map.
   */
  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * User actions that change the state of the map. Some are similar to controls,
   * but are not associated with a DOM element.
   * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is
   * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered
   * by a keyboard event not a button element event.
   * Although interactions do not have a DOM element, some of them do render
   * vectors and so are visible on the screen.
   * @api
   */
  var Interaction = /** @class */ (function (_super) {
      __extends$w(Interaction, _super);
      /**
       * @param {InteractionOptions=} opt_options Options.
       */
      function Interaction(opt_options) {
          var _this = _super.call(this) || this;
          if (opt_options && opt_options.handleEvent) {
              _this.handleEvent = opt_options.handleEvent;
          }
          /**
           * @private
           * @type {import("../PluggableMap.js").default}
           */
          _this.map_ = null;
          _this.setActive(true);
          return _this;
      }
      /**
       * Return whether the interaction is currently active.
       * @return {boolean} `true` if the interaction is active, `false` otherwise.
       * @observable
       * @api
       */
      Interaction.prototype.getActive = function () {
          return /** @type {boolean} */ (this.get(InteractionProperty.ACTIVE));
      };
      /**
       * Get the map associated with this interaction.
       * @return {import("../PluggableMap.js").default} Map.
       * @api
       */
      Interaction.prototype.getMap = function () {
          return this.map_;
      };
      /**
       * Handles the {@link module:ol/MapBrowserEvent map browser event}.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       * @api
       */
      Interaction.prototype.handleEvent = function (mapBrowserEvent) {
          return true;
      };
      /**
       * Activate or deactivate the interaction.
       * @param {boolean} active Active.
       * @observable
       * @api
       */
      Interaction.prototype.setActive = function (active) {
          this.set(InteractionProperty.ACTIVE, active);
      };
      /**
       * Remove the interaction from its current map and attach it to the new map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../PluggableMap.js").default} map Map.
       */
      Interaction.prototype.setMap = function (map) {
          this.map_ = map;
      };
      return Interaction;
  }(BaseObject));
  /**
   * @param {import("../View.js").default} view View.
   * @param {import("../coordinate.js").Coordinate} delta Delta.
   * @param {number=} opt_duration Duration.
   */
  function pan(view, delta, opt_duration) {
      var currentCenter = view.getCenterInternal();
      if (currentCenter) {
          var center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];
          view.animateInternal({
              duration: opt_duration !== undefined ? opt_duration : 250,
              easing: linear,
              center: view.getConstrainedCenter(center),
          });
      }
  }
  /**
   * @param {import("../View.js").default} view View.
   * @param {number} delta Delta from previous zoom level.
   * @param {import("../coordinate.js").Coordinate=} opt_anchor Anchor coordinate in the user projection.
   * @param {number=} opt_duration Duration.
   */
  function zoomByDelta(view, delta, opt_anchor, opt_duration) {
      var currentZoom = view.getZoom();
      if (currentZoom === undefined) {
          return;
      }
      var newZoom = view.getConstrainedZoom(currentZoom + delta);
      var newResolution = view.getResolutionForZoom(newZoom);
      if (view.getAnimating()) {
          view.cancelAnimations();
      }
      view.animate({
          resolution: newResolution,
          anchor: opt_anchor,
          duration: opt_duration !== undefined ? opt_duration : 250,
          easing: easeOut,
      });
  }

  var __extends$x = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {number} [duration=250] Animation duration in milliseconds.
   * @property {number} [delta=1] The zoom delta applied on each double click.
   */
  /**
   * @classdesc
   * Allows the user to zoom by double-clicking on the map.
   * @api
   */
  var DoubleClickZoom = /** @class */ (function (_super) {
      __extends$x(DoubleClickZoom, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function DoubleClickZoom(opt_options) {
          var _this = _super.call(this) || this;
          var options = opt_options ? opt_options : {};
          /**
           * @private
           * @type {number}
           */
          _this.delta_ = options.delta ? options.delta : 1;
          /**
           * @private
           * @type {number}
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 250;
          return _this;
      }
      /**
       * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a
       * doubleclick) and eventually zooms the map.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       */
      DoubleClickZoom.prototype.handleEvent = function (mapBrowserEvent) {
          var stopEvent = false;
          if (mapBrowserEvent.type == MapBrowserEventType.DBLCLICK) {
              var browserEvent = /** @type {MouseEvent} */ (mapBrowserEvent.originalEvent);
              var map = mapBrowserEvent.map;
              var anchor = mapBrowserEvent.coordinate;
              var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
              var view = map.getView();
              zoomByDelta(view, delta, anchor, this.duration_);
              mapBrowserEvent.preventDefault();
              stopEvent = true;
          }
          return !stopEvent;
      };
      return DoubleClickZoom;
  }(Interaction));

  var __extends$y = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleDownEvent]
   * Function handling "down" events. If the function returns `true` then a drag
   * sequence is started.
   * @property {function(import("../MapBrowserEvent.js").default):void} [handleDragEvent]
   * Function handling "drag" events. This function is called on "move" events
   * during a drag sequence.
   * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleEvent]
   * Method called by the map to notify the interaction that a browser event was
   * dispatched to the map. The function may return `false` to prevent the
   * propagation of the event to other interactions in the map's interactions
   * chain.
   * @property {function(import("../MapBrowserEvent.js").default):void} [handleMoveEvent]
   * Function handling "move" events. This function is called on "move" events.
   * This functions is also called during a drag sequence, so during a drag
   * sequence both the `handleDragEvent` function and this function are called.
   * If `handleDownEvent` is defined and it returns true this function will not
   * be called during a drag sequence.
   * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleUpEvent]
   *  Function handling "up" events. If the function returns `false` then the
   * current drag sequence is stopped.
   * @property {function(boolean):boolean} [stopDown]
   * Should the down event be propagated to other interactions, or should be
   * stopped?
   */
  /**
   * @classdesc
   * Base class that calls user-defined functions on `down`, `move` and `up`
   * events. This class also manages "drag sequences".
   *
   * When the `handleDownEvent` user function returns `true` a drag sequence is
   * started. During a drag sequence the `handleDragEvent` user function is
   * called on `move` events. The drag sequence ends when the `handleUpEvent`
   * user function is called and returns `false`.
   * @api
   */
  var PointerInteraction = /** @class */ (function (_super) {
      __extends$y(PointerInteraction, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function PointerInteraction(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, 
          /** @type {import("./Interaction.js").InteractionOptions} */ (options)) || this;
          if (options.handleDownEvent) {
              _this.handleDownEvent = options.handleDownEvent;
          }
          if (options.handleDragEvent) {
              _this.handleDragEvent = options.handleDragEvent;
          }
          if (options.handleMoveEvent) {
              _this.handleMoveEvent = options.handleMoveEvent;
          }
          if (options.handleUpEvent) {
              _this.handleUpEvent = options.handleUpEvent;
          }
          if (options.stopDown) {
              _this.stopDown = options.stopDown;
          }
          /**
           * @type {boolean}
           * @protected
           */
          _this.handlingDownUpSequence = false;
          /**
           * @type {!Object<string, PointerEvent>}
           * @private
           */
          _this.trackedPointers_ = {};
          /**
           * @type {Array<PointerEvent>}
           * @protected
           */
          _this.targetPointers = [];
          return _this;
      }
      /**
       * Returns the current number of pointers involved in the interaction,
       * e.g. `2` when two fingers are used.
       * @return {number} The number of pointers.
       * @api
       */
      PointerInteraction.prototype.getPointerCount = function () {
          return this.targetPointers.length;
      };
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       * @protected
       */
      PointerInteraction.prototype.handleDownEvent = function (mapBrowserEvent) {
          return false;
      };
      /**
       * Handle pointer drag events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @protected
       */
      PointerInteraction.prototype.handleDragEvent = function (mapBrowserEvent) { };
      /**
       * Handles the {@link module:ol/MapBrowserEvent map browser event} and may call into
       * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
       * detected.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       * @api
       */
      PointerInteraction.prototype.handleEvent = function (mapBrowserEvent) {
          if (!mapBrowserEvent.originalEvent) {
              return true;
          }
          var stopEvent = false;
          this.updateTrackedPointers_(mapBrowserEvent);
          if (this.handlingDownUpSequence) {
              if (mapBrowserEvent.type == MapBrowserEventType.POINTERDRAG) {
                  this.handleDragEvent(mapBrowserEvent);
                  // prevent page scrolling during dragging
                  mapBrowserEvent.preventDefault();
              }
              else if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {
                  var handledUp = this.handleUpEvent(mapBrowserEvent);
                  this.handlingDownUpSequence =
                      handledUp && this.targetPointers.length > 0;
              }
          }
          else {
              if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {
                  var handled = this.handleDownEvent(mapBrowserEvent);
                  this.handlingDownUpSequence = handled;
                  stopEvent = this.stopDown(handled);
              }
              else if (mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE) {
                  this.handleMoveEvent(mapBrowserEvent);
              }
          }
          return !stopEvent;
      };
      /**
       * Handle pointer move events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @protected
       */
      PointerInteraction.prototype.handleMoveEvent = function (mapBrowserEvent) { };
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       * @protected
       */
      PointerInteraction.prototype.handleUpEvent = function (mapBrowserEvent) {
          return false;
      };
      /**
       * This function is used to determine if "down" events should be propagated
       * to other interactions or should be stopped.
       * @param {boolean} handled Was the event handled by the interaction?
       * @return {boolean} Should the `down` event be stopped?
       */
      PointerInteraction.prototype.stopDown = function (handled) {
          return handled;
      };
      /**
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @private
       */
      PointerInteraction.prototype.updateTrackedPointers_ = function (mapBrowserEvent) {
          if (isPointerDraggingEvent(mapBrowserEvent)) {
              var event_1 = mapBrowserEvent.originalEvent;
              var id = event_1.pointerId.toString();
              if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {
                  delete this.trackedPointers_[id];
              }
              else if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {
                  this.trackedPointers_[id] = event_1;
              }
              else if (id in this.trackedPointers_) {
                  // update only when there was a pointerdown event for this pointer
                  this.trackedPointers_[id] = event_1;
              }
              this.targetPointers = getValues(this.trackedPointers_);
          }
      };
      return PointerInteraction;
  }(Interaction));
  /**
   * @param {Array<PointerEvent>} pointerEvents List of events.
   * @return {import("../pixel.js").Pixel} Centroid pixel.
   */
  function centroid(pointerEvents) {
      var length = pointerEvents.length;
      var clientX = 0;
      var clientY = 0;
      for (var i = 0; i < length; i++) {
          clientX += pointerEvents[i].clientX;
          clientY += pointerEvents[i].clientY;
      }
      return [clientX / length, clientY / length];
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} Whether the event is a pointerdown, pointerdrag
   *     or pointerup event.
   */
  function isPointerDraggingEvent(mapBrowserEvent) {
      var type = mapBrowserEvent.type;
      return (type === MapBrowserEventType.POINTERDOWN ||
          type === MapBrowserEventType.POINTERDRAG ||
          type === MapBrowserEventType.POINTERUP);
  }

  /**
   * @module ol/events/condition
   */
  /**
   * A function that takes an {@link module:ol/MapBrowserEvent} and returns a
   * `{boolean}`. If the condition is met, true should be returned.
   *
   * @typedef {function(this: ?, import("../MapBrowserEvent.js").default): boolean} Condition
   */
  /**
   * Creates a condition function that passes when all provided conditions pass.
   * @param {...Condition} var_args Conditions to check.
   * @return {Condition} Condition function.
   */
  function all(var_args) {
      var conditions = arguments;
      /**
       * @param {import("../MapBrowserEvent.js").default} event Event.
       * @return {boolean} All conditions passed.
       */
      return function (event) {
          var pass = true;
          for (var i = 0, ii = conditions.length; i < ii; ++i) {
              pass = pass && conditions[i](event);
              if (!pass) {
                  break;
              }
          }
          return pass;
      };
  }
  /**
   * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise
   * (e.g. when additionally the platform-modifier-key is pressed).
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True if only the alt and shift keys are pressed.
   * @api
   */
  var altShiftKeysOnly = function (mapBrowserEvent) {
      var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
      return (originalEvent.altKey &&
          !(originalEvent.metaKey || originalEvent.ctrlKey) &&
          originalEvent.shiftKey);
  };
  /**
   * Return `true` if the map has the focus. This condition requires a map target
   * element with a `tabindex` attribute, e.g. `<div id="map" tabindex="1">`.
   *
   * @param {import("../MapBrowserEvent.js").default} event Map browser event.
   * @return {boolean} The map has the focus.
   * @api
   */
  var focus = function (event) {
      return event.target.getTargetElement().contains(document.activeElement);
  };
  /**
   * Return `true` if the map has the focus or no 'tabindex' attribute set.
   *
   * @param {import("../MapBrowserEvent.js").default} event Map browser event.
   * @return {boolean} The map container has the focus or no 'tabindex' attribute.
   */
  var focusWithTabindex = function (event) {
      return event.map.getTargetElement().hasAttribute('tabindex')
          ? focus(event)
          : true;
  };
  /**
   * Return always true.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True.
   * @api
   */
  var always = TRUE;
  /**
   * Return `true` if the event has an "action"-producing mouse button.
   *
   * By definition, this includes left-click on windows/linux, and left-click
   * without the ctrl key on Macs.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} The result.
   */
  var mouseActionButton = function (mapBrowserEvent) {
      var originalEvent = /** @type {MouseEvent} */ (mapBrowserEvent.originalEvent);
      return originalEvent.button == 0 && !(WEBKIT && MAC && originalEvent.ctrlKey);
  };
  /**
   * Return always false.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} False.
   * @api
   */
  var never = FALSE;
  /**
   * Return `true` if the event is a map `singleclick` event, `false` otherwise.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True if the event is a map `singleclick` event.
   * @api
   */
  var singleClick = function (mapBrowserEvent) {
      return mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK;
  };
  /**
   * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is
   * pressed.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True only if there no modifier keys are pressed.
   * @api
   */
  var noModifierKeys = function (mapBrowserEvent) {
      var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
      return (!originalEvent.altKey &&
          !(originalEvent.metaKey || originalEvent.ctrlKey) &&
          !originalEvent.shiftKey);
  };
  /**
   * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when
   * additionally the alt-key is pressed).
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True if only the shift key is pressed.
   * @api
   */
  var shiftKeyOnly = function (mapBrowserEvent) {
      var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
      return (!originalEvent.altKey &&
          !(originalEvent.metaKey || originalEvent.ctrlKey) &&
          originalEvent.shiftKey);
  };
  /**
   * Return `true` if the target element is not editable, i.e. not a `<input>`-,
   * `<select>`- or `<textarea>`-element, `false` otherwise.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True only if the target element is not editable.
   * @api
   */
  var targetNotEditable = function (mapBrowserEvent) {
      var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
      var tagName = /** @type {Element} */ (originalEvent.target).tagName;
      return tagName !== 'INPUT' && tagName !== 'SELECT' && tagName !== 'TEXTAREA';
  };
  /**
   * Return `true` if the event originates from a mouse device.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True if the event originates from a mouse device.
   * @api
   */
  var mouseOnly = function (mapBrowserEvent) {
      var pointerEvent = /** @type {import("../MapBrowserEvent").default} */ (mapBrowserEvent)
          .originalEvent;
      assert(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event
      // see http://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
      return pointerEvent.pointerType == 'mouse';
  };
  /**
   * Return `true` if the event originates from a primary pointer in
   * contact with the surface or if the left mouse button is pressed.
   * See http://www.w3.org/TR/pointerevents/#button-states.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True if the event originates from a primary pointer.
   * @api
   */
  var primaryAction = function (mapBrowserEvent) {
      var pointerEvent = /** @type {import("../MapBrowserEvent").default} */ (mapBrowserEvent)
          .originalEvent;
      assert(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event
      return pointerEvent.isPrimary && pointerEvent.button === 0;
  };

  var __extends$z = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
   * to indicate whether that event should be handled.
   * Default is {@link module:ol/events/condition~noModifierKeys} and {@link module:ol/events/condition~primaryAction}.
   * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
   * the interaction will only handle events when the map has the focus.
   * @property {import("../Kinetic.js").default} [kinetic] Kinetic inertia to apply to the pan.
   */
  /**
   * @classdesc
   * Allows the user to pan the map by dragging the map.
   * @api
   */
  var DragPan = /** @class */ (function (_super) {
      __extends$z(DragPan, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function DragPan(opt_options) {
          var _this = _super.call(this, {
              stopDown: FALSE,
          }) || this;
          var options = opt_options ? opt_options : {};
          /**
           * @private
           * @type {import("../Kinetic.js").default|undefined}
           */
          _this.kinetic_ = options.kinetic;
          /**
           * @type {import("../pixel.js").Pixel}
           */
          _this.lastCentroid = null;
          /**
           * @type {number}
           */
          _this.lastPointersCount_;
          /**
           * @type {boolean}
           */
          _this.panning_ = false;
          var condition = options.condition
              ? options.condition
              : all(noModifierKeys, primaryAction);
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.condition_ = options.onFocusOnly
              ? all(focusWithTabindex, condition)
              : condition;
          /**
           * @private
           * @type {boolean}
           */
          _this.noKinetic_ = false;
          return _this;
      }
      /**
       * Handle pointer drag events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       */
      DragPan.prototype.handleDragEvent = function (mapBrowserEvent) {
          if (!this.panning_) {
              this.panning_ = true;
              this.getMap().getView().beginInteraction();
          }
          var targetPointers = this.targetPointers;
          var centroid$1 = centroid(targetPointers);
          if (targetPointers.length == this.lastPointersCount_) {
              if (this.kinetic_) {
                  this.kinetic_.update(centroid$1[0], centroid$1[1]);
              }
              if (this.lastCentroid) {
                  var delta = [
                      this.lastCentroid[0] - centroid$1[0],
                      centroid$1[1] - this.lastCentroid[1],
                  ];
                  var map = mapBrowserEvent.map;
                  var view = map.getView();
                  scale$1(delta, view.getResolution());
                  rotate$1(delta, view.getRotation());
                  view.adjustCenterInternal(delta);
              }
          }
          else if (this.kinetic_) {
              // reset so we don't overestimate the kinetic energy after
              // after one finger down, tiny drag, second finger down
              this.kinetic_.begin();
          }
          this.lastCentroid = centroid$1;
          this.lastPointersCount_ = targetPointers.length;
          mapBrowserEvent.originalEvent.preventDefault();
      };
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      DragPan.prototype.handleUpEvent = function (mapBrowserEvent) {
          var map = mapBrowserEvent.map;
          var view = map.getView();
          if (this.targetPointers.length === 0) {
              if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
                  var distance = this.kinetic_.getDistance();
                  var angle = this.kinetic_.getAngle();
                  var center = view.getCenterInternal();
                  var centerpx = map.getPixelFromCoordinateInternal(center);
                  var dest = map.getCoordinateFromPixelInternal([
                      centerpx[0] - distance * Math.cos(angle),
                      centerpx[1] - distance * Math.sin(angle),
                  ]);
                  view.animateInternal({
                      center: view.getConstrainedCenter(dest),
                      duration: 500,
                      easing: easeOut,
                  });
              }
              if (this.panning_) {
                  this.panning_ = false;
                  view.endInteraction();
              }
              return false;
          }
          else {
              if (this.kinetic_) {
                  // reset so we don't overestimate the kinetic energy after
                  // after one finger up, tiny drag, second finger up
                  this.kinetic_.begin();
              }
              this.lastCentroid = null;
              return true;
          }
      };
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      DragPan.prototype.handleDownEvent = function (mapBrowserEvent) {
          if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
              var map = mapBrowserEvent.map;
              var view = map.getView();
              this.lastCentroid = null;
              // stop any current animation
              if (view.getAnimating()) {
                  view.cancelAnimations();
              }
              if (this.kinetic_) {
                  this.kinetic_.begin();
              }
              // No kinetic as soon as more than one pointer on the screen is
              // detected. This is to prevent nasty pans after pinch.
              this.noKinetic_ = this.targetPointers.length > 1;
              return true;
          }
          else {
              return false;
          }
      };
      return DragPan;
  }(PointerInteraction));

  var __extends$A = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {import("../events/condition.js").Condition} [condition] A function that takes an
   * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
   * to indicate whether that event should be handled.
   * Default is {@link module:ol/events/condition~altShiftKeysOnly}.
   * @property {number} [duration=250] Animation duration in milliseconds.
   */
  /**
   * @classdesc
   * Allows the user to rotate the map by clicking and dragging on the map,
   * normally combined with an {@link module:ol/events/condition} that limits
   * it to when the alt and shift keys are held down.
   *
   * This interaction is only supported for mouse devices.
   * @api
   */
  var DragRotate = /** @class */ (function (_super) {
      __extends$A(DragRotate, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function DragRotate(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, {
              stopDown: FALSE,
          }) || this;
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.condition_ = options.condition ? options.condition : altShiftKeysOnly;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.lastAngle_ = undefined;
          /**
           * @private
           * @type {number}
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 250;
          return _this;
      }
      /**
       * Handle pointer drag events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       */
      DragRotate.prototype.handleDragEvent = function (mapBrowserEvent) {
          if (!mouseOnly(mapBrowserEvent)) {
              return;
          }
          var map = mapBrowserEvent.map;
          var view = map.getView();
          if (view.getConstraints().rotation === disable) {
              return;
          }
          var size = map.getSize();
          var offset = mapBrowserEvent.pixel;
          var theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
          if (this.lastAngle_ !== undefined) {
              var delta = theta - this.lastAngle_;
              view.adjustRotationInternal(-delta);
          }
          this.lastAngle_ = theta;
      };
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      DragRotate.prototype.handleUpEvent = function (mapBrowserEvent) {
          if (!mouseOnly(mapBrowserEvent)) {
              return true;
          }
          var map = mapBrowserEvent.map;
          var view = map.getView();
          view.endInteraction(this.duration_);
          return false;
      };
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      DragRotate.prototype.handleDownEvent = function (mapBrowserEvent) {
          if (!mouseOnly(mapBrowserEvent)) {
              return false;
          }
          if (mouseActionButton(mapBrowserEvent) &&
              this.condition_(mapBrowserEvent)) {
              var map = mapBrowserEvent.map;
              map.getView().beginInteraction();
              this.lastAngle_ = undefined;
              return true;
          }
          else {
              return false;
          }
      };
      return DragRotate;
  }(PointerInteraction));

  /**
   * @module ol/render/Box
   */
  var __extends$B = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var RenderBox = /** @class */ (function (_super) {
      __extends$B(RenderBox, _super);
      /**
       * @param {string} className CSS class name.
       */
      function RenderBox(className) {
          var _this = _super.call(this) || this;
          /**
           * @type {import("../geom/Polygon.js").default}
           * @private
           */
          _this.geometry_ = null;
          /**
           * @type {HTMLDivElement}
           * @private
           */
          _this.element_ = document.createElement('div');
          _this.element_.style.position = 'absolute';
          _this.element_.style.pointerEvents = 'auto';
          _this.element_.className = 'ol-box ' + className;
          /**
           * @private
           * @type {import("../PluggableMap.js").default}
           */
          _this.map_ = null;
          /**
           * @private
           * @type {import("../pixel.js").Pixel}
           */
          _this.startPixel_ = null;
          /**
           * @private
           * @type {import("../pixel.js").Pixel}
           */
          _this.endPixel_ = null;
          return _this;
      }
      /**
       * Clean up.
       */
      RenderBox.prototype.disposeInternal = function () {
          this.setMap(null);
      };
      /**
       * @private
       */
      RenderBox.prototype.render_ = function () {
          var startPixel = this.startPixel_;
          var endPixel = this.endPixel_;
          var px = 'px';
          var style = this.element_.style;
          style.left = Math.min(startPixel[0], endPixel[0]) + px;
          style.top = Math.min(startPixel[1], endPixel[1]) + px;
          style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
          style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
      };
      /**
       * @param {import("../PluggableMap.js").default} map Map.
       */
      RenderBox.prototype.setMap = function (map) {
          if (this.map_) {
              this.map_.getOverlayContainer().removeChild(this.element_);
              var style = this.element_.style;
              style.left = 'inherit';
              style.top = 'inherit';
              style.width = 'inherit';
              style.height = 'inherit';
          }
          this.map_ = map;
          if (this.map_) {
              this.map_.getOverlayContainer().appendChild(this.element_);
          }
      };
      /**
       * @param {import("../pixel.js").Pixel} startPixel Start pixel.
       * @param {import("../pixel.js").Pixel} endPixel End pixel.
       */
      RenderBox.prototype.setPixels = function (startPixel, endPixel) {
          this.startPixel_ = startPixel;
          this.endPixel_ = endPixel;
          this.createOrUpdateGeometry();
          this.render_();
      };
      /**
       * Creates or updates the cached geometry.
       */
      RenderBox.prototype.createOrUpdateGeometry = function () {
          var startPixel = this.startPixel_;
          var endPixel = this.endPixel_;
          var pixels = [
              startPixel,
              [startPixel[0], endPixel[1]],
              endPixel,
              [endPixel[0], startPixel[1]],
          ];
          var coordinates = pixels.map(this.map_.getCoordinateFromPixelInternal, this.map_);
          // close the polygon
          coordinates[4] = coordinates[0].slice();
          if (!this.geometry_) {
              this.geometry_ = new Polygon([coordinates]);
          }
          else {
              this.geometry_.setCoordinates([coordinates]);
          }
      };
      /**
       * @return {import("../geom/Polygon.js").default} Geometry.
       */
      RenderBox.prototype.getGeometry = function () {
          return this.geometry_;
      };
      return RenderBox;
  }(Disposable));

  var __extends$C = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * A function that takes a {@link module:ol/MapBrowserEvent} and two
   * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,
   * true should be returned.
   * @typedef {function(this: ?, import("../MapBrowserEvent.js").default, import("../pixel.js").Pixel, import("../pixel.js").Pixel):boolean} EndCondition
   */
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-dragbox'] CSS class name for styling the box.
   * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
   * to indicate whether that event should be handled.
   * Default is {@link ol/events/condition~mouseActionButton}.
   * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default
   * `boxEndCondition` function.
   * @property {EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
   * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.
   * Default is `true` if the area of the box is bigger than the `minArea` option.
   * @property {function(this:DragBox, import("../MapBrowserEvent.js").default):void} [onBoxEnd] Code to execute just
   * before `boxend` is fired.
   */
  /**
   * @enum {string}
   */
  var DragBoxEventType = {
      /**
       * Triggered upon drag box start.
       * @event DragBoxEvent#boxstart
       * @api
       */
      BOXSTART: 'boxstart',
      /**
       * Triggered on drag when box is active.
       * @event DragBoxEvent#boxdrag
       * @api
       */
      BOXDRAG: 'boxdrag',
      /**
       * Triggered upon drag box end.
       * @event DragBoxEvent#boxend
       * @api
       */
      BOXEND: 'boxend',
  };
  /**
   * @classdesc
   * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of
   * this type.
   */
  var DragBoxEvent = /** @class */ (function (_super) {
      __extends$C(DragBoxEvent, _super);
      /**
       * @param {string} type The event type.
       * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
       */
      function DragBoxEvent(type, coordinate, mapBrowserEvent) {
          var _this = _super.call(this, type) || this;
          /**
           * The coordinate of the drag event.
           * @const
           * @type {import("../coordinate.js").Coordinate}
           * @api
           */
          _this.coordinate = coordinate;
          /**
           * @const
           * @type {import("../MapBrowserEvent.js").default}
           * @api
           */
          _this.mapBrowserEvent = mapBrowserEvent;
          return _this;
      }
      return DragBoxEvent;
  }(BaseEvent));
  /**
   * @classdesc
   * Allows the user to draw a vector box by clicking and dragging on the map,
   * normally combined with an {@link module:ol/events/condition} that limits
   * it to when the shift or other key is held down. This is used, for example,
   * for zooming to a specific area of the map
   * (see {@link module:ol/interaction/DragZoom~DragZoom} and
   * {@link module:ol/interaction/DragRotateAndZoom}).
   *
   * @fires DragBoxEvent
   * @api
   */
  var DragBox = /** @class */ (function (_super) {
      __extends$C(DragBox, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function DragBox(opt_options) {
          var _this = _super.call(this) || this;
          var options = opt_options ? opt_options : {};
          /**
           * @type {import("../render/Box.js").default}
           * @private
           */
          _this.box_ = new RenderBox(options.className || 'ol-dragbox');
          /**
           * @type {number}
           * @private
           */
          _this.minArea_ = options.minArea !== undefined ? options.minArea : 64;
          if (options.onBoxEnd) {
              _this.onBoxEnd = options.onBoxEnd;
          }
          /**
           * @type {import("../pixel.js").Pixel}
           * @private
           */
          _this.startPixel_ = null;
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.condition_ = options.condition ? options.condition : mouseActionButton;
          /**
           * @private
           * @type {EndCondition}
           */
          _this.boxEndCondition_ = options.boxEndCondition
              ? options.boxEndCondition
              : _this.defaultBoxEndCondition;
          return _this;
      }
      /**
       * The default condition for determining whether the boxend event
       * should fire.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
       *     leading to the box end.
       * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
       * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
       * @return {boolean} Whether or not the boxend condition should be fired.
       */
      DragBox.prototype.defaultBoxEndCondition = function (mapBrowserEvent, startPixel, endPixel) {
          var width = endPixel[0] - startPixel[0];
          var height = endPixel[1] - startPixel[1];
          return width * width + height * height >= this.minArea_;
      };
      /**
       * Returns geometry of last drawn box.
       * @return {import("../geom/Polygon.js").default} Geometry.
       * @api
       */
      DragBox.prototype.getGeometry = function () {
          return this.box_.getGeometry();
      };
      /**
       * Handle pointer drag events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       */
      DragBox.prototype.handleDragEvent = function (mapBrowserEvent) {
          this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
          this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));
      };
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      DragBox.prototype.handleUpEvent = function (mapBrowserEvent) {
          this.box_.setMap(null);
          if (this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel)) {
              this.onBoxEnd(mapBrowserEvent);
              this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXEND, mapBrowserEvent.coordinate, mapBrowserEvent));
          }
          return false;
      };
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      DragBox.prototype.handleDownEvent = function (mapBrowserEvent) {
          if (this.condition_(mapBrowserEvent)) {
              this.startPixel_ = mapBrowserEvent.pixel;
              this.box_.setMap(mapBrowserEvent.map);
              this.box_.setPixels(this.startPixel_, this.startPixel_);
              this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));
              return true;
          }
          else {
              return false;
          }
      };
      /**
       * Function to execute just before `onboxend` is fired
       * @param {import("../MapBrowserEvent.js").default} event Event.
       */
      DragBox.prototype.onBoxEnd = function (event) { };
      return DragBox;
  }(PointerInteraction));

  var __extends$D = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-dragzoom'] CSS class name for styling the
   * box.
   * @property {import("../events/condition.js").Condition} [condition] A function that
   * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled.
   * Default is {@link module:ol/events/condition~shiftKeyOnly}.
   * @property {number} [duration=200] Animation duration in milliseconds.
   * @property {boolean} [out=false] Use interaction for zooming out.
   * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the parent default
   * `boxEndCondition` function.
   */
  /**
   * @classdesc
   * Allows the user to zoom the map by clicking and dragging on the map,
   * normally combined with an {@link module:ol/events/condition} that limits
   * it to when a key, shift by default, is held down.
   *
   * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
   * your custom one configured with `className`.
   * @api
   */
  var DragZoom = /** @class */ (function (_super) {
      __extends$D(DragZoom, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function DragZoom(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          var condition = options.condition ? options.condition : shiftKeyOnly;
          _this = _super.call(this, {
              condition: condition,
              className: options.className || 'ol-dragzoom',
              minArea: options.minArea,
          }) || this;
          /**
           * @private
           * @type {number}
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 200;
          /**
           * @private
           * @type {boolean}
           */
          _this.out_ = options.out !== undefined ? options.out : false;
          return _this;
      }
      /**
       * Function to execute just before `onboxend` is fired
       * @param {import("../MapBrowserEvent.js").default} event Event.
       */
      DragZoom.prototype.onBoxEnd = function (event) {
          var map = this.getMap();
          var view = /** @type {!import("../View.js").default} */ (map.getView());
          var size = /** @type {!import("../size.js").Size} */ (map.getSize());
          var extent = this.getGeometry().getExtent();
          if (this.out_) {
              var mapExtent = view.calculateExtentInternal(size);
              var boxPixelExtent = createOrUpdateFromCoordinates([
                  map.getPixelFromCoordinateInternal(getBottomLeft(extent)),
                  map.getPixelFromCoordinateInternal(getTopRight(extent)),
              ]);
              var factor = view.getResolutionForExtentInternal(boxPixelExtent, size);
              scaleFromCenter(mapExtent, 1 / factor);
              extent = mapExtent;
          }
          var resolution = view.getConstrainedResolution(view.getResolutionForExtentInternal(extent, size));
          var center = view.getConstrainedCenter(getCenter(extent), resolution);
          view.animateInternal({
              resolution: resolution,
              center: center,
              duration: this.duration_,
              easing: easeOut,
          });
      };
      return DragZoom;
  }(DragBox));

  /**
   * @module ol/events/KeyCode
   */
  /**
   * @enum {number}
   * @const
   */
  var KeyCode = {
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40,
  };

  var __extends$E = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {import("../events/condition.js").Condition} [condition] A function that
   * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled. Default is
   * {@link module:ol/events/condition~noModifierKeys} and
   * {@link module:ol/events/condition~targetNotEditable}.
   * @property {number} [duration=100] Animation duration in milliseconds.
   * @property {number} [pixelDelta=128] The amount of pixels to pan on each key
   * press.
   */
  /**
   * @classdesc
   * Allows the user to pan the map using keyboard arrows.
   * Note that, although this interaction is by default included in maps,
   * the keys can only be used when browser focus is on the element to which
   * the keyboard events are attached. By default, this is the map div,
   * though you can change this with the `keyboardEventTarget` in
   * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
   * element, focus will have to be on, and returned to, this element if the keys
   * are to function.
   * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.
   * @api
   */
  var KeyboardPan = /** @class */ (function (_super) {
      __extends$E(KeyboardPan, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function KeyboardPan(opt_options) {
          var _this = _super.call(this) || this;
          var options = opt_options || {};
          /**
           * @private
           * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
           * @return {boolean} Combined condition result.
           */
          _this.defaultCondition_ = function (mapBrowserEvent) {
              return (noModifierKeys(mapBrowserEvent) && targetNotEditable(mapBrowserEvent));
          };
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.condition_ =
              options.condition !== undefined
                  ? options.condition
                  : _this.defaultCondition_;
          /**
           * @private
           * @type {number}
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 100;
          /**
           * @private
           * @type {number}
           */
          _this.pixelDelta_ =
              options.pixelDelta !== undefined ? options.pixelDelta : 128;
          return _this;
      }
      /**
       * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a
       * `KeyEvent`, and decides the direction to pan to (if an arrow key was
       * pressed).
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       * @this {KeyboardPan}
       */
      KeyboardPan.prototype.handleEvent = function (mapBrowserEvent) {
          var stopEvent = false;
          if (mapBrowserEvent.type == EventType.KEYDOWN) {
              var keyEvent = /** @type {KeyboardEvent} */ (mapBrowserEvent.originalEvent);
              var keyCode = keyEvent.keyCode;
              if (this.condition_(mapBrowserEvent) &&
                  (keyCode == KeyCode.DOWN ||
                      keyCode == KeyCode.LEFT ||
                      keyCode == KeyCode.RIGHT ||
                      keyCode == KeyCode.UP)) {
                  var map = mapBrowserEvent.map;
                  var view = map.getView();
                  var mapUnitsDelta = view.getResolution() * this.pixelDelta_;
                  var deltaX = 0, deltaY = 0;
                  if (keyCode == KeyCode.DOWN) {
                      deltaY = -mapUnitsDelta;
                  }
                  else if (keyCode == KeyCode.LEFT) {
                      deltaX = -mapUnitsDelta;
                  }
                  else if (keyCode == KeyCode.RIGHT) {
                      deltaX = mapUnitsDelta;
                  }
                  else {
                      deltaY = mapUnitsDelta;
                  }
                  var delta = [deltaX, deltaY];
                  rotate$1(delta, view.getRotation());
                  pan(view, delta, this.duration_);
                  mapBrowserEvent.preventDefault();
                  stopEvent = true;
              }
          }
          return !stopEvent;
      };
      return KeyboardPan;
  }(Interaction));

  var __extends$F = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {number} [duration=100] Animation duration in milliseconds.
   * @property {import("../events/condition.js").Condition} [condition] A function that
   * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled. Default is
   * {@link module:ol/events/condition~targetNotEditable}.
   * @property {number} [delta=1] The zoom level delta on each key press.
   */
  /**
   * @classdesc
   * Allows the user to zoom the map using keyboard + and -.
   * Note that, although this interaction is by default included in maps,
   * the keys can only be used when browser focus is on the element to which
   * the keyboard events are attached. By default, this is the map div,
   * though you can change this with the `keyboardEventTarget` in
   * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
   * element, focus will have to be on, and returned to, this element if the keys
   * are to function.
   * See also {@link module:ol/interaction/KeyboardPan~KeyboardPan}.
   * @api
   */
  var KeyboardZoom = /** @class */ (function (_super) {
      __extends$F(KeyboardZoom, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function KeyboardZoom(opt_options) {
          var _this = _super.call(this) || this;
          var options = opt_options ? opt_options : {};
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.condition_ = options.condition ? options.condition : targetNotEditable;
          /**
           * @private
           * @type {number}
           */
          _this.delta_ = options.delta ? options.delta : 1;
          /**
           * @private
           * @type {number}
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 100;
          return _this;
      }
      /**
       * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a
       * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
       * key pressed was '+' or '-').
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       * @this {KeyboardZoom}
       */
      KeyboardZoom.prototype.handleEvent = function (mapBrowserEvent) {
          var stopEvent = false;
          if (mapBrowserEvent.type == EventType.KEYDOWN ||
              mapBrowserEvent.type == EventType.KEYPRESS) {
              var keyEvent = /** @type {KeyboardEvent} */ (mapBrowserEvent.originalEvent);
              var charCode = keyEvent.charCode;
              if (this.condition_(mapBrowserEvent) &&
                  (charCode == '+'.charCodeAt(0) || charCode == '-'.charCodeAt(0))) {
                  var map = mapBrowserEvent.map;
                  var delta = charCode == '+'.charCodeAt(0) ? this.delta_ : -this.delta_;
                  var view = map.getView();
                  zoomByDelta(view, delta, undefined, this.duration_);
                  mapBrowserEvent.preventDefault();
                  stopEvent = true;
              }
          }
          return !stopEvent;
      };
      return KeyboardZoom;
  }(Interaction));

  /**
   * @module ol/Kinetic
   */
  /**
   * @classdesc
   * Implementation of inertial deceleration for map movement.
   *
   * @api
   */
  var Kinetic = /** @class */ (function () {
      /**
       * @param {number} decay Rate of decay (must be negative).
       * @param {number} minVelocity Minimum velocity (pixels/millisecond).
       * @param {number} delay Delay to consider to calculate the kinetic
       *     initial values (milliseconds).
       */
      function Kinetic(decay, minVelocity, delay) {
          /**
           * @private
           * @type {number}
           */
          this.decay_ = decay;
          /**
           * @private
           * @type {number}
           */
          this.minVelocity_ = minVelocity;
          /**
           * @private
           * @type {number}
           */
          this.delay_ = delay;
          /**
           * @private
           * @type {Array<number>}
           */
          this.points_ = [];
          /**
           * @private
           * @type {number}
           */
          this.angle_ = 0;
          /**
           * @private
           * @type {number}
           */
          this.initialVelocity_ = 0;
      }
      /**
       * FIXME empty description for jsdoc
       */
      Kinetic.prototype.begin = function () {
          this.points_.length = 0;
          this.angle_ = 0;
          this.initialVelocity_ = 0;
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       */
      Kinetic.prototype.update = function (x, y) {
          this.points_.push(x, y, Date.now());
      };
      /**
       * @return {boolean} Whether we should do kinetic animation.
       */
      Kinetic.prototype.end = function () {
          if (this.points_.length < 6) {
              // at least 2 points are required (i.e. there must be at least 6 elements
              // in the array)
              return false;
          }
          var delay = Date.now() - this.delay_;
          var lastIndex = this.points_.length - 3;
          if (this.points_[lastIndex + 2] < delay) {
              // the last tracked point is too old, which means that the user stopped
              // panning before releasing the map
              return false;
          }
          // get the first point which still falls into the delay time
          var firstIndex = lastIndex - 3;
          while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
              firstIndex -= 3;
          }
          var duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
          // we don't want a duration of 0 (divide by zero)
          // we also make sure the user panned for a duration of at least one frame
          // (1/60s) to compute sane displacement values
          if (duration < 1000 / 60) {
              return false;
          }
          var dx = this.points_[lastIndex] - this.points_[firstIndex];
          var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
          this.angle_ = Math.atan2(dy, dx);
          this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
          return this.initialVelocity_ > this.minVelocity_;
      };
      /**
       * @return {number} Total distance travelled (pixels).
       */
      Kinetic.prototype.getDistance = function () {
          return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
      };
      /**
       * @return {number} Angle of the kinetic panning animation (radians).
       */
      Kinetic.prototype.getAngle = function () {
          return this.angle_;
      };
      return Kinetic;
  }());

  var __extends$G = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @enum {string}
   */
  var Mode = {
      TRACKPAD: 'trackpad',
      WHEEL: 'wheel',
  };
  /**
   * @typedef {Object} Options
   * @property {import("../events/condition.js").Condition} [condition] A function that
   * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled. Default is
   * {@link module:ol/events/condition~always}.
   * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
   * the interaction will only handle events when the map has the focus.
   * @property {number} [maxDelta=1] Maximum mouse wheel delta.
   * @property {number} [duration=250] Animation duration in milliseconds.
   * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.
   * @property {boolean} [useAnchor=true] Enable zooming using the mouse's
   * location as the anchor. When set to `false`, zooming in and out will zoom to
   * the center of the screen instead of zooming on the mouse's location.
   * @property {boolean} [constrainResolution=false] If true, the mouse wheel zoom
   * event will always animate to the closest zoom level after an interaction;
   * false means intermediary zoom levels are allowed.
   */
  /**
   * @classdesc
   * Allows the user to zoom the map by scrolling the mouse wheel.
   * @api
   */
  var MouseWheelZoom = /** @class */ (function (_super) {
      __extends$G(MouseWheelZoom, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function MouseWheelZoom(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, 
          /** @type {import("./Interaction.js").InteractionOptions} */ (options)) || this;
          /**
           * @private
           * @type {number}
           */
          _this.totalDelta_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.lastDelta_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.maxDelta_ = options.maxDelta !== undefined ? options.maxDelta : 1;
          /**
           * @private
           * @type {number}
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 250;
          /**
           * @private
           * @type {number}
           */
          _this.timeout_ = options.timeout !== undefined ? options.timeout : 80;
          /**
           * @private
           * @type {boolean}
           */
          _this.useAnchor_ =
              options.useAnchor !== undefined ? options.useAnchor : true;
          /**
           * @private
           * @type {boolean}
           */
          _this.constrainResolution_ =
              options.constrainResolution !== undefined
                  ? options.constrainResolution
                  : false;
          var condition = options.condition ? options.condition : always;
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.condition_ = options.onFocusOnly
              ? all(focusWithTabindex, condition)
              : condition;
          /**
           * @private
           * @type {?import("../coordinate.js").Coordinate}
           */
          _this.lastAnchor_ = null;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.startTime_ = undefined;
          /**
           * @private
           * @type {?}
           */
          _this.timeoutId_;
          /**
           * @private
           * @type {Mode|undefined}
           */
          _this.mode_ = undefined;
          /**
           * Trackpad events separated by this delay will be considered separate
           * interactions.
           * @type {number}
           */
          _this.trackpadEventGap_ = 400;
          /**
           * @type {?}
           */
          _this.trackpadTimeoutId_;
          /**
           * The number of delta values per zoom level
           * @private
           * @type {number}
           */
          _this.deltaPerZoom_ = 300;
          return _this;
      }
      /**
       * @private
       */
      MouseWheelZoom.prototype.endInteraction_ = function () {
          this.trackpadTimeoutId_ = undefined;
          var view = this.getMap().getView();
          view.endInteraction(undefined, this.lastDelta_ ? (this.lastDelta_ > 0 ? 1 : -1) : 0, this.lastAnchor_);
      };
      /**
       * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
       * zooms the map.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       */
      MouseWheelZoom.prototype.handleEvent = function (mapBrowserEvent) {
          if (!this.condition_(mapBrowserEvent)) {
              return true;
          }
          var type = mapBrowserEvent.type;
          if (type !== EventType.WHEEL) {
              return true;
          }
          mapBrowserEvent.preventDefault();
          var map = mapBrowserEvent.map;
          var wheelEvent = /** @type {WheelEvent} */ (mapBrowserEvent.originalEvent);
          if (this.useAnchor_) {
              this.lastAnchor_ = mapBrowserEvent.coordinate;
          }
          // Delta normalisation inspired by
          // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js
          var delta;
          if (mapBrowserEvent.type == EventType.WHEEL) {
              delta = wheelEvent.deltaY;
              if (FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
                  delta /= DEVICE_PIXEL_RATIO;
              }
              if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
                  delta *= 40;
              }
          }
          if (delta === 0) {
              return false;
          }
          else {
              this.lastDelta_ = delta;
          }
          var now = Date.now();
          if (this.startTime_ === undefined) {
              this.startTime_ = now;
          }
          if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
              this.mode_ = Math.abs(delta) < 4 ? Mode.TRACKPAD : Mode.WHEEL;
          }
          var view = map.getView();
          if (this.mode_ === Mode.TRACKPAD &&
              !(view.getConstrainResolution() || this.constrainResolution_)) {
              if (this.trackpadTimeoutId_) {
                  clearTimeout(this.trackpadTimeoutId_);
              }
              else {
                  if (view.getAnimating()) {
                      view.cancelAnimations();
                  }
                  view.beginInteraction();
              }
              this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_);
              view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);
              this.startTime_ = now;
              return false;
          }
          this.totalDelta_ += delta;
          var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
          clearTimeout(this.timeoutId_);
          this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);
          return false;
      };
      /**
       * @private
       * @param {import("../PluggableMap.js").default} map Map.
       */
      MouseWheelZoom.prototype.handleWheelZoom_ = function (map) {
          var view = map.getView();
          if (view.getAnimating()) {
              view.cancelAnimations();
          }
          var delta = -clamp(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;
          if (view.getConstrainResolution() || this.constrainResolution_) {
              // view has a zoom constraint, zoom by 1
              delta = delta ? (delta > 0 ? 1 : -1) : 0;
          }
          zoomByDelta(view, delta, this.lastAnchor_, this.duration_);
          this.mode_ = undefined;
          this.totalDelta_ = 0;
          this.lastAnchor_ = null;
          this.startTime_ = undefined;
          this.timeoutId_ = undefined;
      };
      /**
       * Enable or disable using the mouse's location as an anchor when zooming
       * @param {boolean} useAnchor true to zoom to the mouse's location, false
       * to zoom to the center of the map
       * @api
       */
      MouseWheelZoom.prototype.setMouseAnchor = function (useAnchor) {
          this.useAnchor_ = useAnchor;
          if (!useAnchor) {
              this.lastAnchor_ = null;
          }
      };
      return MouseWheelZoom;
  }(Interaction));

  var __extends$H = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {number} [duration=250] The duration of the animation in
   * milliseconds.
   * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.
   */
  /**
   * @classdesc
   * Allows the user to rotate the map by twisting with two fingers
   * on a touch screen.
   * @api
   */
  var PinchRotate = /** @class */ (function (_super) {
      __extends$H(PinchRotate, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function PinchRotate(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          var pointerOptions = /** @type {import("./Pointer.js").Options} */ (options);
          if (!pointerOptions.stopDown) {
              pointerOptions.stopDown = FALSE;
          }
          _this = _super.call(this, pointerOptions) || this;
          /**
           * @private
           * @type {import("../coordinate.js").Coordinate}
           */
          _this.anchor_ = null;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.lastAngle_ = undefined;
          /**
           * @private
           * @type {boolean}
           */
          _this.rotating_ = false;
          /**
           * @private
           * @type {number}
           */
          _this.rotationDelta_ = 0.0;
          /**
           * @private
           * @type {number}
           */
          _this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;
          /**
           * @private
           * @type {number}
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 250;
          return _this;
      }
      /**
       * Handle pointer drag events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       */
      PinchRotate.prototype.handleDragEvent = function (mapBrowserEvent) {
          var rotationDelta = 0.0;
          var touch0 = this.targetPointers[0];
          var touch1 = this.targetPointers[1];
          // angle between touches
          var angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);
          if (this.lastAngle_ !== undefined) {
              var delta = angle - this.lastAngle_;
              this.rotationDelta_ += delta;
              if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
                  this.rotating_ = true;
              }
              rotationDelta = delta;
          }
          this.lastAngle_ = angle;
          var map = mapBrowserEvent.map;
          var view = map.getView();
          if (view.getConstraints().rotation === disable) {
              return;
          }
          // rotate anchor point.
          // FIXME: should be the intersection point between the lines:
          //     touch0,touch1 and previousTouch0,previousTouch1
          var viewportPosition = map.getViewport().getBoundingClientRect();
          var centroid$1 = centroid(this.targetPointers);
          centroid$1[0] -= viewportPosition.left;
          centroid$1[1] -= viewportPosition.top;
          this.anchor_ = map.getCoordinateFromPixelInternal(centroid$1);
          // rotate
          if (this.rotating_) {
              map.render();
              view.adjustRotationInternal(rotationDelta, this.anchor_);
          }
      };
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      PinchRotate.prototype.handleUpEvent = function (mapBrowserEvent) {
          if (this.targetPointers.length < 2) {
              var map = mapBrowserEvent.map;
              var view = map.getView();
              view.endInteraction(this.duration_);
              return false;
          }
          else {
              return true;
          }
      };
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      PinchRotate.prototype.handleDownEvent = function (mapBrowserEvent) {
          if (this.targetPointers.length >= 2) {
              var map = mapBrowserEvent.map;
              this.anchor_ = null;
              this.lastAngle_ = undefined;
              this.rotating_ = false;
              this.rotationDelta_ = 0.0;
              if (!this.handlingDownUpSequence) {
                  map.getView().beginInteraction();
              }
              return true;
          }
          else {
              return false;
          }
      };
      return PinchRotate;
  }(PointerInteraction));

  var __extends$I = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {number} [duration=400] Animation duration in milliseconds.
   */
  /**
   * @classdesc
   * Allows the user to zoom the map by pinching with two fingers
   * on a touch screen.
   * @api
   */
  var PinchZoom = /** @class */ (function (_super) {
      __extends$I(PinchZoom, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function PinchZoom(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          var pointerOptions = /** @type {import("./Pointer.js").Options} */ (options);
          if (!pointerOptions.stopDown) {
              pointerOptions.stopDown = FALSE;
          }
          _this = _super.call(this, pointerOptions) || this;
          /**
           * @private
           * @type {import("../coordinate.js").Coordinate}
           */
          _this.anchor_ = null;
          /**
           * @private
           * @type {number}
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 400;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.lastDistance_ = undefined;
          /**
           * @private
           * @type {number}
           */
          _this.lastScaleDelta_ = 1;
          return _this;
      }
      /**
       * Handle pointer drag events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       */
      PinchZoom.prototype.handleDragEvent = function (mapBrowserEvent) {
          var scaleDelta = 1.0;
          var touch0 = this.targetPointers[0];
          var touch1 = this.targetPointers[1];
          var dx = touch0.clientX - touch1.clientX;
          var dy = touch0.clientY - touch1.clientY;
          // distance between touches
          var distance = Math.sqrt(dx * dx + dy * dy);
          if (this.lastDistance_ !== undefined) {
              scaleDelta = this.lastDistance_ / distance;
          }
          this.lastDistance_ = distance;
          var map = mapBrowserEvent.map;
          var view = map.getView();
          if (scaleDelta != 1.0) {
              this.lastScaleDelta_ = scaleDelta;
          }
          // scale anchor point.
          var viewportPosition = map.getViewport().getBoundingClientRect();
          var centroid$1 = centroid(this.targetPointers);
          centroid$1[0] -= viewportPosition.left;
          centroid$1[1] -= viewportPosition.top;
          this.anchor_ = map.getCoordinateFromPixelInternal(centroid$1);
          // scale, bypass the resolution constraint
          map.render();
          view.adjustResolutionInternal(scaleDelta, this.anchor_);
      };
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      PinchZoom.prototype.handleUpEvent = function (mapBrowserEvent) {
          if (this.targetPointers.length < 2) {
              var map = mapBrowserEvent.map;
              var view = map.getView();
              var direction = this.lastScaleDelta_ > 1 ? 1 : -1;
              view.endInteraction(this.duration_, direction);
              return false;
          }
          else {
              return true;
          }
      };
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      PinchZoom.prototype.handleDownEvent = function (mapBrowserEvent) {
          if (this.targetPointers.length >= 2) {
              var map = mapBrowserEvent.map;
              this.anchor_ = null;
              this.lastDistance_ = undefined;
              this.lastScaleDelta_ = 1;
              if (!this.handlingDownUpSequence) {
                  map.getView().beginInteraction();
              }
              return true;
          }
          else {
              return false;
          }
      };
      return PinchZoom;
  }(PointerInteraction));

  var __extends$J = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {typeof Feature|typeof import("./render/Feature.js").default} FeatureClass
   */
  /**
   * @typedef {Feature|import("./render/Feature.js").default} FeatureLike
   */
  /**
   * @classdesc
   * A vector object for geographic features with a geometry and other
   * attribute properties, similar to the features in vector file formats like
   * GeoJSON.
   *
   * Features can be styled individually with `setStyle`; otherwise they use the
   * style of their vector layer.
   *
   * Note that attribute properties are set as {@link module:ol/Object} properties on
   * the feature object, so they are observable, and have get/set accessors.
   *
   * Typically, a feature has a single geometry property. You can set the
   * geometry using the `setGeometry` method and get it with `getGeometry`.
   * It is possible to store more than one geometry on a feature using attribute
   * properties. By default, the geometry used for rendering is identified by
   * the property name `geometry`. If you want to use another geometry property
   * for rendering, use the `setGeometryName` method to change the attribute
   * property associated with the geometry for the feature.  For example:
   *
   * ```js
   *
   * import Feature from 'ol/Feature';
   * import Polygon from 'ol/geom/Polygon';
   * import Point from 'ol/geom/Point';
   *
   * var feature = new Feature({
   *   geometry: new Polygon(polyCoords),
   *   labelPoint: new Point(labelCoords),
   *   name: 'My Polygon'
   * });
   *
   * // get the polygon geometry
   * var poly = feature.getGeometry();
   *
   * // Render the feature as a point using the coordinates from labelPoint
   * feature.setGeometryName('labelPoint');
   *
   * // get the point geometry
   * var point = feature.getGeometry();
   * ```
   *
   * @api
   * @template {import("./geom/Geometry.js").default} Geometry
   */
  var Feature = /** @class */ (function (_super) {
      __extends$J(Feature, _super);
      /**
       * @param {Geometry|Object<string, *>=} opt_geometryOrProperties
       *     You may pass a Geometry object directly, or an object literal containing
       *     properties. If you pass an object literal, you may include a Geometry
       *     associated with a `geometry` key.
       */
      function Feature(opt_geometryOrProperties) {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {number|string|undefined}
           */
          _this.id_ = undefined;
          /**
           * @type {string}
           * @private
           */
          _this.geometryName_ = 'geometry';
          /**
           * User provided style.
           * @private
           * @type {import("./style/Style.js").StyleLike}
           */
          _this.style_ = null;
          /**
           * @private
           * @type {import("./style/Style.js").StyleFunction|undefined}
           */
          _this.styleFunction_ = undefined;
          /**
           * @private
           * @type {?import("./events.js").EventsKey}
           */
          _this.geometryChangeKey_ = null;
          _this.addEventListener(getChangeEventType(_this.geometryName_), _this.handleGeometryChanged_);
          if (opt_geometryOrProperties) {
              if (typeof (
              /** @type {?} */ (opt_geometryOrProperties).getSimplifiedGeometry) === 'function') {
                  var geometry = /** @type {Geometry} */ (opt_geometryOrProperties);
                  _this.setGeometry(geometry);
              }
              else {
                  /** @type {Object<string, *>} */
                  var properties = opt_geometryOrProperties;
                  _this.setProperties(properties);
              }
          }
          return _this;
      }
      /**
       * Clone this feature. If the original feature has a geometry it
       * is also cloned. The feature id is not set in the clone.
       * @return {Feature} The clone.
       * @api
       */
      Feature.prototype.clone = function () {
          var clone = new Feature(this.hasProperties() ? this.getProperties() : null);
          clone.setGeometryName(this.getGeometryName());
          var geometry = this.getGeometry();
          if (geometry) {
              clone.setGeometry(geometry.clone());
          }
          var style = this.getStyle();
          if (style) {
              clone.setStyle(style);
          }
          return clone;
      };
      /**
       * Get the feature's default geometry.  A feature may have any number of named
       * geometries.  The "default" geometry (the one that is rendered by default) is
       * set when calling {@link module:ol/Feature~Feature#setGeometry}.
       * @return {Geometry|undefined} The default geometry for the feature.
       * @api
       * @observable
       */
      Feature.prototype.getGeometry = function () {
          return /** @type {Geometry|undefined} */ (this.get(this.geometryName_));
      };
      /**
       * Get the feature identifier.  This is a stable identifier for the feature and
       * is either set when reading data from a remote source or set explicitly by
       * calling {@link module:ol/Feature~Feature#setId}.
       * @return {number|string|undefined} Id.
       * @api
       */
      Feature.prototype.getId = function () {
          return this.id_;
      };
      /**
       * Get the name of the feature's default geometry.  By default, the default
       * geometry is named `geometry`.
       * @return {string} Get the property name associated with the default geometry
       *     for this feature.
       * @api
       */
      Feature.prototype.getGeometryName = function () {
          return this.geometryName_;
      };
      /**
       * Get the feature's style. Will return what was provided to the
       * {@link module:ol/Feature~Feature#setStyle} method.
       * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
       * @api
       */
      Feature.prototype.getStyle = function () {
          return this.style_;
      };
      /**
       * Get the feature's style function.
       * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
       * representing the current style of this feature.
       * @api
       */
      Feature.prototype.getStyleFunction = function () {
          return this.styleFunction_;
      };
      /**
       * @private
       */
      Feature.prototype.handleGeometryChange_ = function () {
          this.changed();
      };
      /**
       * @private
       */
      Feature.prototype.handleGeometryChanged_ = function () {
          if (this.geometryChangeKey_) {
              unlistenByKey(this.geometryChangeKey_);
              this.geometryChangeKey_ = null;
          }
          var geometry = this.getGeometry();
          if (geometry) {
              this.geometryChangeKey_ = listen(geometry, EventType.CHANGE, this.handleGeometryChange_, this);
          }
          this.changed();
      };
      /**
       * Set the default geometry for the feature.  This will update the property
       * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
       * @param {Geometry|undefined} geometry The new geometry.
       * @api
       * @observable
       */
      Feature.prototype.setGeometry = function (geometry) {
          this.set(this.geometryName_, geometry);
      };
      /**
       * Set the style for the feature to override the layer style.  This can be a
       * single style object, an array of styles, or a function that takes a
       * resolution and returns an array of styles. To unset the feature style, call
       * `setStyle()` without arguments or a falsey value.
       * @param {import("./style/Style.js").StyleLike=} opt_style Style for this feature.
       * @api
       * @fires module:ol/events/Event~BaseEvent#event:change
       */
      Feature.prototype.setStyle = function (opt_style) {
          this.style_ = opt_style;
          this.styleFunction_ = !opt_style
              ? undefined
              : createStyleFunction(opt_style);
          this.changed();
      };
      /**
       * Set the feature id.  The feature id is considered stable and may be used when
       * requesting features or comparing identifiers returned from a remote source.
       * The feature id can be used with the
       * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
       * @param {number|string|undefined} id The feature id.
       * @api
       * @fires module:ol/events/Event~BaseEvent#event:change
       */
      Feature.prototype.setId = function (id) {
          this.id_ = id;
          this.changed();
      };
      /**
       * Set the property name to be used when getting the feature's default geometry.
       * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
       * this name will be returned.
       * @param {string} name The property name of the default geometry.
       * @api
       */
      Feature.prototype.setGeometryName = function (name) {
          this.removeEventListener(getChangeEventType(this.geometryName_), this.handleGeometryChanged_);
          this.geometryName_ = name;
          this.addEventListener(getChangeEventType(this.geometryName_), this.handleGeometryChanged_);
          this.handleGeometryChanged_();
      };
      return Feature;
  }(BaseObject));
  /**
   * Convert the provided object into a feature style function.  Functions passed
   * through unchanged.  Arrays of Style or single style objects wrapped
   * in a new feature style function.
   * @param {!import("./style/Style.js").StyleFunction|!Array<import("./style/Style.js").default>|!import("./style/Style.js").default} obj
   *     A feature style function, a single style, or an array of styles.
   * @return {import("./style/Style.js").StyleFunction} A style function.
   */
  function createStyleFunction(obj) {
      if (typeof obj === 'function') {
          return obj;
      }
      else {
          /**
           * @type {Array<import("./style/Style.js").default>}
           */
          var styles_1;
          if (Array.isArray(obj)) {
              styles_1 = obj;
          }
          else {
              assert(typeof ( /** @type {?} */(obj).getZIndex) === 'function', 41); // Expected an `import("./style/Style.js").Style` or an array of `import("./style/Style.js").Style`
              var style = /** @type {import("./style/Style.js").default} */ (obj);
              styles_1 = [style];
          }
          return function () {
              return styles_1;
          };
      }
  }

  /**
   * @module ol/geom/flat/interpolate
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} fraction Fraction.
   * @param {Array<number>=} opt_dest Destination.
   * @param {number=} opt_dimension Destination dimension (default is `2`)
   * @return {Array<number>} Destination.
   */
  function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest, opt_dimension) {
      var o, t;
      var n = (end - offset) / stride;
      if (n === 1) {
          o = offset;
      }
      else if (n === 2) {
          o = offset;
          t = fraction;
      }
      else if (n !== 0) {
          var x1 = flatCoordinates[offset];
          var y1 = flatCoordinates[offset + 1];
          var length_1 = 0;
          var cumulativeLengths = [0];
          for (var i = offset + stride; i < end; i += stride) {
              var x2 = flatCoordinates[i];
              var y2 = flatCoordinates[i + 1];
              length_1 += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
              cumulativeLengths.push(length_1);
              x1 = x2;
              y1 = y2;
          }
          var target = fraction * length_1;
          var index = binarySearch(cumulativeLengths, target);
          if (index < 0) {
              t =
                  (target - cumulativeLengths[-index - 2]) /
                      (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
              o = offset + (-index - 2) * stride;
          }
          else {
              o = offset + index * stride;
          }
      }
      var dimension = opt_dimension > 1 ? opt_dimension : 2;
      var dest = opt_dest ? opt_dest : new Array(dimension);
      for (var i = 0; i < dimension; ++i) {
          dest[i] =
              o === undefined
                  ? NaN
                  : t === undefined
                      ? flatCoordinates[o + i]
                      : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);
      }
      return dest;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} m M.
   * @param {boolean} extrapolate Extrapolate.
   * @return {import("../../coordinate.js").Coordinate} Coordinate.
   */
  function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {
      if (end == offset) {
          return null;
      }
      var coordinate;
      if (m < flatCoordinates[offset + stride - 1]) {
          if (extrapolate) {
              coordinate = flatCoordinates.slice(offset, offset + stride);
              coordinate[stride - 1] = m;
              return coordinate;
          }
          else {
              return null;
          }
      }
      else if (flatCoordinates[end - 1] < m) {
          if (extrapolate) {
              coordinate = flatCoordinates.slice(end - stride, end);
              coordinate[stride - 1] = m;
              return coordinate;
          }
          else {
              return null;
          }
      }
      // FIXME use O(1) search
      if (m == flatCoordinates[offset + stride - 1]) {
          return flatCoordinates.slice(offset, offset + stride);
      }
      var lo = offset / stride;
      var hi = end / stride;
      while (lo < hi) {
          var mid = (lo + hi) >> 1;
          if (m < flatCoordinates[(mid + 1) * stride - 1]) {
              hi = mid;
          }
          else {
              lo = mid + 1;
          }
      }
      var m0 = flatCoordinates[lo * stride - 1];
      if (m == m0) {
          return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
      }
      var m1 = flatCoordinates[(lo + 1) * stride - 1];
      var t = (m - m0) / (m1 - m0);
      coordinate = [];
      for (var i = 0; i < stride - 1; ++i) {
          coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));
      }
      coordinate.push(m);
      return coordinate;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {number} m M.
   * @param {boolean} extrapolate Extrapolate.
   * @param {boolean} interpolate Interpolate.
   * @return {import("../../coordinate.js").Coordinate} Coordinate.
   */
  function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
      if (interpolate) {
          return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);
      }
      var coordinate;
      if (m < flatCoordinates[stride - 1]) {
          if (extrapolate) {
              coordinate = flatCoordinates.slice(0, stride);
              coordinate[stride - 1] = m;
              return coordinate;
          }
          else {
              return null;
          }
      }
      if (flatCoordinates[flatCoordinates.length - 1] < m) {
          if (extrapolate) {
              coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
              coordinate[stride - 1] = m;
              return coordinate;
          }
          else {
              return null;
          }
      }
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          if (offset == end) {
              continue;
          }
          if (m < flatCoordinates[offset + stride - 1]) {
              return null;
          }
          else if (m <= flatCoordinates[end - 1]) {
              return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);
          }
          offset = end;
      }
      return null;
  }

  /**
   * @module ol/geom/flat/length
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @return {number} Length.
   */
  function lineStringLength(flatCoordinates, offset, end, stride) {
      var x1 = flatCoordinates[offset];
      var y1 = flatCoordinates[offset + 1];
      var length = 0;
      for (var i = offset + stride; i < end; i += stride) {
          var x2 = flatCoordinates[i];
          var y2 = flatCoordinates[i + 1];
          length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
          x1 = x2;
          y1 = y2;
      }
      return length;
  }

  var __extends$K = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Linestring geometry.
   *
   * @api
   */
  var LineString = /** @class */ (function (_super) {
      __extends$K(LineString, _super);
      /**
       * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       */
      function LineString(coordinates, opt_layout) {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {import("../coordinate.js").Coordinate}
           */
          _this.flatMidpoint_ = null;
          /**
           * @private
           * @type {number}
           */
          _this.flatMidpointRevision_ = -1;
          /**
           * @private
           * @type {number}
           */
          _this.maxDelta_ = -1;
          /**
           * @private
           * @type {number}
           */
          _this.maxDeltaRevision_ = -1;
          if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {
              _this.setFlatCoordinates(opt_layout, 
              /** @type {Array<number>} */ (coordinates));
          }
          else {
              _this.setCoordinates(
              /** @type {Array<import("../coordinate.js").Coordinate>} */ (coordinates), opt_layout);
          }
          return _this;
      }
      /**
       * Append the passed coordinate to the coordinates of the linestring.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @api
       */
      LineString.prototype.appendCoordinate = function (coordinate) {
          if (!this.flatCoordinates) {
              this.flatCoordinates = coordinate.slice();
          }
          else {
              extend(this.flatCoordinates, coordinate);
          }
          this.changed();
      };
      /**
       * Make a complete copy of the geometry.
       * @return {!LineString} Clone.
       * @api
       */
      LineString.prototype.clone = function () {
          return new LineString(this.flatCoordinates.slice(), this.layout);
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      LineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
          if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
          }
          if (this.maxDeltaRevision_ != this.getRevision()) {
              this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
              this.maxDeltaRevision_ = this.getRevision();
          }
          return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
      };
      /**
       * Iterate over each segment, calling the provided callback.
       * If the callback returns a truthy value the function returns that
       * value immediately. Otherwise the function returns `false`.
       *
       * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
       *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
       * @return {T|boolean} Value.
       * @template T,S
       * @api
       */
      LineString.prototype.forEachSegment = function (callback) {
          return forEach(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);
      };
      /**
       * Returns the coordinate at `m` using linear interpolation, or `null` if no
       * such coordinate exists.
       *
       * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
       * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
       * M will return the first coordinate and Ms greater than the last M will
       * return the last coordinate.
       *
       * @param {number} m M.
       * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
       * @return {import("../coordinate.js").Coordinate} Coordinate.
       * @api
       */
      LineString.prototype.getCoordinateAtM = function (m, opt_extrapolate) {
          if (this.layout != GeometryLayout.XYM &&
              this.layout != GeometryLayout.XYZM) {
              return null;
          }
          var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
          return lineStringCoordinateAtM(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);
      };
      /**
       * Return the coordinates of the linestring.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       */
      LineString.prototype.getCoordinates = function () {
          return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      };
      /**
       * Return the coordinate at the provided fraction along the linestring.
       * The `fraction` is a number between 0 and 1, where 0 is the start of the
       * linestring and 1 is the end.
       * @param {number} fraction Fraction.
       * @param {import("../coordinate.js").Coordinate=} opt_dest Optional coordinate whose values will
       *     be modified. If not provided, a new coordinate will be returned.
       * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
       * @api
       */
      LineString.prototype.getCoordinateAt = function (fraction, opt_dest) {
          return interpolatePoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, opt_dest, this.stride);
      };
      /**
       * Return the length of the linestring on projected plane.
       * @return {number} Length (on projected plane).
       * @api
       */
      LineString.prototype.getLength = function () {
          return lineStringLength(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      };
      /**
       * @return {Array<number>} Flat midpoint.
       */
      LineString.prototype.getFlatMidpoint = function () {
          if (this.flatMidpointRevision_ != this.getRevision()) {
              this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);
              this.flatMidpointRevision_ = this.getRevision();
          }
          return this.flatMidpoint_;
      };
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {LineString} Simplified LineString.
       * @protected
       */
      LineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
          var simplifiedFlatCoordinates = [];
          simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
          return new LineString(simplifiedFlatCoordinates, GeometryLayout.XY);
      };
      /**
       * Get the type of this geometry.
       * @return {import("./GeometryType.js").default} Geometry type.
       * @api
       */
      LineString.prototype.getType = function () {
          return GeometryType.LINE_STRING;
      };
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      LineString.prototype.intersectsExtent = function (extent) {
          return intersectsLineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
      };
      /**
       * Set the coordinates of the linestring.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @api
       */
      LineString.prototype.setCoordinates = function (coordinates, opt_layout) {
          this.setLayout(opt_layout, coordinates, 1);
          if (!this.flatCoordinates) {
              this.flatCoordinates = [];
          }
          this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);
          this.changed();
      };
      return LineString;
  }(SimpleGeometry));

  var __extends$L = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Multi-linestring geometry.
   *
   * @api
   */
  var MultiLineString = /** @class */ (function (_super) {
      __extends$L(MultiLineString, _super);
      /**
       * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
       *     Coordinates or LineString geometries. (For internal use, flat coordinates in
       *     combination with `opt_layout` and `opt_ends` are also accepted.)
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @param {Array<number>=} opt_ends Flat coordinate ends for internal use.
       */
      function MultiLineString(coordinates, opt_layout, opt_ends) {
          var _this = _super.call(this) || this;
          /**
           * @type {Array<number>}
           * @private
           */
          _this.ends_ = [];
          /**
           * @private
           * @type {number}
           */
          _this.maxDelta_ = -1;
          /**
           * @private
           * @type {number}
           */
          _this.maxDeltaRevision_ = -1;
          if (Array.isArray(coordinates[0])) {
              _this.setCoordinates(
              /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */ (coordinates), opt_layout);
          }
          else if (opt_layout !== undefined && opt_ends) {
              _this.setFlatCoordinates(opt_layout, 
              /** @type {Array<number>} */ (coordinates));
              _this.ends_ = opt_ends;
          }
          else {
              var layout = _this.getLayout();
              var lineStrings = /** @type {Array<LineString>} */ (coordinates);
              var flatCoordinates = [];
              var ends = [];
              for (var i = 0, ii = lineStrings.length; i < ii; ++i) {
                  var lineString = lineStrings[i];
                  if (i === 0) {
                      layout = lineString.getLayout();
                  }
                  extend(flatCoordinates, lineString.getFlatCoordinates());
                  ends.push(flatCoordinates.length);
              }
              _this.setFlatCoordinates(layout, flatCoordinates);
              _this.ends_ = ends;
          }
          return _this;
      }
      /**
       * Append the passed linestring to the multilinestring.
       * @param {LineString} lineString LineString.
       * @api
       */
      MultiLineString.prototype.appendLineString = function (lineString) {
          if (!this.flatCoordinates) {
              this.flatCoordinates = lineString.getFlatCoordinates().slice();
          }
          else {
              extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());
          }
          this.ends_.push(this.flatCoordinates.length);
          this.changed();
      };
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiLineString} Clone.
       * @api
       */
      MultiLineString.prototype.clone = function () {
          return new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      MultiLineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
          if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
          }
          if (this.maxDeltaRevision_ != this.getRevision()) {
              this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
              this.maxDeltaRevision_ = this.getRevision();
          }
          return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
      };
      /**
       * Returns the coordinate at `m` using linear interpolation, or `null` if no
       * such coordinate exists.
       *
       * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
       * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
       * M will return the first coordinate and Ms greater than the last M will
       * return the last coordinate.
       *
       * `opt_interpolate` controls interpolation between consecutive LineStrings
       * within the MultiLineString. If `opt_interpolate` is `true` the coordinates
       * will be linearly interpolated between the last coordinate of one LineString
       * and the first coordinate of the next LineString.  If `opt_interpolate` is
       * `false` then the function will return `null` for Ms falling between
       * LineStrings.
       *
       * @param {number} m M.
       * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
       * @param {boolean=} opt_interpolate Interpolate. Default is `false`.
       * @return {import("../coordinate.js").Coordinate} Coordinate.
       * @api
       */
      MultiLineString.prototype.getCoordinateAtM = function (m, opt_extrapolate, opt_interpolate) {
          if ((this.layout != GeometryLayout.XYM &&
              this.layout != GeometryLayout.XYZM) ||
              this.flatCoordinates.length === 0) {
              return null;
          }
          var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
          var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;
          return lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);
      };
      /**
       * Return the coordinates of the multilinestring.
       * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
       * @api
       */
      MultiLineString.prototype.getCoordinates = function () {
          return inflateCoordinatesArray(this.flatCoordinates, 0, this.ends_, this.stride);
      };
      /**
       * @return {Array<number>} Ends.
       */
      MultiLineString.prototype.getEnds = function () {
          return this.ends_;
      };
      /**
       * Return the linestring at the specified index.
       * @param {number} index Index.
       * @return {LineString} LineString.
       * @api
       */
      MultiLineString.prototype.getLineString = function (index) {
          if (index < 0 || this.ends_.length <= index) {
              return null;
          }
          return new LineString(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
      };
      /**
       * Return the linestrings of this multilinestring.
       * @return {Array<LineString>} LineStrings.
       * @api
       */
      MultiLineString.prototype.getLineStrings = function () {
          var flatCoordinates = this.flatCoordinates;
          var ends = this.ends_;
          var layout = this.layout;
          /** @type {Array<LineString>} */
          var lineStrings = [];
          var offset = 0;
          for (var i = 0, ii = ends.length; i < ii; ++i) {
              var end = ends[i];
              var lineString = new LineString(flatCoordinates.slice(offset, end), layout);
              lineStrings.push(lineString);
              offset = end;
          }
          return lineStrings;
      };
      /**
       * @return {Array<number>} Flat midpoints.
       */
      MultiLineString.prototype.getFlatMidpoints = function () {
          var midpoints = [];
          var flatCoordinates = this.flatCoordinates;
          var offset = 0;
          var ends = this.ends_;
          var stride = this.stride;
          for (var i = 0, ii = ends.length; i < ii; ++i) {
              var end = ends[i];
              var midpoint = interpolatePoint(flatCoordinates, offset, end, stride, 0.5);
              extend(midpoints, midpoint);
              offset = end;
          }
          return midpoints;
      };
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {MultiLineString} Simplified MultiLineString.
       * @protected
       */
      MultiLineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
          var simplifiedFlatCoordinates = [];
          var simplifiedEnds = [];
          simplifiedFlatCoordinates.length = douglasPeuckerArray(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);
          return new MultiLineString(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);
      };
      /**
       * Get the type of this geometry.
       * @return {import("./GeometryType.js").default} Geometry type.
       * @api
       */
      MultiLineString.prototype.getType = function () {
          return GeometryType.MULTI_LINE_STRING;
      };
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      MultiLineString.prototype.intersectsExtent = function (extent) {
          return intersectsLineStringArray(this.flatCoordinates, 0, this.ends_, this.stride, extent);
      };
      /**
       * Set the coordinates of the multilinestring.
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
       * @param {GeometryLayout=} opt_layout Layout.
       * @api
       */
      MultiLineString.prototype.setCoordinates = function (coordinates, opt_layout) {
          this.setLayout(opt_layout, coordinates, 2);
          if (!this.flatCoordinates) {
              this.flatCoordinates = [];
          }
          var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
          this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
          this.changed();
      };
      return MultiLineString;
  }(SimpleGeometry));

  var __extends$M = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Multi-point geometry.
   *
   * @api
   */
  var MultiPoint = /** @class */ (function (_super) {
      __extends$M(MultiPoint, _super);
      /**
       * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       */
      function MultiPoint(coordinates, opt_layout) {
          var _this = _super.call(this) || this;
          if (opt_layout && !Array.isArray(coordinates[0])) {
              _this.setFlatCoordinates(opt_layout, 
              /** @type {Array<number>} */ (coordinates));
          }
          else {
              _this.setCoordinates(
              /** @type {Array<import("../coordinate.js").Coordinate>} */ (coordinates), opt_layout);
          }
          return _this;
      }
      /**
       * Append the passed point to this multipoint.
       * @param {Point} point Point.
       * @api
       */
      MultiPoint.prototype.appendPoint = function (point) {
          if (!this.flatCoordinates) {
              this.flatCoordinates = point.getFlatCoordinates().slice();
          }
          else {
              extend(this.flatCoordinates, point.getFlatCoordinates());
          }
          this.changed();
      };
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiPoint} Clone.
       * @api
       */
      MultiPoint.prototype.clone = function () {
          var multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);
          return multiPoint;
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      MultiPoint.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
          if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
          }
          var flatCoordinates = this.flatCoordinates;
          var stride = this.stride;
          for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
              var squaredDistance$1 = squaredDistance(x, y, flatCoordinates[i], flatCoordinates[i + 1]);
              if (squaredDistance$1 < minSquaredDistance) {
                  minSquaredDistance = squaredDistance$1;
                  for (var j = 0; j < stride; ++j) {
                      closestPoint[j] = flatCoordinates[i + j];
                  }
                  closestPoint.length = stride;
              }
          }
          return minSquaredDistance;
      };
      /**
       * Return the coordinates of the multipoint.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       */
      MultiPoint.prototype.getCoordinates = function () {
          return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      };
      /**
       * Return the point at the specified index.
       * @param {number} index Index.
       * @return {Point} Point.
       * @api
       */
      MultiPoint.prototype.getPoint = function (index) {
          var n = !this.flatCoordinates
              ? 0
              : this.flatCoordinates.length / this.stride;
          if (index < 0 || n <= index) {
              return null;
          }
          return new Point(this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride), this.layout);
      };
      /**
       * Return the points of this multipoint.
       * @return {Array<Point>} Points.
       * @api
       */
      MultiPoint.prototype.getPoints = function () {
          var flatCoordinates = this.flatCoordinates;
          var layout = this.layout;
          var stride = this.stride;
          /** @type {Array<Point>} */
          var points = [];
          for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
              var point = new Point(flatCoordinates.slice(i, i + stride), layout);
              points.push(point);
          }
          return points;
      };
      /**
       * Get the type of this geometry.
       * @return {import("./GeometryType.js").default} Geometry type.
       * @api
       */
      MultiPoint.prototype.getType = function () {
          return GeometryType.MULTI_POINT;
      };
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      MultiPoint.prototype.intersectsExtent = function (extent) {
          var flatCoordinates = this.flatCoordinates;
          var stride = this.stride;
          for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
              var x = flatCoordinates[i];
              var y = flatCoordinates[i + 1];
              if (containsXY(extent, x, y)) {
                  return true;
              }
          }
          return false;
      };
      /**
       * Set the coordinates of the multipoint.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @api
       */
      MultiPoint.prototype.setCoordinates = function (coordinates, opt_layout) {
          this.setLayout(opt_layout, coordinates, 1);
          if (!this.flatCoordinates) {
              this.flatCoordinates = [];
          }
          this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);
          this.changed();
      };
      return MultiPoint;
  }(SimpleGeometry));

  /**
   * @module ol/geom/flat/center
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @return {Array<number>} Flat centers.
   */
  function linearRingss$1(flatCoordinates, offset, endss, stride) {
      var flatCenters = [];
      var extent = createEmpty();
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          extent = createOrUpdateFromFlatCoordinates(flatCoordinates, offset, ends[0], stride);
          flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
          offset = ends[ends.length - 1];
      }
      return flatCenters;
  }

  var __extends$N = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Multi-polygon geometry.
   *
   * @api
   */
  var MultiPolygon = /** @class */ (function (_super) {
      __extends$N(MultiPolygon, _super);
      /**
       * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `opt_layout` and `opt_endss` are also accepted.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @param {Array<Array<number>>=} opt_endss Array of ends for internal use with flat coordinates.
       */
      function MultiPolygon(coordinates, opt_layout, opt_endss) {
          var _this = _super.call(this) || this;
          /**
           * @type {Array<Array<number>>}
           * @private
           */
          _this.endss_ = [];
          /**
           * @private
           * @type {number}
           */
          _this.flatInteriorPointsRevision_ = -1;
          /**
           * @private
           * @type {Array<number>}
           */
          _this.flatInteriorPoints_ = null;
          /**
           * @private
           * @type {number}
           */
          _this.maxDelta_ = -1;
          /**
           * @private
           * @type {number}
           */
          _this.maxDeltaRevision_ = -1;
          /**
           * @private
           * @type {number}
           */
          _this.orientedRevision_ = -1;
          /**
           * @private
           * @type {Array<number>}
           */
          _this.orientedFlatCoordinates_ = null;
          if (!opt_endss && !Array.isArray(coordinates[0])) {
              var layout = _this.getLayout();
              var polygons = /** @type {Array<Polygon>} */ (coordinates);
              var flatCoordinates = [];
              var endss = [];
              for (var i = 0, ii = polygons.length; i < ii; ++i) {
                  var polygon = polygons[i];
                  if (i === 0) {
                      layout = polygon.getLayout();
                  }
                  var offset = flatCoordinates.length;
                  var ends = polygon.getEnds();
                  for (var j = 0, jj = ends.length; j < jj; ++j) {
                      ends[j] += offset;
                  }
                  extend(flatCoordinates, polygon.getFlatCoordinates());
                  endss.push(ends);
              }
              opt_layout = layout;
              coordinates = flatCoordinates;
              opt_endss = endss;
          }
          if (opt_layout !== undefined && opt_endss) {
              _this.setFlatCoordinates(opt_layout, 
              /** @type {Array<number>} */ (coordinates));
              _this.endss_ = opt_endss;
          }
          else {
              _this.setCoordinates(
              /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */ (coordinates), opt_layout);
          }
          return _this;
      }
      /**
       * Append the passed polygon to this multipolygon.
       * @param {Polygon} polygon Polygon.
       * @api
       */
      MultiPolygon.prototype.appendPolygon = function (polygon) {
          /** @type {Array<number>} */
          var ends;
          if (!this.flatCoordinates) {
              this.flatCoordinates = polygon.getFlatCoordinates().slice();
              ends = polygon.getEnds().slice();
              this.endss_.push();
          }
          else {
              var offset = this.flatCoordinates.length;
              extend(this.flatCoordinates, polygon.getFlatCoordinates());
              ends = polygon.getEnds().slice();
              for (var i = 0, ii = ends.length; i < ii; ++i) {
                  ends[i] += offset;
              }
          }
          this.endss_.push(ends);
          this.changed();
      };
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiPolygon} Clone.
       * @api
       */
      MultiPolygon.prototype.clone = function () {
          var len = this.endss_.length;
          var newEndss = new Array(len);
          for (var i = 0; i < len; ++i) {
              newEndss[i] = this.endss_[i].slice();
          }
          return new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      MultiPolygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
          if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
          }
          if (this.maxDeltaRevision_ != this.getRevision()) {
              this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));
              this.maxDeltaRevision_ = this.getRevision();
          }
          return assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */
      MultiPolygon.prototype.containsXY = function (x, y) {
          return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);
      };
      /**
       * Return the area of the multipolygon on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      MultiPolygon.prototype.getArea = function () {
          return linearRingss(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
      };
      /**
       * Get the coordinate array for this geometry.  This array has the structure
       * of a GeoJSON coordinate array for multi-polygons.
       *
       * @param {boolean=} opt_right Orient coordinates according to the right-hand
       *     rule (counter-clockwise for exterior and clockwise for interior rings).
       *     If `false`, coordinates will be oriented according to the left-hand rule
       *     (clockwise for exterior and counter-clockwise for interior rings).
       *     By default, coordinate orientation will depend on how the geometry was
       *     constructed.
       * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
       * @api
       */
      MultiPolygon.prototype.getCoordinates = function (opt_right) {
          var flatCoordinates;
          if (opt_right !== undefined) {
              flatCoordinates = this.getOrientedFlatCoordinates().slice();
              orientLinearRingsArray(flatCoordinates, 0, this.endss_, this.stride, opt_right);
          }
          else {
              flatCoordinates = this.flatCoordinates;
          }
          return inflateMultiCoordinatesArray(flatCoordinates, 0, this.endss_, this.stride);
      };
      /**
       * @return {Array<Array<number>>} Endss.
       */
      MultiPolygon.prototype.getEndss = function () {
          return this.endss_;
      };
      /**
       * @return {Array<number>} Flat interior points.
       */
      MultiPolygon.prototype.getFlatInteriorPoints = function () {
          if (this.flatInteriorPointsRevision_ != this.getRevision()) {
              var flatCenters = linearRingss$1(this.flatCoordinates, 0, this.endss_, this.stride);
              this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);
              this.flatInteriorPointsRevision_ = this.getRevision();
          }
          return this.flatInteriorPoints_;
      };
      /**
       * Return the interior points as {@link module:ol/geom/MultiPoint multipoint}.
       * @return {MultiPoint} Interior points as XYM coordinates, where M is
       * the length of the horizontal intersection that the point belongs to.
       * @api
       */
      MultiPolygon.prototype.getInteriorPoints = function () {
          return new MultiPoint(this.getFlatInteriorPoints().slice(), GeometryLayout.XYM);
      };
      /**
       * @return {Array<number>} Oriented flat coordinates.
       */
      MultiPolygon.prototype.getOrientedFlatCoordinates = function () {
          if (this.orientedRevision_ != this.getRevision()) {
              var flatCoordinates = this.flatCoordinates;
              if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {
                  this.orientedFlatCoordinates_ = flatCoordinates;
              }
              else {
                  this.orientedFlatCoordinates_ = flatCoordinates.slice();
                  this.orientedFlatCoordinates_.length = orientLinearRingsArray(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);
              }
              this.orientedRevision_ = this.getRevision();
          }
          return this.orientedFlatCoordinates_;
      };
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {MultiPolygon} Simplified MultiPolygon.
       * @protected
       */
      MultiPolygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
          var simplifiedFlatCoordinates = [];
          var simplifiedEndss = [];
          simplifiedFlatCoordinates.length = quantizeMultiArray(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);
          return new MultiPolygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEndss);
      };
      /**
       * Return the polygon at the specified index.
       * @param {number} index Index.
       * @return {Polygon} Polygon.
       * @api
       */
      MultiPolygon.prototype.getPolygon = function (index) {
          if (index < 0 || this.endss_.length <= index) {
              return null;
          }
          var offset;
          if (index === 0) {
              offset = 0;
          }
          else {
              var prevEnds = this.endss_[index - 1];
              offset = prevEnds[prevEnds.length - 1];
          }
          var ends = this.endss_[index].slice();
          var end = ends[ends.length - 1];
          if (offset !== 0) {
              for (var i = 0, ii = ends.length; i < ii; ++i) {
                  ends[i] -= offset;
              }
          }
          return new Polygon(this.flatCoordinates.slice(offset, end), this.layout, ends);
      };
      /**
       * Return the polygons of this multipolygon.
       * @return {Array<Polygon>} Polygons.
       * @api
       */
      MultiPolygon.prototype.getPolygons = function () {
          var layout = this.layout;
          var flatCoordinates = this.flatCoordinates;
          var endss = this.endss_;
          var polygons = [];
          var offset = 0;
          for (var i = 0, ii = endss.length; i < ii; ++i) {
              var ends = endss[i].slice();
              var end = ends[ends.length - 1];
              if (offset !== 0) {
                  for (var j = 0, jj = ends.length; j < jj; ++j) {
                      ends[j] -= offset;
                  }
              }
              var polygon = new Polygon(flatCoordinates.slice(offset, end), layout, ends);
              polygons.push(polygon);
              offset = end;
          }
          return polygons;
      };
      /**
       * Get the type of this geometry.
       * @return {import("./GeometryType.js").default} Geometry type.
       * @api
       */
      MultiPolygon.prototype.getType = function () {
          return GeometryType.MULTI_POLYGON;
      };
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      MultiPolygon.prototype.intersectsExtent = function (extent) {
          return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);
      };
      /**
       * Set the coordinates of the multipolygon.
       * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @api
       */
      MultiPolygon.prototype.setCoordinates = function (coordinates, opt_layout) {
          this.setLayout(opt_layout, coordinates, 3);
          if (!this.flatCoordinates) {
              this.flatCoordinates = [];
          }
          var endss = deflateMultiCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);
          if (endss.length === 0) {
              this.flatCoordinates.length = 0;
          }
          else {
              var lastEnds = endss[endss.length - 1];
              this.flatCoordinates.length =
                  lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
          }
          this.changed();
      };
      return MultiPolygon;
  }(SimpleGeometry));

  /**
   * @module ol/style/Image
   */
  /**
   * @typedef {Object} Options
   * @property {number} opacity
   * @property {boolean} rotateWithView
   * @property {number} rotation
   * @property {number|import("../size.js").Size} scale
   * @property {Array<number>} displacement
   */
  /**
   * @classdesc
   * A base class used for creating subclasses and not instantiated in
   * apps. Base class for {@link module:ol/style/Icon~Icon}, {@link module:ol/style/Circle~CircleStyle} and
   * {@link module:ol/style/RegularShape~RegularShape}.
   * @abstract
   * @api
   */
  var ImageStyle = /** @class */ (function () {
      /**
       * @param {Options} options Options.
       */
      function ImageStyle(options) {
          /**
           * @private
           * @type {number}
           */
          this.opacity_ = options.opacity;
          /**
           * @private
           * @type {boolean}
           */
          this.rotateWithView_ = options.rotateWithView;
          /**
           * @private
           * @type {number}
           */
          this.rotation_ = options.rotation;
          /**
           * @private
           * @type {number|import("../size.js").Size}
           */
          this.scale_ = options.scale;
          /**
           * @private
           * @type {import("../size.js").Size}
           */
          this.scaleArray_ = toSize(options.scale);
          /**
           * @private
           * @type {Array<number>}
           */
          this.displacement_ = options.displacement;
      }
      /**
       * Clones the style.
       * @return {ImageStyle} The cloned style.
       * @api
       */
      ImageStyle.prototype.clone = function () {
          var scale = this.getScale();
          return new ImageStyle({
              opacity: this.getOpacity(),
              scale: Array.isArray(scale) ? scale.slice() : scale,
              rotation: this.getRotation(),
              rotateWithView: this.getRotateWithView(),
              displacement: this.getDisplacement().slice(),
          });
      };
      /**
       * Get the symbolizer opacity.
       * @return {number} Opacity.
       * @api
       */
      ImageStyle.prototype.getOpacity = function () {
          return this.opacity_;
      };
      /**
       * Determine whether the symbolizer rotates with the map.
       * @return {boolean} Rotate with map.
       * @api
       */
      ImageStyle.prototype.getRotateWithView = function () {
          return this.rotateWithView_;
      };
      /**
       * Get the symoblizer rotation.
       * @return {number} Rotation.
       * @api
       */
      ImageStyle.prototype.getRotation = function () {
          return this.rotation_;
      };
      /**
       * Get the symbolizer scale.
       * @return {number|import("../size.js").Size} Scale.
       * @api
       */
      ImageStyle.prototype.getScale = function () {
          return this.scale_;
      };
      /**
       * Get the symbolizer scale array.
       * @return {import("../size.js").Size} Scale array.
       */
      ImageStyle.prototype.getScaleArray = function () {
          return this.scaleArray_;
      };
      /**
       * Get the displacement of the shape
       * @return {Array<number>} Shape's center displacement
       * @api
       */
      ImageStyle.prototype.getDisplacement = function () {
          return this.displacement_;
      };
      /**
       * Get the anchor point in pixels. The anchor determines the center point for the
       * symbolizer.
       * @abstract
       * @return {Array<number>} Anchor.
       */
      ImageStyle.prototype.getAnchor = function () {
          return abstract();
      };
      /**
       * Get the image element for the symbolizer.
       * @abstract
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
       */
      ImageStyle.prototype.getImage = function (pixelRatio) {
          return abstract();
      };
      /**
       * @abstract
       * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
       */
      ImageStyle.prototype.getHitDetectionImage = function () {
          return abstract();
      };
      /*
       * Get the image pixel ratio.
       * @param {number} pixelRatio Pixel ratio.
       * */
      ImageStyle.prototype.getPixelRatio = function (pixelRatio) {
          return 1;
      };
      /**
       * @abstract
       * @return {import("../ImageState.js").default} Image state.
       */
      ImageStyle.prototype.getImageState = function () {
          return abstract();
      };
      /**
       * @abstract
       * @return {import("../size.js").Size} Image size.
       */
      ImageStyle.prototype.getImageSize = function () {
          return abstract();
      };
      /**
       * @abstract
       * @return {import("../size.js").Size} Size of the hit-detection image.
       */
      ImageStyle.prototype.getHitDetectionImageSize = function () {
          return abstract();
      };
      /**
       * Get the origin of the symbolizer.
       * @abstract
       * @return {Array<number>} Origin.
       */
      ImageStyle.prototype.getOrigin = function () {
          return abstract();
      };
      /**
       * Get the size of the symbolizer (in pixels).
       * @abstract
       * @return {import("../size.js").Size} Size.
       */
      ImageStyle.prototype.getSize = function () {
          return abstract();
      };
      /**
       * Set the opacity.
       *
       * @param {number} opacity Opacity.
       * @api
       */
      ImageStyle.prototype.setOpacity = function (opacity) {
          this.opacity_ = opacity;
      };
      /**
       * Set whether to rotate the style with the view.
       *
       * @param {boolean} rotateWithView Rotate with map.
       * @api
       */
      ImageStyle.prototype.setRotateWithView = function (rotateWithView) {
          this.rotateWithView_ = rotateWithView;
      };
      /**
       * Set the rotation.
       *
       * @param {number} rotation Rotation.
       * @api
       */
      ImageStyle.prototype.setRotation = function (rotation) {
          this.rotation_ = rotation;
      };
      /**
       * Set the scale.
       *
       * @param {number|import("../size.js").Size} scale Scale.
       * @api
       */
      ImageStyle.prototype.setScale = function (scale) {
          this.scale_ = scale;
          this.scaleArray_ = toSize(scale);
      };
      /**
       * @abstract
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      ImageStyle.prototype.listenImageChange = function (listener) {
          abstract();
      };
      /**
       * Load not yet loaded URI.
       * @abstract
       */
      ImageStyle.prototype.load = function () {
          abstract();
      };
      /**
       * @abstract
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      ImageStyle.prototype.unlistenImageChange = function (listener) {
          abstract();
      };
      return ImageStyle;
  }());

  /**
   * @module ol/style/RegularShape
   */
  var __extends$O = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * Specify radius for regular polygons, or radius1 and radius2 for stars.
   * @typedef {Object} Options
   * @property {import("./Fill.js").default} [fill] Fill style.
   * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points
   * is the number of sides.
   * @property {number} [radius] Radius of a regular polygon.
   * @property {number} [radius1] Outer radius of a star.
   * @property {number} [radius2] Inner radius of a star.
   * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.
   * @property {Array<number>} [displacement=[0,0]] Displacement of the shape
   * @property {import("./Stroke.js").default} [stroke] Stroke style.
   * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
   * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.
   */
  /**
   * @typedef {Object} RenderOptions
   * @property {import("../colorlike.js").ColorLike} [strokeStyle]
   * @property {number} strokeWidth
   * @property {number} size
   * @property {CanvasLineCap} lineCap
   * @property {Array<number>} lineDash
   * @property {number} lineDashOffset
   * @property {CanvasLineJoin} lineJoin
   * @property {number} miterLimit
   */
  /**
   * @classdesc
   * Set regular shape style for vector features. The resulting shape will be
   * a regular polygon when `radius` is provided, or a star when `radius1` and
   * `radius2` are provided.
   * @api
   */
  var RegularShape = /** @class */ (function (_super) {
      __extends$O(RegularShape, _super);
      /**
       * @param {Options} options Options.
       */
      function RegularShape(options) {
          var _this = this;
          /**
           * @type {boolean}
           */
          var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
          _this = _super.call(this, {
              opacity: 1,
              rotateWithView: rotateWithView,
              rotation: options.rotation !== undefined ? options.rotation : 0,
              scale: 1,
              displacement: options.displacement !== undefined ? options.displacement : [0, 0],
          }) || this;
          /**
           * @private
           * @type {Object<number, HTMLCanvasElement>}
           */
          _this.canvas_ = {};
          /**
           * @private
           * @type {HTMLCanvasElement}
           */
          _this.hitDetectionCanvas_ = null;
          /**
           * @private
           * @type {import("./Fill.js").default}
           */
          _this.fill_ = options.fill !== undefined ? options.fill : null;
          /**
           * @private
           * @type {Array<number>}
           */
          _this.origin_ = [0, 0];
          /**
           * @private
           * @type {number}
           */
          _this.points_ = options.points;
          /**
           * @protected
           * @type {number}
           */
          _this.radius_ =
              options.radius !== undefined ? options.radius : options.radius1;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.radius2_ = options.radius2;
          /**
           * @private
           * @type {number}
           */
          _this.angle_ = options.angle !== undefined ? options.angle : 0;
          /**
           * @private
           * @type {import("./Stroke.js").default}
           */
          _this.stroke_ = options.stroke !== undefined ? options.stroke : null;
          /**
           * @private
           * @type {Array<number>}
           */
          _this.anchor_ = null;
          /**
           * @private
           * @type {import("../size.js").Size}
           */
          _this.size_ = null;
          /**
           * @private
           * @type {import("../size.js").Size}
           */
          _this.imageSize_ = null;
          /**
           * @private
           * @type {import("../size.js").Size}
           */
          _this.hitDetectionImageSize_ = null;
          _this.render();
          return _this;
      }
      /**
       * Clones the style.
       * @return {RegularShape} The cloned style.
       * @api
       */
      RegularShape.prototype.clone = function () {
          var style = new RegularShape({
              fill: this.getFill() ? this.getFill().clone() : undefined,
              points: this.getPoints(),
              radius: this.getRadius(),
              radius2: this.getRadius2(),
              angle: this.getAngle(),
              stroke: this.getStroke() ? this.getStroke().clone() : undefined,
              rotation: this.getRotation(),
              rotateWithView: this.getRotateWithView(),
              displacement: this.getDisplacement().slice(),
          });
          style.setOpacity(this.getOpacity());
          style.setScale(this.getScale());
          return style;
      };
      /**
       * Get the anchor point in pixels. The anchor determines the center point for the
       * symbolizer.
       * @return {Array<number>} Anchor.
       * @api
       */
      RegularShape.prototype.getAnchor = function () {
          return this.anchor_;
      };
      /**
       * Get the angle used in generating the shape.
       * @return {number} Shape's rotation in radians.
       * @api
       */
      RegularShape.prototype.getAngle = function () {
          return this.angle_;
      };
      /**
       * Get the fill style for the shape.
       * @return {import("./Fill.js").default} Fill style.
       * @api
       */
      RegularShape.prototype.getFill = function () {
          return this.fill_;
      };
      /**
       * @return {HTMLCanvasElement} Image element.
       */
      RegularShape.prototype.getHitDetectionImage = function () {
          if (!this.hitDetectionCanvas_) {
              var renderOptions = this.createRenderOptions();
              this.createHitDetectionCanvas_(renderOptions);
          }
          return this.hitDetectionCanvas_;
      };
      /**
       * Get the image icon.
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLCanvasElement} Image or Canvas element.
       * @api
       */
      RegularShape.prototype.getImage = function (pixelRatio) {
          if (!this.canvas_[pixelRatio || 1]) {
              var renderOptions = this.createRenderOptions();
              var context = createCanvasContext2D(renderOptions.size * pixelRatio || 1, renderOptions.size * pixelRatio || 1);
              this.draw_(renderOptions, context, 0, 0, pixelRatio || 1);
              this.canvas_[pixelRatio || 1] = context.canvas;
          }
          return this.canvas_[pixelRatio || 1];
      };
      /*
       * Get the image pixel ratio.
       * @param {number} pixelRatio Pixel ratio.
       * */
      RegularShape.prototype.getPixelRatio = function (pixelRatio) {
          return pixelRatio;
      };
      /**
       * @return {import("../size.js").Size} Image size.
       */
      RegularShape.prototype.getImageSize = function () {
          return this.imageSize_;
      };
      /**
       * @return {import("../size.js").Size} Size of the hit-detection image.
       */
      RegularShape.prototype.getHitDetectionImageSize = function () {
          return this.hitDetectionImageSize_;
      };
      /**
       * @return {import("../ImageState.js").default} Image state.
       */
      RegularShape.prototype.getImageState = function () {
          return ImageState.LOADED;
      };
      /**
       * Get the origin of the symbolizer.
       * @return {Array<number>} Origin.
       * @api
       */
      RegularShape.prototype.getOrigin = function () {
          return this.origin_;
      };
      /**
       * Get the number of points for generating the shape.
       * @return {number} Number of points for stars and regular polygons.
       * @api
       */
      RegularShape.prototype.getPoints = function () {
          return this.points_;
      };
      /**
       * Get the (primary) radius for the shape.
       * @return {number} Radius.
       * @api
       */
      RegularShape.prototype.getRadius = function () {
          return this.radius_;
      };
      /**
       * Get the secondary radius for the shape.
       * @return {number|undefined} Radius2.
       * @api
       */
      RegularShape.prototype.getRadius2 = function () {
          return this.radius2_;
      };
      /**
       * Get the size of the symbolizer (in pixels).
       * @return {import("../size.js").Size} Size.
       * @api
       */
      RegularShape.prototype.getSize = function () {
          return this.size_;
      };
      /**
       * Get the stroke style for the shape.
       * @return {import("./Stroke.js").default} Stroke style.
       * @api
       */
      RegularShape.prototype.getStroke = function () {
          return this.stroke_;
      };
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      RegularShape.prototype.listenImageChange = function (listener) { };
      /**
       * Load not yet loaded URI.
       */
      RegularShape.prototype.load = function () { };
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      RegularShape.prototype.unlistenImageChange = function (listener) { };
      /**
       * @returns {RenderOptions}  The render options
       * @protected
       */
      RegularShape.prototype.createRenderOptions = function () {
          var lineCap = defaultLineCap;
          var lineJoin = defaultLineJoin;
          var miterLimit = 0;
          var lineDash = null;
          var lineDashOffset = 0;
          var strokeStyle;
          var strokeWidth = 0;
          if (this.stroke_) {
              strokeStyle = this.stroke_.getColor();
              if (strokeStyle === null) {
                  strokeStyle = defaultStrokeStyle;
              }
              strokeStyle = asColorLike(strokeStyle);
              strokeWidth = this.stroke_.getWidth();
              if (strokeWidth === undefined) {
                  strokeWidth = defaultLineWidth;
              }
              lineDash = this.stroke_.getLineDash();
              lineDashOffset = this.stroke_.getLineDashOffset();
              lineJoin = this.stroke_.getLineJoin();
              if (lineJoin === undefined) {
                  lineJoin = defaultLineJoin;
              }
              lineCap = this.stroke_.getLineCap();
              if (lineCap === undefined) {
                  lineCap = defaultLineCap;
              }
              miterLimit = this.stroke_.getMiterLimit();
              if (miterLimit === undefined) {
                  miterLimit = defaultMiterLimit;
              }
          }
          var size = 2 * (this.radius_ + strokeWidth) + 1;
          return {
              strokeStyle: strokeStyle,
              strokeWidth: strokeWidth,
              size: size,
              lineCap: lineCap,
              lineDash: lineDash,
              lineDashOffset: lineDashOffset,
              lineJoin: lineJoin,
              miterLimit: miterLimit,
          };
      };
      /**
       * @protected
       */
      RegularShape.prototype.render = function () {
          var renderOptions = this.createRenderOptions();
          var context = createCanvasContext2D(renderOptions.size, renderOptions.size);
          this.draw_(renderOptions, context, 0, 0, 1);
          this.canvas_[1] = context.canvas;
          // canvas.width and height are rounded to the closest integer
          var size = context.canvas.width;
          var imageSize = size;
          var displacement = this.getDisplacement();
          this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];
          this.createHitDetectionCanvas_(renderOptions);
          this.anchor_ = [size / 2 - displacement[0], size / 2 + displacement[1]];
          this.size_ = [size, size];
          this.imageSize_ = [imageSize, imageSize];
      };
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       * @param {CanvasRenderingContext2D} context The rendering context.
       * @param {number} x The origin for the symbol (x).
       * @param {number} y The origin for the symbol (y).
       * @param {number} pixelRatio The pixel ratio.
       */
      RegularShape.prototype.draw_ = function (renderOptions, context, x, y, pixelRatio) {
          var i, angle0, radiusC;
          // reset transform
          context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
          // then move to (x, y)
          context.translate(x, y);
          context.beginPath();
          var points = this.points_;
          if (points === Infinity) {
              context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);
          }
          else {
              var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;
              if (radius2 !== this.radius_) {
                  points = 2 * points;
              }
              for (i = 0; i <= points; i++) {
                  angle0 = (i * 2 * Math.PI) / points - Math.PI / 2 + this.angle_;
                  radiusC = i % 2 === 0 ? this.radius_ : radius2;
                  context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));
              }
          }
          if (this.fill_) {
              var color = this.fill_.getColor();
              if (color === null) {
                  color = defaultFillStyle;
              }
              context.fillStyle = asColorLike(color);
              context.fill();
          }
          if (this.stroke_) {
              context.strokeStyle = renderOptions.strokeStyle;
              context.lineWidth = renderOptions.strokeWidth;
              if (context.setLineDash && renderOptions.lineDash) {
                  context.setLineDash(renderOptions.lineDash);
                  context.lineDashOffset = renderOptions.lineDashOffset;
              }
              context.lineCap = renderOptions.lineCap;
              context.lineJoin = renderOptions.lineJoin;
              context.miterLimit = renderOptions.miterLimit;
              context.stroke();
          }
          context.closePath();
      };
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       */
      RegularShape.prototype.createHitDetectionCanvas_ = function (renderOptions) {
          this.hitDetectionCanvas_ = this.getImage(1);
          if (this.fill_) {
              var color = this.fill_.getColor();
              // determine if fill is transparent (or pattern or gradient)
              var opacity = 0;
              if (typeof color === 'string') {
                  color = asArray(color);
              }
              if (color === null) {
                  opacity = 1;
              }
              else if (Array.isArray(color)) {
                  opacity = color.length === 4 ? color[3] : 1;
              }
              if (opacity === 0) {
                  // if a transparent fill style is set, create an extra hit-detection image
                  // with a default fill style
                  var context = createCanvasContext2D(renderOptions.size, renderOptions.size);
                  this.hitDetectionCanvas_ = context.canvas;
                  this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);
              }
          }
      };
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       * @param {CanvasRenderingContext2D} context The context.
       * @param {number} x The origin for the symbol (x).
       * @param {number} y The origin for the symbol (y).
       */
      RegularShape.prototype.drawHitDetectionCanvas_ = function (renderOptions, context, x, y) {
          // move to (x, y)
          context.translate(x, y);
          context.beginPath();
          var points = this.points_;
          if (points === Infinity) {
              context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);
          }
          else {
              var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;
              if (radius2 !== this.radius_) {
                  points = 2 * points;
              }
              var i = void 0, radiusC = void 0, angle0 = void 0;
              for (i = 0; i <= points; i++) {
                  angle0 = (i * 2 * Math.PI) / points - Math.PI / 2 + this.angle_;
                  radiusC = i % 2 === 0 ? this.radius_ : radius2;
                  context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));
              }
          }
          context.fillStyle = defaultFillStyle;
          context.fill();
          if (this.stroke_) {
              context.strokeStyle = renderOptions.strokeStyle;
              context.lineWidth = renderOptions.strokeWidth;
              if (renderOptions.lineDash) {
                  context.setLineDash(renderOptions.lineDash);
                  context.lineDashOffset = renderOptions.lineDashOffset;
              }
              context.stroke();
          }
          context.closePath();
      };
      return RegularShape;
  }(ImageStyle));

  /**
   * @module ol/style/Circle
   */
  var __extends$P = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {import("./Fill.js").default} [fill] Fill style.
   * @property {number} radius Circle radius.
   * @property {import("./Stroke.js").default} [stroke] Stroke style.
   * @property {Array<number>} [displacement=[0,0]] displacement
   */
  /**
   * @classdesc
   * Set circle style for vector features.
   * @api
   */
  var CircleStyle = /** @class */ (function (_super) {
      __extends$P(CircleStyle, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function CircleStyle(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, {
              points: Infinity,
              fill: options.fill,
              radius: options.radius,
              stroke: options.stroke,
              displacement: options.displacement !== undefined ? options.displacement : [0, 0],
          }) || this;
          return _this;
      }
      /**
       * Clones the style.
       * @return {CircleStyle} The cloned style.
       * @api
       */
      CircleStyle.prototype.clone = function () {
          var style = new CircleStyle({
              fill: this.getFill() ? this.getFill().clone() : undefined,
              stroke: this.getStroke() ? this.getStroke().clone() : undefined,
              radius: this.getRadius(),
              displacement: this.getDisplacement().slice(),
          });
          style.setOpacity(this.getOpacity());
          style.setScale(this.getScale());
          return style;
      };
      /**
       * Set the circle radius.
       *
       * @param {number} radius Circle radius.
       * @api
       */
      CircleStyle.prototype.setRadius = function (radius) {
          this.radius_ = radius;
          this.render();
      };
      return CircleStyle;
  }(RegularShape));

  /**
   * @module ol/style/Fill
   */
  /**
   * @typedef {Object} Options
   * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color=null] A color, gradient or pattern.
   * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
   * Default null; if null, the Canvas/renderer default black will be used.
   */
  /**
   * @classdesc
   * Set fill style for vector features.
   * @api
   */
  var Fill = /** @class */ (function () {
      /**
       * @param {Options=} opt_options Options.
       */
      function Fill(opt_options) {
          var options = opt_options || {};
          /**
           * @private
           * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
           */
          this.color_ = options.color !== undefined ? options.color : null;
      }
      /**
       * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
       * @return {Fill} The cloned style.
       * @api
       */
      Fill.prototype.clone = function () {
          var color = this.getColor();
          return new Fill({
              color: Array.isArray(color) ? color.slice() : color || undefined,
          });
      };
      /**
       * Get the fill color.
       * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
       * @api
       */
      Fill.prototype.getColor = function () {
          return this.color_;
      };
      /**
       * Set the color.
       *
       * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
       * @api
       */
      Fill.prototype.setColor = function (color) {
          this.color_ = color;
      };
      return Fill;
  }());

  /**
   * @module ol/style/Stroke
   */
  /**
   * @typedef {Object} Options
   * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.
   * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
   * Default null; if null, the Canvas/renderer default black will be used.
   * @property {CanvasLineCap} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.
   * @property {CanvasLineJoin} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.
   * @property {Array<number>} [lineDash] Line dash pattern. Default is `null` (no dash).
   * Please note that Internet Explorer 10 and lower do not support the `setLineDash` method on
   * the `CanvasRenderingContext2D` and therefore this option will have no visual effect in these browsers.
   * @property {number} [lineDashOffset=0] Line dash offset.
   * @property {number} [miterLimit=10] Miter limit.
   * @property {number} [width] Width.
   */
  /**
   * @classdesc
   * Set stroke style for vector features.
   * Note that the defaults given are the Canvas defaults, which will be used if
   * option is not defined. The `get` functions return whatever was entered in
   * the options; they will not return the default.
   * @api
   */
  var Stroke = /** @class */ (function () {
      /**
       * @param {Options=} opt_options Options.
       */
      function Stroke(opt_options) {
          var options = opt_options || {};
          /**
           * @private
           * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
           */
          this.color_ = options.color !== undefined ? options.color : null;
          /**
           * @private
           * @type {CanvasLineCap|undefined}
           */
          this.lineCap_ = options.lineCap;
          /**
           * @private
           * @type {Array<number>}
           */
          this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;
          /**
           * @private
           * @type {number|undefined}
           */
          this.lineDashOffset_ = options.lineDashOffset;
          /**
           * @private
           * @type {CanvasLineJoin|undefined}
           */
          this.lineJoin_ = options.lineJoin;
          /**
           * @private
           * @type {number|undefined}
           */
          this.miterLimit_ = options.miterLimit;
          /**
           * @private
           * @type {number|undefined}
           */
          this.width_ = options.width;
      }
      /**
       * Clones the style.
       * @return {Stroke} The cloned style.
       * @api
       */
      Stroke.prototype.clone = function () {
          var color = this.getColor();
          return new Stroke({
              color: Array.isArray(color) ? color.slice() : color || undefined,
              lineCap: this.getLineCap(),
              lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
              lineDashOffset: this.getLineDashOffset(),
              lineJoin: this.getLineJoin(),
              miterLimit: this.getMiterLimit(),
              width: this.getWidth(),
          });
      };
      /**
       * Get the stroke color.
       * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
       * @api
       */
      Stroke.prototype.getColor = function () {
          return this.color_;
      };
      /**
       * Get the line cap type for the stroke.
       * @return {CanvasLineCap|undefined} Line cap.
       * @api
       */
      Stroke.prototype.getLineCap = function () {
          return this.lineCap_;
      };
      /**
       * Get the line dash style for the stroke.
       * @return {Array<number>} Line dash.
       * @api
       */
      Stroke.prototype.getLineDash = function () {
          return this.lineDash_;
      };
      /**
       * Get the line dash offset for the stroke.
       * @return {number|undefined} Line dash offset.
       * @api
       */
      Stroke.prototype.getLineDashOffset = function () {
          return this.lineDashOffset_;
      };
      /**
       * Get the line join type for the stroke.
       * @return {CanvasLineJoin|undefined} Line join.
       * @api
       */
      Stroke.prototype.getLineJoin = function () {
          return this.lineJoin_;
      };
      /**
       * Get the miter limit for the stroke.
       * @return {number|undefined} Miter limit.
       * @api
       */
      Stroke.prototype.getMiterLimit = function () {
          return this.miterLimit_;
      };
      /**
       * Get the stroke width.
       * @return {number|undefined} Width.
       * @api
       */
      Stroke.prototype.getWidth = function () {
          return this.width_;
      };
      /**
       * Set the color.
       *
       * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
       * @api
       */
      Stroke.prototype.setColor = function (color) {
          this.color_ = color;
      };
      /**
       * Set the line cap.
       *
       * @param {CanvasLineCap|undefined} lineCap Line cap.
       * @api
       */
      Stroke.prototype.setLineCap = function (lineCap) {
          this.lineCap_ = lineCap;
      };
      /**
       * Set the line dash.
       *
       * Please note that Internet Explorer 10 and lower [do not support][mdn] the
       * `setLineDash` method on the `CanvasRenderingContext2D` and therefore this
       * property will have no visual effect in these browsers.
       *
       * [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility
       *
       * @param {Array<number>} lineDash Line dash.
       * @api
       */
      Stroke.prototype.setLineDash = function (lineDash) {
          this.lineDash_ = lineDash;
      };
      /**
       * Set the line dash offset.
       *
       * @param {number|undefined} lineDashOffset Line dash offset.
       * @api
       */
      Stroke.prototype.setLineDashOffset = function (lineDashOffset) {
          this.lineDashOffset_ = lineDashOffset;
      };
      /**
       * Set the line join.
       *
       * @param {CanvasLineJoin|undefined} lineJoin Line join.
       * @api
       */
      Stroke.prototype.setLineJoin = function (lineJoin) {
          this.lineJoin_ = lineJoin;
      };
      /**
       * Set the miter limit.
       *
       * @param {number|undefined} miterLimit Miter limit.
       * @api
       */
      Stroke.prototype.setMiterLimit = function (miterLimit) {
          this.miterLimit_ = miterLimit;
      };
      /**
       * Set the width.
       *
       * @param {number|undefined} width Width.
       * @api
       */
      Stroke.prototype.setWidth = function (width) {
          this.width_ = width;
      };
      return Stroke;
  }());

  /**
   * @module ol/style/Style
   */
  /**
   * A function that takes an {@link module:ol/Feature} and a `{number}`
   * representing the view's resolution. The function should return a
   * {@link module:ol/style/Style} or an array of them. This way e.g. a
   * vector layer can be styled. If the function returns `undefined`, the
   * feature will not be rendered.
   *
   * @typedef {function(import("../Feature.js").FeatureLike, number):(Style|Array<Style>|void)} StyleFunction
   */
  /**
   * A {@link Style}, an array of {@link Style}, or a {@link StyleFunction}.
   * @typedef {Style|Array<Style>|StyleFunction} StyleLike
   */
  /**
   * A function that takes an {@link module:ol/Feature} as argument and returns an
   * {@link module:ol/geom/Geometry} that will be rendered and styled for the feature.
   *
   * @typedef {function(import("../Feature.js").FeatureLike):
   *     (import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined)} GeometryFunction
   */
  /**
   * Custom renderer function. Takes two arguments:
   *
   * 1. The pixel coordinates of the geometry in GeoJSON notation.
   * 2. The {@link module:ol/render~State} of the layer renderer.
   *
   * @typedef {function((import("../coordinate.js").Coordinate|Array<import("../coordinate.js").Coordinate>|Array<Array<import("../coordinate.js").Coordinate>>),import("../render.js").State): void}
   * RenderFunction
   */
  /**
   * @typedef {Object} Options
   * @property {string|import("../geom/Geometry.js").default|GeometryFunction} [geometry] Feature property or geometry
   * or function returning a geometry to render for this style.
   * @property {import("./Fill.js").default} [fill] Fill style.
   * @property {import("./Image.js").default} [image] Image style.
   * @property {RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be
   * ignored, and the provided function will be called with each render frame for each geometry.
   * @property {import("./Stroke.js").default} [stroke] Stroke style.
   * @property {import("./Text.js").default} [text] Text style.
   * @property {number} [zIndex] Z index.
   */
  /**
   * @classdesc
   * Container for vector feature rendering styles. Any changes made to the style
   * or its children through `set*()` methods will not take effect until the
   * feature or layer that uses the style is re-rendered.
   *
   * ## Feature styles
   *
   * If no style is defined, the following default style is used:
   * ```js
   *  import {Fill, Stroke, Circle, Style} from 'ol/style';
   *
   *  var fill = new Fill({
   *    color: 'rgba(255,255,255,0.4)'
   *  });
   *  var stroke = new Stroke({
   *    color: '#3399CC',
   *    width: 1.25
   *  });
   *  var styles = [
   *    new Style({
   *      image: new Circle({
   *        fill: fill,
   *        stroke: stroke,
   *        radius: 5
   *      }),
   *      fill: fill,
   *      stroke: stroke
   *    })
   *  ];
   * ```
   *
   * A separate editing style has the following defaults:
   * ```js
   *  import {Fill, Stroke, Circle, Style} from 'ol/style';
   *  import GeometryType from 'ol/geom/GeometryType';
   *
   *  var white = [255, 255, 255, 1];
   *  var blue = [0, 153, 255, 1];
   *  var width = 3;
   *  styles[GeometryType.POLYGON] = [
   *    new Style({
   *      fill: new Fill({
   *        color: [255, 255, 255, 0.5]
   *      })
   *    })
   *  ];
   *  styles[GeometryType.MULTI_POLYGON] =
   *      styles[GeometryType.POLYGON];
   *  styles[GeometryType.LINE_STRING] = [
   *    new Style({
   *      stroke: new Stroke({
   *        color: white,
   *        width: width + 2
   *      })
   *    }),
   *    new Style({
   *      stroke: new Stroke({
   *        color: blue,
   *        width: width
   *      })
   *    })
   *  ];
   *  styles[GeometryType.MULTI_LINE_STRING] =
   *      styles[GeometryType.LINE_STRING];
   *  styles[GeometryType.POINT] = [
   *    new Style({
   *      image: new Circle({
   *        radius: width * 2,
   *        fill: new Fill({
   *          color: blue
   *        }),
   *        stroke: new Stroke({
   *          color: white,
   *          width: width / 2
   *        })
   *      }),
   *      zIndex: Infinity
   *    })
   *  ];
   *  styles[GeometryType.MULTI_POINT] =
   *      styles[GeometryType.POINT];
   *  styles[GeometryType.GEOMETRY_COLLECTION] =
   *      styles[GeometryType.POLYGON].concat(
   *          styles[GeometryType.LINE_STRING],
   *          styles[GeometryType.POINT]
   *      );
   * ```
   *
   * @api
   */
  var Style = /** @class */ (function () {
      /**
       * @param {Options=} opt_options Style options.
       */
      function Style(opt_options) {
          var options = opt_options || {};
          /**
           * @private
           * @type {string|import("../geom/Geometry.js").default|GeometryFunction}
           */
          this.geometry_ = null;
          /**
           * @private
           * @type {!GeometryFunction}
           */
          this.geometryFunction_ = defaultGeometryFunction;
          if (options.geometry !== undefined) {
              this.setGeometry(options.geometry);
          }
          /**
           * @private
           * @type {import("./Fill.js").default}
           */
          this.fill_ = options.fill !== undefined ? options.fill : null;
          /**
           * @private
           * @type {import("./Image.js").default}
           */
          this.image_ = options.image !== undefined ? options.image : null;
          /**
           * @private
           * @type {RenderFunction|null}
           */
          this.renderer_ = options.renderer !== undefined ? options.renderer : null;
          /**
           * @private
           * @type {import("./Stroke.js").default}
           */
          this.stroke_ = options.stroke !== undefined ? options.stroke : null;
          /**
           * @private
           * @type {import("./Text.js").default}
           */
          this.text_ = options.text !== undefined ? options.text : null;
          /**
           * @private
           * @type {number|undefined}
           */
          this.zIndex_ = options.zIndex;
      }
      /**
       * Clones the style.
       * @return {Style} The cloned style.
       * @api
       */
      Style.prototype.clone = function () {
          var geometry = this.getGeometry();
          if (geometry && typeof geometry === 'object') {
              geometry = /** @type {import("../geom/Geometry.js").default} */ (geometry).clone();
          }
          return new Style({
              geometry: geometry,
              fill: this.getFill() ? this.getFill().clone() : undefined,
              image: this.getImage() ? this.getImage().clone() : undefined,
              stroke: this.getStroke() ? this.getStroke().clone() : undefined,
              text: this.getText() ? this.getText().clone() : undefined,
              zIndex: this.getZIndex(),
          });
      };
      /**
       * Get the custom renderer function that was configured with
       * {@link #setRenderer} or the `renderer` constructor option.
       * @return {RenderFunction|null} Custom renderer function.
       * @api
       */
      Style.prototype.getRenderer = function () {
          return this.renderer_;
      };
      /**
       * Sets a custom renderer function for this style. When set, `fill`, `stroke`
       * and `image` options of the style will be ignored.
       * @param {RenderFunction|null} renderer Custom renderer function.
       * @api
       */
      Style.prototype.setRenderer = function (renderer) {
          this.renderer_ = renderer;
      };
      /**
       * Get the geometry to be rendered.
       * @return {string|import("../geom/Geometry.js").default|GeometryFunction}
       * Feature property or geometry or function that returns the geometry that will
       * be rendered with this style.
       * @api
       */
      Style.prototype.getGeometry = function () {
          return this.geometry_;
      };
      /**
       * Get the function used to generate a geometry for rendering.
       * @return {!GeometryFunction} Function that is called with a feature
       * and returns the geometry to render instead of the feature's geometry.
       * @api
       */
      Style.prototype.getGeometryFunction = function () {
          return this.geometryFunction_;
      };
      /**
       * Get the fill style.
       * @return {import("./Fill.js").default} Fill style.
       * @api
       */
      Style.prototype.getFill = function () {
          return this.fill_;
      };
      /**
       * Set the fill style.
       * @param {import("./Fill.js").default} fill Fill style.
       * @api
       */
      Style.prototype.setFill = function (fill) {
          this.fill_ = fill;
      };
      /**
       * Get the image style.
       * @return {import("./Image.js").default} Image style.
       * @api
       */
      Style.prototype.getImage = function () {
          return this.image_;
      };
      /**
       * Set the image style.
       * @param {import("./Image.js").default} image Image style.
       * @api
       */
      Style.prototype.setImage = function (image) {
          this.image_ = image;
      };
      /**
       * Get the stroke style.
       * @return {import("./Stroke.js").default} Stroke style.
       * @api
       */
      Style.prototype.getStroke = function () {
          return this.stroke_;
      };
      /**
       * Set the stroke style.
       * @param {import("./Stroke.js").default} stroke Stroke style.
       * @api
       */
      Style.prototype.setStroke = function (stroke) {
          this.stroke_ = stroke;
      };
      /**
       * Get the text style.
       * @return {import("./Text.js").default} Text style.
       * @api
       */
      Style.prototype.getText = function () {
          return this.text_;
      };
      /**
       * Set the text style.
       * @param {import("./Text.js").default} text Text style.
       * @api
       */
      Style.prototype.setText = function (text) {
          this.text_ = text;
      };
      /**
       * Get the z-index for the style.
       * @return {number|undefined} ZIndex.
       * @api
       */
      Style.prototype.getZIndex = function () {
          return this.zIndex_;
      };
      /**
       * Set a geometry that is rendered instead of the feature's geometry.
       *
       * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
       *     Feature property or geometry or function returning a geometry to render
       *     for this style.
       * @api
       */
      Style.prototype.setGeometry = function (geometry) {
          if (typeof geometry === 'function') {
              this.geometryFunction_ = geometry;
          }
          else if (typeof geometry === 'string') {
              this.geometryFunction_ = function (feature) {
                  return /** @type {import("../geom/Geometry.js").default} */ (feature.get(geometry));
              };
          }
          else if (!geometry) {
              this.geometryFunction_ = defaultGeometryFunction;
          }
          else if (geometry !== undefined) {
              this.geometryFunction_ = function () {
                  return /** @type {import("../geom/Geometry.js").default} */ (geometry);
              };
          }
          this.geometry_ = geometry;
      };
      /**
       * Set the z-index.
       *
       * @param {number|undefined} zIndex ZIndex.
       * @api
       */
      Style.prototype.setZIndex = function (zIndex) {
          this.zIndex_ = zIndex;
      };
      return Style;
  }());
  /**
   * Convert the provided object into a style function.  Functions passed through
   * unchanged.  Arrays of Style or single style objects wrapped in a
   * new style function.
   * @param {StyleFunction|Array<Style>|Style} obj
   *     A style function, a single style, or an array of styles.
   * @return {StyleFunction} A style function.
   */
  function toFunction(obj) {
      var styleFunction;
      if (typeof obj === 'function') {
          styleFunction = obj;
      }
      else {
          /**
           * @type {Array<Style>}
           */
          var styles_1;
          if (Array.isArray(obj)) {
              styles_1 = obj;
          }
          else {
              assert(typeof ( /** @type {?} */(obj).getZIndex) === 'function', 41); // Expected an `Style` or an array of `Style`
              var style = /** @type {Style} */ (obj);
              styles_1 = [style];
          }
          styleFunction = function () {
              return styles_1;
          };
      }
      return styleFunction;
  }
  /**
   * @type {Array<Style>}
   */
  var defaultStyles = null;
  /**
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} resolution Resolution.
   * @return {Array<Style>} Style.
   */
  function createDefaultStyle(feature, resolution) {
      // We don't use an immediately-invoked function
      // and a closure so we don't get an error at script evaluation time in
      // browsers that do not support Canvas. (import("./Circle.js").CircleStyle does
      // canvas.getContext('2d') at construction time, which will cause an.error
      // in such browsers.)
      if (!defaultStyles) {
          var fill = new Fill({
              color: 'rgba(255,255,255,0.4)',
          });
          var stroke = new Stroke({
              color: '#3399CC',
              width: 1.25,
          });
          defaultStyles = [
              new Style({
                  image: new CircleStyle({
                      fill: fill,
                      stroke: stroke,
                      radius: 5,
                  }),
                  fill: fill,
                  stroke: stroke,
              }),
          ];
      }
      return defaultStyles;
  }
  /**
   * Default styles for editing features.
   * @return {Object<import("../geom/GeometryType.js").default, Array<Style>>} Styles
   */
  function createEditingStyle() {
      /** @type {Object<import("../geom/GeometryType.js").default, Array<Style>>} */
      var styles = {};
      var white = [255, 255, 255, 1];
      var blue = [0, 153, 255, 1];
      var width = 3;
      styles[GeometryType.POLYGON] = [
          new Style({
              fill: new Fill({
                  color: [255, 255, 255, 0.5],
              }),
          }),
      ];
      styles[GeometryType.MULTI_POLYGON] = styles[GeometryType.POLYGON];
      styles[GeometryType.LINE_STRING] = [
          new Style({
              stroke: new Stroke({
                  color: white,
                  width: width + 2,
              }),
          }),
          new Style({
              stroke: new Stroke({
                  color: blue,
                  width: width,
              }),
          }),
      ];
      styles[GeometryType.MULTI_LINE_STRING] = styles[GeometryType.LINE_STRING];
      styles[GeometryType.CIRCLE] = styles[GeometryType.POLYGON].concat(styles[GeometryType.LINE_STRING]);
      styles[GeometryType.POINT] = [
          new Style({
              image: new CircleStyle({
                  radius: width * 2,
                  fill: new Fill({
                      color: blue,
                  }),
                  stroke: new Stroke({
                      color: white,
                      width: width / 2,
                  }),
              }),
              zIndex: Infinity,
          }),
      ];
      styles[GeometryType.MULTI_POINT] = styles[GeometryType.POINT];
      styles[GeometryType.GEOMETRY_COLLECTION] = styles[GeometryType.POLYGON].concat(styles[GeometryType.LINE_STRING], styles[GeometryType.POINT]);
      return styles;
  }
  /**
   * Function that is called with a feature and returns its default geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature to get the geometry for.
   * @return {import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined} Geometry to render.
   */
  function defaultGeometryFunction(feature) {
      return feature.getGeometry();
  }

  var __extends$Q = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
   * @property {number} [opacity=1] Opacity (0, 1).
   * @property {boolean} [visible=true] Visibility.
   * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
   * rendered outside of this extent.
   * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
   * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
   * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
   * method was used.
   * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
   * visible.
   * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
   * be visible.
   * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
   * visible.
   * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
   * be visible.
   * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
   * features before rendering. By default features are drawn in the order that they are created. Use
   * `null` to avoid the sort, but get an undefined draw order.
   * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
   * renderer when getting features from the vector source for the rendering or hit-detection.
   * Recommended value: the size of the largest symbol, line width or label.
   * @property {import("../source/Vector.js").default} [source] Source.
   * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
   * this layer in its layers collection, and the layer will be rendered on top. This is useful for
   * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
   * use {@link module:ol/Map#addLayer}.
   * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all
   * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority
   * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.
   * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has
   * higher priority.
   * @property {import("../style/Style.js").StyleLike|null} [style] Layer style. When set to `null`, only
   * features that have their own style will be rendered. See {@link module:ol/style} for default style
   * which will be used if this is not set.
   * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will
   * be recreated during animations. This means that no vectors will be shown clipped, but the
   * setting will have a performance impact for large amounts of vector data. When set to `false`,
   * batches will be recreated when no animation is active.
   * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will
   * be recreated during interactions. See also `updateWhileAnimating`.
   */
  /**
   * @enum {string}
   * @private
   */
  var Property$3 = {
      RENDER_ORDER: 'renderOrder',
  };
  /**
   * @classdesc
   * Vector data that is rendered client-side.
   * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
   * property on the layer object; for example, setting `title: 'My Title'` in the
   * options means that `title` is observable, and has get/set accessors.
   *
   * @template {import("../source/Vector.js").default|import("../source/VectorTile.js").default} VectorSourceType
   * @extends {Layer<VectorSourceType>}
   * @api
   */
  var BaseVectorLayer = /** @class */ (function (_super) {
      __extends$Q(BaseVectorLayer, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function BaseVectorLayer(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          var baseOptions = assign({}, options);
          delete baseOptions.style;
          delete baseOptions.renderBuffer;
          delete baseOptions.updateWhileAnimating;
          delete baseOptions.updateWhileInteracting;
          _this = _super.call(this, baseOptions) || this;
          /**
           * @private
           * @type {boolean}
           */
          _this.declutter_ =
              options.declutter !== undefined ? options.declutter : false;
          /**
           * @type {number}
           * @private
           */
          _this.renderBuffer_ =
              options.renderBuffer !== undefined ? options.renderBuffer : 100;
          /**
           * User provided style.
           * @type {import("../style/Style.js").StyleLike}
           * @private
           */
          _this.style_ = null;
          /**
           * Style function for use within the library.
           * @type {import("../style/Style.js").StyleFunction|undefined}
           * @private
           */
          _this.styleFunction_ = undefined;
          _this.setStyle(options.style);
          /**
           * @type {boolean}
           * @private
           */
          _this.updateWhileAnimating_ =
              options.updateWhileAnimating !== undefined
                  ? options.updateWhileAnimating
                  : false;
          /**
           * @type {boolean}
           * @private
           */
          _this.updateWhileInteracting_ =
              options.updateWhileInteracting !== undefined
                  ? options.updateWhileInteracting
                  : false;
          return _this;
      }
      /**
       * @return {boolean} Declutter.
       */
      BaseVectorLayer.prototype.getDeclutter = function () {
          return this.declutter_;
      };
      /**
       * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
       * that resolves with an array of features. The array will either contain the topmost feature
       * when a hit was detected, or it will be empty.
       *
       * The hit detection algorithm used for this method is optimized for performance, but is less
       * accurate than the one used in {@link import("../PluggableMap.js").default#getFeaturesAtPixel}: Text
       * is not considered, and icons are only represented by their bounding box instead of the exact
       * image.
       *
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with an array of features.
       * @api
       */
      BaseVectorLayer.prototype.getFeatures = function (pixel) {
          return _super.prototype.getFeatures.call(this, pixel);
      };
      /**
       * @return {number|undefined} Render buffer.
       */
      BaseVectorLayer.prototype.getRenderBuffer = function () {
          return this.renderBuffer_;
      };
      /**
       * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
       *     order.
       */
      BaseVectorLayer.prototype.getRenderOrder = function () {
          return /** @type {import("../render.js").OrderFunction|null|undefined} */ (this.get(Property$3.RENDER_ORDER));
      };
      /**
       * Get the style for features.  This returns whatever was passed to the `style`
       * option at construction or to the `setStyle` method.
       * @return {import("../style/Style.js").StyleLike|null|undefined} Layer style.
       * @api
       */
      BaseVectorLayer.prototype.getStyle = function () {
          return this.style_;
      };
      /**
       * Get the style function.
       * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
       * @api
       */
      BaseVectorLayer.prototype.getStyleFunction = function () {
          return this.styleFunction_;
      };
      /**
       * @return {boolean} Whether the rendered layer should be updated while
       *     animating.
       */
      BaseVectorLayer.prototype.getUpdateWhileAnimating = function () {
          return this.updateWhileAnimating_;
      };
      /**
       * @return {boolean} Whether the rendered layer should be updated while
       *     interacting.
       */
      BaseVectorLayer.prototype.getUpdateWhileInteracting = function () {
          return this.updateWhileInteracting_;
      };
      /**
       * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
       *     Render order.
       */
      BaseVectorLayer.prototype.setRenderOrder = function (renderOrder) {
          this.set(Property$3.RENDER_ORDER, renderOrder);
      };
      /**
       * Set the style for features.  This can be a single style object, an array
       * of styles, or a function that takes a feature and resolution and returns
       * an array of styles. If set to `null`, the layer has no style (a `null` style),
       * so only features that have their own styles will be rendered in the layer. Call
       * `setStyle()` without arguments to reset to the default style. See
       * {@link module:ol/style} for information on the default style.
       * @param {(import("../style/Style.js").StyleLike|null)=} opt_style Layer style.
       * @api
       */
      BaseVectorLayer.prototype.setStyle = function (opt_style) {
          this.style_ = opt_style !== undefined ? opt_style : createDefaultStyle;
          this.styleFunction_ =
              opt_style === null ? undefined : toFunction(this.style_);
          this.changed();
      };
      return BaseVectorLayer;
  }(Layer));

  /**
   * @module ol/render/canvas/Instruction
   */
  /**
   * @enum {number}
   */
  var Instruction = {
      BEGIN_GEOMETRY: 0,
      BEGIN_PATH: 1,
      CIRCLE: 2,
      CLOSE_PATH: 3,
      CUSTOM: 4,
      DRAW_CHARS: 5,
      DRAW_IMAGE: 6,
      END_GEOMETRY: 7,
      FILL: 8,
      MOVE_TO_LINE_TO: 9,
      SET_FILL_STYLE: 10,
      SET_STROKE_STYLE: 11,
      STROKE: 12,
  };
  /**
   * @type {Array<Instruction>}
   */
  var fillInstruction = [Instruction.FILL];
  /**
   * @type {Array<Instruction>}
   */
  var strokeInstruction = [Instruction.STROKE];
  /**
   * @type {Array<Instruction>}
   */
  var beginPathInstruction = [Instruction.BEGIN_PATH];
  /**
   * @type {Array<Instruction>}
   */
  var closePathInstruction = [Instruction.CLOSE_PATH];

  var __extends$R = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} SerializableInstructions
   * @property {Array<*>} instructions The rendering instructions.
   * @property {Array<*>} hitDetectionInstructions The rendering hit detection instructions.
   * @property {Array<number>} coordinates The array of all coordinates.
   * @property {!Object<string, import("../canvas.js").TextState>} [textStates] The text states (decluttering).
   * @property {!Object<string, import("../canvas.js").FillState>} [fillStates] The fill states (decluttering).
   * @property {!Object<string, import("../canvas.js").StrokeState>} [strokeStates] The stroke states (decluttering).
   */
  var CanvasBuilder = /** @class */ (function (_super) {
      __extends$R(CanvasBuilder, _super);
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      function CanvasBuilder(tolerance, maxExtent, resolution, pixelRatio) {
          var _this = _super.call(this) || this;
          /**
           * @protected
           * @type {number}
           */
          _this.tolerance = tolerance;
          /**
           * @protected
           * @const
           * @type {import("../../extent.js").Extent}
           */
          _this.maxExtent = maxExtent;
          /**
           * @protected
           * @type {number}
           */
          _this.pixelRatio = pixelRatio;
          /**
           * @protected
           * @type {number}
           */
          _this.maxLineWidth = 0;
          /**
           * @protected
           * @const
           * @type {number}
           */
          _this.resolution = resolution;
          /**
           * @private
           * @type {Array<*>}
           */
          _this.beginGeometryInstruction1_ = null;
          /**
           * @private
           * @type {Array<*>}
           */
          _this.beginGeometryInstruction2_ = null;
          /**
           * @private
           * @type {import("../../extent.js").Extent}
           */
          _this.bufferedMaxExtent_ = null;
          /**
           * @protected
           * @type {Array<*>}
           */
          _this.instructions = [];
          /**
           * @protected
           * @type {Array<number>}
           */
          _this.coordinates = [];
          /**
           * @private
           * @type {import("../../coordinate.js").Coordinate}
           */
          _this.tmpCoordinate_ = [];
          /**
           * @protected
           * @type {Array<*>}
           */
          _this.hitDetectionInstructions = [];
          /**
           * @protected
           * @type {import("../canvas.js").FillStrokeState}
           */
          _this.state = /** @type {import("../canvas.js").FillStrokeState} */ ({});
          return _this;
      }
      /**
       * @protected
       * @param {Array<number>} dashArray Dash array.
       * @return {Array<number>} Dash array with pixel ratio applied
       */
      CanvasBuilder.prototype.applyPixelRatio = function (dashArray) {
          var pixelRatio = this.pixelRatio;
          return pixelRatio == 1
              ? dashArray
              : dashArray.map(function (dash) {
                  return dash * pixelRatio;
              });
      };
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @param {boolean} closed Last input coordinate equals first.
       * @param {boolean} skipFirst Skip first coordinate.
       * @protected
       * @return {number} My end.
       */
      CanvasBuilder.prototype.appendFlatCoordinates = function (flatCoordinates, offset, end, stride, closed, skipFirst) {
          var myEnd = this.coordinates.length;
          var extent = this.getBufferedMaxExtent();
          if (skipFirst) {
              offset += stride;
          }
          var lastXCoord = flatCoordinates[offset];
          var lastYCoord = flatCoordinates[offset + 1];
          var nextCoord = this.tmpCoordinate_;
          var skipped = true;
          var i, lastRel, nextRel;
          for (i = offset + stride; i < end; i += stride) {
              nextCoord[0] = flatCoordinates[i];
              nextCoord[1] = flatCoordinates[i + 1];
              nextRel = coordinateRelationship(extent, nextCoord);
              if (nextRel !== lastRel) {
                  if (skipped) {
                      this.coordinates[myEnd++] = lastXCoord;
                      this.coordinates[myEnd++] = lastYCoord;
                  }
                  this.coordinates[myEnd++] = nextCoord[0];
                  this.coordinates[myEnd++] = nextCoord[1];
                  skipped = false;
              }
              else if (nextRel === Relationship.INTERSECTING) {
                  this.coordinates[myEnd++] = nextCoord[0];
                  this.coordinates[myEnd++] = nextCoord[1];
                  skipped = false;
              }
              else {
                  skipped = true;
              }
              lastXCoord = nextCoord[0];
              lastYCoord = nextCoord[1];
              lastRel = nextRel;
          }
          // Last coordinate equals first or only one point to append:
          if ((closed && skipped) || i === offset + stride) {
              this.coordinates[myEnd++] = lastXCoord;
              this.coordinates[myEnd++] = lastYCoord;
          }
          return myEnd;
      };
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @param {Array<number>} builderEnds Builder ends.
       * @return {number} Offset.
       */
      CanvasBuilder.prototype.drawCustomCoordinates_ = function (flatCoordinates, offset, ends, stride, builderEnds) {
          for (var i = 0, ii = ends.length; i < ii; ++i) {
              var end = ends[i];
              var builderEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
              builderEnds.push(builderEnd);
              offset = end;
          }
          return offset;
      };
      /**
       * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {Function} renderer Renderer.
       */
      CanvasBuilder.prototype.drawCustom = function (geometry, feature, renderer) {
          this.beginGeometry(geometry, feature);
          var type = geometry.getType();
          var stride = geometry.getStride();
          var builderBegin = this.coordinates.length;
          var flatCoordinates, builderEnd, builderEnds, builderEndss;
          var offset;
          if (type == GeometryType.MULTI_POLYGON) {
              flatCoordinates = /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry).getOrientedFlatCoordinates();
              builderEndss = [];
              var endss = /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry).getEndss();
              offset = 0;
              for (var i = 0, ii = endss.length; i < ii; ++i) {
                  var myEnds = [];
                  offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);
                  builderEndss.push(myEnds);
              }
              this.instructions.push([
                  Instruction.CUSTOM,
                  builderBegin,
                  builderEndss,
                  geometry,
                  renderer,
                  inflateMultiCoordinatesArray,
              ]);
          }
          else if (type == GeometryType.POLYGON ||
              type == GeometryType.MULTI_LINE_STRING) {
              builderEnds = [];
              flatCoordinates =
                  type == GeometryType.POLYGON
                      ? /** @type {import("../../geom/Polygon.js").default} */ (geometry).getOrientedFlatCoordinates()
                      : geometry.getFlatCoordinates();
              offset = this.drawCustomCoordinates_(flatCoordinates, 0, 
              /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */ (geometry).getEnds(), stride, builderEnds);
              this.instructions.push([
                  Instruction.CUSTOM,
                  builderBegin,
                  builderEnds,
                  geometry,
                  renderer,
                  inflateCoordinatesArray,
              ]);
          }
          else if (type == GeometryType.LINE_STRING ||
              type == GeometryType.MULTI_POINT) {
              flatCoordinates = geometry.getFlatCoordinates();
              builderEnd = this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
              this.instructions.push([
                  Instruction.CUSTOM,
                  builderBegin,
                  builderEnd,
                  geometry,
                  renderer,
                  inflateCoordinates,
              ]);
          }
          else if (type == GeometryType.POINT) {
              flatCoordinates = geometry.getFlatCoordinates();
              this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
              builderEnd = this.coordinates.length;
              this.instructions.push([
                  Instruction.CUSTOM,
                  builderBegin,
                  builderEnd,
                  geometry,
                  renderer,
              ]);
          }
          this.endGeometry(feature);
      };
      /**
       * @protected
       * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasBuilder.prototype.beginGeometry = function (geometry, feature) {
          var extent = geometry.getExtent();
          this.beginGeometryInstruction1_ = [
              Instruction.BEGIN_GEOMETRY,
              feature,
              0,
              extent,
          ];
          this.instructions.push(this.beginGeometryInstruction1_);
          this.beginGeometryInstruction2_ = [
              Instruction.BEGIN_GEOMETRY,
              feature,
              0,
              extent,
          ];
          this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
      };
      /**
       * @return {SerializableInstructions} the serializable instructions.
       */
      CanvasBuilder.prototype.finish = function () {
          return {
              instructions: this.instructions,
              hitDetectionInstructions: this.hitDetectionInstructions,
              coordinates: this.coordinates,
          };
      };
      /**
       * Reverse the hit detection instructions.
       */
      CanvasBuilder.prototype.reverseHitDetectionInstructions = function () {
          var hitDetectionInstructions = this.hitDetectionInstructions;
          // step 1 - reverse array
          hitDetectionInstructions.reverse();
          // step 2 - reverse instructions within geometry blocks
          var i;
          var n = hitDetectionInstructions.length;
          var instruction;
          var type;
          var begin = -1;
          for (i = 0; i < n; ++i) {
              instruction = hitDetectionInstructions[i];
              type = /** @type {import("./Instruction.js").default} */ (instruction[0]);
              if (type == Instruction.END_GEOMETRY) {
                  begin = i;
              }
              else if (type == Instruction.BEGIN_GEOMETRY) {
                  instruction[2] = i;
                  reverseSubArray(this.hitDetectionInstructions, begin, i);
                  begin = -1;
              }
          }
      };
      /**
       * @param {import("../../style/Fill.js").default} fillStyle Fill style.
       * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
       */
      CanvasBuilder.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
          var state = this.state;
          if (fillStyle) {
              var fillStyleColor = fillStyle.getColor();
              state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);
          }
          else {
              state.fillStyle = undefined;
          }
          if (strokeStyle) {
              var strokeStyleColor = strokeStyle.getColor();
              state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);
              var strokeStyleLineCap = strokeStyle.getLineCap();
              state.lineCap =
                  strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap;
              var strokeStyleLineDash = strokeStyle.getLineDash();
              state.lineDash = strokeStyleLineDash
                  ? strokeStyleLineDash.slice()
                  : defaultLineDash;
              var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
              state.lineDashOffset = strokeStyleLineDashOffset
                  ? strokeStyleLineDashOffset
                  : defaultLineDashOffset;
              var strokeStyleLineJoin = strokeStyle.getLineJoin();
              state.lineJoin =
                  strokeStyleLineJoin !== undefined
                      ? strokeStyleLineJoin
                      : defaultLineJoin;
              var strokeStyleWidth = strokeStyle.getWidth();
              state.lineWidth =
                  strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth;
              var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
              state.miterLimit =
                  strokeStyleMiterLimit !== undefined
                      ? strokeStyleMiterLimit
                      : defaultMiterLimit;
              if (state.lineWidth > this.maxLineWidth) {
                  this.maxLineWidth = state.lineWidth;
                  // invalidate the buffered max extent cache
                  this.bufferedMaxExtent_ = null;
              }
          }
          else {
              state.strokeStyle = undefined;
              state.lineCap = undefined;
              state.lineDash = null;
              state.lineDashOffset = undefined;
              state.lineJoin = undefined;
              state.lineWidth = undefined;
              state.miterLimit = undefined;
          }
      };
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @return {Array<*>} Fill instruction.
       */
      CanvasBuilder.prototype.createFill = function (state) {
          var fillStyle = state.fillStyle;
          /** @type {Array<*>} */
          var fillInstruction = [Instruction.SET_FILL_STYLE, fillStyle];
          if (typeof fillStyle !== 'string') {
              // Fill is a pattern or gradient - align it!
              fillInstruction.push(true);
          }
          return fillInstruction;
      };
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       */
      CanvasBuilder.prototype.applyStroke = function (state) {
          this.instructions.push(this.createStroke(state));
      };
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @return {Array<*>} Stroke instruction.
       */
      CanvasBuilder.prototype.createStroke = function (state) {
          return [
              Instruction.SET_STROKE_STYLE,
              state.strokeStyle,
              state.lineWidth * this.pixelRatio,
              state.lineCap,
              state.lineJoin,
              state.miterLimit,
              this.applyPixelRatio(state.lineDash),
              state.lineDashOffset * this.pixelRatio,
          ];
      };
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
       */
      CanvasBuilder.prototype.updateFillStyle = function (state, createFill) {
          var fillStyle = state.fillStyle;
          if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {
              if (fillStyle !== undefined) {
                  this.instructions.push(createFill.call(this, state));
              }
              state.currentFillStyle = fillStyle;
          }
      };
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
       */
      CanvasBuilder.prototype.updateStrokeStyle = function (state, applyStroke) {
          var strokeStyle = state.strokeStyle;
          var lineCap = state.lineCap;
          var lineDash = state.lineDash;
          var lineDashOffset = state.lineDashOffset;
          var lineJoin = state.lineJoin;
          var lineWidth = state.lineWidth;
          var miterLimit = state.miterLimit;
          if (state.currentStrokeStyle != strokeStyle ||
              state.currentLineCap != lineCap ||
              (lineDash != state.currentLineDash &&
                  !equals(state.currentLineDash, lineDash)) ||
              state.currentLineDashOffset != lineDashOffset ||
              state.currentLineJoin != lineJoin ||
              state.currentLineWidth != lineWidth ||
              state.currentMiterLimit != miterLimit) {
              if (strokeStyle !== undefined) {
                  applyStroke.call(this, state);
              }
              state.currentStrokeStyle = strokeStyle;
              state.currentLineCap = lineCap;
              state.currentLineDash = lineDash;
              state.currentLineDashOffset = lineDashOffset;
              state.currentLineJoin = lineJoin;
              state.currentLineWidth = lineWidth;
              state.currentMiterLimit = miterLimit;
          }
      };
      /**
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasBuilder.prototype.endGeometry = function (feature) {
          this.beginGeometryInstruction1_[2] = this.instructions.length;
          this.beginGeometryInstruction1_ = null;
          this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
          this.beginGeometryInstruction2_ = null;
          var endGeometryInstruction = [Instruction.END_GEOMETRY, feature];
          this.instructions.push(endGeometryInstruction);
          this.hitDetectionInstructions.push(endGeometryInstruction);
      };
      /**
       * Get the buffered rendering extent.  Rendering will be clipped to the extent
       * provided to the constructor.  To account for symbolizers that may intersect
       * this extent, we calculate a buffered extent (e.g. based on stroke width).
       * @return {import("../../extent.js").Extent} The buffered rendering extent.
       * @protected
       */
      CanvasBuilder.prototype.getBufferedMaxExtent = function () {
          if (!this.bufferedMaxExtent_) {
              this.bufferedMaxExtent_ = clone(this.maxExtent);
              if (this.maxLineWidth > 0) {
                  var width = (this.resolution * (this.maxLineWidth + 1)) / 2;
                  buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
              }
          }
          return this.bufferedMaxExtent_;
      };
      return CanvasBuilder;
  }(VectorContext));

  var __extends$S = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var CanvasImageBuilder = /** @class */ (function (_super) {
      __extends$S(CanvasImageBuilder, _super);
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      function CanvasImageBuilder(tolerance, maxExtent, resolution, pixelRatio) {
          var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
          /**
           * @private
           * @type {import("../canvas.js").DeclutterGroups}
           */
          _this.declutterGroups_ = null;
          /**
           * @private
           * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
           */
          _this.hitDetectionImage_ = null;
          /**
           * @private
           * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
           */
          _this.image_ = null;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.imagePixelRatio_ = undefined;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.anchorX_ = undefined;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.anchorY_ = undefined;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.height_ = undefined;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.opacity_ = undefined;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.originX_ = undefined;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.originY_ = undefined;
          /**
           * @private
           * @type {boolean|undefined}
           */
          _this.rotateWithView_ = undefined;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.rotation_ = undefined;
          /**
           * @private
           * @type {import("../../size.js").Size|undefined}
           */
          _this.scale_ = undefined;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.width_ = undefined;
          return _this;
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       * @return {number} My end.
       */
      CanvasImageBuilder.prototype.drawCoordinates_ = function (flatCoordinates, offset, end, stride) {
          return this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
      };
      /**
       * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasImageBuilder.prototype.drawPoint = function (pointGeometry, feature) {
          if (!this.image_) {
              return;
          }
          this.beginGeometry(pointGeometry, feature);
          var flatCoordinates = pointGeometry.getFlatCoordinates();
          var stride = pointGeometry.getStride();
          var myBegin = this.coordinates.length;
          var myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
          this.instructions.push([
              Instruction.DRAW_IMAGE,
              myBegin,
              myEnd,
              this.image_,
              // Remaining arguments to DRAW_IMAGE are in alphabetical order
              this.anchorX_ * this.imagePixelRatio_,
              this.anchorY_ * this.imagePixelRatio_,
              this.declutterGroups_,
              Math.ceil(this.height_ * this.imagePixelRatio_),
              this.opacity_,
              this.originX_,
              this.originY_,
              this.rotateWithView_,
              this.rotation_,
              [
                  (this.scale_[0] * this.pixelRatio) / this.imagePixelRatio_,
                  (this.scale_[1] * this.pixelRatio) / this.imagePixelRatio_,
              ],
              Math.ceil(this.width_ * this.imagePixelRatio_),
          ]);
          this.hitDetectionInstructions.push([
              Instruction.DRAW_IMAGE,
              myBegin,
              myEnd,
              this.hitDetectionImage_,
              // Remaining arguments to DRAW_IMAGE are in alphabetical order
              this.anchorX_,
              this.anchorY_,
              this.declutterGroups_,
              this.height_,
              this.opacity_,
              this.originX_,
              this.originY_,
              this.rotateWithView_,
              this.rotation_,
              this.scale_,
              this.width_,
          ]);
          this.endGeometry(feature);
      };
      /**
       * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasImageBuilder.prototype.drawMultiPoint = function (multiPointGeometry, feature) {
          if (!this.image_) {
              return;
          }
          this.beginGeometry(multiPointGeometry, feature);
          var flatCoordinates = multiPointGeometry.getFlatCoordinates();
          var stride = multiPointGeometry.getStride();
          var myBegin = this.coordinates.length;
          var myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
          this.instructions.push([
              Instruction.DRAW_IMAGE,
              myBegin,
              myEnd,
              this.image_,
              // Remaining arguments to DRAW_IMAGE are in alphabetical order
              this.anchorX_ * this.imagePixelRatio_,
              this.anchorY_ * this.imagePixelRatio_,
              this.declutterGroups_,
              Math.ceil(this.height_ * this.imagePixelRatio_),
              this.opacity_,
              this.originX_,
              this.originY_,
              this.rotateWithView_,
              this.rotation_,
              [
                  (this.scale_[0] * this.pixelRatio) / this.imagePixelRatio_,
                  (this.scale_[1] * this.pixelRatio) / this.imagePixelRatio_,
              ],
              Math.ceil(this.width_ * this.imagePixelRatio_),
          ]);
          this.hitDetectionInstructions.push([
              Instruction.DRAW_IMAGE,
              myBegin,
              myEnd,
              this.hitDetectionImage_,
              // Remaining arguments to DRAW_IMAGE are in alphabetical order
              this.anchorX_,
              this.anchorY_,
              this.declutterGroups_,
              this.height_,
              this.opacity_,
              this.originX_,
              this.originY_,
              this.rotateWithView_,
              this.rotation_,
              this.scale_,
              this.width_,
          ]);
          this.endGeometry(feature);
      };
      /**
       * @return {import("./Builder.js").SerializableInstructions} the serializable instructions.
       */
      CanvasImageBuilder.prototype.finish = function () {
          this.reverseHitDetectionInstructions();
          // FIXME this doesn't really protect us against further calls to draw*Geometry
          this.anchorX_ = undefined;
          this.anchorY_ = undefined;
          this.hitDetectionImage_ = null;
          this.image_ = null;
          this.imagePixelRatio_ = undefined;
          this.height_ = undefined;
          this.scale_ = undefined;
          this.opacity_ = undefined;
          this.originX_ = undefined;
          this.originY_ = undefined;
          this.rotateWithView_ = undefined;
          this.rotation_ = undefined;
          this.width_ = undefined;
          return _super.prototype.finish.call(this);
      };
      /**
       * @param {import("../../style/Image.js").default} imageStyle Image style.
       * @param {import("../canvas.js").DeclutterGroup} declutterGroups Declutter.
       */
      CanvasImageBuilder.prototype.setImageStyle = function (imageStyle, declutterGroups) {
          var anchor = imageStyle.getAnchor();
          var size = imageStyle.getSize();
          var hitDetectionImage = imageStyle.getHitDetectionImage();
          var image = imageStyle.getImage(this.pixelRatio);
          var origin = imageStyle.getOrigin();
          this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
          this.anchorX_ = anchor[0];
          this.anchorY_ = anchor[1];
          this.declutterGroups_ = declutterGroups;
          this.hitDetectionImage_ = hitDetectionImage;
          this.image_ = image;
          this.height_ = size[1];
          this.opacity_ = imageStyle.getOpacity();
          this.originX_ = origin[0];
          this.originY_ = origin[1];
          this.rotateWithView_ = imageStyle.getRotateWithView();
          this.rotation_ = imageStyle.getRotation();
          this.scale_ = imageStyle.getScaleArray();
          this.width_ = size[0];
      };
      return CanvasImageBuilder;
  }(CanvasBuilder));

  var __extends$T = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var CanvasLineStringBuilder = /** @class */ (function (_super) {
      __extends$T(CanvasLineStringBuilder, _super);
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      function CanvasLineStringBuilder(tolerance, maxExtent, resolution, pixelRatio) {
          return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       * @return {number} end.
       */
      CanvasLineStringBuilder.prototype.drawFlatCoordinates_ = function (flatCoordinates, offset, end, stride) {
          var myBegin = this.coordinates.length;
          var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
          var moveToLineToInstruction = [
              Instruction.MOVE_TO_LINE_TO,
              myBegin,
              myEnd,
          ];
          this.instructions.push(moveToLineToInstruction);
          this.hitDetectionInstructions.push(moveToLineToInstruction);
          return end;
      };
      /**
       * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasLineStringBuilder.prototype.drawLineString = function (lineStringGeometry, feature) {
          var state = this.state;
          var strokeStyle = state.strokeStyle;
          var lineWidth = state.lineWidth;
          if (strokeStyle === undefined || lineWidth === undefined) {
              return;
          }
          this.updateStrokeStyle(state, this.applyStroke);
          this.beginGeometry(lineStringGeometry, feature);
          this.hitDetectionInstructions.push([
              Instruction.SET_STROKE_STYLE,
              state.strokeStyle,
              state.lineWidth,
              state.lineCap,
              state.lineJoin,
              state.miterLimit,
              state.lineDash,
              state.lineDashOffset,
          ], beginPathInstruction);
          var flatCoordinates = lineStringGeometry.getFlatCoordinates();
          var stride = lineStringGeometry.getStride();
          this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
          this.hitDetectionInstructions.push(strokeInstruction);
          this.endGeometry(feature);
      };
      /**
       * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasLineStringBuilder.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) {
          var state = this.state;
          var strokeStyle = state.strokeStyle;
          var lineWidth = state.lineWidth;
          if (strokeStyle === undefined || lineWidth === undefined) {
              return;
          }
          this.updateStrokeStyle(state, this.applyStroke);
          this.beginGeometry(multiLineStringGeometry, feature);
          this.hitDetectionInstructions.push([
              Instruction.SET_STROKE_STYLE,
              state.strokeStyle,
              state.lineWidth,
              state.lineCap,
              state.lineJoin,
              state.miterLimit,
              state.lineDash,
              state.lineDashOffset,
          ], beginPathInstruction);
          var ends = multiLineStringGeometry.getEnds();
          var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
          var stride = multiLineStringGeometry.getStride();
          var offset = 0;
          for (var i = 0, ii = ends.length; i < ii; ++i) {
              offset = this.drawFlatCoordinates_(flatCoordinates, offset, 
              /** @type {number} */ (ends[i]), stride);
          }
          this.hitDetectionInstructions.push(strokeInstruction);
          this.endGeometry(feature);
      };
      /**
       * @return {import("./Builder.js").SerializableInstructions} the serializable instructions.
       */
      CanvasLineStringBuilder.prototype.finish = function () {
          var state = this.state;
          if (state.lastStroke != undefined &&
              state.lastStroke != this.coordinates.length) {
              this.instructions.push(strokeInstruction);
          }
          this.reverseHitDetectionInstructions();
          this.state = null;
          return _super.prototype.finish.call(this);
      };
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       */
      CanvasLineStringBuilder.prototype.applyStroke = function (state) {
          if (state.lastStroke != undefined &&
              state.lastStroke != this.coordinates.length) {
              this.instructions.push(strokeInstruction);
              state.lastStroke = this.coordinates.length;
          }
          state.lastStroke = 0;
          _super.prototype.applyStroke.call(this, state);
          this.instructions.push(beginPathInstruction);
      };
      return CanvasLineStringBuilder;
  }(CanvasBuilder));

  var __extends$U = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var CanvasPolygonBuilder = /** @class */ (function (_super) {
      __extends$U(CanvasPolygonBuilder, _super);
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      function CanvasPolygonBuilder(tolerance, maxExtent, resolution, pixelRatio) {
          return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @private
       * @return {number} End.
       */
      CanvasPolygonBuilder.prototype.drawFlatCoordinatess_ = function (flatCoordinates, offset, ends, stride) {
          var state = this.state;
          var fill = state.fillStyle !== undefined;
          var stroke = state.strokeStyle !== undefined;
          var numEnds = ends.length;
          this.instructions.push(beginPathInstruction);
          this.hitDetectionInstructions.push(beginPathInstruction);
          for (var i = 0; i < numEnds; ++i) {
              var end = ends[i];
              var myBegin = this.coordinates.length;
              var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
              var moveToLineToInstruction = [
                  Instruction.MOVE_TO_LINE_TO,
                  myBegin,
                  myEnd,
              ];
              this.instructions.push(moveToLineToInstruction);
              this.hitDetectionInstructions.push(moveToLineToInstruction);
              if (stroke) {
                  // Performance optimization: only call closePath() when we have a stroke.
                  // Otherwise the ring is closed already (see appendFlatCoordinates above).
                  this.instructions.push(closePathInstruction);
                  this.hitDetectionInstructions.push(closePathInstruction);
              }
              offset = end;
          }
          if (fill) {
              this.instructions.push(fillInstruction);
              this.hitDetectionInstructions.push(fillInstruction);
          }
          if (stroke) {
              this.instructions.push(strokeInstruction);
              this.hitDetectionInstructions.push(strokeInstruction);
          }
          return offset;
      };
      /**
       * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
       * @param {import("../../Feature.js").default} feature Feature.
       */
      CanvasPolygonBuilder.prototype.drawCircle = function (circleGeometry, feature) {
          var state = this.state;
          var fillStyle = state.fillStyle;
          var strokeStyle = state.strokeStyle;
          if (fillStyle === undefined && strokeStyle === undefined) {
              return;
          }
          this.setFillStrokeStyles_();
          this.beginGeometry(circleGeometry, feature);
          if (state.fillStyle !== undefined) {
              this.hitDetectionInstructions.push([
                  Instruction.SET_FILL_STYLE,
                  defaultFillStyle,
              ]);
          }
          if (state.strokeStyle !== undefined) {
              this.hitDetectionInstructions.push([
                  Instruction.SET_STROKE_STYLE,
                  state.strokeStyle,
                  state.lineWidth,
                  state.lineCap,
                  state.lineJoin,
                  state.miterLimit,
                  state.lineDash,
                  state.lineDashOffset,
              ]);
          }
          var flatCoordinates = circleGeometry.getFlatCoordinates();
          var stride = circleGeometry.getStride();
          var myBegin = this.coordinates.length;
          this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
          var circleInstruction = [Instruction.CIRCLE, myBegin];
          this.instructions.push(beginPathInstruction, circleInstruction);
          this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);
          if (state.fillStyle !== undefined) {
              this.instructions.push(fillInstruction);
              this.hitDetectionInstructions.push(fillInstruction);
          }
          if (state.strokeStyle !== undefined) {
              this.instructions.push(strokeInstruction);
              this.hitDetectionInstructions.push(strokeInstruction);
          }
          this.endGeometry(feature);
      };
      /**
       * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasPolygonBuilder.prototype.drawPolygon = function (polygonGeometry, feature) {
          var state = this.state;
          var fillStyle = state.fillStyle;
          var strokeStyle = state.strokeStyle;
          if (fillStyle === undefined && strokeStyle === undefined) {
              return;
          }
          this.setFillStrokeStyles_();
          this.beginGeometry(polygonGeometry, feature);
          if (state.fillStyle !== undefined) {
              this.hitDetectionInstructions.push([
                  Instruction.SET_FILL_STYLE,
                  defaultFillStyle,
              ]);
          }
          if (state.strokeStyle !== undefined) {
              this.hitDetectionInstructions.push([
                  Instruction.SET_STROKE_STYLE,
                  state.strokeStyle,
                  state.lineWidth,
                  state.lineCap,
                  state.lineJoin,
                  state.miterLimit,
                  state.lineDash,
                  state.lineDashOffset,
              ]);
          }
          var ends = polygonGeometry.getEnds();
          var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
          var stride = polygonGeometry.getStride();
          this.drawFlatCoordinatess_(flatCoordinates, 0, 
          /** @type {Array<number>} */ (ends), stride);
          this.endGeometry(feature);
      };
      /**
       * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasPolygonBuilder.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {
          var state = this.state;
          var fillStyle = state.fillStyle;
          var strokeStyle = state.strokeStyle;
          if (fillStyle === undefined && strokeStyle === undefined) {
              return;
          }
          this.setFillStrokeStyles_();
          this.beginGeometry(multiPolygonGeometry, feature);
          if (state.fillStyle !== undefined) {
              this.hitDetectionInstructions.push([
                  Instruction.SET_FILL_STYLE,
                  defaultFillStyle,
              ]);
          }
          if (state.strokeStyle !== undefined) {
              this.hitDetectionInstructions.push([
                  Instruction.SET_STROKE_STYLE,
                  state.strokeStyle,
                  state.lineWidth,
                  state.lineCap,
                  state.lineJoin,
                  state.miterLimit,
                  state.lineDash,
                  state.lineDashOffset,
              ]);
          }
          var endss = multiPolygonGeometry.getEndss();
          var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
          var stride = multiPolygonGeometry.getStride();
          var offset = 0;
          for (var i = 0, ii = endss.length; i < ii; ++i) {
              offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
          }
          this.endGeometry(feature);
      };
      /**
       * @return {import("./Builder.js").SerializableInstructions} the serializable instructions.
       */
      CanvasPolygonBuilder.prototype.finish = function () {
          this.reverseHitDetectionInstructions();
          this.state = null;
          // We want to preserve topology when drawing polygons.  Polygons are
          // simplified using quantization and point elimination. However, we might
          // have received a mix of quantized and non-quantized geometries, so ensure
          // that all are quantized by quantizing all coordinates in the batch.
          var tolerance = this.tolerance;
          if (tolerance !== 0) {
              var coordinates = this.coordinates;
              for (var i = 0, ii = coordinates.length; i < ii; ++i) {
                  coordinates[i] = snap(coordinates[i], tolerance);
              }
          }
          return _super.prototype.finish.call(this);
      };
      /**
       * @private
       */
      CanvasPolygonBuilder.prototype.setFillStrokeStyles_ = function () {
          var state = this.state;
          var fillStyle = state.fillStyle;
          if (fillStyle !== undefined) {
              this.updateFillStyle(state, this.createFill);
          }
          if (state.strokeStyle !== undefined) {
              this.updateStrokeStyle(state, this.applyStroke);
          }
      };
      return CanvasPolygonBuilder;
  }(CanvasBuilder));

  /**
   * @module ol/style/TextPlacement
   */
  /**
   * Text placement. One of `'point'`, `'line'`. Default is `'point'`. Note that
   * `'line'` requires the underlying geometry to be a {@link module:ol/geom/LineString~LineString},
   * {@link module:ol/geom/Polygon~Polygon}, {@link module:ol/geom/MultiLineString~MultiLineString} or
   * {@link module:ol/geom/MultiPolygon~MultiPolygon}.
   * @enum {string}
   */
  var TextPlacement = {
      POINT: 'point',
      LINE: 'line',
  };

  /**
   * @module ol/geom/flat/straightchunk
   */
  /**
   * @param {number} maxAngle Maximum acceptable angle delta between segments.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @return {Array<number>} Start and end of the first suitable chunk of the
   * given `flatCoordinates`.
   */
  function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
      var chunkStart = offset;
      var chunkEnd = offset;
      var chunkM = 0;
      var m = 0;
      var start = offset;
      var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
      for (i = offset; i < end; i += stride) {
          var x2 = flatCoordinates[i];
          var y2 = flatCoordinates[i + 1];
          if (x1 !== undefined) {
              x23 = x2 - x1;
              y23 = y2 - y1;
              m23 = Math.sqrt(x23 * x23 + y23 * y23);
              if (x12 !== undefined) {
                  m += m12;
                  acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
                  if (acos > maxAngle) {
                      if (m > chunkM) {
                          chunkM = m;
                          chunkStart = start;
                          chunkEnd = i;
                      }
                      m = 0;
                      start = i - stride;
                  }
              }
              m12 = m23;
              x12 = x23;
              y12 = y23;
          }
          x1 = x2;
          y1 = y2;
      }
      m += m23;
      return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
  }

  var __extends$V = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @const
   * @enum {number}
   */
  var TEXT_ALIGN = {
      'left': 0,
      'end': 0,
      'center': 0.5,
      'right': 1,
      'start': 1,
      'top': 0,
      'middle': 0.5,
      'hanging': 0.2,
      'alphabetic': 0.8,
      'ideographic': 0.8,
      'bottom': 1,
  };
  var CanvasTextBuilder = /** @class */ (function (_super) {
      __extends$V(CanvasTextBuilder, _super);
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      function CanvasTextBuilder(tolerance, maxExtent, resolution, pixelRatio) {
          var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
          /**
           * @private
           * @type {import("../canvas.js").DeclutterGroups}
           */
          _this.declutterGroups_;
          /**
           * @private
           * @type {Array<HTMLCanvasElement>}
           */
          _this.labels_ = null;
          /**
           * @private
           * @type {string}
           */
          _this.text_ = '';
          /**
           * @private
           * @type {number}
           */
          _this.textOffsetX_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.textOffsetY_ = 0;
          /**
           * @private
           * @type {boolean|undefined}
           */
          _this.textRotateWithView_ = undefined;
          /**
           * @private
           * @type {number}
           */
          _this.textRotation_ = 0;
          /**
           * @private
           * @type {?import("../canvas.js").FillState}
           */
          _this.textFillState_ = null;
          /**
           * @type {!Object<string, import("../canvas.js").FillState>}
           */
          _this.fillStates = {};
          /**
           * @private
           * @type {?import("../canvas.js").StrokeState}
           */
          _this.textStrokeState_ = null;
          /**
           * @type {!Object<string, import("../canvas.js").StrokeState>}
           */
          _this.strokeStates = {};
          /**
           * @private
           * @type {import("../canvas.js").TextState}
           */
          _this.textState_ = /** @type {import("../canvas.js").TextState} */ ({});
          /**
           * @type {!Object<string, import("../canvas.js").TextState>}
           */
          _this.textStates = {};
          /**
           * @private
           * @type {string}
           */
          _this.textKey_ = '';
          /**
           * @private
           * @type {string}
           */
          _this.fillKey_ = '';
          /**
           * @private
           * @type {string}
           */
          _this.strokeKey_ = '';
          return _this;
      }
      /**
       * @return {import("./Builder.js").SerializableInstructions} the serializable instructions.
       */
      CanvasTextBuilder.prototype.finish = function () {
          var instructions = _super.prototype.finish.call(this);
          instructions.textStates = this.textStates;
          instructions.fillStates = this.fillStates;
          instructions.strokeStates = this.strokeStates;
          return instructions;
      };
      /**
       * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasTextBuilder.prototype.drawText = function (geometry, feature) {
          var fillState = this.textFillState_;
          var strokeState = this.textStrokeState_;
          var textState = this.textState_;
          if (this.text_ === '' || !textState || (!fillState && !strokeState)) {
              return;
          }
          var begin = this.coordinates.length;
          var geometryType = geometry.getType();
          var flatCoordinates = null;
          var end = 2;
          var stride = geometry.getStride();
          var i, ii;
          if (textState.placement === TextPlacement.LINE) {
              if (!intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {
                  return;
              }
              var ends = void 0;
              flatCoordinates = geometry.getFlatCoordinates();
              if (geometryType == GeometryType.LINE_STRING) {
                  ends = [flatCoordinates.length];
              }
              else if (geometryType == GeometryType.MULTI_LINE_STRING) {
                  ends = /** @type {import("../../geom/MultiLineString.js").default} */ (geometry).getEnds();
              }
              else if (geometryType == GeometryType.POLYGON) {
                  ends = /** @type {import("../../geom/Polygon.js").default} */ (geometry)
                      .getEnds()
                      .slice(0, 1);
              }
              else if (geometryType == GeometryType.MULTI_POLYGON) {
                  var endss = /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry).getEndss();
                  ends = [];
                  for (i = 0, ii = endss.length; i < ii; ++i) {
                      ends.push(endss[i][0]);
                  }
              }
              this.beginGeometry(geometry, feature);
              var textAlign = textState.textAlign;
              var flatOffset = 0;
              var flatEnd = void 0;
              for (var o = 0, oo = ends.length; o < oo; ++o) {
                  if (textAlign == undefined) {
                      var range = matchingChunk(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);
                      flatOffset = range[0];
                      flatEnd = range[1];
                  }
                  else {
                      flatEnd = ends[o];
                  }
                  for (i = flatOffset; i < flatEnd; i += stride) {
                      this.coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);
                  }
                  end = this.coordinates.length;
                  flatOffset = ends[o];
                  var declutterGroup = this.declutterGroups_
                      ? o === 0
                          ? this.declutterGroups_[0]
                          : [].concat(this.declutterGroups_[0])
                      : null;
                  this.drawChars_(begin, end, declutterGroup);
                  begin = end;
              }
              this.endGeometry(feature);
          }
          else {
              var geometryWidths = null;
              if (!textState.overflow) {
                  geometryWidths = [];
              }
              switch (geometryType) {
                  case GeometryType.POINT:
                  case GeometryType.MULTI_POINT:
                      flatCoordinates = /** @type {import("../../geom/MultiPoint.js").default} */ (geometry).getFlatCoordinates();
                      end = flatCoordinates.length;
                      break;
                  case GeometryType.LINE_STRING:
                      flatCoordinates = /** @type {import("../../geom/LineString.js").default} */ (geometry).getFlatMidpoint();
                      break;
                  case GeometryType.CIRCLE:
                      flatCoordinates = /** @type {import("../../geom/Circle.js").default} */ (geometry).getCenter();
                      break;
                  case GeometryType.MULTI_LINE_STRING:
                      flatCoordinates = /** @type {import("../../geom/MultiLineString.js").default} */ (geometry).getFlatMidpoints();
                      stride = 2;
                      end = flatCoordinates.length;
                      break;
                  case GeometryType.POLYGON:
                      flatCoordinates = /** @type {import("../../geom/Polygon.js").default} */ (geometry).getFlatInteriorPoint();
                      if (!textState.overflow) {
                          geometryWidths.push(flatCoordinates[2] / this.resolution);
                      }
                      stride = 3;
                      break;
                  case GeometryType.MULTI_POLYGON:
                      var interiorPoints = /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry).getFlatInteriorPoints();
                      flatCoordinates = [];
                      for (i = 0, ii = interiorPoints.length; i < ii; i += 3) {
                          if (!textState.overflow) {
                              geometryWidths.push(interiorPoints[i + 2] / this.resolution);
                          }
                          flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
                      }
                      stride = 2;
                      end = flatCoordinates.length;
                      if (end == 0) {
                          return;
                      }
                      break;
              }
              end = this.appendFlatCoordinates(flatCoordinates, 0, end, stride, false, false);
              this.saveTextStates_();
              if (textState.backgroundFill || textState.backgroundStroke) {
                  this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);
                  if (textState.backgroundFill) {
                      this.updateFillStyle(this.state, this.createFill);
                      this.hitDetectionInstructions.push(this.createFill(this.state));
                  }
                  if (textState.backgroundStroke) {
                      this.updateStrokeStyle(this.state, this.applyStroke);
                      this.hitDetectionInstructions.push(this.createStroke(this.state));
                  }
              }
              this.beginGeometry(geometry, feature);
              // adjust padding for negative scale
              var padding = textState.padding;
              if (padding != defaultPadding &&
                  (textState.scale[0] < 0 || textState.scale[1] < 0)) {
                  var p0 = textState.padding[0];
                  var p1 = textState.padding[1];
                  var p2 = textState.padding[2];
                  var p3 = textState.padding[3];
                  if (textState.scale[0] < 0) {
                      p1 = -p1;
                      p3 = -p3;
                  }
                  if (textState.scale[1] < 0) {
                      p0 = -p0;
                      p2 = -p2;
                  }
                  padding = [p0, p1, p2, p3];
              }
              // The image is unknown at this stage so we pass null; it will be computed at render time.
              // For clarity, we pass NaN for offsetX, offsetY, width and height, which will be computed at
              // render time.
              var pixelRatio_1 = this.pixelRatio;
              this.instructions.push([
                  Instruction.DRAW_IMAGE,
                  begin,
                  end,
                  null,
                  NaN,
                  NaN,
                  this.declutterGroups_,
                  NaN,
                  1,
                  0,
                  0,
                  this.textRotateWithView_,
                  this.textRotation_,
                  [1, 1],
                  NaN,
                  padding == defaultPadding
                      ? defaultPadding
                      : padding.map(function (p) {
                          return p * pixelRatio_1;
                      }),
                  !!textState.backgroundFill,
                  !!textState.backgroundStroke,
                  this.text_,
                  this.textKey_,
                  this.strokeKey_,
                  this.fillKey_,
                  this.textOffsetX_,
                  this.textOffsetY_,
                  geometryWidths,
              ]);
              var scale = 1 / pixelRatio_1;
              this.hitDetectionInstructions.push([
                  Instruction.DRAW_IMAGE,
                  begin,
                  end,
                  null,
                  NaN,
                  NaN,
                  this.declutterGroups_,
                  NaN,
                  1,
                  0,
                  0,
                  this.textRotateWithView_,
                  this.textRotation_,
                  [scale, scale],
                  NaN,
                  padding,
                  !!textState.backgroundFill,
                  !!textState.backgroundStroke,
                  this.text_,
                  this.textKey_,
                  this.strokeKey_,
                  this.fillKey_,
                  this.textOffsetX_,
                  this.textOffsetY_,
                  geometryWidths,
              ]);
              this.endGeometry(feature);
          }
      };
      /**
       * @private
       */
      CanvasTextBuilder.prototype.saveTextStates_ = function () {
          var strokeState = this.textStrokeState_;
          var textState = this.textState_;
          var fillState = this.textFillState_;
          var strokeKey = this.strokeKey_;
          if (strokeState) {
              if (!(strokeKey in this.strokeStates)) {
                  this.strokeStates[strokeKey] = {
                      strokeStyle: strokeState.strokeStyle,
                      lineCap: strokeState.lineCap,
                      lineDashOffset: strokeState.lineDashOffset,
                      lineWidth: strokeState.lineWidth,
                      lineJoin: strokeState.lineJoin,
                      miterLimit: strokeState.miterLimit,
                      lineDash: strokeState.lineDash,
                  };
              }
          }
          var textKey = this.textKey_;
          if (!(textKey in this.textStates)) {
              this.textStates[textKey] = {
                  font: textState.font,
                  textAlign: textState.textAlign || defaultTextAlign,
                  textBaseline: textState.textBaseline || defaultTextBaseline,
                  scale: textState.scale,
              };
          }
          var fillKey = this.fillKey_;
          if (fillState) {
              if (!(fillKey in this.fillStates)) {
                  this.fillStates[fillKey] = {
                      fillStyle: fillState.fillStyle,
                  };
              }
          }
      };
      /**
       * @private
       * @param {number} begin Begin.
       * @param {number} end End.
       * @param {import("../canvas.js").DeclutterGroup} declutterGroup Declutter group.
       */
      CanvasTextBuilder.prototype.drawChars_ = function (begin, end, declutterGroup) {
          var strokeState = this.textStrokeState_;
          var textState = this.textState_;
          var strokeKey = this.strokeKey_;
          var textKey = this.textKey_;
          var fillKey = this.fillKey_;
          this.saveTextStates_();
          var pixelRatio = this.pixelRatio;
          var baseline = TEXT_ALIGN[textState.textBaseline];
          var offsetY = this.textOffsetY_ * pixelRatio;
          var text = this.text_;
          var strokeWidth = strokeState
              ? (strokeState.lineWidth * Math.abs(textState.scale[0])) / 2
              : 0;
          this.instructions.push([
              Instruction.DRAW_CHARS,
              begin,
              end,
              baseline,
              declutterGroup,
              textState.overflow,
              fillKey,
              textState.maxAngle,
              pixelRatio,
              offsetY,
              strokeKey,
              strokeWidth * pixelRatio,
              text,
              textKey,
              1,
          ]);
          this.hitDetectionInstructions.push([
              Instruction.DRAW_CHARS,
              begin,
              end,
              baseline,
              declutterGroup,
              textState.overflow,
              fillKey,
              textState.maxAngle,
              1,
              offsetY,
              strokeKey,
              strokeWidth,
              text,
              textKey,
              1 / pixelRatio,
          ]);
      };
      /**
       * @param {import("../../style/Text.js").default} textStyle Text style.
       * @param {import("../canvas.js").DeclutterGroups} declutterGroups Declutter.
       */
      CanvasTextBuilder.prototype.setTextStyle = function (textStyle, declutterGroups) {
          var textState, fillState, strokeState;
          if (!textStyle) {
              this.text_ = '';
          }
          else {
              this.declutterGroups_ = declutterGroups;
              var textFillStyle = textStyle.getFill();
              if (!textFillStyle) {
                  fillState = null;
                  this.textFillState_ = fillState;
              }
              else {
                  fillState = this.textFillState_;
                  if (!fillState) {
                      fillState = /** @type {import("../canvas.js").FillState} */ ({});
                      this.textFillState_ = fillState;
                  }
                  fillState.fillStyle = asColorLike(textFillStyle.getColor() || defaultFillStyle);
              }
              var textStrokeStyle = textStyle.getStroke();
              if (!textStrokeStyle) {
                  strokeState = null;
                  this.textStrokeState_ = strokeState;
              }
              else {
                  strokeState = this.textStrokeState_;
                  if (!strokeState) {
                      strokeState = /** @type {import("../canvas.js").StrokeState} */ ({});
                      this.textStrokeState_ = strokeState;
                  }
                  var lineDash = textStrokeStyle.getLineDash();
                  var lineDashOffset = textStrokeStyle.getLineDashOffset();
                  var lineWidth = textStrokeStyle.getWidth();
                  var miterLimit = textStrokeStyle.getMiterLimit();
                  strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;
                  strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;
                  strokeState.lineDashOffset =
                      lineDashOffset === undefined ? defaultLineDashOffset : lineDashOffset;
                  strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;
                  strokeState.lineWidth =
                      lineWidth === undefined ? defaultLineWidth : lineWidth;
                  strokeState.miterLimit =
                      miterLimit === undefined ? defaultMiterLimit : miterLimit;
                  strokeState.strokeStyle = asColorLike(textStrokeStyle.getColor() || defaultStrokeStyle);
              }
              textState = this.textState_;
              var font = textStyle.getFont() || defaultFont;
              registerFont(font);
              var textScale = textStyle.getScaleArray();
              textState.overflow = textStyle.getOverflow();
              textState.font = font;
              textState.maxAngle = textStyle.getMaxAngle();
              textState.placement = textStyle.getPlacement();
              textState.textAlign = textStyle.getTextAlign();
              textState.textBaseline =
                  textStyle.getTextBaseline() || defaultTextBaseline;
              textState.backgroundFill = textStyle.getBackgroundFill();
              textState.backgroundStroke = textStyle.getBackgroundStroke();
              textState.padding = textStyle.getPadding() || defaultPadding;
              textState.scale = textScale === undefined ? [1, 1] : textScale;
              var textOffsetX = textStyle.getOffsetX();
              var textOffsetY = textStyle.getOffsetY();
              var textRotateWithView = textStyle.getRotateWithView();
              var textRotation = textStyle.getRotation();
              this.text_ = textStyle.getText() || '';
              this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;
              this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;
              this.textRotateWithView_ =
                  textRotateWithView === undefined ? false : textRotateWithView;
              this.textRotation_ = textRotation === undefined ? 0 : textRotation;
              this.strokeKey_ = strokeState
                  ? (typeof strokeState.strokeStyle == 'string'
                      ? strokeState.strokeStyle
                      : getUid(strokeState.strokeStyle)) +
                      strokeState.lineCap +
                      strokeState.lineDashOffset +
                      '|' +
                      strokeState.lineWidth +
                      strokeState.lineJoin +
                      strokeState.miterLimit +
                      '[' +
                      strokeState.lineDash.join() +
                      ']'
                  : '';
              this.textKey_ =
                  textState.font +
                      textState.scale +
                      (textState.textAlign || '?') +
                      (textState.textBaseline || '?');
              this.fillKey_ = fillState
                  ? typeof fillState.fillStyle == 'string'
                      ? fillState.fillStyle
                      : '|' + getUid(fillState.fillStyle)
                  : '';
          }
      };
      return CanvasTextBuilder;
  }(CanvasBuilder));

  /**
   * @module ol/render/canvas/BuilderGroup
   */
  /**
   * @type {Object<import("./BuilderType").default, typeof Builder>}
   */
  var BATCH_CONSTRUCTORS = {
      'Circle': CanvasPolygonBuilder,
      'Default': CanvasBuilder,
      'Image': CanvasImageBuilder,
      'LineString': CanvasLineStringBuilder,
      'Polygon': CanvasPolygonBuilder,
      'Text': CanvasTextBuilder,
  };
  var BuilderGroup = /** @class */ (function () {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Max extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {boolean} declutter Decluttering enabled.
       */
      function BuilderGroup(tolerance, maxExtent, resolution, pixelRatio, declutter) {
          /**
           * @type {boolean}
           * @private
           */
          this.declutter_ = declutter;
          /**
           * @type {import("../canvas.js").DeclutterGroups}
           * @private
           */
          this.declutterGroups_ = null;
          /**
           * @private
           * @type {number}
           */
          this.tolerance_ = tolerance;
          /**
           * @private
           * @type {import("../../extent.js").Extent}
           */
          this.maxExtent_ = maxExtent;
          /**
           * @private
           * @type {number}
           */
          this.pixelRatio_ = pixelRatio;
          /**
           * @private
           * @type {number}
           */
          this.resolution_ = resolution;
          /**
           * @private
           * @type {!Object<string, !Object<import("./BuilderType").default, Builder>>}
           */
          this.buildersByZIndex_ = {};
      }
      /**
       * @param {boolean} group Group with previous builder.
       * @return {import("../canvas").DeclutterGroups} The resulting instruction groups.
       */
      BuilderGroup.prototype.addDeclutter = function (group) {
          /** @type {Array<*>} */
          var declutter = null;
          if (this.declutter_) {
              if (group) {
                  declutter = this.declutterGroups_;
                  /** @type {number} */ (declutter[0][0])++;
              }
              else {
                  declutter = [[1]];
                  this.declutterGroups_ = declutter;
              }
          }
          return declutter;
      };
      /**
       * @return {!Object<string, !Object<import("./BuilderType").default, import("./Builder.js").SerializableInstructions>>} The serializable instructions
       */
      BuilderGroup.prototype.finish = function () {
          var builderInstructions = {};
          for (var zKey in this.buildersByZIndex_) {
              builderInstructions[zKey] = builderInstructions[zKey] || {};
              var builders = this.buildersByZIndex_[zKey];
              for (var builderKey in builders) {
                  var builderInstruction = builders[builderKey].finish();
                  builderInstructions[zKey][builderKey] = builderInstruction;
              }
          }
          return builderInstructions;
      };
      /**
       * @param {number|undefined} zIndex Z index.
       * @param {import("./BuilderType.js").default} builderType Replay type.
       * @return {import("../VectorContext.js").default} Replay.
       */
      BuilderGroup.prototype.getBuilder = function (zIndex, builderType) {
          var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
          var replays = this.buildersByZIndex_[zIndexKey];
          if (replays === undefined) {
              replays = {};
              this.buildersByZIndex_[zIndexKey] = replays;
          }
          var replay = replays[builderType];
          if (replay === undefined) {
              var Constructor = BATCH_CONSTRUCTORS[builderType];
              replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_);
              replays[builderType] = replay;
          }
          return replay;
      };
      return BuilderGroup;
  }());

  var __extends$W = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @template {import("../layer/Layer.js").default} LayerType
   */
  var LayerRenderer = /** @class */ (function (_super) {
      __extends$W(LayerRenderer, _super);
      /**
       * @param {LayerType} layer Layer.
       */
      function LayerRenderer(layer) {
          var _this = _super.call(this) || this;
          /** @private */
          _this.boundHandleImageChange_ = _this.handleImageChange_.bind(_this);
          /**
           * @protected
           * @type {LayerType}
           */
          _this.layer_ = layer;
          return _this;
      }
      /**
       * Asynchronous layer level hit detection.
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
       * an array of features.
       */
      LayerRenderer.prototype.getFeatures = function (pixel) {
          return abstract();
      };
      /**
       * Determine whether render should be called.
       * @abstract
       * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
       * @return {boolean} Layer is ready to be rendered.
       */
      LayerRenderer.prototype.prepareFrame = function (frameState) {
          return abstract();
      };
      /**
       * Render the layer.
       * @abstract
       * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target that may be used to render content to.
       * @return {HTMLElement} The rendered element.
       */
      LayerRenderer.prototype.renderFrame = function (frameState, target) {
          return abstract();
      };
      /**
       * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
       * @param {number} zoom Zoom level.
       * @param {import("../Tile.js").default} tile Tile.
       * @return {boolean|void} If `false`, the tile will not be considered loaded.
       */
      LayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {
          if (!tiles[zoom]) {
              tiles[zoom] = {};
          }
          tiles[zoom][tile.tileCoord.toString()] = tile;
          return undefined;
      };
      /**
       * Create a function that adds loaded tiles to the tile lookup.
       * @param {import("../source/Tile.js").default} source Tile source.
       * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
       * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
       * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
       *     called with a zoom level and a tile range to add loaded tiles to the lookup.
       * @protected
       */
      LayerRenderer.prototype.createLoadedTileFinder = function (source, projection, tiles) {
          return (
          /**
           * @param {number} zoom Zoom level.
           * @param {import("../TileRange.js").default} tileRange Tile range.
           * @return {boolean} The tile range is fully loaded.
           * @this {LayerRenderer}
           */
          function (zoom, tileRange) {
              var callback = this.loadedTileCallback.bind(this, tiles, zoom);
              return source.forEachLoadedTile(projection, zoom, tileRange, callback);
          }.bind(this));
      };
      /**
       * @abstract
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default): T} callback Feature callback.
       * @param {Array<import("../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
       * @return {T|void} Callback result.
       * @template T
       */
      LayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, declutteredFeatures) { };
      /**
       * @abstract
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel
       *    location, null will be returned.  If there is data, but pixel values cannot be
       *    returned, and empty array will be returned.
       */
      LayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {
          return abstract();
      };
      /**
       * @return {LayerType} Layer.
       */
      LayerRenderer.prototype.getLayer = function () {
          return this.layer_;
      };
      /**
       * Perform action necessary to get the layer rendered after new fonts have loaded
       * @abstract
       */
      LayerRenderer.prototype.handleFontsChanged = function () { };
      /**
       * Handle changes in image state.
       * @param {import("../events/Event.js").default} event Image change event.
       * @private
       */
      LayerRenderer.prototype.handleImageChange_ = function (event) {
          var image = /** @type {import("../Image.js").default} */ (event.target);
          if (image.getState() === ImageState.LOADED) {
              this.renderIfReadyAndVisible();
          }
      };
      /**
       * Load the image if not already loaded, and register the image change
       * listener if needed.
       * @param {import("../ImageBase.js").default} image Image.
       * @return {boolean} `true` if the image is already loaded, `false` otherwise.
       * @protected
       */
      LayerRenderer.prototype.loadImage = function (image) {
          var imageState = image.getState();
          if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {
              image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);
          }
          if (imageState == ImageState.IDLE) {
              image.load();
              imageState = image.getState();
          }
          return imageState == ImageState.LOADED;
      };
      /**
       * @protected
       */
      LayerRenderer.prototype.renderIfReadyAndVisible = function () {
          var layer = this.getLayer();
          if (layer.getVisible() && layer.getSourceState() == SourceState.READY) {
              layer.changed();
          }
      };
      return LayerRenderer;
  }(Observable));

  var __extends$X = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @abstract
   * @template {import("../../layer/Layer.js").default} LayerType
   */
  var CanvasLayerRenderer = /** @class */ (function (_super) {
      __extends$X(CanvasLayerRenderer, _super);
      /**
       * @param {LayerType} layer Layer.
       */
      function CanvasLayerRenderer(layer) {
          var _this = _super.call(this, layer) || this;
          /**
           * @protected
           * @type {HTMLElement}
           */
          _this.container = null;
          /**
           * @protected
           * @type {number}
           */
          _this.renderedResolution;
          /**
           * A temporary transform.  The values in this transform should only be used in a
           * function that sets the values.
           * @protected
           * @type {import("../../transform.js").Transform}
           */
          _this.tempTransform = create();
          /**
           * The transform for rendered pixels to viewport CSS pixels.  This transform must
           * be set when rendering a frame and may be used by other functions after rendering.
           * @protected
           * @type {import("../../transform.js").Transform}
           */
          _this.pixelTransform = create();
          /**
           * The transform for viewport CSS pixels to rendered pixels.  This transform must
           * be set when rendering a frame and may be used by other functions after rendering.
           * @protected
           * @type {import("../../transform.js").Transform}
           */
          _this.inversePixelTransform = create();
          /**
           * @type {CanvasRenderingContext2D}
           */
          _this.context = null;
          /**
           * @type {boolean}
           */
          _this.containerReused = false;
          return _this;
      }
      /**
       * Get a rendering container from an existing target, if compatible.
       * @param {HTMLElement} target Potential render target.
       * @param {string} transform CSS Transform.
       * @param {number} opacity Opacity.
       */
      CanvasLayerRenderer.prototype.useContainer = function (target, transform, opacity) {
          var layerClassName = this.getLayer().getClassName();
          var container, context;
          if (target &&
              target.style.opacity === '' &&
              target.className === layerClassName) {
              var canvas = target.firstElementChild;
              if (canvas instanceof HTMLCanvasElement) {
                  context = canvas.getContext('2d');
              }
          }
          if (context &&
              (context.canvas.width === 0 ||
                  context.canvas.style.transform === transform)) {
              // Container of the previous layer renderer can be used.
              this.container = target;
              this.context = context;
              this.containerReused = true;
          }
          else if (this.containerReused) {
              // Previously reused container cannot be used any more.
              this.container = null;
              this.context = null;
              this.containerReused = false;
          }
          if (!this.container) {
              container = document.createElement('div');
              container.className = layerClassName;
              var style = container.style;
              style.position = 'absolute';
              style.width = '100%';
              style.height = '100%';
              context = createCanvasContext2D();
              var canvas = context.canvas;
              container.appendChild(canvas);
              style = canvas.style;
              style.position = 'absolute';
              style.left = '0';
              style.transformOrigin = 'top left';
              this.container = container;
              this.context = context;
          }
      };
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @param {import("../../extent.js").Extent} extent Clip extent.
       * @protected
       */
      CanvasLayerRenderer.prototype.clip = function (context, frameState, extent) {
          var pixelRatio = frameState.pixelRatio;
          var halfWidth = (frameState.size[0] * pixelRatio) / 2;
          var halfHeight = (frameState.size[1] * pixelRatio) / 2;
          var rotation = frameState.viewState.rotation;
          var topLeft = getTopLeft(extent);
          var topRight = getTopRight(extent);
          var bottomRight = getBottomRight(extent);
          var bottomLeft = getBottomLeft(extent);
          apply(frameState.coordinateToPixelTransform, topLeft);
          apply(frameState.coordinateToPixelTransform, topRight);
          apply(frameState.coordinateToPixelTransform, bottomRight);
          apply(frameState.coordinateToPixelTransform, bottomLeft);
          context.save();
          rotateAtOffset(context, -rotation, halfWidth, halfHeight);
          context.beginPath();
          context.moveTo(topLeft[0] * pixelRatio, topLeft[1] * pixelRatio);
          context.lineTo(topRight[0] * pixelRatio, topRight[1] * pixelRatio);
          context.lineTo(bottomRight[0] * pixelRatio, bottomRight[1] * pixelRatio);
          context.lineTo(bottomLeft[0] * pixelRatio, bottomLeft[1] * pixelRatio);
          context.clip();
          rotateAtOffset(context, rotation, halfWidth, halfHeight);
      };
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @param {import("../../extent.js").Extent} extent Clip extent.
       * @protected
       */
      CanvasLayerRenderer.prototype.clipUnrotated = function (context, frameState, extent) {
          var topLeft = getTopLeft(extent);
          var topRight = getTopRight(extent);
          var bottomRight = getBottomRight(extent);
          var bottomLeft = getBottomLeft(extent);
          apply(frameState.coordinateToPixelTransform, topLeft);
          apply(frameState.coordinateToPixelTransform, topRight);
          apply(frameState.coordinateToPixelTransform, bottomRight);
          apply(frameState.coordinateToPixelTransform, bottomLeft);
          var inverted = this.inversePixelTransform;
          apply(inverted, topLeft);
          apply(inverted, topRight);
          apply(inverted, bottomRight);
          apply(inverted, bottomLeft);
          context.save();
          context.beginPath();
          context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
          context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
          context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
          context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
          context.clip();
      };
      /**
       * @param {import("../../render/EventType.js").default} type Event type.
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @private
       */
      CanvasLayerRenderer.prototype.dispatchRenderEvent_ = function (type, context, frameState) {
          var layer = this.getLayer();
          if (layer.hasListener(type)) {
              var event_1 = new RenderEvent(type, this.inversePixelTransform, frameState, context);
              layer.dispatchEvent(event_1);
          }
      };
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @protected
       */
      CanvasLayerRenderer.prototype.preRender = function (context, frameState) {
          this.dispatchRenderEvent_(EventType$1.PRERENDER, context, frameState);
      };
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @protected
       */
      CanvasLayerRenderer.prototype.postRender = function (context, frameState) {
          this.dispatchRenderEvent_(EventType$1.POSTRENDER, context, frameState);
      };
      /**
       * Creates a transform for rendering to an element that will be rotated after rendering.
       * @param {import("../../coordinate.js").Coordinate} center Center.
       * @param {number} resolution Resolution.
       * @param {number} rotation Rotation.
       * @param {number} pixelRatio Pixel ratio.
       * @param {number} width Width of the rendered element (in pixels).
       * @param {number} height Height of the rendered element (in pixels).
       * @param {number} offsetX Offset on the x-axis in view coordinates.
       * @protected
       * @return {!import("../../transform.js").Transform} Transform.
       */
      CanvasLayerRenderer.prototype.getRenderTransform = function (center, resolution, rotation, pixelRatio, width, height, offsetX) {
          var dx1 = width / 2;
          var dy1 = height / 2;
          var sx = pixelRatio / resolution;
          var sy = -sx;
          var dx2 = -center[0] + offsetX;
          var dy2 = -center[1];
          return compose(this.tempTransform, dx1, dy1, sx, sy, -rotation, dx2, dy2);
      };
      /**
       * @param {import("../../pixel.js").Pixel} pixel Pixel.
       * @param {import("../../PluggableMap.js").FrameState} frameState FrameState.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel
       *    location, null will be returned.  If there is data, but pixel values cannot be
       *    returned, and empty array will be returned.
       */
      CanvasLayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {
          var renderPixel = apply(this.inversePixelTransform, pixel.slice());
          var context = this.context;
          var data;
          try {
              var x = Math.round(renderPixel[0]);
              var y = Math.round(renderPixel[1]);
              var newCanvas = document.createElement('canvas');
              var newContext = newCanvas.getContext('2d');
              newCanvas.width = 1;
              newCanvas.height = 1;
              newContext.clearRect(0, 0, 1, 1);
              newContext.drawImage(context.canvas, x, y, 1, 1, 0, 0, 1, 1);
              data = newContext.getImageData(0, 0, 1, 1).data;
          }
          catch (err) {
              if (err.name === 'SecurityError') {
                  // tainted canvas, we assume there is data at the given pixel (although there might not be)
                  return new Uint8Array();
              }
              return data;
          }
          if (data[3] === 0) {
              return null;
          }
          return data;
      };
      return CanvasLayerRenderer;
  }(LayerRenderer));

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, basedir, module) {
  	return module = {
  		path: basedir,
  		exports: {},
  		require: function (path, base) {
  			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
  		}
  	}, fn(module, module.exports), module.exports;
  }

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  var rbush = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
   module.exports = factory() ;
  }(commonjsGlobal, function () {
  function quickselect(arr, k, left, right, compare) {
      quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
  }

  function quickselectStep(arr, k, left, right, compare) {

      while (right > left) {
          if (right - left > 600) {
              var n = right - left + 1;
              var m = k - left + 1;
              var z = Math.log(n);
              var s = 0.5 * Math.exp(2 * z / 3);
              var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
              var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
              var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
              quickselectStep(arr, k, newLeft, newRight, compare);
          }

          var t = arr[k];
          var i = left;
          var j = right;

          swap(arr, left, k);
          if (compare(arr[right], t) > 0) { swap(arr, left, right); }

          while (i < j) {
              swap(arr, i, j);
              i++;
              j--;
              while (compare(arr[i], t) < 0) { i++; }
              while (compare(arr[j], t) > 0) { j--; }
          }

          if (compare(arr[left], t) === 0) { swap(arr, left, j); }
          else {
              j++;
              swap(arr, j, right);
          }

          if (j <= k) { left = j + 1; }
          if (k <= j) { right = j - 1; }
      }
  }

  function swap(arr, i, j) {
      var tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
  }

  function defaultCompare(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
  }

  var RBush = function RBush(maxEntries) {
      if ( maxEntries === void 0 ) maxEntries = 9;

      // max entries in a node is 9 by default; min node fill is 40% for best performance
      this._maxEntries = Math.max(4, maxEntries);
      this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
      this.clear();
  };

  RBush.prototype.all = function all () {
      return this._all(this.data, []);
  };

  RBush.prototype.search = function search (bbox) {
      var node = this.data;
      var result = [];

      if (!intersects(bbox, node)) { return result; }

      var toBBox = this.toBBox;
      var nodesToSearch = [];

      while (node) {
          for (var i = 0; i < node.children.length; i++) {
              var child = node.children[i];
              var childBBox = node.leaf ? toBBox(child) : child;

              if (intersects(bbox, childBBox)) {
                  if (node.leaf) { result.push(child); }
                  else if (contains(bbox, childBBox)) { this._all(child, result); }
                  else { nodesToSearch.push(child); }
              }
          }
          node = nodesToSearch.pop();
      }

      return result;
  };

  RBush.prototype.collides = function collides (bbox) {
      var node = this.data;

      if (!intersects(bbox, node)) { return false; }

      var nodesToSearch = [];
      while (node) {
          for (var i = 0; i < node.children.length; i++) {
              var child = node.children[i];
              var childBBox = node.leaf ? this.toBBox(child) : child;

              if (intersects(bbox, childBBox)) {
                  if (node.leaf || contains(bbox, childBBox)) { return true; }
                  nodesToSearch.push(child);
              }
          }
          node = nodesToSearch.pop();
      }

      return false;
  };

  RBush.prototype.load = function load (data) {
      if (!(data && data.length)) { return this; }

      if (data.length < this._minEntries) {
          for (var i = 0; i < data.length; i++) {
              this.insert(data[i]);
          }
          return this;
      }

      // recursively build the tree with the given data from scratch using OMT algorithm
      var node = this._build(data.slice(), 0, data.length - 1, 0);

      if (!this.data.children.length) {
          // save as is if tree is empty
          this.data = node;

      } else if (this.data.height === node.height) {
          // split root if trees have the same height
          this._splitRoot(this.data, node);

      } else {
          if (this.data.height < node.height) {
              // swap trees if inserted one is bigger
              var tmpNode = this.data;
              this.data = node;
              node = tmpNode;
          }

          // insert the small tree into the large tree at appropriate level
          this._insert(node, this.data.height - node.height - 1, true);
      }

      return this;
  };

  RBush.prototype.insert = function insert (item) {
      if (item) { this._insert(item, this.data.height - 1); }
      return this;
  };

  RBush.prototype.clear = function clear () {
      this.data = createNode([]);
      return this;
  };

  RBush.prototype.remove = function remove (item, equalsFn) {
      if (!item) { return this; }

      var node = this.data;
      var bbox = this.toBBox(item);
      var path = [];
      var indexes = [];
      var i, parent, goingUp;

      // depth-first iterative tree traversal
      while (node || path.length) {

          if (!node) { // go up
              node = path.pop();
              parent = path[path.length - 1];
              i = indexes.pop();
              goingUp = true;
          }

          if (node.leaf) { // check current node
              var index = findItem(item, node.children, equalsFn);

              if (index !== -1) {
                  // item found, remove the item and condense tree upwards
                  node.children.splice(index, 1);
                  path.push(node);
                  this._condense(path);
                  return this;
              }
          }

          if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
              path.push(node);
              indexes.push(i);
              i = 0;
              parent = node;
              node = node.children[0];

          } else if (parent) { // go right
              i++;
              node = parent.children[i];
              goingUp = false;

          } else { node = null; } // nothing found
      }

      return this;
  };

  RBush.prototype.toBBox = function toBBox (item) { return item; };

  RBush.prototype.compareMinX = function compareMinX (a, b) { return a.minX - b.minX; };
  RBush.prototype.compareMinY = function compareMinY (a, b) { return a.minY - b.minY; };

  RBush.prototype.toJSON = function toJSON () { return this.data; };

  RBush.prototype.fromJSON = function fromJSON (data) {
      this.data = data;
      return this;
  };

  RBush.prototype._all = function _all (node, result) {
      var nodesToSearch = [];
      while (node) {
          if (node.leaf) { result.push.apply(result, node.children); }
          else { nodesToSearch.push.apply(nodesToSearch, node.children); }

          node = nodesToSearch.pop();
      }
      return result;
  };

  RBush.prototype._build = function _build (items, left, right, height) {

      var N = right - left + 1;
      var M = this._maxEntries;
      var node;

      if (N <= M) {
          // reached leaf level; return leaf
          node = createNode(items.slice(left, right + 1));
          calcBBox(node, this.toBBox);
          return node;
      }

      if (!height) {
          // target height of the bulk-loaded tree
          height = Math.ceil(Math.log(N) / Math.log(M));

          // target number of root entries to maximize storage utilization
          M = Math.ceil(N / Math.pow(M, height - 1));
      }

      node = createNode([]);
      node.leaf = false;
      node.height = height;

      // split the items into M mostly square tiles

      var N2 = Math.ceil(N / M);
      var N1 = N2 * Math.ceil(Math.sqrt(M));

      multiSelect(items, left, right, N1, this.compareMinX);

      for (var i = left; i <= right; i += N1) {

          var right2 = Math.min(i + N1 - 1, right);

          multiSelect(items, i, right2, N2, this.compareMinY);

          for (var j = i; j <= right2; j += N2) {

              var right3 = Math.min(j + N2 - 1, right2);

              // pack each entry recursively
              node.children.push(this._build(items, j, right3, height - 1));
          }
      }

      calcBBox(node, this.toBBox);

      return node;
  };

  RBush.prototype._chooseSubtree = function _chooseSubtree (bbox, node, level, path) {
      while (true) {
          path.push(node);

          if (node.leaf || path.length - 1 === level) { break; }

          var minArea = Infinity;
          var minEnlargement = Infinity;
          var targetNode = (void 0);

          for (var i = 0; i < node.children.length; i++) {
              var child = node.children[i];
              var area = bboxArea(child);
              var enlargement = enlargedArea(bbox, child) - area;

              // choose entry with the least area enlargement
              if (enlargement < minEnlargement) {
                  minEnlargement = enlargement;
                  minArea = area < minArea ? area : minArea;
                  targetNode = child;

              } else if (enlargement === minEnlargement) {
                  // otherwise choose one with the smallest area
                  if (area < minArea) {
                      minArea = area;
                      targetNode = child;
                  }
              }
          }

          node = targetNode || node.children[0];
      }

      return node;
  };

  RBush.prototype._insert = function _insert (item, level, isNode) {
      var bbox = isNode ? item : this.toBBox(item);
      var insertPath = [];

      // find the best node for accommodating the item, saving all nodes along the path too
      var node = this._chooseSubtree(bbox, this.data, level, insertPath);

      // put the item into the node
      node.children.push(item);
      extend(node, bbox);

      // split on node overflow; propagate upwards if necessary
      while (level >= 0) {
          if (insertPath[level].children.length > this._maxEntries) {
              this._split(insertPath, level);
              level--;
          } else { break; }
      }

      // adjust bboxes along the insertion path
      this._adjustParentBBoxes(bbox, insertPath, level);
  };

  // split overflowed node into two
  RBush.prototype._split = function _split (insertPath, level) {
      var node = insertPath[level];
      var M = node.children.length;
      var m = this._minEntries;

      this._chooseSplitAxis(node, m, M);

      var splitIndex = this._chooseSplitIndex(node, m, M);

      var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
      newNode.height = node.height;
      newNode.leaf = node.leaf;

      calcBBox(node, this.toBBox);
      calcBBox(newNode, this.toBBox);

      if (level) { insertPath[level - 1].children.push(newNode); }
      else { this._splitRoot(node, newNode); }
  };

  RBush.prototype._splitRoot = function _splitRoot (node, newNode) {
      // split root node
      this.data = createNode([node, newNode]);
      this.data.height = node.height + 1;
      this.data.leaf = false;
      calcBBox(this.data, this.toBBox);
  };

  RBush.prototype._chooseSplitIndex = function _chooseSplitIndex (node, m, M) {
      var index;
      var minOverlap = Infinity;
      var minArea = Infinity;

      for (var i = m; i <= M - m; i++) {
          var bbox1 = distBBox(node, 0, i, this.toBBox);
          var bbox2 = distBBox(node, i, M, this.toBBox);

          var overlap = intersectionArea(bbox1, bbox2);
          var area = bboxArea(bbox1) + bboxArea(bbox2);

          // choose distribution with minimum overlap
          if (overlap < minOverlap) {
              minOverlap = overlap;
              index = i;

              minArea = area < minArea ? area : minArea;

          } else if (overlap === minOverlap) {
              // otherwise choose distribution with minimum area
              if (area < minArea) {
                  minArea = area;
                  index = i;
              }
          }
      }

      return index || M - m;
  };

  // sorts node children by the best axis for split
  RBush.prototype._chooseSplitAxis = function _chooseSplitAxis (node, m, M) {
      var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
      var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
      var xMargin = this._allDistMargin(node, m, M, compareMinX);
      var yMargin = this._allDistMargin(node, m, M, compareMinY);

      // if total distributions margin value is minimal for x, sort by minX,
      // otherwise it's already sorted by minY
      if (xMargin < yMargin) { node.children.sort(compareMinX); }
  };

  // total margin of all possible split distributions where each node is at least m full
  RBush.prototype._allDistMargin = function _allDistMargin (node, m, M, compare) {
      node.children.sort(compare);

      var toBBox = this.toBBox;
      var leftBBox = distBBox(node, 0, m, toBBox);
      var rightBBox = distBBox(node, M - m, M, toBBox);
      var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);

      for (var i = m; i < M - m; i++) {
          var child = node.children[i];
          extend(leftBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(leftBBox);
      }

      for (var i$1 = M - m - 1; i$1 >= m; i$1--) {
          var child$1 = node.children[i$1];
          extend(rightBBox, node.leaf ? toBBox(child$1) : child$1);
          margin += bboxMargin(rightBBox);
      }

      return margin;
  };

  RBush.prototype._adjustParentBBoxes = function _adjustParentBBoxes (bbox, path, level) {
      // adjust bboxes along the given tree path
      for (var i = level; i >= 0; i--) {
          extend(path[i], bbox);
      }
  };

  RBush.prototype._condense = function _condense (path) {
      // go through the path, removing empty nodes and updating bboxes
      for (var i = path.length - 1, siblings = (void 0); i >= 0; i--) {
          if (path[i].children.length === 0) {
              if (i > 0) {
                  siblings = path[i - 1].children;
                  siblings.splice(siblings.indexOf(path[i]), 1);

              } else { this.clear(); }

          } else { calcBBox(path[i], this.toBBox); }
      }
  };

  function findItem(item, items, equalsFn) {
      if (!equalsFn) { return items.indexOf(item); }

      for (var i = 0; i < items.length; i++) {
          if (equalsFn(item, items[i])) { return i; }
      }
      return -1;
  }

  // calculate node's bbox from bboxes of its children
  function calcBBox(node, toBBox) {
      distBBox(node, 0, node.children.length, toBBox, node);
  }

  // min bounding rectangle of node children from k to p-1
  function distBBox(node, k, p, toBBox, destNode) {
      if (!destNode) { destNode = createNode(null); }
      destNode.minX = Infinity;
      destNode.minY = Infinity;
      destNode.maxX = -Infinity;
      destNode.maxY = -Infinity;

      for (var i = k; i < p; i++) {
          var child = node.children[i];
          extend(destNode, node.leaf ? toBBox(child) : child);
      }

      return destNode;
  }

  function extend(a, b) {
      a.minX = Math.min(a.minX, b.minX);
      a.minY = Math.min(a.minY, b.minY);
      a.maxX = Math.max(a.maxX, b.maxX);
      a.maxY = Math.max(a.maxY, b.maxY);
      return a;
  }

  function compareNodeMinX(a, b) { return a.minX - b.minX; }
  function compareNodeMinY(a, b) { return a.minY - b.minY; }

  function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
  function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

  function enlargedArea(a, b) {
      return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
             (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
  }

  function intersectionArea(a, b) {
      var minX = Math.max(a.minX, b.minX);
      var minY = Math.max(a.minY, b.minY);
      var maxX = Math.min(a.maxX, b.maxX);
      var maxY = Math.min(a.maxY, b.maxY);

      return Math.max(0, maxX - minX) *
             Math.max(0, maxY - minY);
  }

  function contains(a, b) {
      return a.minX <= b.minX &&
             a.minY <= b.minY &&
             b.maxX <= a.maxX &&
             b.maxY <= a.maxY;
  }

  function intersects(a, b) {
      return b.minX <= a.maxX &&
             b.minY <= a.maxY &&
             b.maxX >= a.minX &&
             b.maxY >= a.minY;
  }

  function createNode(children) {
      return {
          children: children,
          height: 1,
          leaf: true,
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity
      };
  }

  // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
  // combines selection algorithm with binary divide & conquer approach

  function multiSelect(arr, left, right, n, compare) {
      var stack = [left, right];

      while (stack.length) {
          right = stack.pop();
          left = stack.pop();

          if (right - left <= n) { continue; }

          var mid = left + Math.ceil((right - left) / n / 2) * n;
          quickselect(arr, mid, left, right, compare);

          stack.push(left, mid, mid, right);
      }
  }

  return RBush;

  }));
  });

  /**
   * @module ol/geom/flat/textpath
   */
  /**
   * @param {Array<number>} flatCoordinates Path to put text on.
   * @param {number} offset Start offset of the `flatCoordinates`.
   * @param {number} end End offset of the `flatCoordinates`.
   * @param {number} stride Stride.
   * @param {string} text Text to place on the path.
   * @param {number} startM m along the path where the text starts.
   * @param {number} maxAngle Max angle between adjacent chars in radians.
   * @param {number} scale The product of the text scale and the device pixel ratio.
   * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.
   * @param {string} font The font.
   * @param {Object<string, number>} cache A cache of measured widths.
   * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.
   * @return {Array<Array<*>>} The result array (or null if `maxAngle` was
   * exceeded). Entries of the array are x, y, anchorX, angle, chunk.
   */
  function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {
      var result = [];
      // Keep text upright
      var reverse;
      if (rotation) {
          var rotatedCoordinates = rotate(flatCoordinates, offset, end, stride, rotation, [flatCoordinates[offset], flatCoordinates[offset + 1]]);
          reverse =
              rotatedCoordinates[0] >
                  rotatedCoordinates[rotatedCoordinates.length - stride];
      }
      else {
          reverse = flatCoordinates[offset] > flatCoordinates[end - stride];
      }
      var numChars = text.length;
      var x1 = flatCoordinates[offset];
      var y1 = flatCoordinates[offset + 1];
      offset += stride;
      var x2 = flatCoordinates[offset];
      var y2 = flatCoordinates[offset + 1];
      var segmentM = 0;
      var segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
      var angleChanged = false;
      var index, previousAngle;
      for (var i = 0; i < numChars; ++i) {
          index = reverse ? numChars - i - 1 : i;
          var char = text[index];
          var charLength = scale * measureAndCacheTextWidth(font, char, cache);
          var charM = startM + charLength / 2;
          while (offset < end - stride && segmentM + segmentLength < charM) {
              x1 = x2;
              y1 = y2;
              offset += stride;
              x2 = flatCoordinates[offset];
              y2 = flatCoordinates[offset + 1];
              segmentM += segmentLength;
              segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
          }
          var segmentPos = charM - segmentM;
          var angle = Math.atan2(y2 - y1, x2 - x1);
          if (reverse) {
              angle += angle > 0 ? -Math.PI : Math.PI;
          }
          if (previousAngle !== undefined) {
              var delta = angle - previousAngle;
              angleChanged = angleChanged || delta !== 0;
              delta +=
                  delta > Math.PI ? -2 * Math.PI : delta < -Math.PI ? 2 * Math.PI : 0;
              if (Math.abs(delta) > maxAngle) {
                  return null;
              }
          }
          previousAngle = angle;
          var interpolate = segmentPos / segmentLength;
          var x = lerp(x1, x2, interpolate);
          var y = lerp(y1, y2, interpolate);
          result[index] = [x, y, charLength / 2, angle, char];
          startM += charLength;
      }
      return angleChanged
          ? result
          : [[result[0][0], result[0][1], result[0][2], result[0][3], text]];
  }

  /**
   * @module ol/render/canvas/Executor
   */
  /**
   * @typedef {Object} SerializableInstructions
   * @property {Array<*>} instructions The rendering instructions.
   * @property {Array<*>} hitDetectionInstructions The rendering hit detection instructions.
   * @property {Array<number>} coordinates The array of all coordinates.
   * @property {!Object<string, import("../canvas.js").TextState>} textStates The text states (decluttering).
   * @property {!Object<string, import("../canvas.js").FillState>} fillStates The fill states (decluttering).
   * @property {!Object<string, import("../canvas.js").StrokeState>} strokeStates The stroke states (decluttering).
   */
  /**
   * @type {import("../../extent.js").Extent}
   */
  var tmpExtent = createEmpty();
  /**
   * @type {!import("../../transform.js").Transform}
   */
  var tmpTransform$1 = create();
  /** @type {import("../../coordinate.js").Coordinate} */
  var p1 = [];
  /** @type {import("../../coordinate.js").Coordinate} */
  var p2 = [];
  /** @type {import("../../coordinate.js").Coordinate} */
  var p3 = [];
  /** @type {import("../../coordinate.js").Coordinate} */
  var p4 = [];
  var Executor = /** @class */ (function () {
      /**
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {boolean} overlaps The replay can have overlapping geometries.
       * @param {SerializableInstructions} instructions The serializable instructions
       * @param {import("../../size.js").Size} renderBuffer Render buffer (width/height) in pixels.
       */
      function Executor(resolution, pixelRatio, overlaps, instructions, renderBuffer) {
          /**
           * @protected
           * @type {boolean}
           */
          this.overlaps = overlaps;
          /**
           * @protected
           * @type {number}
           */
          this.pixelRatio = pixelRatio;
          /**
           * @protected
           * @const
           * @type {number}
           */
          this.resolution = resolution;
          /**
           * @private
           * @type {boolean}
           */
          this.alignFill_;
          /**
           * @type {Array<*>}
           */
          this.declutterItems = [];
          /**
           * @protected
           * @type {Array<*>}
           */
          this.instructions = instructions.instructions;
          /**
           * @protected
           * @type {Array<number>}
           */
          this.coordinates = instructions.coordinates;
          /**
           * @private
           * @type {!Object<number,import("../../coordinate.js").Coordinate|Array<import("../../coordinate.js").Coordinate>|Array<Array<import("../../coordinate.js").Coordinate>>>}
           */
          this.coordinateCache_ = {};
          /**
           * @private
           * @type {import("../../size.js").Size}
           */
          this.renderBuffer_ = renderBuffer;
          /**
           * @private
           * @type {!import("../../transform.js").Transform}
           */
          this.renderedTransform_ = create();
          /**
           * @protected
           * @type {Array<*>}
           */
          this.hitDetectionInstructions = instructions.hitDetectionInstructions;
          /**
           * @private
           * @type {Array<number>}
           */
          this.pixelCoordinates_ = null;
          /**
           * @private
           * @type {number}
           */
          this.viewRotation_ = 0;
          /**
           * @type {!Object<string, import("../canvas.js").FillState>}
           */
          this.fillStates = instructions.fillStates || {};
          /**
           * @type {!Object<string, import("../canvas.js").StrokeState>}
           */
          this.strokeStates = instructions.strokeStates || {};
          /**
           * @type {!Object<string, import("../canvas.js").TextState>}
           */
          this.textStates = instructions.textStates || {};
          /**
           * @private
           * @type {Object<string, Object<string, number>>}
           */
          this.widths_ = {};
          /**
           * @private
           * @type {Object<string, import("../canvas.js").Label>}
           */
          this.labels_ = {};
      }
      /**
       * @param {string} text Text.
       * @param {string} textKey Text style key.
       * @param {string} fillKey Fill style key.
       * @param {string} strokeKey Stroke style key.
       * @return {import("../canvas.js").Label} Label.
       */
      Executor.prototype.createLabel = function (text, textKey, fillKey, strokeKey) {
          var key = text + textKey + fillKey + strokeKey;
          if (this.labels_[key]) {
              return this.labels_[key];
          }
          var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
          var fillState = fillKey ? this.fillStates[fillKey] : null;
          var textState = this.textStates[textKey];
          var pixelRatio = this.pixelRatio;
          var scale = [
              textState.scale[0] * pixelRatio,
              textState.scale[1] * pixelRatio,
          ];
          var align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];
          var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
          var lines = text.split('\n');
          var numLines = lines.length;
          var widths = [];
          var width = measureTextWidths(textState.font, lines, widths);
          var lineHeight = measureTextHeight(textState.font);
          var height = lineHeight * numLines;
          var renderWidth = width + strokeWidth;
          var contextInstructions = [];
          // make canvas 2 pixels wider to account for italic text width measurement errors
          var w = (renderWidth + 2) * scale[0];
          var h = (height + strokeWidth) * scale[1];
          /** @type {import("../canvas.js").Label} */
          var label = {
              width: w < 0 ? Math.floor(w) : Math.ceil(w),
              height: h < 0 ? Math.floor(h) : Math.ceil(h),
              contextInstructions: contextInstructions,
          };
          if (scale[0] != 1 || scale[1] != 1) {
              contextInstructions.push('scale', scale);
          }
          contextInstructions.push('font', textState.font);
          if (strokeKey) {
              contextInstructions.push('strokeStyle', strokeState.strokeStyle);
              contextInstructions.push('lineWidth', strokeWidth);
              contextInstructions.push('lineCap', strokeState.lineCap);
              contextInstructions.push('lineJoin', strokeState.lineJoin);
              contextInstructions.push('miterLimit', strokeState.miterLimit);
              // eslint-disable-next-line
              var Context = WORKER_OFFSCREEN_CANVAS ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D;
              if (Context.prototype.setLineDash) {
                  contextInstructions.push('setLineDash', [strokeState.lineDash]);
                  contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);
              }
          }
          if (fillKey) {
              contextInstructions.push('fillStyle', fillState.fillStyle);
          }
          contextInstructions.push('textBaseline', 'middle');
          contextInstructions.push('textAlign', 'center');
          var leftRight = 0.5 - align;
          var x = align * renderWidth + leftRight * strokeWidth;
          var i;
          if (strokeKey) {
              for (i = 0; i < numLines; ++i) {
                  contextInstructions.push('strokeText', [
                      lines[i],
                      x + leftRight * widths[i],
                      0.5 * (strokeWidth + lineHeight) + i * lineHeight,
                  ]);
              }
          }
          if (fillKey) {
              for (i = 0; i < numLines; ++i) {
                  contextInstructions.push('fillText', [
                      lines[i],
                      x + leftRight * widths[i],
                      0.5 * (strokeWidth + lineHeight) + i * lineHeight,
                  ]);
              }
          }
          this.labels_[key] = label;
          return label;
      };
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
       * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
       * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
       * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
       * @param {Array<*>} fillInstruction Fill instruction.
       * @param {Array<*>} strokeInstruction Stroke instruction.
       * @param {boolean} declutter Declutter.
       */
      Executor.prototype.replayTextBackground_ = function (context, p1, p2, p3, p4, fillInstruction, strokeInstruction, declutter) {
          context.beginPath();
          context.moveTo.apply(context, p1);
          context.lineTo.apply(context, p2);
          context.lineTo.apply(context, p3);
          context.lineTo.apply(context, p4);
          context.lineTo.apply(context, p1);
          if (fillInstruction) {
              this.alignFill_ = /** @type {boolean} */ (fillInstruction[2]);
              if (declutter) {
                  context.fillStyle = /** @type {import("../../colorlike.js").ColorLike} */ (fillInstruction[1]);
              }
              this.fill_(context);
          }
          if (strokeInstruction) {
              this.setStrokeStyle_(context, 
              /** @type {Array<*>} */ (strokeInstruction));
              context.stroke();
          }
      };
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} contextScale Scale of the context.
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
       * @param {number} anchorX Anchor X.
       * @param {number} anchorY Anchor Y.
       * @param {import("../canvas.js").DeclutterGroup} declutterGroup Declutter group.
       * @param {number} height Height.
       * @param {number} opacity Opacity.
       * @param {number} originX Origin X.
       * @param {number} originY Origin Y.
       * @param {number} rotation Rotation.
       * @param {import("../../size.js").Size} scale Scale.
       * @param {boolean} snapToPixel Snap to pixel.
       * @param {number} width Width.
       * @param {Array<number>} padding Padding.
       * @param {Array<*>} fillInstruction Fill instruction.
       * @param {Array<*>} strokeInstruction Stroke instruction.
       * @return {boolean} The image or label was rendered.
       */
      Executor.prototype.replayImageOrLabel_ = function (context, contextScale, x, y, imageOrLabel, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, fillInstruction, strokeInstruction) {
          var fillStroke = fillInstruction || strokeInstruction;
          anchorX *= scale[0];
          anchorY *= scale[1];
          x -= anchorX;
          y -= anchorY;
          var w = width + originX > imageOrLabel.width
              ? imageOrLabel.width - originX
              : width;
          var h = height + originY > imageOrLabel.height
              ? imageOrLabel.height - originY
              : height;
          var boxW = padding[3] + w * scale[0] + padding[1];
          var boxH = padding[0] + h * scale[1] + padding[2];
          var boxX = x - padding[3];
          var boxY = y - padding[0];
          if (fillStroke || rotation !== 0) {
              p1[0] = boxX;
              p4[0] = boxX;
              p1[1] = boxY;
              p2[1] = boxY;
              p2[0] = boxX + boxW;
              p3[0] = p2[0];
              p3[1] = boxY + boxH;
              p4[1] = p3[1];
          }
          var transform = null;
          if (rotation !== 0) {
              var centerX = x + anchorX;
              var centerY = y + anchorY;
              transform = compose(tmpTransform$1, centerX, centerY, 1, 1, rotation, -centerX, -centerY);
              apply(tmpTransform$1, p1);
              apply(tmpTransform$1, p2);
              apply(tmpTransform$1, p3);
              apply(tmpTransform$1, p4);
              createOrUpdate(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);
          }
          else {
              createOrUpdate(boxX, boxY, boxX + boxW, boxY + boxH, tmpExtent);
          }
          var renderBufferX = 0;
          var renderBufferY = 0;
          if (declutterGroup) {
              var renderBuffer = this.renderBuffer_;
              renderBuffer[0] = Math.max(renderBuffer[0], getWidth(tmpExtent));
              renderBufferX = renderBuffer[0];
              renderBuffer[1] = Math.max(renderBuffer[1], getHeight(tmpExtent));
              renderBufferY = renderBuffer[1];
          }
          var canvas = context.canvas;
          var strokePadding = strokeInstruction
              ? (strokeInstruction[2] * scale[0]) / 2
              : 0;
          var intersects = tmpExtent[0] - strokePadding <=
              (canvas.width + renderBufferX) / contextScale &&
              tmpExtent[2] + strokePadding >= -renderBufferX / contextScale &&
              tmpExtent[1] - strokePadding <=
                  (canvas.height + renderBufferY) / contextScale &&
              tmpExtent[3] + strokePadding >= -renderBufferY / contextScale;
          if (snapToPixel) {
              x = Math.round(x);
              y = Math.round(y);
          }
          if (declutterGroup) {
              if (!intersects && declutterGroup[0] == 1) {
                  return false;
              }
              var declutterArgs = intersects
                  ? [
                      context,
                      transform ? transform.slice(0) : null,
                      opacity,
                      imageOrLabel,
                      originX,
                      originY,
                      w,
                      h,
                      x,
                      y,
                      scale,
                      tmpExtent.slice(),
                  ]
                  : null;
              if (declutterArgs) {
                  if (fillStroke) {
                      declutterArgs.push(fillInstruction, strokeInstruction, p1.slice(0), p2.slice(0), p3.slice(0), p4.slice(0));
                  }
                  declutterGroup.push(declutterArgs);
              }
          }
          else if (intersects) {
              if (fillStroke) {
                  this.replayTextBackground_(context, p1, p2, p3, p4, 
                  /** @type {Array<*>} */ (fillInstruction), 
                  /** @type {Array<*>} */ (strokeInstruction), false);
              }
              drawImageOrLabel(context, transform, opacity, imageOrLabel, originX, originY, w, h, x, y, scale);
          }
          return true;
      };
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       */
      Executor.prototype.fill_ = function (context) {
          if (this.alignFill_) {
              var origin_1 = apply(this.renderedTransform_, [0, 0]);
              var repeatSize = 512 * this.pixelRatio;
              context.save();
              context.translate(origin_1[0] % repeatSize, origin_1[1] % repeatSize);
              context.rotate(this.viewRotation_);
          }
          context.fill();
          if (this.alignFill_) {
              context.restore();
          }
      };
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       * @param {Array<*>} instruction Instruction.
       */
      Executor.prototype.setStrokeStyle_ = function (context, instruction) {
          context.strokeStyle = /** @type {import("../../colorlike.js").ColorLike} */ (instruction[1]);
          context.lineWidth = /** @type {number} */ (instruction[2]);
          context.lineCap = /** @type {CanvasLineCap} */ (instruction[3]);
          context.lineJoin = /** @type {CanvasLineJoin} */ (instruction[4]);
          context.miterLimit = /** @type {number} */ (instruction[5]);
          if (context.setLineDash) {
              context.lineDashOffset = /** @type {number} */ (instruction[7]);
              context.setLineDash(/** @type {Array<number>} */ (instruction[6]));
          }
      };
      /**
       * @param {import("../canvas.js").DeclutterGroup} declutterGroup Declutter group.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {number} opacity Layer opacity.
       * @param {?} declutterTree Declutter tree.
       * @return {?} Declutter tree.
       */
      Executor.prototype.renderDeclutter = function (declutterGroup, feature, opacity, declutterTree) {
          /** @type {Array<import("../../structs/RBush.js").Entry>} */
          var boxes = [];
          for (var i = 1, ii = declutterGroup.length; i < ii; ++i) {
              var declutterData = declutterGroup[i];
              var box = declutterData[11];
              boxes.push({
                  minX: box[0],
                  minY: box[1],
                  maxX: box[2],
                  maxY: box[3],
                  value: feature,
              });
          }
          if (!declutterTree) {
              declutterTree = new rbush(9);
          }
          var collides = false;
          for (var i = 0, ii = boxes.length; i < ii; ++i) {
              if (declutterTree.collides(boxes[i])) {
                  collides = true;
                  break;
              }
          }
          if (!collides) {
              declutterTree.load(boxes);
              for (var j = 1, jj = declutterGroup.length; j < jj; ++j) {
                  var declutterData = /** @type {Array} */ (declutterGroup[j]);
                  var context = declutterData[0];
                  var currentAlpha = context.globalAlpha;
                  if (currentAlpha !== opacity) {
                      context.globalAlpha = opacity;
                  }
                  if (declutterData.length > 12) {
                      this.replayTextBackground_(declutterData[0], declutterData[14], declutterData[15], declutterData[16], declutterData[17], declutterData[12], declutterData[13], true);
                  }
                  drawImageOrLabel.apply(undefined, declutterData);
                  if (currentAlpha !== opacity) {
                      context.globalAlpha = currentAlpha;
                  }
              }
          }
          declutterGroup.length = 1;
          return declutterTree;
      };
      /**
       * @private
       * @param {string} text The text to draw.
       * @param {string} textKey The key of the text state.
       * @param {string} strokeKey The key for the stroke state.
       * @param {string} fillKey The key for the fill state.
       * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
       */
      Executor.prototype.drawLabelWithPointPlacement_ = function (text, textKey, strokeKey, fillKey) {
          var textState = this.textStates[textKey];
          var label = this.createLabel(text, textKey, fillKey, strokeKey);
          var strokeState = this.strokeStates[strokeKey];
          var pixelRatio = this.pixelRatio;
          var align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];
          var baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];
          var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;
          // Remove the 2 pixels we added in createLabel() for the anchor
          var width = label.width / pixelRatio - 2 * textState.scale[0];
          var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
          var anchorY = (baseline * label.height) / pixelRatio +
              2 * (0.5 - baseline) * strokeWidth;
          return {
              label: label,
              anchorX: anchorX,
              anchorY: anchorY,
          };
      };
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} contextScale Scale of the context.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {Array<*>} instructions Instructions array.
       * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
       * @param {function(import("../../Feature.js").FeatureLike): T|undefined} featureCallback Feature callback.
       * @param {import("../../extent.js").Extent=} opt_hitExtent Only check features that intersect this
       *     extent.
       * @return {T|undefined} Callback result.
       * @template T
       */
      Executor.prototype.execute_ = function (context, contextScale, transform, instructions, snapToPixel, featureCallback, opt_hitExtent) {
          this.declutterItems.length = 0;
          /** @type {Array<number>} */
          var pixelCoordinates;
          if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {
              pixelCoordinates = this.pixelCoordinates_;
          }
          else {
              if (!this.pixelCoordinates_) {
                  this.pixelCoordinates_ = [];
              }
              pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);
              setFromArray(this.renderedTransform_, transform);
          }
          var i = 0; // instruction index
          var ii = instructions.length; // end of instructions
          var d = 0; // data index
          var dd; // end of per-instruction data
          var anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, declutterGroups, image, text, textKey;
          var strokeKey, fillKey;
          var pendingFill = 0;
          var pendingStroke = 0;
          var lastFillInstruction = null;
          var lastStrokeInstruction = null;
          var coordinateCache = this.coordinateCache_;
          var viewRotation = this.viewRotation_;
          var viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;
          var state = /** @type {import("../../render.js").State} */ ({
              context: context,
              pixelRatio: this.pixelRatio,
              resolution: this.resolution,
              rotation: viewRotation,
          });
          // When the batch size gets too big, performance decreases. 200 is a good
          // balance between batch size and number of fill/stroke instructions.
          var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
          var /** @type {import("../../Feature.js").FeatureLike} */ feature;
          var x, y;
          while (i < ii) {
              var instruction = instructions[i];
              var type = /** @type {import("./Instruction.js").default} */ (instruction[0]);
              switch (type) {
                  case Instruction.BEGIN_GEOMETRY:
                      feature = /** @type {import("../../Feature.js").FeatureLike} */ (instruction[1]);
                      if (!feature.getGeometry()) {
                          i = /** @type {number} */ (instruction[2]);
                      }
                      else if (opt_hitExtent !== undefined &&
                          !intersects(opt_hitExtent, instruction[3])) {
                          i = /** @type {number} */ (instruction[2]) + 1;
                      }
                      else {
                          ++i;
                      }
                      break;
                  case Instruction.BEGIN_PATH:
                      if (pendingFill > batchSize) {
                          this.fill_(context);
                          pendingFill = 0;
                      }
                      if (pendingStroke > batchSize) {
                          context.stroke();
                          pendingStroke = 0;
                      }
                      if (!pendingFill && !pendingStroke) {
                          context.beginPath();
                          prevX = NaN;
                          prevY = NaN;
                      }
                      ++i;
                      break;
                  case Instruction.CIRCLE:
                      d = /** @type {number} */ (instruction[1]);
                      var x1 = pixelCoordinates[d];
                      var y1 = pixelCoordinates[d + 1];
                      var x2 = pixelCoordinates[d + 2];
                      var y2 = pixelCoordinates[d + 3];
                      var dx = x2 - x1;
                      var dy = y2 - y1;
                      var r = Math.sqrt(dx * dx + dy * dy);
                      context.moveTo(x1 + r, y1);
                      context.arc(x1, y1, r, 0, 2 * Math.PI, true);
                      ++i;
                      break;
                  case Instruction.CLOSE_PATH:
                      context.closePath();
                      ++i;
                      break;
                  case Instruction.CUSTOM:
                      d = /** @type {number} */ (instruction[1]);
                      dd = instruction[2];
                      var geometry = /** @type {import("../../geom/SimpleGeometry.js").default} */ (instruction[3]);
                      var renderer = instruction[4];
                      var fn = instruction.length == 6 ? instruction[5] : undefined;
                      state.geometry = geometry;
                      state.feature = feature;
                      if (!(i in coordinateCache)) {
                          coordinateCache[i] = [];
                      }
                      var coords = coordinateCache[i];
                      if (fn) {
                          fn(pixelCoordinates, d, dd, 2, coords);
                      }
                      else {
                          coords[0] = pixelCoordinates[d];
                          coords[1] = pixelCoordinates[d + 1];
                          coords.length = 2;
                      }
                      renderer(coords, state);
                      ++i;
                      break;
                  case Instruction.DRAW_IMAGE:
                      d = /** @type {number} */ (instruction[1]);
                      dd = /** @type {number} */ (instruction[2]);
                      image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */ (instruction[3]);
                      // Remaining arguments in DRAW_IMAGE are in alphabetical order
                      anchorX = /** @type {number} */ (instruction[4]);
                      anchorY = /** @type {number} */ (instruction[5]);
                      declutterGroups = featureCallback ? null : instruction[6];
                      var height = /** @type {number} */ (instruction[7]);
                      var opacity = /** @type {number} */ (instruction[8]);
                      var originX = /** @type {number} */ (instruction[9]);
                      var originY = /** @type {number} */ (instruction[10]);
                      var rotateWithView = /** @type {boolean} */ (instruction[11]);
                      var rotation = /** @type {number} */ (instruction[12]);
                      var scale = /** @type {import("../../size.js").Size} */ (instruction[13]);
                      var width = /** @type {number} */ (instruction[14]);
                      if (!image && instruction.length >= 19) {
                          // create label images
                          text = /** @type {string} */ (instruction[18]);
                          textKey = /** @type {string} */ (instruction[19]);
                          strokeKey = /** @type {string} */ (instruction[20]);
                          fillKey = /** @type {string} */ (instruction[21]);
                          var labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);
                          image = labelWithAnchor.label;
                          instruction[3] = image;
                          var textOffsetX = /** @type {number} */ (instruction[22]);
                          anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
                          instruction[4] = anchorX;
                          var textOffsetY = /** @type {number} */ (instruction[23]);
                          anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
                          instruction[5] = anchorY;
                          height = image.height;
                          instruction[7] = height;
                          width = image.width;
                          instruction[14] = width;
                      }
                      var geometryWidths = void 0;
                      if (instruction.length > 24) {
                          geometryWidths = /** @type {number} */ (instruction[24]);
                      }
                      var padding = void 0, backgroundFill = void 0, backgroundStroke = void 0;
                      if (instruction.length > 16) {
                          padding = /** @type {Array<number>} */ (instruction[15]);
                          backgroundFill = /** @type {boolean} */ (instruction[16]);
                          backgroundStroke = /** @type {boolean} */ (instruction[17]);
                      }
                      else {
                          padding = defaultPadding;
                          backgroundFill = false;
                          backgroundStroke = false;
                      }
                      if (rotateWithView && viewRotationFromTransform) {
                          // Canvas is expected to be rotated to reverse view rotation.
                          rotation += viewRotation;
                      }
                      else if (!rotateWithView && !viewRotationFromTransform) {
                          // Canvas is not rotated, images need to be rotated back to be north-up.
                          rotation -= viewRotation;
                      }
                      var widthIndex = 0;
                      var declutterGroupIndex = 0;
                      for (; d < dd; d += 2) {
                          if (geometryWidths &&
                              geometryWidths[widthIndex++] < width / this.pixelRatio) {
                              continue;
                          }
                          if (declutterGroups) {
                              var index = Math.floor(declutterGroupIndex);
                              declutterGroup =
                                  declutterGroups.length < index + 1
                                      ? [declutterGroups[0][0]]
                                      : declutterGroups[index];
                          }
                          var rendered = this.replayImageOrLabel_(context, contextScale, pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, backgroundFill
                              ? /** @type {Array<*>} */ (lastFillInstruction)
                              : null, backgroundStroke
                              ? /** @type {Array<*>} */ (lastStrokeInstruction)
                              : null);
                          if (rendered &&
                              declutterGroup &&
                              declutterGroups[declutterGroups.length - 1] !== declutterGroup) {
                              declutterGroups.push(declutterGroup);
                          }
                          if (declutterGroup) {
                              if (declutterGroup.length - 1 === declutterGroup[0]) {
                                  this.declutterItems.push(this, declutterGroup, feature);
                              }
                              declutterGroupIndex += 1 / declutterGroup[0];
                          }
                      }
                      ++i;
                      break;
                  case Instruction.DRAW_CHARS:
                      var begin = /** @type {number} */ (instruction[1]);
                      var end = /** @type {number} */ (instruction[2]);
                      var baseline = /** @type {number} */ (instruction[3]);
                      declutterGroup = featureCallback ? null : instruction[4];
                      var overflow = /** @type {number} */ (instruction[5]);
                      fillKey = /** @type {string} */ (instruction[6]);
                      var maxAngle = /** @type {number} */ (instruction[7]);
                      var measurePixelRatio = /** @type {number} */ (instruction[8]);
                      var offsetY = /** @type {number} */ (instruction[9]);
                      strokeKey = /** @type {string} */ (instruction[10]);
                      var strokeWidth = /** @type {number} */ (instruction[11]);
                      text = /** @type {string} */ (instruction[12]);
                      textKey = /** @type {string} */ (instruction[13]);
                      var pixelRatioScale = [
                          /** @type {number} */ (instruction[14]),
                          /** @type {number} */ (instruction[14]),
                      ];
                      var textState = this.textStates[textKey];
                      var font = textState.font;
                      var textScale = [
                          textState.scale[0] * measurePixelRatio,
                          textState.scale[1] * measurePixelRatio,
                      ];
                      var cachedWidths = void 0;
                      if (font in this.widths_) {
                          cachedWidths = this.widths_[font];
                      }
                      else {
                          cachedWidths = {};
                          this.widths_[font] = cachedWidths;
                      }
                      var pathLength = lineStringLength(pixelCoordinates, begin, end, 2);
                      var textLength = Math.abs(textScale[0]) *
                          measureAndCacheTextWidth(font, text, cachedWidths);
                      if (overflow || textLength <= pathLength) {
                          var textAlign = this.textStates[textKey].textAlign;
                          var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];
                          var parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);
                          if (parts) {
                              var rendered = false;
                              var c = void 0, cc = void 0, chars = void 0, label = void 0, part = void 0;
                              if (strokeKey) {
                                  for (c = 0, cc = parts.length; c < cc; ++c) {
                                      part = parts[c]; // x, y, anchorX, rotation, chunk
                                      chars = /** @type {string} */ (part[4]);
                                      label = this.createLabel(chars, textKey, '', strokeKey);
                                      anchorX = /** @type {number} */ (part[2]) + strokeWidth;
                                      anchorY =
                                          baseline * label.height +
                                              ((0.5 - baseline) * 2 * strokeWidth * textScale[1]) /
                                                  textScale[0] -
                                              offsetY;
                                      rendered =
                                          this.replayImageOrLabel_(context, contextScale, 
                                          /** @type {number} */ (part[0]), 
                                          /** @type {number} */ (part[1]), label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0, 
                                          /** @type {number} */ (part[3]), pixelRatioScale, false, label.width, defaultPadding, null, null) || rendered;
                                  }
                              }
                              if (fillKey) {
                                  for (c = 0, cc = parts.length; c < cc; ++c) {
                                      part = parts[c]; // x, y, anchorX, rotation, chunk
                                      chars = /** @type {string} */ (part[4]);
                                      label = this.createLabel(chars, textKey, fillKey, '');
                                      anchorX = /** @type {number} */ (part[2]);
                                      anchorY = baseline * label.height - offsetY;
                                      rendered =
                                          this.replayImageOrLabel_(context, contextScale, 
                                          /** @type {number} */ (part[0]), 
                                          /** @type {number} */ (part[1]), label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0, 
                                          /** @type {number} */ (part[3]), pixelRatioScale, false, label.width, defaultPadding, null, null) || rendered;
                                  }
                              }
                              if (rendered) {
                                  this.declutterItems.push(this, declutterGroup, feature);
                              }
                          }
                      }
                      ++i;
                      break;
                  case Instruction.END_GEOMETRY:
                      if (featureCallback !== undefined) {
                          feature = /** @type {import("../../Feature.js").FeatureLike} */ (instruction[1]);
                          var result = featureCallback(feature);
                          if (result) {
                              return result;
                          }
                      }
                      ++i;
                      break;
                  case Instruction.FILL:
                      if (batchSize) {
                          pendingFill++;
                      }
                      else {
                          this.fill_(context);
                      }
                      ++i;
                      break;
                  case Instruction.MOVE_TO_LINE_TO:
                      d = /** @type {number} */ (instruction[1]);
                      dd = /** @type {number} */ (instruction[2]);
                      x = pixelCoordinates[d];
                      y = pixelCoordinates[d + 1];
                      roundX = (x + 0.5) | 0;
                      roundY = (y + 0.5) | 0;
                      if (roundX !== prevX || roundY !== prevY) {
                          context.moveTo(x, y);
                          prevX = roundX;
                          prevY = roundY;
                      }
                      for (d += 2; d < dd; d += 2) {
                          x = pixelCoordinates[d];
                          y = pixelCoordinates[d + 1];
                          roundX = (x + 0.5) | 0;
                          roundY = (y + 0.5) | 0;
                          if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
                              context.lineTo(x, y);
                              prevX = roundX;
                              prevY = roundY;
                          }
                      }
                      ++i;
                      break;
                  case Instruction.SET_FILL_STYLE:
                      lastFillInstruction = instruction;
                      this.alignFill_ = instruction[2];
                      if (pendingFill) {
                          this.fill_(context);
                          pendingFill = 0;
                          if (pendingStroke) {
                              context.stroke();
                              pendingStroke = 0;
                          }
                      }
                      context.fillStyle = /** @type {import("../../colorlike.js").ColorLike} */ (instruction[1]);
                      ++i;
                      break;
                  case Instruction.SET_STROKE_STYLE:
                      lastStrokeInstruction = instruction;
                      if (pendingStroke) {
                          context.stroke();
                          pendingStroke = 0;
                      }
                      this.setStrokeStyle_(context, /** @type {Array<*>} */ (instruction));
                      ++i;
                      break;
                  case Instruction.STROKE:
                      if (batchSize) {
                          pendingStroke++;
                      }
                      else {
                          context.stroke();
                      }
                      ++i;
                      break;
                  default:
                      ++i; // consume the instruction anyway, to avoid an infinite loop
                      break;
              }
          }
          if (pendingFill) {
              this.fill_(context);
          }
          if (pendingStroke) {
              context.stroke();
          }
          return undefined;
      };
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} contextScale Scale of the context.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
       */
      Executor.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel) {
          this.viewRotation_ = viewRotation;
          this.execute_(context, contextScale, transform, this.instructions, snapToPixel, undefined, undefined);
      };
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {function(import("../../Feature.js").FeatureLike): T=} opt_featureCallback
       *     Feature callback.
       * @param {import("../../extent.js").Extent=} opt_hitExtent Only check features that intersect this
       *     extent.
       * @return {T|undefined} Callback result.
       * @template T
       */
      Executor.prototype.executeHitDetection = function (context, transform, viewRotation, opt_featureCallback, opt_hitExtent) {
          this.viewRotation_ = viewRotation;
          return this.execute_(context, 1, transform, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);
      };
      return Executor;
  }());

  /**
   * @module ol/render/canvas/ExecutorGroup
   */
  /**
   * @const
   * @type {Array<import("./BuilderType.js").default>}
   */
  var ORDER = [
      ReplayType.POLYGON,
      ReplayType.CIRCLE,
      ReplayType.LINE_STRING,
      ReplayType.IMAGE,
      ReplayType.TEXT,
      ReplayType.DEFAULT,
  ];
  var ExecutorGroup = /** @class */ (function () {
      /**
       * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
       * `maxExtent` was set on the Buillder for this executor group, the same `maxExtent`
       * should be set here, unless the target context does not exceet that extent (which
       * can be the case when rendering to tiles).
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {boolean} overlaps The executor group can have overlapping geometries.
       * @param {!Object<string, !Object<import("./BuilderType.js").default, import("./Builder.js").SerializableInstructions>>} allInstructions
       * The serializable instructions.
       * @param {number=} opt_renderBuffer Optional rendering buffer.
       */
      function ExecutorGroup(maxExtent, resolution, pixelRatio, overlaps, allInstructions, opt_renderBuffer) {
          /**
           * @private
           * @type {import("../../extent.js").Extent}
           */
          this.maxExtent_ = maxExtent;
          /**
           * @private
           * @type {boolean}
           */
          this.overlaps_ = overlaps;
          /**
           * @private
           * @type {number}
           */
          this.pixelRatio_ = pixelRatio;
          /**
           * @private
           * @type {number}
           */
          this.resolution_ = resolution;
          /**
           * @private
           * @type {number|undefined}
           */
          this.renderBuffer_ = opt_renderBuffer;
          /**
           * @private
           * @type {!Object<string, !Object<import("./BuilderType.js").default, import("./Executor").default>>}
           */
          this.executorsByZIndex_ = {};
          /**
           * @private
           * @type {CanvasRenderingContext2D}
           */
          this.hitDetectionContext_ = null;
          /**
           * @private
           * @type {import("../../transform.js").Transform}
           */
          this.hitDetectionTransform_ = create();
          this.createExecutors_(allInstructions);
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../transform.js").Transform} transform Transform.
       */
      ExecutorGroup.prototype.clip = function (context, transform) {
          var flatClipCoords = this.getClipCoords(transform);
          context.beginPath();
          context.moveTo(flatClipCoords[0], flatClipCoords[1]);
          context.lineTo(flatClipCoords[2], flatClipCoords[3]);
          context.lineTo(flatClipCoords[4], flatClipCoords[5]);
          context.lineTo(flatClipCoords[6], flatClipCoords[7]);
          context.clip();
      };
      /**
       * Create executors and populate them using the provided instructions.
       * @private
       * @param {!Object<string, !Object<import("./BuilderType.js").default, import("./Builder.js").SerializableInstructions>>} allInstructions The serializable instructions
       */
      ExecutorGroup.prototype.createExecutors_ = function (allInstructions) {
          for (var zIndex in allInstructions) {
              var executors = this.executorsByZIndex_[zIndex];
              if (executors === undefined) {
                  executors = {};
                  this.executorsByZIndex_[zIndex] = executors;
              }
              var instructionByZindex = allInstructions[zIndex];
              var renderBuffer = [this.renderBuffer_ || 0, this.renderBuffer_ || 0];
              for (var builderType in instructionByZindex) {
                  var instructions = instructionByZindex[builderType];
                  executors[builderType] = new Executor(this.resolution_, this.pixelRatio_, this.overlaps_, instructions, renderBuffer);
              }
          }
      };
      /**
       * @param {Array<import("./BuilderType.js").default>} executors Executors.
       * @return {boolean} Has executors of the provided types.
       */
      ExecutorGroup.prototype.hasExecutors = function (executors) {
          for (var zIndex in this.executorsByZIndex_) {
              var candidates = this.executorsByZIndex_[zIndex];
              for (var i = 0, ii = executors.length; i < ii; ++i) {
                  if (executors[i] in candidates) {
                      return true;
                  }
              }
          }
          return false;
      };
      /**
       * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {number} resolution Resolution.
       * @param {number} rotation Rotation.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {function(import("../../Feature.js").FeatureLike): T} callback Feature callback.
       * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
       * @return {T|undefined} Callback result.
       * @template T
       */
      ExecutorGroup.prototype.forEachFeatureAtCoordinate = function (coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
          hitTolerance = Math.round(hitTolerance);
          var contextSize = hitTolerance * 2 + 1;
          var transform = compose(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);
          if (!this.hitDetectionContext_) {
              this.hitDetectionContext_ = createCanvasContext2D(contextSize, contextSize);
          }
          var context = this.hitDetectionContext_;
          if (context.canvas.width !== contextSize ||
              context.canvas.height !== contextSize) {
              context.canvas.width = contextSize;
              context.canvas.height = contextSize;
          }
          else {
              context.clearRect(0, 0, contextSize, contextSize);
          }
          /**
           * @type {import("../../extent.js").Extent}
           */
          var hitExtent;
          if (this.renderBuffer_ !== undefined) {
              hitExtent = createEmpty();
              extendCoordinate(hitExtent, coordinate);
              buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
          }
          var mask = getCircleArray(hitTolerance);
          var builderType;
          /**
           * @param {import("../../Feature.js").FeatureLike} feature Feature.
           * @return {?} Callback result.
           */
          function featureCallback(feature) {
              var imageData = context.getImageData(0, 0, contextSize, contextSize)
                  .data;
              for (var i_1 = 0; i_1 < contextSize; i_1++) {
                  for (var j_1 = 0; j_1 < contextSize; j_1++) {
                      if (mask[i_1][j_1]) {
                          if (imageData[(j_1 * contextSize + i_1) * 4 + 3] > 0) {
                              var result_1 = void 0;
                              if (!(declutteredFeatures &&
                                  (builderType == ReplayType.IMAGE ||
                                      builderType == ReplayType.TEXT)) ||
                                  declutteredFeatures.indexOf(feature) !== -1) {
                                  result_1 = callback(feature);
                              }
                              if (result_1) {
                                  return result_1;
                              }
                              else {
                                  context.clearRect(0, 0, contextSize, contextSize);
                                  return undefined;
                              }
                          }
                      }
                  }
              }
          }
          /** @type {Array<number>} */
          var zs = Object.keys(this.executorsByZIndex_).map(Number);
          zs.sort(numberSafeCompareFunction);
          var i, j, executors, executor, result;
          for (i = zs.length - 1; i >= 0; --i) {
              var zIndexKey = zs[i].toString();
              executors = this.executorsByZIndex_[zIndexKey];
              for (j = ORDER.length - 1; j >= 0; --j) {
                  builderType = ORDER[j];
                  executor = executors[builderType];
                  if (executor !== undefined) {
                      result = executor.executeHitDetection(context, transform, rotation, featureCallback, hitExtent);
                      if (result) {
                          return result;
                      }
                  }
              }
          }
          return undefined;
      };
      /**
       * @param {import("../../transform.js").Transform} transform Transform.
       * @return {Array<number>} Clip coordinates.
       */
      ExecutorGroup.prototype.getClipCoords = function (transform) {
          var maxExtent = this.maxExtent_;
          if (!maxExtent) {
              return null;
          }
          var minX = maxExtent[0];
          var minY = maxExtent[1];
          var maxX = maxExtent[2];
          var maxY = maxExtent[3];
          var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
          transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);
          return flatClipCoords;
      };
      /**
       * @return {boolean} Is empty.
       */
      ExecutorGroup.prototype.isEmpty = function () {
          return isEmpty$1(this.executorsByZIndex_);
      };
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} contextScale Scale of the context.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
       * @param {Array<import("./BuilderType.js").default>=} opt_builderTypes Ordered replay types to replay.
       *     Default is {@link module:ol/render/replay~ORDER}
       * @param {Object<string, import("../canvas.js").DeclutterGroup>=} opt_declutterReplays Declutter replays.
       */
      ExecutorGroup.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel, opt_builderTypes, opt_declutterReplays) {
          /** @type {Array<number>} */
          var zs = Object.keys(this.executorsByZIndex_).map(Number);
          zs.sort(numberSafeCompareFunction);
          // setup clipping so that the parts of over-simplified geometries are not
          // visible outside the current extent when panning
          if (this.maxExtent_) {
              context.save();
              this.clip(context, transform);
          }
          var builderTypes = opt_builderTypes ? opt_builderTypes : ORDER;
          var i, ii, j, jj, replays, replay;
          for (i = 0, ii = zs.length; i < ii; ++i) {
              var zIndexKey = zs[i].toString();
              replays = this.executorsByZIndex_[zIndexKey];
              for (j = 0, jj = builderTypes.length; j < jj; ++j) {
                  var builderType = builderTypes[j];
                  replay = replays[builderType];
                  if (replay !== undefined) {
                      if (opt_declutterReplays &&
                          (builderType == ReplayType.IMAGE ||
                              builderType == ReplayType.TEXT)) {
                          var declutter = opt_declutterReplays[zIndexKey];
                          if (!declutter) {
                              opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];
                          }
                          else {
                              declutter.push(replay, transform.slice(0));
                          }
                      }
                      else {
                          replay.execute(context, contextScale, transform, viewRotation, snapToPixel);
                      }
                  }
              }
          }
          if (this.maxExtent_) {
              context.restore();
          }
      };
      return ExecutorGroup;
  }());
  /**
   * This cache is used for storing calculated pixel circles for increasing performance.
   * It is a static property to allow each Replaygroup to access it.
   * @type {Object<number, Array<Array<(boolean|undefined)>>>}
   */
  var circleArrayCache = {
      0: [[true]],
  };
  /**
   * This method fills a row in the array from the given coordinate to the
   * middle with `true`.
   * @param {Array<Array<(boolean|undefined)>>} array The array that will be altered.
   * @param {number} x X coordinate.
   * @param {number} y Y coordinate.
   */
  function fillCircleArrayRowToMiddle(array, x, y) {
      var i;
      var radius = Math.floor(array.length / 2);
      if (x >= radius) {
          for (i = radius; i < x; i++) {
              array[i][y] = true;
          }
      }
      else if (x < radius) {
          for (i = x + 1; i < radius; i++) {
              array[i][y] = true;
          }
      }
  }
  /**
   * This methods creates a circle inside a fitting array. Points inside the
   * circle are marked by true, points on the outside are undefined.
   * It uses the midpoint circle algorithm.
   * A cache is used to increase performance.
   * @param {number} radius Radius.
   * @returns {Array<Array<(boolean|undefined)>>} An array with marked circle points.
   */
  function getCircleArray(radius) {
      if (circleArrayCache[radius] !== undefined) {
          return circleArrayCache[radius];
      }
      var arraySize = radius * 2 + 1;
      var arr = new Array(arraySize);
      for (var i = 0; i < arraySize; i++) {
          arr[i] = new Array(arraySize);
      }
      var x = radius;
      var y = 0;
      var error = 0;
      while (x >= y) {
          fillCircleArrayRowToMiddle(arr, radius + x, radius + y);
          fillCircleArrayRowToMiddle(arr, radius + y, radius + x);
          fillCircleArrayRowToMiddle(arr, radius - y, radius + x);
          fillCircleArrayRowToMiddle(arr, radius - x, radius + y);
          fillCircleArrayRowToMiddle(arr, radius - x, radius - y);
          fillCircleArrayRowToMiddle(arr, radius - y, radius - x);
          fillCircleArrayRowToMiddle(arr, radius + y, radius - x);
          fillCircleArrayRowToMiddle(arr, radius + x, radius - y);
          y++;
          error += 1 + 2 * y;
          if (2 * (error - x) + 1 > 0) {
              x -= 1;
              error += 1 - 2 * x;
          }
      }
      circleArrayCache[radius] = arr;
      return arr;
  }
  /**
   * @param {!Object<string, Array<*>>} declutterReplays Declutter replays.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} rotation Rotation.
   * @param {number} opacity Opacity.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {Array<import("../../PluggableMap.js").DeclutterItems>} declutterItems Declutter items.
   */
  function replayDeclutter(declutterReplays, context, rotation, opacity, snapToPixel, declutterItems) {
      var zs = Object.keys(declutterReplays)
          .map(Number)
          .sort(numberSafeCompareFunction);
      for (var z = 0, zz = zs.length; z < zz; ++z) {
          var executorData = declutterReplays[zs[z].toString()];
          var currentExecutor = void 0;
          for (var i = 0, ii = executorData.length; i < ii;) {
              var executor = executorData[i++];
              var transform = executorData[i++];
              executor.execute(context, 1, transform, rotation, snapToPixel);
              if (executor !== currentExecutor && executor.declutterItems.length > 0) {
                  currentExecutor = executor;
                  declutterItems.push({
                      items: executor.declutterItems,
                      opacity: opacity,
                  });
              }
          }
      }
  }

  /**
   * @module ol/style/IconAnchorUnits
   */
  /**
   * Icon anchor units. One of 'fraction', 'pixels'.
   * @enum {string}
   */
  var IconAnchorUnits = {
      /**
       * Anchor is a fraction
       * @api
       */
      FRACTION: 'fraction',
      /**
       * Anchor is in pixels
       * @api
       */
      PIXELS: 'pixels',
  };

  /**
   * @module ol/style/IconOrigin
   */
  /**
   * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.
   * @enum {string}
   */
  var IconOrigin = {
      /**
       * Origin is at bottom left
       * @api
       */
      BOTTOM_LEFT: 'bottom-left',
      /**
       * Origin is at bottom right
       * @api
       */
      BOTTOM_RIGHT: 'bottom-right',
      /**
       * Origin is at top left
       * @api
       */
      TOP_LEFT: 'top-left',
      /**
       * Origin is at top right
       * @api
       */
      TOP_RIGHT: 'top-right',
  };

  var __extends$Y = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @abstract
   */
  var ImageBase = /** @class */ (function (_super) {
      __extends$Y(ImageBase, _super);
      /**
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {number|undefined} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("./ImageState.js").default} state State.
       */
      function ImageBase(extent, resolution, pixelRatio, state) {
          var _this = _super.call(this) || this;
          /**
           * @protected
           * @type {import("./extent.js").Extent}
           */
          _this.extent = extent;
          /**
           * @private
           * @type {number}
           */
          _this.pixelRatio_ = pixelRatio;
          /**
           * @protected
           * @type {number|undefined}
           */
          _this.resolution = resolution;
          /**
           * @protected
           * @type {import("./ImageState.js").default}
           */
          _this.state = state;
          return _this;
      }
      /**
       * @protected
       */
      ImageBase.prototype.changed = function () {
          this.dispatchEvent(EventType.CHANGE);
      };
      /**
       * @return {import("./extent.js").Extent} Extent.
       */
      ImageBase.prototype.getExtent = function () {
          return this.extent;
      };
      /**
       * @abstract
       * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
       */
      ImageBase.prototype.getImage = function () {
          return abstract();
      };
      /**
       * @return {number} PixelRatio.
       */
      ImageBase.prototype.getPixelRatio = function () {
          return this.pixelRatio_;
      };
      /**
       * @return {number} Resolution.
       */
      ImageBase.prototype.getResolution = function () {
          return /** @type {number} */ (this.resolution);
      };
      /**
       * @return {import("./ImageState.js").default} State.
       */
      ImageBase.prototype.getState = function () {
          return this.state;
      };
      /**
       * Load not yet loaded URI.
       * @abstract
       */
      ImageBase.prototype.load = function () {
          abstract();
      };
      return ImageBase;
  }(Target));

  var __extends$Z = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * A function that takes an {@link module:ol/Image~Image} for the image and a
   * `{string}` for the src as arguments. It is supposed to make it so the
   * underlying image {@link module:ol/Image~Image#getImage} is assigned the
   * content specified by the src. If not specified, the default is
   *
   *     function(image, src) {
   *       image.getImage().src = src;
   *     }
   *
   * Providing a custom `imageLoadFunction` can be useful to load images with
   * post requests or - in general - through XHR requests, where the src of the
   * image element would be set to a data URI when the content is loaded.
   *
   * @typedef {function(ImageWrapper, string): void} LoadFunction
   * @api
   */
  var ImageWrapper = /** @class */ (function (_super) {
      __extends$Z(ImageWrapper, _super);
      /**
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {number|undefined} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {string} src Image source URI.
       * @param {?string} crossOrigin Cross origin.
       * @param {LoadFunction} imageLoadFunction Image load function.
       */
      function ImageWrapper(extent, resolution, pixelRatio, src, crossOrigin, imageLoadFunction) {
          var _this = _super.call(this, extent, resolution, pixelRatio, ImageState.IDLE) || this;
          /**
           * @private
           * @type {string}
           */
          _this.src_ = src;
          /**
           * @private
           * @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement}
           */
          _this.image_ = new Image();
          if (crossOrigin !== null) {
              _this.image_.crossOrigin = crossOrigin;
          }
          /**
           * @private
           * @type {?function():void}
           */
          _this.unlisten_ = null;
          /**
           * @protected
           * @type {import("./ImageState.js").default}
           */
          _this.state = ImageState.IDLE;
          /**
           * @private
           * @type {LoadFunction}
           */
          _this.imageLoadFunction_ = imageLoadFunction;
          return _this;
      }
      /**
       * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
       * @api
       */
      ImageWrapper.prototype.getImage = function () {
          return this.image_;
      };
      /**
       * Tracks loading or read errors.
       *
       * @private
       */
      ImageWrapper.prototype.handleImageError_ = function () {
          this.state = ImageState.ERROR;
          this.unlistenImage_();
          this.changed();
      };
      /**
       * Tracks successful image load.
       *
       * @private
       */
      ImageWrapper.prototype.handleImageLoad_ = function () {
          if (this.resolution === undefined) {
              this.resolution = getHeight(this.extent) / this.image_.height;
          }
          this.state = ImageState.LOADED;
          this.unlistenImage_();
          this.changed();
      };
      /**
       * Load the image or retry if loading previously failed.
       * Loading is taken care of by the tile queue, and calling this method is
       * only needed for preloading or for reloading in case of an error.
       * @api
       */
      ImageWrapper.prototype.load = function () {
          if (this.state == ImageState.IDLE || this.state == ImageState.ERROR) {
              this.state = ImageState.LOADING;
              this.changed();
              this.imageLoadFunction_(this, this.src_);
              this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
          }
      };
      /**
       * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
       */
      ImageWrapper.prototype.setImage = function (image) {
          this.image_ = image;
      };
      /**
       * Discards event handlers which listen for load completion or errors.
       *
       * @private
       */
      ImageWrapper.prototype.unlistenImage_ = function () {
          if (this.unlisten_) {
              this.unlisten_();
              this.unlisten_ = null;
          }
      };
      return ImageWrapper;
  }(ImageBase));
  /**
   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image element.
   * @param {function():any} loadHandler Load callback function.
   * @param {function():any} errorHandler Error callback function.
   * @return {function():void} Callback to stop listening.
   */
  function listenImage(image, loadHandler, errorHandler) {
      var img = /** @type {HTMLImageElement} */ (image);
      if (img.src && IMAGE_DECODE) {
          var promise = img.decode();
          var listening_1 = true;
          var unlisten = function () {
              listening_1 = false;
          };
          promise
              .then(function () {
              if (listening_1) {
                  loadHandler();
              }
          })
              .catch(function (error) {
              if (listening_1) {
                  // FIXME: Unconditionally call errorHandler() when this bug is fixed upstream:
                  //        https://bugs.webkit.org/show_bug.cgi?id=198527
                  if (error.name === 'EncodingError' &&
                      error.message === 'Invalid image type.') {
                      loadHandler();
                  }
                  else {
                      errorHandler();
                  }
              }
          });
          return unlisten;
      }
      var listenerKeys = [
          listenOnce(img, EventType.LOAD, loadHandler),
          listenOnce(img, EventType.ERROR, errorHandler),
      ];
      return function unlisten() {
          listenerKeys.forEach(unlistenByKey);
      };
  }

  /**
   * @module ol/style/IconImage
   */
  var __extends$_ = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @type {CanvasRenderingContext2D}
   */
  var taintedTestContext = null;
  var IconImage = /** @class */ (function (_super) {
      __extends$_(IconImage, _super);
      /**
       * @param {HTMLImageElement|HTMLCanvasElement} image Image.
       * @param {string|undefined} src Src.
       * @param {import("../size.js").Size} size Size.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../ImageState.js").default} imageState Image state.
       * @param {import("../color.js").Color} color Color.
       */
      function IconImage(image, src, size, crossOrigin, imageState, color) {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {HTMLImageElement|HTMLCanvasElement}
           */
          _this.hitDetectionImage_ = null;
          /**
           * @private
           * @type {HTMLImageElement|HTMLCanvasElement}
           */
          _this.image_ = !image ? new Image() : image;
          if (crossOrigin !== null) {
              /** @type {HTMLImageElement} */ (_this.image_).crossOrigin = crossOrigin;
          }
          /**
           * @private
           * @type {Object<number, HTMLCanvasElement>}
           */
          _this.canvas_ = {};
          /**
           * @private
           * @type {import("../color.js").Color}
           */
          _this.color_ = color;
          /**
           * @private
           * @type {?function():void}
           */
          _this.unlisten_ = null;
          /**
           * @private
           * @type {import("../ImageState.js").default}
           */
          _this.imageState_ = imageState;
          /**
           * @private
           * @type {import("../size.js").Size}
           */
          _this.size_ = size;
          /**
           * @private
           * @type {string|undefined}
           */
          _this.src_ = src;
          /**
           * @private
           */
          _this.tainted_;
          return _this;
      }
      /**
       * @private
       * @return {boolean} The image canvas is tainted.
       */
      IconImage.prototype.isTainted_ = function () {
          if (this.tainted_ === undefined && this.imageState_ === ImageState.LOADED) {
              if (!taintedTestContext) {
                  taintedTestContext = createCanvasContext2D(1, 1);
              }
              taintedTestContext.drawImage(this.image_, 0, 0);
              try {
                  taintedTestContext.getImageData(0, 0, 1, 1);
                  this.tainted_ = false;
              }
              catch (e) {
                  taintedTestContext = null;
                  this.tainted_ = true;
              }
          }
          return this.tainted_ === true;
      };
      /**
       * @private
       */
      IconImage.prototype.dispatchChangeEvent_ = function () {
          this.dispatchEvent(EventType.CHANGE);
      };
      /**
       * @private
       */
      IconImage.prototype.handleImageError_ = function () {
          this.imageState_ = ImageState.ERROR;
          this.unlistenImage_();
          this.dispatchChangeEvent_();
      };
      /**
       * @private
       */
      IconImage.prototype.handleImageLoad_ = function () {
          this.imageState_ = ImageState.LOADED;
          if (this.size_) {
              this.image_.width = this.size_[0];
              this.image_.height = this.size_[1];
          }
          else {
              this.size_ = [this.image_.width, this.image_.height];
          }
          this.unlistenImage_();
          this.dispatchChangeEvent_();
      };
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
       */
      IconImage.prototype.getImage = function (pixelRatio) {
          this.replaceColor_(pixelRatio);
          return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
      };
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Image or Canvas element.
       */
      IconImage.prototype.getPixelRatio = function (pixelRatio) {
          this.replaceColor_(pixelRatio);
          return this.canvas_[pixelRatio] ? pixelRatio : 1;
      };
      /**
       * @return {import("../ImageState.js").default} Image state.
       */
      IconImage.prototype.getImageState = function () {
          return this.imageState_;
      };
      /**
       * @return {HTMLImageElement|HTMLCanvasElement} Image element.
       */
      IconImage.prototype.getHitDetectionImage = function () {
          if (!this.hitDetectionImage_) {
              if (this.isTainted_()) {
                  var width = this.size_[0];
                  var height = this.size_[1];
                  var context = createCanvasContext2D(width, height);
                  context.fillRect(0, 0, width, height);
                  this.hitDetectionImage_ = context.canvas;
              }
              else {
                  this.hitDetectionImage_ = this.image_;
              }
          }
          return this.hitDetectionImage_;
      };
      /**
       * Get the size of the icon (in pixels).
       * @return {import("../size.js").Size} Image size.
       */
      IconImage.prototype.getSize = function () {
          return this.size_;
      };
      /**
       * @return {string|undefined} Image src.
       */
      IconImage.prototype.getSrc = function () {
          return this.src_;
      };
      /**
       * Load not yet loaded URI.
       */
      IconImage.prototype.load = function () {
          if (this.imageState_ == ImageState.IDLE) {
              this.imageState_ = ImageState.LOADING;
              try {
                  /** @type {HTMLImageElement} */ (this.image_).src = this.src_;
              }
              catch (e) {
                  this.handleImageError_();
              }
              this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
          }
      };
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @private
       */
      IconImage.prototype.replaceColor_ = function (pixelRatio) {
          if (!this.color_ || this.canvas_[pixelRatio]) {
              return;
          }
          var canvas = document.createElement('canvas');
          this.canvas_[pixelRatio] = canvas;
          canvas.width = Math.ceil(this.image_.width * pixelRatio);
          canvas.height = Math.ceil(this.image_.height * pixelRatio);
          var ctx = canvas.getContext('2d');
          ctx.scale(pixelRatio, pixelRatio);
          ctx.drawImage(this.image_, 0, 0);
          if (this.isTainted_()) {
              // If reading from the canvas throws a SecurityError the same effect can be
              // achieved with globalCompositeOperation.
              // This could be used as the default, but it is not fully supported by all
              // browsers. E. g. Internet Explorer 11 does not support the multiply
              // operation and the resulting image shape will be completelly filled with
              // the provided color.
              // So this is only used as a fallback. It is still better than having no icon
              // at all.
              var c = this.color_;
              ctx.globalCompositeOperation = 'multiply';
              ctx.fillStyle = 'rgb(' + c[0] + ',' + c[1] + ',' + c[2] + ')';
              ctx.fillRect(0, 0, canvas.width, canvas.height);
              ctx.globalCompositeOperation = 'destination-in';
              ctx.drawImage(this.image_, 0, 0);
              return;
          }
          var imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          var data = imgData.data;
          var r = this.color_[0] / 255.0;
          var g = this.color_[1] / 255.0;
          var b = this.color_[2] / 255.0;
          for (var i = 0, ii = data.length; i < ii; i += 4) {
              data[i] *= r;
              data[i + 1] *= g;
              data[i + 2] *= b;
          }
          ctx.putImageData(imgData, 0, 0);
      };
      /**
       * Discards event handlers which listen for load completion or errors.
       *
       * @private
       */
      IconImage.prototype.unlistenImage_ = function () {
          if (this.unlisten_) {
              this.unlisten_();
              this.unlisten_ = null;
          }
      };
      return IconImage;
  }(Target));
  /**
   * @param {HTMLImageElement|HTMLCanvasElement} image Image.
   * @param {string} src Src.
   * @param {import("../size.js").Size} size Size.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../ImageState.js").default} imageState Image state.
   * @param {import("../color.js").Color} color Color.
   * @return {IconImage} Icon image.
   */
  function get$3(image, src, size, crossOrigin, imageState, color) {
      var iconImage = shared.get(src, crossOrigin, color);
      if (!iconImage) {
          iconImage = new IconImage(image, src, size, crossOrigin, imageState, color);
          shared.set(src, crossOrigin, color, iconImage);
      }
      return iconImage;
  }

  var __extends$$ = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {Array<number>} [anchor=[0.5, 0.5]] Anchor. Default value is the icon center.
   * @property {import("./IconOrigin.js").default} [anchorOrigin='top-left'] Origin of the anchor: `bottom-left`, `bottom-right`,
   * `top-left` or `top-right`.
   * @property {import("./IconAnchorUnits.js").default} [anchorXUnits='fraction'] Units in which the anchor x value is
   * specified. A value of `'fraction'` indicates the x value is a fraction of the icon. A value of `'pixels'` indicates
   * the x value in pixels.
   * @property {import("./IconAnchorUnits.js").default} [anchorYUnits='fraction'] Units in which the anchor y value is
   * specified. A value of `'fraction'` indicates the y value is a fraction of the icon. A value of `'pixels'` indicates
   * the y value in pixels.
   * @property {import("../color.js").Color|string} [color] Color to tint the icon. If not specified,
   * the icon will be left as is.
   * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images. Note that you must provide a
   * `crossOrigin` value if you want to access pixel data with the Canvas renderer.
   * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
   * @property {HTMLImageElement|HTMLCanvasElement} [img] Image object for the icon. If the `src` option is not provided then the
   * provided image must already be loaded. And in that case, it is required
   * to provide the size of the image, with the `imgSize` option.
   * @property {Array<number>} [offset=[0, 0]] Offset, which, together with the size and the offset origin, define the
   * sub-rectangle to use from the original icon image.
   * @property {Array<number>} [displacement=[0,0]] Displacement the icon
   * @property {import("./IconOrigin.js").default} [offsetOrigin='top-left'] Origin of the offset: `bottom-left`, `bottom-right`,
   * `top-left` or `top-right`.
   * @property {number} [opacity=1] Opacity of the icon.
   * @property {number|import("../size.js").Size} [scale=1] Scale.
   * @property {boolean} [rotateWithView=false] Whether to rotate the icon with the view.
   * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
   * @property {import("../size.js").Size} [size] Icon size in pixel. Can be used together with `offset` to define the
   * sub-rectangle to use from the origin (sprite) icon image.
   * @property {import("../size.js").Size} [imgSize] Image size in pixels. Only required if `img` is set and `src` is not, and
   * for SVG images in Internet Explorer 11. The provided `imgSize` needs to match the actual size of the image.
   * @property {string} [src] Image source URI.
   */
  /**
   * @classdesc
   * Set icon style for vector features.
   * @api
   */
  var Icon = /** @class */ (function (_super) {
      __extends$$(Icon, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function Icon(opt_options) {
          var _this = this;
          var options = opt_options || {};
          /**
           * @type {number}
           */
          var opacity = options.opacity !== undefined ? options.opacity : 1;
          /**
           * @type {number}
           */
          var rotation = options.rotation !== undefined ? options.rotation : 0;
          /**
           * @type {number|import("../size.js").Size}
           */
          var scale = options.scale !== undefined ? options.scale : 1;
          /**
           * @type {boolean}
           */
          var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
          _this = _super.call(this, {
              opacity: opacity,
              rotation: rotation,
              scale: scale,
              displacement: options.displacement !== undefined ? options.displacement : [0, 0],
              rotateWithView: rotateWithView,
          }) || this;
          /**
           * @private
           * @type {Array<number>}
           */
          _this.anchor_ = options.anchor !== undefined ? options.anchor : [0.5, 0.5];
          /**
           * @private
           * @type {Array<number>}
           */
          _this.normalizedAnchor_ = null;
          /**
           * @private
           * @type {import("./IconOrigin.js").default}
           */
          _this.anchorOrigin_ =
              options.anchorOrigin !== undefined
                  ? options.anchorOrigin
                  : IconOrigin.TOP_LEFT;
          /**
           * @private
           * @type {import("./IconAnchorUnits.js").default}
           */
          _this.anchorXUnits_ =
              options.anchorXUnits !== undefined
                  ? options.anchorXUnits
                  : IconAnchorUnits.FRACTION;
          /**
           * @private
           * @type {import("./IconAnchorUnits.js").default}
           */
          _this.anchorYUnits_ =
              options.anchorYUnits !== undefined
                  ? options.anchorYUnits
                  : IconAnchorUnits.FRACTION;
          /**
           * @private
           * @type {?string}
           */
          _this.crossOrigin_ =
              options.crossOrigin !== undefined ? options.crossOrigin : null;
          /**
           * @type {HTMLImageElement|HTMLCanvasElement}
           */
          var image = options.img !== undefined ? options.img : null;
          /**
           * @type {import("../size.js").Size}
           */
          var imgSize = options.imgSize !== undefined ? options.imgSize : null;
          /**
           * @type {string|undefined}
           */
          var src = options.src;
          assert(!(src !== undefined && image), 4); // `image` and `src` cannot be provided at the same time
          assert(!image || (image && imgSize), 5); // `imgSize` must be set when `image` is provided
          if ((src === undefined || src.length === 0) && image) {
              src = /** @type {HTMLImageElement} */ (image).src || getUid(image);
          }
          assert(src !== undefined && src.length > 0, 6); // A defined and non-empty `src` or `image` must be provided
          /**
           * @type {import("../ImageState.js").default}
           */
          var imageState = options.src !== undefined ? ImageState.IDLE : ImageState.LOADED;
          /**
           * @private
           * @type {import("../color.js").Color}
           */
          _this.color_ = options.color !== undefined ? asArray(options.color) : null;
          /**
           * @private
           * @type {import("./IconImage.js").default}
           */
          _this.iconImage_ = get$3(image, 
          /** @type {string} */ (src), imgSize, _this.crossOrigin_, imageState, _this.color_);
          /**
           * @private
           * @type {Array<number>}
           */
          _this.offset_ = options.offset !== undefined ? options.offset : [0, 0];
          /**
           * @private
           * @type {import("./IconOrigin.js").default}
           */
          _this.offsetOrigin_ =
              options.offsetOrigin !== undefined
                  ? options.offsetOrigin
                  : IconOrigin.TOP_LEFT;
          /**
           * @private
           * @type {Array<number>}
           */
          _this.origin_ = null;
          /**
           * @private
           * @type {import("../size.js").Size}
           */
          _this.size_ = options.size !== undefined ? options.size : null;
          return _this;
      }
      /**
       * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
       * @return {Icon} The cloned style.
       * @api
       */
      Icon.prototype.clone = function () {
          var scale = this.getScale();
          return new Icon({
              anchor: this.anchor_.slice(),
              anchorOrigin: this.anchorOrigin_,
              anchorXUnits: this.anchorXUnits_,
              anchorYUnits: this.anchorYUnits_,
              crossOrigin: this.crossOrigin_,
              color: this.color_ && this.color_.slice
                  ? this.color_.slice()
                  : this.color_ || undefined,
              src: this.getSrc(),
              offset: this.offset_.slice(),
              offsetOrigin: this.offsetOrigin_,
              size: this.size_ !== null ? this.size_.slice() : undefined,
              opacity: this.getOpacity(),
              scale: Array.isArray(scale) ? scale.slice() : scale,
              rotation: this.getRotation(),
              rotateWithView: this.getRotateWithView(),
          });
      };
      /**
       * Get the anchor point in pixels. The anchor determines the center point for the
       * symbolizer.
       * @return {Array<number>} Anchor.
       * @api
       */
      Icon.prototype.getAnchor = function () {
          if (this.normalizedAnchor_) {
              return this.normalizedAnchor_;
          }
          var anchor = this.anchor_;
          var size = this.getSize();
          if (this.anchorXUnits_ == IconAnchorUnits.FRACTION ||
              this.anchorYUnits_ == IconAnchorUnits.FRACTION) {
              if (!size) {
                  return null;
              }
              anchor = this.anchor_.slice();
              if (this.anchorXUnits_ == IconAnchorUnits.FRACTION) {
                  anchor[0] *= size[0];
              }
              if (this.anchorYUnits_ == IconAnchorUnits.FRACTION) {
                  anchor[1] *= size[1];
              }
          }
          if (this.anchorOrigin_ != IconOrigin.TOP_LEFT) {
              if (!size) {
                  return null;
              }
              if (anchor === this.anchor_) {
                  anchor = this.anchor_.slice();
              }
              if (this.anchorOrigin_ == IconOrigin.TOP_RIGHT ||
                  this.anchorOrigin_ == IconOrigin.BOTTOM_RIGHT) {
                  anchor[0] = -anchor[0] + size[0];
              }
              if (this.anchorOrigin_ == IconOrigin.BOTTOM_LEFT ||
                  this.anchorOrigin_ == IconOrigin.BOTTOM_RIGHT) {
                  anchor[1] = -anchor[1] + size[1];
              }
          }
          this.normalizedAnchor_ = anchor;
          return this.normalizedAnchor_;
      };
      /**
       * Set the anchor point. The anchor determines the center point for the
       * symbolizer.
       *
       * @param {Array<number>} anchor Anchor.
       * @api
       */
      Icon.prototype.setAnchor = function (anchor) {
          this.anchor_ = anchor;
          this.normalizedAnchor_ = null;
      };
      /**
       * Get the icon color.
       * @return {import("../color.js").Color} Color.
       * @api
       */
      Icon.prototype.getColor = function () {
          return this.color_;
      };
      /**
       * Get the image icon.
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
       * @api
       */
      Icon.prototype.getImage = function (pixelRatio) {
          return this.iconImage_.getImage(pixelRatio);
      };
      /**
       * Get the pixel ratio.
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} The pixel ration of the image.
       * @api
       */
      Icon.prototype.getPixelRatio = function (pixelRatio) {
          return this.iconImage_.getPixelRatio(pixelRatio);
      };
      /**
       * @return {import("../size.js").Size} Image size.
       */
      Icon.prototype.getImageSize = function () {
          return this.iconImage_.getSize();
      };
      /**
       * @return {import("../size.js").Size} Size of the hit-detection image.
       */
      Icon.prototype.getHitDetectionImageSize = function () {
          return this.getImageSize();
      };
      /**
       * @return {import("../ImageState.js").default} Image state.
       */
      Icon.prototype.getImageState = function () {
          return this.iconImage_.getImageState();
      };
      /**
       * @return {HTMLImageElement|HTMLCanvasElement} Image element.
       */
      Icon.prototype.getHitDetectionImage = function () {
          return this.iconImage_.getHitDetectionImage();
      };
      /**
       * Get the origin of the symbolizer.
       * @return {Array<number>} Origin.
       * @api
       */
      Icon.prototype.getOrigin = function () {
          if (this.origin_) {
              return this.origin_;
          }
          var offset = this.offset_;
          var displacement = this.getDisplacement();
          if (this.offsetOrigin_ != IconOrigin.TOP_LEFT) {
              var size = this.getSize();
              var iconImageSize = this.iconImage_.getSize();
              if (!size || !iconImageSize) {
                  return null;
              }
              offset = offset.slice();
              if (this.offsetOrigin_ == IconOrigin.TOP_RIGHT ||
                  this.offsetOrigin_ == IconOrigin.BOTTOM_RIGHT) {
                  offset[0] = iconImageSize[0] - size[0] - offset[0];
              }
              if (this.offsetOrigin_ == IconOrigin.BOTTOM_LEFT ||
                  this.offsetOrigin_ == IconOrigin.BOTTOM_RIGHT) {
                  offset[1] = iconImageSize[1] - size[1] - offset[1];
              }
          }
          offset[0] += displacement[0];
          offset[1] += displacement[1];
          this.origin_ = offset;
          return this.origin_;
      };
      /**
       * Get the image URL.
       * @return {string|undefined} Image src.
       * @api
       */
      Icon.prototype.getSrc = function () {
          return this.iconImage_.getSrc();
      };
      /**
       * Get the size of the icon (in pixels).
       * @return {import("../size.js").Size} Image size.
       * @api
       */
      Icon.prototype.getSize = function () {
          return !this.size_ ? this.iconImage_.getSize() : this.size_;
      };
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      Icon.prototype.listenImageChange = function (listener) {
          this.iconImage_.addEventListener(EventType.CHANGE, listener);
      };
      /**
       * Load not yet loaded URI.
       * When rendering a feature with an icon style, the vector renderer will
       * automatically call this method. However, you might want to call this
       * method yourself for preloading or other purposes.
       * @api
       */
      Icon.prototype.load = function () {
          this.iconImage_.load();
      };
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      Icon.prototype.unlistenImageChange = function (listener) {
          this.iconImage_.removeEventListener(EventType.CHANGE, listener);
      };
      return Icon;
  }(ImageStyle));

  /**
   * @module ol/render/canvas/hitdetet
   */
  /**
   * @param {import("../../size.js").Size} size Canvas size in css pixels.
   * @param {Array<import("../../transform.js").Transform>} transforms Transforms
   * for rendering features to all worlds of the viewport, from coordinates to css
   * pixels.
   * @param {Array<import("../../Feature.js").FeatureLike>} features
   * Features to consider for hit detection.
   * @param {import("../../style/Style.js").StyleFunction|undefined} styleFunction
   * Layer style function.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @return {ImageData} Hit detection image data.
   */
  function createHitDetectionImageData(size, transforms, features, styleFunction, extent, resolution, rotation) {
      var width = size[0] / 2;
      var height = size[1] / 2;
      var context = createCanvasContext2D(width, height);
      context.imageSmoothingEnabled = false;
      var canvas = context.canvas;
      var renderer = new CanvasImmediateRenderer(context, 0.5, extent, null, rotation);
      var featureCount = features.length;
      // Stretch hit detection index to use the whole available color range
      var indexFactor = Math.floor((256 * 256 * 256 - 1) / featureCount);
      var featuresByZIndex = {};
      for (var i = 1; i <= featureCount; ++i) {
          var feature = features[i - 1];
          var featureStyleFunction = feature.getStyleFunction() || styleFunction;
          if (!styleFunction) {
              continue;
          }
          var styles = featureStyleFunction(feature, resolution);
          if (!styles) {
              continue;
          }
          if (!Array.isArray(styles)) {
              styles = [styles];
          }
          var index = i * indexFactor;
          var color = '#' + ('000000' + index.toString(16)).slice(-6);
          for (var j = 0, jj = styles.length; j < jj; ++j) {
              var originalStyle = styles[j];
              var style = originalStyle.clone();
              var fill = style.getFill();
              if (fill) {
                  fill.setColor(color);
              }
              var stroke = style.getStroke();
              if (stroke) {
                  stroke.setColor(color);
              }
              style.setText(undefined);
              var image = originalStyle.getImage();
              if (image) {
                  var imgSize = image.getImageSize();
                  if (!imgSize) {
                      continue;
                  }
                  var canvas_1 = document.createElement('canvas');
                  canvas_1.width = imgSize[0];
                  canvas_1.height = imgSize[1];
                  var imgContext = canvas_1.getContext('2d', { alpha: false });
                  imgContext.fillStyle = color;
                  var img = imgContext.canvas;
                  imgContext.fillRect(0, 0, img.width, img.height);
                  var width_1 = imgSize ? imgSize[0] : img.width;
                  var height_1 = imgSize ? imgSize[1] : img.height;
                  var iconContext = createCanvasContext2D(width_1, height_1);
                  iconContext.drawImage(img, 0, 0);
                  style.setImage(new Icon({
                      img: img,
                      imgSize: imgSize,
                      anchor: image.getAnchor(),
                      anchorXUnits: IconAnchorUnits.PIXELS,
                      anchorYUnits: IconAnchorUnits.PIXELS,
                      offset: image.getOrigin(),
                      size: image.getSize(),
                      opacity: image.getOpacity(),
                      scale: image.getScale(),
                      rotation: image.getRotation(),
                      rotateWithView: image.getRotateWithView(),
                  }));
              }
              var zIndex = Number(style.getZIndex());
              var byGeometryType = featuresByZIndex[zIndex];
              if (!byGeometryType) {
                  byGeometryType = {};
                  featuresByZIndex[zIndex] = byGeometryType;
                  byGeometryType[GeometryType.POLYGON] = [];
                  byGeometryType[GeometryType.CIRCLE] = [];
                  byGeometryType[GeometryType.LINE_STRING] = [];
                  byGeometryType[GeometryType.POINT] = [];
              }
              var geometry = style.getGeometryFunction()(feature);
              if (geometry && intersects(extent, geometry.getExtent())) {
                  byGeometryType[geometry.getType().replace('Multi', '')].push(geometry, style);
              }
          }
      }
      var zIndexKeys = Object.keys(featuresByZIndex)
          .map(Number)
          .sort(numberSafeCompareFunction);
      for (var i = 0, ii = zIndexKeys.length; i < ii; ++i) {
          var byGeometryType = featuresByZIndex[zIndexKeys[i]];
          for (var type in byGeometryType) {
              var geomAndStyle = byGeometryType[type];
              for (var j = 0, jj = geomAndStyle.length; j < jj; j += 2) {
                  renderer.setStyle(geomAndStyle[j + 1]);
                  for (var k = 0, kk = transforms.length; k < kk; ++k) {
                      renderer.setTransform(transforms[k]);
                      renderer.drawGeometry(geomAndStyle[j]);
                  }
              }
          }
      }
      return context.getImageData(0, 0, canvas.width, canvas.height);
  }
  /**
   * @param {import("../../pixel").Pixel} pixel Pixel coordinate on the hit
   * detection canvas in css pixels.
   * @param {Array<import("../../Feature").FeatureLike>} features Features. Has to
   * match the `features` array that was passed to `createHitDetectionImageData()`.
   * @param {ImageData} imageData Hit detection image data generated by
   * `createHitDetectionImageData()`.
   * @return {Array<import("../../Feature").FeatureLike>} features Features.
   */
  function hitDetect(pixel, features, imageData) {
      var resultFeatures = [];
      if (imageData) {
          var index = (Math.round(pixel[0] / 2) + Math.round(pixel[1] / 2) * imageData.width) *
              4;
          var r = imageData.data[index];
          var g = imageData.data[index + 1];
          var b = imageData.data[index + 2];
          var i = b + 256 * (g + 256 * r);
          var indexFactor = Math.floor((256 * 256 * 256 - 1) / features.length);
          if (i && i % indexFactor === 0) {
              resultFeatures.push(features[i / indexFactor - 1]);
          }
      }
      return resultFeatures;
  }

  var __extends$10 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Canvas renderer for vector layers.
   * @api
   */
  var CanvasVectorLayerRenderer = /** @class */ (function (_super) {
      __extends$10(CanvasVectorLayerRenderer, _super);
      /**
       * @param {import("../../layer/Vector.js").default} vectorLayer Vector layer.
       */
      function CanvasVectorLayerRenderer(vectorLayer) {
          var _this = _super.call(this, vectorLayer) || this;
          /** @private */
          _this.boundHandleStyleImageChange_ = _this.handleStyleImageChange_.bind(_this);
          /**
           * @type {boolean}
           */
          _this.animatingOrInteracting_;
          /**
           * @private
           * @type {boolean}
           */
          _this.dirty_ = false;
          /**
           * @type {ImageData}
           */
          _this.hitDetectionImageData_ = null;
          /**
           * @type {Array<import("../../Feature.js").default>}
           */
          _this.renderedFeatures_ = null;
          /**
           * @private
           * @type {number}
           */
          _this.renderedRevision_ = -1;
          /**
           * @private
           * @type {number}
           */
          _this.renderedResolution_ = NaN;
          /**
           * @private
           * @type {import("../../extent.js").Extent}
           */
          _this.renderedExtent_ = createEmpty();
          /**
           * @private
           * @type {number}
           */
          _this.renderedRotation_;
          /**
           * @private
           * @type {import("../../coordinate").Coordinate}
           */
          _this.renderedCenter_ = null;
          /**
           * @private
           * @type {import("../../proj/Projection").default}
           */
          _this.renderedProjection_ = null;
          /**
           * @private
           * @type {function(import("../../Feature.js").default, import("../../Feature.js").default): number|null}
           */
          _this.renderedRenderOrder_ = null;
          /**
           * @private
           * @type {import("../../render/canvas/ExecutorGroup").default}
           */
          _this.replayGroup_ = null;
          /**
           * A new replay group had to be created by `prepareFrame()`
           * @type {boolean}
           */
          _this.replayGroupChanged = true;
          /**
           * Clipping to be performed by `renderFrame()`
           * @type {boolean}
           */
          _this.clipping = true;
          return _this;
      }
      /**
       * Get a rendering container from an existing target, if compatible.
       * @param {HTMLElement} target Potential render target.
       * @param {string} transform CSS Transform.
       * @param {number} opacity Opacity.
       */
      CanvasVectorLayerRenderer.prototype.useContainer = function (target, transform, opacity) {
          if (opacity < 1) {
              target = null;
          }
          _super.prototype.useContainer.call(this, target, transform, opacity);
      };
      /**
       * Render the layer.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target that may be used to render content to.
       * @return {HTMLElement} The rendered element.
       */
      CanvasVectorLayerRenderer.prototype.renderFrame = function (frameState, target) {
          var pixelRatio = frameState.pixelRatio;
          var layerState = frameState.layerStatesArray[frameState.layerIndex];
          // set forward and inverse pixel transforms
          makeScale(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);
          makeInverse(this.inversePixelTransform, this.pixelTransform);
          var canvasTransform = toString(this.pixelTransform);
          this.useContainer(target, canvasTransform, layerState.opacity);
          var context = this.context;
          var canvas = context.canvas;
          var replayGroup = this.replayGroup_;
          if (!replayGroup || replayGroup.isEmpty()) {
              if (!this.containerReused && canvas.width > 0) {
                  canvas.width = 0;
              }
              return this.container;
          }
          // resize and clear
          var width = Math.round(frameState.size[0] * pixelRatio);
          var height = Math.round(frameState.size[1] * pixelRatio);
          if (canvas.width != width || canvas.height != height) {
              canvas.width = width;
              canvas.height = height;
              if (canvas.style.transform !== canvasTransform) {
                  canvas.style.transform = canvasTransform;
              }
          }
          else if (!this.containerReused) {
              context.clearRect(0, 0, width, height);
          }
          this.preRender(context, frameState);
          var extent = frameState.extent;
          var viewState = frameState.viewState;
          var center = viewState.center;
          var resolution = viewState.resolution;
          var projection = viewState.projection;
          var rotation = viewState.rotation;
          var projectionExtent = projection.getExtent();
          var vectorSource = this.getLayer().getSource();
          // clipped rendering if layer extent is set
          var clipped = false;
          if (layerState.extent && this.clipping) {
              var layerExtent = fromUserExtent(layerState.extent);
              clipped =
                  !containsExtent(layerExtent, frameState.extent) &&
                      intersects(layerExtent, frameState.extent);
              if (clipped) {
                  this.clipUnrotated(context, frameState, layerExtent);
              }
          }
          var viewHints = frameState.viewHints;
          var snapToPixel = !(viewHints[ViewHint.ANIMATING] || viewHints[ViewHint.INTERACTING]);
          var transform = this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, 0);
          var declutterReplays = this.getLayer().getDeclutter() ? {} : null;
          replayGroup.execute(context, 1, transform, rotation, snapToPixel, undefined, declutterReplays);
          if (vectorSource.getWrapX() &&
              projection.canWrapX() &&
              !containsExtent(projectionExtent, extent)) {
              var startX = extent[0];
              var worldWidth = getWidth(projectionExtent);
              var world = 0;
              var offsetX = void 0;
              while (startX < projectionExtent[0]) {
                  --world;
                  offsetX = worldWidth * world;
                  var transform_1 = this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX);
                  replayGroup.execute(context, 1, transform_1, rotation, snapToPixel, undefined, declutterReplays);
                  startX += worldWidth;
              }
              world = 0;
              startX = extent[2];
              while (startX > projectionExtent[2]) {
                  ++world;
                  offsetX = worldWidth * world;
                  var transform_2 = this.getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX);
                  replayGroup.execute(context, 1, transform_2, rotation, snapToPixel, undefined, declutterReplays);
                  startX -= worldWidth;
              }
          }
          if (declutterReplays) {
              var viewHints_1 = frameState.viewHints;
              var hifi = !(viewHints_1[ViewHint.ANIMATING] || viewHints_1[ViewHint.INTERACTING]);
              replayDeclutter(declutterReplays, context, rotation, 1, hifi, frameState.declutterItems);
          }
          if (clipped) {
              context.restore();
          }
          this.postRender(context, frameState);
          var opacity = layerState.opacity;
          var container = this.container;
          if (opacity !== parseFloat(container.style.opacity)) {
              container.style.opacity = opacity === 1 ? '' : String(opacity);
          }
          if (this.renderedRotation_ !== viewState.rotation) {
              this.renderedRotation_ = viewState.rotation;
              this.hitDetectionImageData_ = null;
          }
          return this.container;
      };
      /**
       * Asynchronous layer level hit detection.
       * @param {import("../../pixel.js").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../../Feature").default>>} Promise that resolves with an array of features.
       */
      CanvasVectorLayerRenderer.prototype.getFeatures = function (pixel) {
          return new Promise(function (resolve, reject) {
              if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
                  var size = [this.context.canvas.width, this.context.canvas.height];
                  apply(this.pixelTransform, size);
                  var center = this.renderedCenter_;
                  var resolution = this.renderedResolution_;
                  var rotation = this.renderedRotation_;
                  var projection = this.renderedProjection_;
                  var extent = this.renderedExtent_;
                  var layer = this.getLayer();
                  var transforms = [];
                  var width = size[0] / 2;
                  var height = size[1] / 2;
                  transforms.push(this.getRenderTransform(center, resolution, rotation, 0.5, width, height, 0).slice());
                  var source = layer.getSource();
                  var projectionExtent = projection.getExtent();
                  if (source.getWrapX() &&
                      projection.canWrapX() &&
                      !containsExtent(projectionExtent, extent)) {
                      var startX = extent[0];
                      var worldWidth = getWidth(projectionExtent);
                      var world = 0;
                      var offsetX = void 0;
                      while (startX < projectionExtent[0]) {
                          --world;
                          offsetX = worldWidth * world;
                          transforms.push(this.getRenderTransform(center, resolution, rotation, 0.5, width, height, offsetX).slice());
                          startX += worldWidth;
                      }
                      world = 0;
                      startX = extent[2];
                      while (startX > projectionExtent[2]) {
                          ++world;
                          offsetX = worldWidth * world;
                          transforms.push(this.getRenderTransform(center, resolution, rotation, 0.5, width, height, offsetX).slice());
                          startX -= worldWidth;
                      }
                  }
                  this.hitDetectionImageData_ = createHitDetectionImageData(size, transforms, this.renderedFeatures_, layer.getStyleFunction(), extent, resolution, rotation);
              }
              resolve(hitDetect(pixel, this.renderedFeatures_, this.hitDetectionImageData_));
          }.bind(this));
      };
      /**
       * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {function(import("../../Feature.js").FeatureLike, import("../../layer/Layer.js").default): T} callback Feature callback.
       * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
       * @return {T|void} Callback result.
       * @template T
       */
      CanvasVectorLayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, declutteredFeatures) {
          if (!this.replayGroup_) {
              return undefined;
          }
          else {
              var resolution = frameState.viewState.resolution;
              var rotation = frameState.viewState.rotation;
              var layer_1 = this.getLayer();
              /** @type {!Object<string, boolean>} */
              var features_1 = {};
              var result = this.replayGroup_.forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, 
              /**
               * @param {import("../../Feature.js").FeatureLike} feature Feature.
               * @return {?} Callback result.
               */
              function (feature) {
                  var key = getUid(feature);
                  if (!(key in features_1)) {
                      features_1[key] = true;
                      return callback(feature, layer_1);
                  }
              }, layer_1.getDeclutter() ? declutteredFeatures : null);
              return result;
          }
      };
      /**
       * Perform action necessary to get the layer rendered after new fonts have loaded
       */
      CanvasVectorLayerRenderer.prototype.handleFontsChanged = function () {
          var layer = this.getLayer();
          if (layer.getVisible() && this.replayGroup_) {
              layer.changed();
          }
      };
      /**
       * Handle changes in image style state.
       * @param {import("../../events/Event.js").default} event Image style change event.
       * @private
       */
      CanvasVectorLayerRenderer.prototype.handleStyleImageChange_ = function (event) {
          this.renderIfReadyAndVisible();
      };
      /**
       * Determine whether render should be called.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @return {boolean} Layer is ready to be rendered.
       */
      CanvasVectorLayerRenderer.prototype.prepareFrame = function (frameState) {
          var vectorLayer = this.getLayer();
          var vectorSource = vectorLayer.getSource();
          if (!vectorSource) {
              return false;
          }
          var animating = frameState.viewHints[ViewHint.ANIMATING];
          var interacting = frameState.viewHints[ViewHint.INTERACTING];
          var updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
          var updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();
          if ((!this.dirty_ && !updateWhileAnimating && animating) ||
              (!updateWhileInteracting && interacting)) {
              this.animatingOrInteracting_ = true;
              return true;
          }
          this.animatingOrInteracting_ = false;
          var frameStateExtent = frameState.extent;
          var viewState = frameState.viewState;
          var projection = viewState.projection;
          var resolution = viewState.resolution;
          var pixelRatio = frameState.pixelRatio;
          var vectorLayerRevision = vectorLayer.getRevision();
          var vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
          var vectorLayerRenderOrder = vectorLayer.getRenderOrder();
          if (vectorLayerRenderOrder === undefined) {
              vectorLayerRenderOrder = defaultOrder;
          }
          var center = viewState.center.slice();
          var extent = buffer(frameStateExtent, vectorLayerRenderBuffer * resolution);
          var loadExtents = [extent.slice()];
          var projectionExtent = projection.getExtent();
          if (vectorSource.getWrapX() &&
              projection.canWrapX() &&
              !containsExtent(projectionExtent, frameState.extent)) {
              // For the replay group, we need an extent that intersects the real world
              // (-180° to +180°). To support geometries in a coordinate range from -540°
              // to +540°, we add at least 1 world width on each side of the projection
              // extent. If the viewport is wider than the world, we need to add half of
              // the viewport width to make sure we cover the whole viewport.
              var worldWidth = getWidth(projectionExtent);
              var gutter = Math.max(getWidth(extent) / 2, worldWidth);
              extent[0] = projectionExtent[0] - gutter;
              extent[2] = projectionExtent[2] + gutter;
              wrapX$1(center, projection);
              var loadExtent = wrapX(loadExtents[0], projection);
              // If the extent crosses the date line, we load data for both edges of the worlds
              if (loadExtent[0] < projectionExtent[0] &&
                  loadExtent[2] < projectionExtent[2]) {
                  loadExtents.push([
                      loadExtent[0] + worldWidth,
                      loadExtent[1],
                      loadExtent[2] + worldWidth,
                      loadExtent[3],
                  ]);
              }
              else if (loadExtent[0] > projectionExtent[0] &&
                  loadExtent[2] > projectionExtent[2]) {
                  loadExtents.push([
                      loadExtent[0] - worldWidth,
                      loadExtent[1],
                      loadExtent[2] - worldWidth,
                      loadExtent[3],
                  ]);
              }
          }
          if (!this.dirty_ &&
              this.renderedResolution_ == resolution &&
              this.renderedRevision_ == vectorLayerRevision &&
              this.renderedRenderOrder_ == vectorLayerRenderOrder &&
              containsExtent(this.renderedExtent_, extent)) {
              this.replayGroupChanged = false;
              return true;
          }
          this.replayGroup_ = null;
          this.dirty_ = false;
          var replayGroup = new BuilderGroup(getTolerance(resolution, pixelRatio), extent, resolution, pixelRatio, vectorLayer.getDeclutter());
          var userTransform;
          var i, ii; {
              for (var i = 0, ii = loadExtents.length; i < ii; ++i) {
                  vectorSource.loadFeatures(loadExtents[i], resolution, projection);
              }
          }
          var squaredTolerance = getSquaredTolerance(resolution, pixelRatio);
          /**
           * @param {import("../../Feature.js").default} feature Feature.
           * @this {CanvasVectorLayerRenderer}
           */
          var render = function (feature) {
              var styles;
              var styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();
              if (styleFunction) {
                  styles = styleFunction(feature, resolution);
              }
              if (styles) {
                  var dirty = this.renderFeature(feature, squaredTolerance, styles, replayGroup, userTransform);
                  this.dirty_ = this.dirty_ || dirty;
              }
          }.bind(this);
          var userExtent = toUserExtent(extent);
          /** @type {Array<import("../../Feature.js").default>} */
          var features = vectorSource.getFeaturesInExtent(userExtent);
          if (vectorLayerRenderOrder) {
              features.sort(vectorLayerRenderOrder);
          }
          for (var i = 0, ii = features.length; i < ii; ++i) {
              render(features[i]);
          }
          this.renderedFeatures_ = features;
          var replayGroupInstructions = replayGroup.finish();
          var executorGroup = new ExecutorGroup(extent, resolution, pixelRatio, vectorSource.getOverlaps(), replayGroupInstructions, vectorLayer.getRenderBuffer());
          this.renderedResolution_ = resolution;
          this.renderedRevision_ = vectorLayerRevision;
          this.renderedRenderOrder_ = vectorLayerRenderOrder;
          this.renderedExtent_ = extent;
          this.renderedCenter_ = center;
          this.renderedProjection_ = projection;
          this.replayGroup_ = executorGroup;
          this.hitDetectionImageData_ = null;
          this.replayGroupChanged = true;
          return true;
      };
      /**
       * @param {import("../../Feature.js").default} feature Feature.
       * @param {number} squaredTolerance Squared render tolerance.
       * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
       * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
       * @param {import("../../proj.js").TransformFunction=} opt_transform Transform from user to view projection.
       * @return {boolean} `true` if an image is loading.
       */
      CanvasVectorLayerRenderer.prototype.renderFeature = function (feature, squaredTolerance, styles, builderGroup, opt_transform) {
          if (!styles) {
              return false;
          }
          var loading = false;
          if (Array.isArray(styles)) {
              for (var i = 0, ii = styles.length; i < ii; ++i) {
                  loading =
                      renderFeature(builderGroup, feature, styles[i], squaredTolerance, this.boundHandleStyleImageChange_, opt_transform) || loading;
              }
          }
          else {
              loading = renderFeature(builderGroup, feature, styles, squaredTolerance, this.boundHandleStyleImageChange_, opt_transform);
          }
          return loading;
      };
      return CanvasVectorLayerRenderer;
  }(CanvasLayerRenderer));

  var __extends$11 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Vector data that is rendered client-side.
   * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
   * property on the layer object; for example, setting `title: 'My Title'` in the
   * options means that `title` is observable, and has get/set accessors.
   *
   * @extends {BaseVectorLayer<import("../source/Vector.js").default>}
   * @api
   */
  var VectorLayer = /** @class */ (function (_super) {
      __extends$11(VectorLayer, _super);
      /**
       * @param {import("./BaseVector.js").Options=} opt_options Options.
       */
      function VectorLayer(opt_options) {
          return _super.call(this, opt_options) || this;
      }
      /**
       * Create a renderer for this layer.
       * @return {import("../renderer/Layer.js").default} A layer renderer.
       */
      VectorLayer.prototype.createRenderer = function () {
          return new CanvasVectorLayerRenderer(this);
      };
      return VectorLayer;
  }(BaseVectorLayer));

  /**
   * @module ol/structs/RBush
   */
  /**
   * @typedef {Object} Entry
   * @property {number} minX
   * @property {number} minY
   * @property {number} maxX
   * @property {number} maxY
   * @property {Object} [value]
   */
  /**
   * @classdesc
   * Wrapper around the RBush by Vladimir Agafonkin.
   * See https://github.com/mourner/rbush.
   *
   * @template T
   */
  var RBush = /** @class */ (function () {
      /**
       * @param {number=} opt_maxEntries Max entries.
       */
      function RBush(opt_maxEntries) {
          /**
           * @private
           */
          this.rbush_ = new rbush(opt_maxEntries);
          /**
           * A mapping between the objects added to this rbush wrapper
           * and the objects that are actually added to the internal rbush.
           * @private
           * @type {Object<string, Entry>}
           */
          this.items_ = {};
      }
      /**
       * Insert a value into the RBush.
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {T} value Value.
       */
      RBush.prototype.insert = function (extent, value) {
          /** @type {Entry} */
          var item = {
              minX: extent[0],
              minY: extent[1],
              maxX: extent[2],
              maxY: extent[3],
              value: value,
          };
          this.rbush_.insert(item);
          this.items_[getUid(value)] = item;
      };
      /**
       * Bulk-insert values into the RBush.
       * @param {Array<import("../extent.js").Extent>} extents Extents.
       * @param {Array<T>} values Values.
       */
      RBush.prototype.load = function (extents, values) {
          var items = new Array(values.length);
          for (var i = 0, l = values.length; i < l; i++) {
              var extent = extents[i];
              var value = values[i];
              /** @type {Entry} */
              var item = {
                  minX: extent[0],
                  minY: extent[1],
                  maxX: extent[2],
                  maxY: extent[3],
                  value: value,
              };
              items[i] = item;
              this.items_[getUid(value)] = item;
          }
          this.rbush_.load(items);
      };
      /**
       * Remove a value from the RBush.
       * @param {T} value Value.
       * @return {boolean} Removed.
       */
      RBush.prototype.remove = function (value) {
          var uid = getUid(value);
          // get the object in which the value was wrapped when adding to the
          // internal rbush. then use that object to do the removal.
          var item = this.items_[uid];
          delete this.items_[uid];
          return this.rbush_.remove(item) !== null;
      };
      /**
       * Update the extent of a value in the RBush.
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {T} value Value.
       */
      RBush.prototype.update = function (extent, value) {
          var item = this.items_[getUid(value)];
          var bbox = [item.minX, item.minY, item.maxX, item.maxY];
          if (!equals$1(bbox, extent)) {
              this.remove(value);
              this.insert(extent, value);
          }
      };
      /**
       * Return all values in the RBush.
       * @return {Array<T>} All.
       */
      RBush.prototype.getAll = function () {
          var items = this.rbush_.all();
          return items.map(function (item) {
              return item.value;
          });
      };
      /**
       * Return all values in the given extent.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {Array<T>} All in extent.
       */
      RBush.prototype.getInExtent = function (extent) {
          /** @type {Entry} */
          var bbox = {
              minX: extent[0],
              minY: extent[1],
              maxX: extent[2],
              maxY: extent[3],
          };
          var items = this.rbush_.search(bbox);
          return items.map(function (item) {
              return item.value;
          });
      };
      /**
       * Calls a callback function with each value in the tree.
       * If the callback returns a truthy value, this value is returned without
       * checking the rest of the tree.
       * @param {function(T): *} callback Callback.
       * @return {*} Callback return value.
       */
      RBush.prototype.forEach = function (callback) {
          return this.forEach_(this.getAll(), callback);
      };
      /**
       * Calls a callback function with each value in the provided extent.
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {function(T): *} callback Callback.
       * @return {*} Callback return value.
       */
      RBush.prototype.forEachInExtent = function (extent, callback) {
          return this.forEach_(this.getInExtent(extent), callback);
      };
      /**
       * @param {Array<T>} values Values.
       * @param {function(T): *} callback Callback.
       * @private
       * @return {*} Callback return value.
       */
      RBush.prototype.forEach_ = function (values, callback) {
          var result;
          for (var i = 0, l = values.length; i < l; i++) {
              result = callback(values[i]);
              if (result) {
                  return result;
              }
          }
          return result;
      };
      /**
       * @return {boolean} Is empty.
       */
      RBush.prototype.isEmpty = function () {
          return isEmpty$1(this.items_);
      };
      /**
       * Remove all values from the RBush.
       */
      RBush.prototype.clear = function () {
          this.rbush_.clear();
          this.items_ = {};
      };
      /**
       * @param {import("../extent.js").Extent=} opt_extent Extent.
       * @return {import("../extent.js").Extent} Extent.
       */
      RBush.prototype.getExtent = function (opt_extent) {
          var data = this.rbush_.toJSON();
          return createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, opt_extent);
      };
      /**
       * @param {RBush} rbush R-Tree.
       */
      RBush.prototype.concat = function (rbush) {
          this.rbush_.load(rbush.rbush_.all());
          for (var i in rbush.items_) {
              this.items_[i] = rbush.items_[i];
          }
      };
      return RBush;
  }());

  var __extends$12 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * A function that returns a string or an array of strings representing source
   * attributions.
   *
   * @typedef {function(import("../PluggableMap.js").FrameState): (string|Array<string>)} Attribution
   */
  /**
   * A type that can be used to provide attribution information for data sources.
   *
   * It represents either
   * * a simple string (e.g. `'© Acme Inc.'`)
   * * an array of simple strings (e.g. `['© Acme Inc.', '© Bacme Inc.']`)
   * * a function that returns a string or array of strings ({@link module:ol/source/Source~Attribution})
   *
   * @typedef {string|Array<string>|Attribution} AttributionLike
   */
  /**
   * @typedef {Object} Options
   * @property {AttributionLike} [attributions]
   * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
   * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
   * @property {import("./State.js").default} [state='ready']
   * @property {boolean} [wrapX=false]
   */
  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * Base class for {@link module:ol/layer/Layer~Layer} sources.
   *
   * A generic `change` event is triggered when the state of the source changes.
   * @abstract
   * @api
   */
  var Source = /** @class */ (function (_super) {
      __extends$12(Source, _super);
      /**
       * @param {Options} options Source options.
       */
      function Source(options) {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {import("../proj/Projection.js").default}
           */
          _this.projection_ = get$2(options.projection);
          /**
           * @private
           * @type {?Attribution}
           */
          _this.attributions_ = adaptAttributions(options.attributions);
          /**
           * @private
           * @type {boolean}
           */
          _this.attributionsCollapsible_ =
              options.attributionsCollapsible !== undefined
                  ? options.attributionsCollapsible
                  : true;
          /**
           * This source is currently loading data. Sources that defer loading to the
           * map's tile queue never set this to `true`.
           * @type {boolean}
           */
          _this.loading = false;
          /**
           * @private
           * @type {import("./State.js").default}
           */
          _this.state_ =
              options.state !== undefined ? options.state : SourceState.READY;
          /**
           * @private
           * @type {boolean}
           */
          _this.wrapX_ = options.wrapX !== undefined ? options.wrapX : false;
          return _this;
      }
      /**
       * Get the attribution function for the source.
       * @return {?Attribution} Attribution function.
       */
      Source.prototype.getAttributions = function () {
          return this.attributions_;
      };
      /**
       * @return {boolean} Attributions are collapsible.
       */
      Source.prototype.getAttributionsCollapsible = function () {
          return this.attributionsCollapsible_;
      };
      /**
       * Get the projection of the source.
       * @return {import("../proj/Projection.js").default} Projection.
       * @api
       */
      Source.prototype.getProjection = function () {
          return this.projection_;
      };
      /**
       * @abstract
       * @return {Array<number>|undefined} Resolutions.
       */
      Source.prototype.getResolutions = function () {
          return abstract();
      };
      /**
       * Get the state of the source, see {@link module:ol/source/State~State} for possible states.
       * @return {import("./State.js").default} State.
       * @api
       */
      Source.prototype.getState = function () {
          return this.state_;
      };
      /**
       * @return {boolean|undefined} Wrap X.
       */
      Source.prototype.getWrapX = function () {
          return this.wrapX_;
      };
      /**
       * @return {Object|undefined} Context options.
       */
      Source.prototype.getContextOptions = function () {
          return undefined;
      };
      /**
       * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
       * @api
       */
      Source.prototype.refresh = function () {
          this.changed();
      };
      /**
       * Set the attributions of the source.
       * @param {AttributionLike|undefined} attributions Attributions.
       *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
       *     or `undefined`.
       * @api
       */
      Source.prototype.setAttributions = function (attributions) {
          this.attributions_ = adaptAttributions(attributions);
          this.changed();
      };
      /**
       * Set the state of the source.
       * @param {import("./State.js").default} state State.
       */
      Source.prototype.setState = function (state) {
          this.state_ = state;
          this.changed();
      };
      return Source;
  }(BaseObject));
  /**
   * Turns the attributions option into an attributions function.
   * @param {AttributionLike|undefined} attributionLike The attribution option.
   * @return {?Attribution} An attribution function (or null).
   */
  function adaptAttributions(attributionLike) {
      if (!attributionLike) {
          return null;
      }
      if (Array.isArray(attributionLike)) {
          return function (frameState) {
              return attributionLike;
          };
      }
      if (typeof attributionLike === 'function') {
          return attributionLike;
      }
      return function (frameState) {
          return [attributionLike];
      };
  }

  /**
   * @module ol/source/VectorEventType
   */
  /**
   * @enum {string}
   */
  var VectorEventType = {
      /**
       * Triggered when a feature is added to the source.
       * @event module:ol/source/Vector.VectorSourceEvent#addfeature
       * @api
       */
      ADDFEATURE: 'addfeature',
      /**
       * Triggered when a feature is updated.
       * @event module:ol/source/Vector.VectorSourceEvent#changefeature
       * @api
       */
      CHANGEFEATURE: 'changefeature',
      /**
       * Triggered when the clear method is called on the source.
       * @event module:ol/source/Vector.VectorSourceEvent#clear
       * @api
       */
      CLEAR: 'clear',
      /**
       * Triggered when a feature is removed from the source.
       * See {@link module:ol/source/Vector#clear source.clear()} for exceptions.
       * @event module:ol/source/Vector.VectorSourceEvent#removefeature
       * @api
       */
      REMOVEFEATURE: 'removefeature',
  };

  /**
   * @module ol/loadingstrategy
   */
  /**
   * Strategy function for loading all features with a single request.
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number} resolution Resolution.
   * @return {Array<import("./extent.js").Extent>} Extents.
   * @api
   */
  function all$1(extent, resolution) {
      return [[-Infinity, -Infinity, Infinity, Infinity]];
  }

  /**
   * @module ol/format/FormatType
   */
  /**
   * @enum {string}
   */
  var FormatType = {
      ARRAY_BUFFER: 'arraybuffer',
      JSON: 'json',
      TEXT: 'text',
      XML: 'xml',
  };

  /**
   * @module ol/featureloader
   */
  /**
   *
   * @type {boolean}
   * @private
   */
  var withCredentials = false;
  /**
   * {@link module:ol/source/Vector} sources use a function of this type to
   * load features.
   *
   * This function takes an {@link module:ol/extent~Extent} representing the area to be loaded,
   * a `{number}` representing the resolution (map units per pixel) and an
   * {@link module:ol/proj/Projection} for the projection  as
   * arguments. `this` within the function is bound to the
   * {@link module:ol/source/Vector} it's called from.
   *
   * The function is responsible for loading the features and adding them to the
   * source.
   * @typedef {function(this:(import("./source/Vector").default|import("./VectorTile.js").default), import("./extent.js").Extent, number,
   *                    import("./proj/Projection.js").default): void} FeatureLoader
   * @api
   */
  /**
   * {@link module:ol/source/Vector} sources use a function of this type to
   * get the url to load features from.
   *
   * This function takes an {@link module:ol/extent~Extent} representing the area
   * to be loaded, a `{number}` representing the resolution (map units per pixel)
   * and an {@link module:ol/proj/Projection} for the projection  as
   * arguments and returns a `{string}` representing the URL.
   * @typedef {function(import("./extent.js").Extent, number, import("./proj/Projection.js").default): string} FeatureUrlFunction
   * @api
   */
  /**
   * @param {string|FeatureUrlFunction} url Feature URL service.
   * @param {import("./format/Feature.js").default} format Feature format.
   * @param {function(this:import("./VectorTile.js").default, Array<import("./Feature.js").default>, import("./proj/Projection.js").default, import("./extent.js").Extent): void|function(this:import("./source/Vector").default, Array<import("./Feature.js").default>): void} success
   *     Function called with the loaded features and optionally with the data
   *     projection. Called with the vector tile or source as `this`.
   * @param {function(this:import("./VectorTile.js").default): void|function(this:import("./source/Vector").default): void} failure
   *     Function called when loading failed. Called with the vector tile or
   *     source as `this`.
   * @return {FeatureLoader} The feature loader.
   */
  function loadFeaturesXhr(url, format, success, failure) {
      return (
      /**
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {number} resolution Resolution.
       * @param {import("./proj/Projection.js").default} projection Projection.
       * @this {import("./source/Vector").default|import("./VectorTile.js").default}
       */
      function (extent, resolution, projection) {
          var xhr = new XMLHttpRequest();
          xhr.open('GET', typeof url === 'function' ? url(extent, resolution, projection) : url, true);
          if (format.getType() == FormatType.ARRAY_BUFFER) {
              xhr.responseType = 'arraybuffer';
          }
          xhr.withCredentials = withCredentials;
          /**
           * @param {Event} event Event.
           * @private
           */
          xhr.onload = function (event) {
              // status will be 0 for file:// urls
              if (!xhr.status || (xhr.status >= 200 && xhr.status < 300)) {
                  var type = format.getType();
                  /** @type {Document|Node|Object|string|undefined} */
                  var source = void 0;
                  if (type == FormatType.JSON || type == FormatType.TEXT) {
                      source = xhr.responseText;
                  }
                  else if (type == FormatType.XML) {
                      source = xhr.responseXML;
                      if (!source) {
                          source = new DOMParser().parseFromString(xhr.responseText, 'application/xml');
                      }
                  }
                  else if (type == FormatType.ARRAY_BUFFER) {
                      source = /** @type {ArrayBuffer} */ (xhr.response);
                  }
                  if (source) {
                      success.call(this, format.readFeatures(source, {
                          extent: extent,
                          featureProjection: projection,
                      }), format.readProjection(source));
                  }
                  else {
                      failure.call(this);
                  }
              }
              else {
                  failure.call(this);
              }
          }.bind(this);
          /**
           * @private
           */
          xhr.onerror = function () {
              failure.call(this);
          }.bind(this);
          xhr.send();
      });
  }
  /**
   * Create an XHR feature loader for a `url` and `format`. The feature loader
   * loads features (with XHR), parses the features, and adds them to the
   * vector source.
   * @param {string|FeatureUrlFunction} url Feature URL service.
   * @param {import("./format/Feature.js").default} format Feature format.
   * @return {FeatureLoader} The feature loader.
   * @api
   */
  function xhr(url, format) {
      return loadFeaturesXhr(url, format, 
      /**
       * @param {Array<import("./Feature.js").default>} features The loaded features.
       * @param {import("./proj/Projection.js").default} dataProjection Data
       * projection.
       * @this {import("./source/Vector").default|import("./VectorTile.js").default}
       */
      function (features, dataProjection) {
          var sourceOrTile = /** @type {?} */ (this);
          if (typeof sourceOrTile.addFeatures === 'function') {
              /** @type {import("./source/Vector").default} */ (sourceOrTile).addFeatures(features);
          }
      }, 
      /* FIXME handle error */ VOID);
  }

  /**
   * @module ol/source/Vector
   */
  var __extends$13 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * A function that takes an {@link module:ol/extent~Extent} and a resolution as arguments, and
   * returns an array of {@link module:ol/extent~Extent} with the extents to load. Usually this
   * is one of the standard {@link module:ol/loadingstrategy} strategies.
   *
   * @typedef {function(import("../extent.js").Extent, number): Array<import("../extent.js").Extent>} LoadingStrategy
   * @api
   */
  /**
   * @classdesc
   * Events emitted by {@link module:ol/source/Vector} instances are instances of this
   * type.
   * @template {import("../geom/Geometry.js").default} Geometry
   */
  var VectorSourceEvent = /** @class */ (function (_super) {
      __extends$13(VectorSourceEvent, _super);
      /**
       * @param {string} type Type.
       * @param {import("../Feature.js").default<Geometry>=} opt_feature Feature.
       */
      function VectorSourceEvent(type, opt_feature) {
          var _this = _super.call(this, type) || this;
          /**
           * The feature being added or removed.
           * @type {import("../Feature.js").default<Geometry>|undefined}
           * @api
           */
          _this.feature = opt_feature;
          return _this;
      }
      return VectorSourceEvent;
  }(BaseEvent));
  /**
   * @typedef {Object} Options
   * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
   * @property {Array<import("../Feature.js").default>|Collection<import("../Feature.js").default>} [features]
   * Features. If provided as {@link module:ol/Collection}, the features in the source
   * and the collection will stay in sync.
   * @property {import("../format/Feature.js").default} [format] The feature format used by the XHR
   * feature loader when `url` is set. Required if `url` is set, otherwise ignored.
   * @property {import("../featureloader.js").FeatureLoader} [loader]
   * The loader function used to load features, from a remote source for example.
   * If this is not set and `url` is set, the source will create and use an XHR
   * feature loader.
   *
   * Example:
   *
   * ```js
   * import {Vector} from 'ol/source';
   * import {GeoJSON} from 'ol/format';
   * import {bbox} from 'ol/loadingstrategy';
   *
   * var vectorSource = new Vector({
   *   format: new GeoJSON(),
   *   loader: function(extent, resolution, projection) {
   *      var proj = projection.getCode();
   *      var url = 'https://ahocevar.com/geoserver/wfs?service=WFS&' +
   *          'version=1.1.0&request=GetFeature&typename=osm:water_areas&' +
   *          'outputFormat=application/json&srsname=' + proj + '&' +
   *          'bbox=' + extent.join(',') + ',' + proj;
   *      var xhr = new XMLHttpRequest();
   *      xhr.open('GET', url);
   *      var onError = function() {
   *        vectorSource.removeLoadedExtent(extent);
   *      }
   *      xhr.onerror = onError;
   *      xhr.onload = function() {
   *        if (xhr.status == 200) {
   *          vectorSource.addFeatures(
   *              vectorSource.getFormat().readFeatures(xhr.responseText));
   *        } else {
   *          onError();
   *        }
   *      }
   *      xhr.send();
   *    },
   *    strategy: bbox
   *  });
   * ```
   * @property {boolean} [overlaps=true] This source may have overlapping geometries.
   * Setting this to `false` (e.g. for sources with polygons that represent administrative
   * boundaries or TopoJSON sources) allows the renderer to optimise fill and
   * stroke operations.
   * @property {LoadingStrategy} [strategy] The loading strategy to use.
   * By default an {@link module:ol/loadingstrategy~all}
   * strategy is used, a one-off strategy which loads all features at once.
   * @property {string|import("../featureloader.js").FeatureUrlFunction} [url]
   * Setting this option instructs the source to load features using an XHR loader
   * (see {@link module:ol/featureloader~xhr}). Use a `string` and an
   * {@link module:ol/loadingstrategy~all} for a one-off download of all features from
   * the given URL. Use a {@link module:ol/featureloader~FeatureUrlFunction} to generate the url with
   * other loading strategies.
   * Requires `format` to be set as well.
   * When default XHR feature loader is provided, the features will
   * be transformed from the data projection to the view projection
   * during parsing. If your remote data source does not advertise its projection
   * properly, this transformation will be incorrect. For some formats, the
   * default projection (usually EPSG:4326) can be overridden by setting the
   * dataProjection constructor option on the format.
   * Note that if a source contains non-feature data, such as a GeoJSON geometry
   * or a KML NetworkLink, these will be ignored. Use a custom loader to load these.
   * @property {boolean} [useSpatialIndex=true]
   * By default, an RTree is used as spatial index. When features are removed and
   * added frequently, and the total number of features is low, setting this to
   * `false` may improve performance.
   *
   * Note that
   * {@link module:ol/source/Vector~VectorSource#getFeaturesInExtent},
   * {@link module:ol/source/Vector~VectorSource#getClosestFeatureToCoordinate} and
   * {@link module:ol/source/Vector~VectorSource#getExtent} cannot be used when `useSpatialIndex` is
   * set to `false`, and {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent} will loop
   * through all features.
   *
   * When set to `false`, the features will be maintained in an
   * {@link module:ol/Collection}, which can be retrieved through
   * {@link module:ol/source/Vector~VectorSource#getFeaturesCollection}.
   * @property {boolean} [wrapX=true] Wrap the world horizontally. For vector editing across the
   * -180° and 180° meridians to work properly, this should be set to `false`. The
   * resulting geometry coordinates will then exceed the world bounds.
   */
  /**
   * @classdesc
   * Provides a source of features for vector layers. Vector features provided
   * by this source are suitable for editing. See {@link module:ol/source/VectorTile~VectorTile} for
   * vector data that is optimized for rendering.
   *
   * @fires VectorSourceEvent
   * @api
   * @template {import("../geom/Geometry.js").default} Geometry
   */
  var VectorSource = /** @class */ (function (_super) {
      __extends$13(VectorSource, _super);
      /**
       * @param {Options=} opt_options Vector source options.
       */
      function VectorSource(opt_options) {
          var _this = this;
          var options = opt_options || {};
          _this = _super.call(this, {
              attributions: options.attributions,
              projection: undefined,
              state: SourceState.READY,
              wrapX: options.wrapX !== undefined ? options.wrapX : true,
          }) || this;
          /**
           * @private
           * @type {import("../featureloader.js").FeatureLoader}
           */
          _this.loader_ = VOID;
          /**
           * @private
           * @type {import("../format/Feature.js").default|undefined}
           */
          _this.format_ = options.format;
          /**
           * @private
           * @type {boolean}
           */
          _this.overlaps_ = options.overlaps === undefined ? true : options.overlaps;
          /**
           * @private
           * @type {string|import("../featureloader.js").FeatureUrlFunction|undefined}
           */
          _this.url_ = options.url;
          if (options.loader !== undefined) {
              _this.loader_ = options.loader;
          }
          else if (_this.url_ !== undefined) {
              assert(_this.format_, 7); // `format` must be set when `url` is set
              // create a XHR feature loader for "url" and "format"
              _this.loader_ = xhr(_this.url_, 
              /** @type {import("../format/Feature.js").default} */ (_this.format_));
          }
          /**
           * @private
           * @type {LoadingStrategy}
           */
          _this.strategy_ =
              options.strategy !== undefined ? options.strategy : all$1;
          var useSpatialIndex = options.useSpatialIndex !== undefined ? options.useSpatialIndex : true;
          /**
           * @private
           * @type {RBush<import("../Feature.js").default<Geometry>>}
           */
          _this.featuresRtree_ = useSpatialIndex ? new RBush() : null;
          /**
           * @private
           * @type {RBush<{extent: import("../extent.js").Extent}>}
           */
          _this.loadedExtentsRtree_ = new RBush();
          /**
           * @private
           * @type {!Object<string, import("../Feature.js").default<Geometry>>}
           */
          _this.nullGeometryFeatures_ = {};
          /**
           * A lookup of features by id (the return from feature.getId()).
           * @private
           * @type {!Object<string, import("../Feature.js").default<Geometry>>}
           */
          _this.idIndex_ = {};
          /**
           * A lookup of features by uid (using getUid(feature)).
           * @private
           * @type {!Object<string, import("../Feature.js").default<Geometry>>}
           */
          _this.uidIndex_ = {};
          /**
           * @private
           * @type {Object<string, Array<import("../events.js").EventsKey>>}
           */
          _this.featureChangeKeys_ = {};
          /**
           * @private
           * @type {Collection<import("../Feature.js").default<Geometry>>}
           */
          _this.featuresCollection_ = null;
          var collection, features;
          if (Array.isArray(options.features)) {
              features = options.features;
          }
          else if (options.features) {
              collection = options.features;
              features = collection.getArray();
          }
          if (!useSpatialIndex && collection === undefined) {
              collection = new Collection(features);
          }
          if (features !== undefined) {
              _this.addFeaturesInternal(features);
          }
          if (collection !== undefined) {
              _this.bindFeaturesCollection_(collection);
          }
          return _this;
      }
      /**
       * Add a single feature to the source.  If you want to add a batch of features
       * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
       * instead. A feature will not be added to the source if feature with
       * the same id is already there. The reason for this behavior is to avoid
       * feature duplication when using bbox or tile loading strategies.
       * Note: this also applies if an {@link module:ol/Collection} is used for features,
       * meaning that if a feature with a duplicate id is added in the collection, it will
       * be removed from it right away.
       * @param {import("../Feature.js").default<Geometry>} feature Feature to add.
       * @api
       */
      VectorSource.prototype.addFeature = function (feature) {
          this.addFeatureInternal(feature);
          this.changed();
      };
      /**
       * Add a feature without firing a `change` event.
       * @param {import("../Feature.js").default<Geometry>} feature Feature.
       * @protected
       */
      VectorSource.prototype.addFeatureInternal = function (feature) {
          var featureKey = getUid(feature);
          if (!this.addToIndex_(featureKey, feature)) {
              if (this.featuresCollection_) {
                  this.featuresCollection_.remove(feature);
              }
              return;
          }
          this.setupChangeEvents_(featureKey, feature);
          var geometry = feature.getGeometry();
          if (geometry) {
              var extent = geometry.getExtent();
              if (this.featuresRtree_) {
                  this.featuresRtree_.insert(extent, feature);
              }
          }
          else {
              this.nullGeometryFeatures_[featureKey] = feature;
          }
          this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, feature));
      };
      /**
       * @param {string} featureKey Unique identifier for the feature.
       * @param {import("../Feature.js").default<Geometry>} feature The feature.
       * @private
       */
      VectorSource.prototype.setupChangeEvents_ = function (featureKey, feature) {
          this.featureChangeKeys_[featureKey] = [
              listen(feature, EventType.CHANGE, this.handleFeatureChange_, this),
              listen(feature, ObjectEventType.PROPERTYCHANGE, this.handleFeatureChange_, this),
          ];
      };
      /**
       * @param {string} featureKey Unique identifier for the feature.
       * @param {import("../Feature.js").default<Geometry>} feature The feature.
       * @return {boolean} The feature is "valid", in the sense that it is also a
       *     candidate for insertion into the Rtree.
       * @private
       */
      VectorSource.prototype.addToIndex_ = function (featureKey, feature) {
          var valid = true;
          var id = feature.getId();
          if (id !== undefined) {
              if (!(id.toString() in this.idIndex_)) {
                  this.idIndex_[id.toString()] = feature;
              }
              else {
                  valid = false;
              }
          }
          if (valid) {
              assert(!(featureKey in this.uidIndex_), 30); // The passed `feature` was already added to the source
              this.uidIndex_[featureKey] = feature;
          }
          return valid;
      };
      /**
       * Add a batch of features to the source.
       * @param {Array<import("../Feature.js").default<Geometry>>} features Features to add.
       * @api
       */
      VectorSource.prototype.addFeatures = function (features) {
          this.addFeaturesInternal(features);
          this.changed();
      };
      /**
       * Add features without firing a `change` event.
       * @param {Array<import("../Feature.js").default<Geometry>>} features Features.
       * @protected
       */
      VectorSource.prototype.addFeaturesInternal = function (features) {
          var extents = [];
          var newFeatures = [];
          var geometryFeatures = [];
          for (var i = 0, length_1 = features.length; i < length_1; i++) {
              var feature = features[i];
              var featureKey = getUid(feature);
              if (this.addToIndex_(featureKey, feature)) {
                  newFeatures.push(feature);
              }
          }
          for (var i = 0, length_2 = newFeatures.length; i < length_2; i++) {
              var feature = newFeatures[i];
              var featureKey = getUid(feature);
              this.setupChangeEvents_(featureKey, feature);
              var geometry = feature.getGeometry();
              if (geometry) {
                  var extent = geometry.getExtent();
                  extents.push(extent);
                  geometryFeatures.push(feature);
              }
              else {
                  this.nullGeometryFeatures_[featureKey] = feature;
              }
          }
          if (this.featuresRtree_) {
              this.featuresRtree_.load(extents, geometryFeatures);
          }
          for (var i = 0, length_3 = newFeatures.length; i < length_3; i++) {
              this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE, newFeatures[i]));
          }
      };
      /**
       * @param {!Collection<import("../Feature.js").default<Geometry>>} collection Collection.
       * @private
       */
      VectorSource.prototype.bindFeaturesCollection_ = function (collection) {
          var modifyingCollection = false;
          this.addEventListener(VectorEventType.ADDFEATURE, 
          /**
           * @param {VectorSourceEvent<Geometry>} evt The vector source event
           */
          function (evt) {
              if (!modifyingCollection) {
                  modifyingCollection = true;
                  collection.push(evt.feature);
                  modifyingCollection = false;
              }
          });
          this.addEventListener(VectorEventType.REMOVEFEATURE, 
          /**
           * @param {VectorSourceEvent<Geometry>} evt The vector source event
           */
          function (evt) {
              if (!modifyingCollection) {
                  modifyingCollection = true;
                  collection.remove(evt.feature);
                  modifyingCollection = false;
              }
          });
          collection.addEventListener(CollectionEventType.ADD, 
          /**
           * @param {import("../Collection.js").CollectionEvent} evt The collection event
           */
          function (evt) {
              if (!modifyingCollection) {
                  modifyingCollection = true;
                  this.addFeature(
                  /** @type {import("../Feature.js").default<Geometry>} */ (evt.element));
                  modifyingCollection = false;
              }
          }.bind(this));
          collection.addEventListener(CollectionEventType.REMOVE, 
          /**
           * @param {import("../Collection.js").CollectionEvent} evt The collection event
           */
          function (evt) {
              if (!modifyingCollection) {
                  modifyingCollection = true;
                  this.removeFeature(
                  /** @type {import("../Feature.js").default<Geometry>} */ (evt.element));
                  modifyingCollection = false;
              }
          }.bind(this));
          this.featuresCollection_ = collection;
      };
      /**
       * Remove all features from the source.
       * @param {boolean=} opt_fast Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#removefeature} events.
       * @api
       */
      VectorSource.prototype.clear = function (opt_fast) {
          if (opt_fast) {
              for (var featureId in this.featureChangeKeys_) {
                  var keys = this.featureChangeKeys_[featureId];
                  keys.forEach(unlistenByKey);
              }
              if (!this.featuresCollection_) {
                  this.featureChangeKeys_ = {};
                  this.idIndex_ = {};
                  this.uidIndex_ = {};
              }
          }
          else {
              if (this.featuresRtree_) {
                  this.featuresRtree_.forEach(this.removeFeatureInternal.bind(this));
                  for (var id in this.nullGeometryFeatures_) {
                      this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
                  }
              }
          }
          if (this.featuresCollection_) {
              this.featuresCollection_.clear();
          }
          if (this.featuresRtree_) {
              this.featuresRtree_.clear();
          }
          this.nullGeometryFeatures_ = {};
          var clearEvent = new VectorSourceEvent(VectorEventType.CLEAR);
          this.dispatchEvent(clearEvent);
          this.changed();
      };
      /**
       * Iterate through all features on the source, calling the provided callback
       * with each one.  If the callback returns any "truthy" value, iteration will
       * stop and the function will return the same value.
       * Note: this function only iterate through the feature that have a defined geometry.
       *
       * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
       *     on the source.  Return a truthy value to stop iteration.
       * @return {T|undefined} The return value from the last call to the callback.
       * @template T
       * @api
       */
      VectorSource.prototype.forEachFeature = function (callback) {
          if (this.featuresRtree_) {
              return this.featuresRtree_.forEach(callback);
          }
          else if (this.featuresCollection_) {
              this.featuresCollection_.forEach(callback);
          }
      };
      /**
       * Iterate through all features whose geometries contain the provided
       * coordinate, calling the callback with each feature.  If the callback returns
       * a "truthy" value, iteration will stop and the function will return the same
       * value.
       *
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
       *     whose goemetry contains the provided coordinate.
       * @return {T|undefined} The return value from the last call to the callback.
       * @template T
       */
      VectorSource.prototype.forEachFeatureAtCoordinateDirect = function (coordinate, callback) {
          var extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
          return this.forEachFeatureInExtent(extent, function (feature) {
              var geometry = feature.getGeometry();
              if (geometry.intersectsCoordinate(coordinate)) {
                  return callback(feature);
              }
              else {
                  return undefined;
              }
          });
      };
      /**
       * Iterate through all features whose bounding box intersects the provided
       * extent (note that the feature's geometry may not intersect the extent),
       * calling the callback with each feature.  If the callback returns a "truthy"
       * value, iteration will stop and the function will return the same value.
       *
       * If you are interested in features whose geometry intersects an extent, call
       * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
       *
       * When `useSpatialIndex` is set to false, this method will loop through all
       * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
       *
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
       *     whose bounding box intersects the provided extent.
       * @return {T|undefined} The return value from the last call to the callback.
       * @template T
       * @api
       */
      VectorSource.prototype.forEachFeatureInExtent = function (extent, callback) {
          if (this.featuresRtree_) {
              return this.featuresRtree_.forEachInExtent(extent, callback);
          }
          else if (this.featuresCollection_) {
              this.featuresCollection_.forEach(callback);
          }
      };
      /**
       * Iterate through all features whose geometry intersects the provided extent,
       * calling the callback with each feature.  If the callback returns a "truthy"
       * value, iteration will stop and the function will return the same value.
       *
       * If you only want to test for bounding box intersection, call the
       * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
       *
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
       *     whose geometry intersects the provided extent.
       * @return {T|undefined} The return value from the last call to the callback.
       * @template T
       * @api
       */
      VectorSource.prototype.forEachFeatureIntersectingExtent = function (extent, callback) {
          return this.forEachFeatureInExtent(extent, 
          /**
           * @param {import("../Feature.js").default<Geometry>} feature Feature.
           * @return {T|undefined} The return value from the last call to the callback.
           */
          function (feature) {
              var geometry = feature.getGeometry();
              if (geometry.intersectsExtent(extent)) {
                  var result = callback(feature);
                  if (result) {
                      return result;
                  }
              }
          });
      };
      /**
       * Get the features collection associated with this source. Will be `null`
       * unless the source was configured with `useSpatialIndex` set to `false`, or
       * with an {@link module:ol/Collection} as `features`.
       * @return {Collection<import("../Feature.js").default<Geometry>>} The collection of features.
       * @api
       */
      VectorSource.prototype.getFeaturesCollection = function () {
          return this.featuresCollection_;
      };
      /**
       * Get all features on the source in random order.
       * @return {Array<import("../Feature.js").default<Geometry>>} Features.
       * @api
       */
      VectorSource.prototype.getFeatures = function () {
          var features;
          if (this.featuresCollection_) {
              features = this.featuresCollection_.getArray();
          }
          else if (this.featuresRtree_) {
              features = this.featuresRtree_.getAll();
              if (!isEmpty$1(this.nullGeometryFeatures_)) {
                  extend(features, getValues(this.nullGeometryFeatures_));
              }
          }
          return /** @type {Array<import("../Feature.js").default<Geometry>>} */ (features);
      };
      /**
       * Get all features whose geometry intersects the provided coordinate.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @return {Array<import("../Feature.js").default<Geometry>>} Features.
       * @api
       */
      VectorSource.prototype.getFeaturesAtCoordinate = function (coordinate) {
          var features = [];
          this.forEachFeatureAtCoordinateDirect(coordinate, function (feature) {
              features.push(feature);
          });
          return features;
      };
      /**
       * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
       * all features intersecting the given extent in random order (so it may include
       * features whose geometries do not intersect the extent).
       *
       * When `useSpatialIndex` is set to false, this method will return all
       * features.
       *
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {Array<import("../Feature.js").default<Geometry>>} Features.
       * @api
       */
      VectorSource.prototype.getFeaturesInExtent = function (extent) {
          if (this.featuresRtree_) {
              return this.featuresRtree_.getInExtent(extent);
          }
          else if (this.featuresCollection_) {
              return this.featuresCollection_.getArray();
          }
          else {
              return [];
          }
      };
      /**
       * Get the closest feature to the provided coordinate.
       *
       * This method is not available when the source is configured with
       * `useSpatialIndex` set to `false`.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {function(import("../Feature.js").default<Geometry>):boolean=} opt_filter Feature filter function.
       *     The filter function will receive one argument, the {@link module:ol/Feature feature}
       *     and it should return a boolean value. By default, no filtering is made.
       * @return {import("../Feature.js").default<Geometry>} Closest feature.
       * @api
       */
      VectorSource.prototype.getClosestFeatureToCoordinate = function (coordinate, opt_filter) {
          // Find the closest feature using branch and bound.  We start searching an
          // infinite extent, and find the distance from the first feature found.  This
          // becomes the closest feature.  We then compute a smaller extent which any
          // closer feature must intersect.  We continue searching with this smaller
          // extent, trying to find a closer feature.  Every time we find a closer
          // feature, we update the extent being searched so that any even closer
          // feature must intersect it.  We continue until we run out of features.
          var x = coordinate[0];
          var y = coordinate[1];
          var closestFeature = null;
          var closestPoint = [NaN, NaN];
          var minSquaredDistance = Infinity;
          var extent = [-Infinity, -Infinity, Infinity, Infinity];
          var filter = opt_filter ? opt_filter : TRUE;
          this.featuresRtree_.forEachInExtent(extent, 
          /**
           * @param {import("../Feature.js").default<Geometry>} feature Feature.
           */
          function (feature) {
              if (filter(feature)) {
                  var geometry = feature.getGeometry();
                  var previousMinSquaredDistance = minSquaredDistance;
                  minSquaredDistance = geometry.closestPointXY(x, y, closestPoint, minSquaredDistance);
                  if (minSquaredDistance < previousMinSquaredDistance) {
                      closestFeature = feature;
                      // This is sneaky.  Reduce the extent that it is currently being
                      // searched while the R-Tree traversal using this same extent object
                      // is still in progress.  This is safe because the new extent is
                      // strictly contained by the old extent.
                      var minDistance = Math.sqrt(minSquaredDistance);
                      extent[0] = x - minDistance;
                      extent[1] = y - minDistance;
                      extent[2] = x + minDistance;
                      extent[3] = y + minDistance;
                  }
              }
          });
          return closestFeature;
      };
      /**
       * Get the extent of the features currently in the source.
       *
       * This method is not available when the source is configured with
       * `useSpatialIndex` set to `false`.
       * @param {import("../extent.js").Extent=} opt_extent Destination extent. If provided, no new extent
       *     will be created. Instead, that extent's coordinates will be overwritten.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      VectorSource.prototype.getExtent = function (opt_extent) {
          return this.featuresRtree_.getExtent(opt_extent);
      };
      /**
       * Get a feature by its identifier (the value returned by feature.getId()).
       * Note that the index treats string and numeric identifiers as the same.  So
       * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
       *
       * @param {string|number} id Feature identifier.
       * @return {import("../Feature.js").default<Geometry>} The feature (or `null` if not found).
       * @api
       */
      VectorSource.prototype.getFeatureById = function (id) {
          var feature = this.idIndex_[id.toString()];
          return feature !== undefined ? feature : null;
      };
      /**
       * Get a feature by its internal unique identifier (using `getUid`).
       *
       * @param {string} uid Feature identifier.
       * @return {import("../Feature.js").default<Geometry>} The feature (or `null` if not found).
       */
      VectorSource.prototype.getFeatureByUid = function (uid) {
          var feature = this.uidIndex_[uid];
          return feature !== undefined ? feature : null;
      };
      /**
       * Get the format associated with this source.
       *
       * @return {import("../format/Feature.js").default|undefined} The feature format.
       * @api
       */
      VectorSource.prototype.getFormat = function () {
          return this.format_;
      };
      /**
       * @return {boolean} The source can have overlapping geometries.
       */
      VectorSource.prototype.getOverlaps = function () {
          return this.overlaps_;
      };
      /**
       * Get the url associated with this source.
       *
       * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
       * @api
       */
      VectorSource.prototype.getUrl = function () {
          return this.url_;
      };
      /**
       * @param {Event} event Event.
       * @private
       */
      VectorSource.prototype.handleFeatureChange_ = function (event) {
          var feature = /** @type {import("../Feature.js").default<Geometry>} */ (event.target);
          var featureKey = getUid(feature);
          var geometry = feature.getGeometry();
          if (!geometry) {
              if (!(featureKey in this.nullGeometryFeatures_)) {
                  if (this.featuresRtree_) {
                      this.featuresRtree_.remove(feature);
                  }
                  this.nullGeometryFeatures_[featureKey] = feature;
              }
          }
          else {
              var extent = geometry.getExtent();
              if (featureKey in this.nullGeometryFeatures_) {
                  delete this.nullGeometryFeatures_[featureKey];
                  if (this.featuresRtree_) {
                      this.featuresRtree_.insert(extent, feature);
                  }
              }
              else {
                  if (this.featuresRtree_) {
                      this.featuresRtree_.update(extent, feature);
                  }
              }
          }
          var id = feature.getId();
          if (id !== undefined) {
              var sid = id.toString();
              if (this.idIndex_[sid] !== feature) {
                  this.removeFromIdIndex_(feature);
                  this.idIndex_[sid] = feature;
              }
          }
          else {
              this.removeFromIdIndex_(feature);
              this.uidIndex_[featureKey] = feature;
          }
          this.changed();
          this.dispatchEvent(new VectorSourceEvent(VectorEventType.CHANGEFEATURE, feature));
      };
      /**
       * Returns true if the feature is contained within the source.
       * @param {import("../Feature.js").default<Geometry>} feature Feature.
       * @return {boolean} Has feature.
       * @api
       */
      VectorSource.prototype.hasFeature = function (feature) {
          var id = feature.getId();
          if (id !== undefined) {
              return id in this.idIndex_;
          }
          else {
              return getUid(feature) in this.uidIndex_;
          }
      };
      /**
       * @return {boolean} Is empty.
       */
      VectorSource.prototype.isEmpty = function () {
          return this.featuresRtree_.isEmpty() && isEmpty$1(this.nullGeometryFeatures_);
      };
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {number} resolution Resolution.
       * @param {import("../proj/Projection.js").default} projection Projection.
       */
      VectorSource.prototype.loadFeatures = function (extent, resolution, projection) {
          var loadedExtentsRtree = this.loadedExtentsRtree_;
          var extentsToLoad = this.strategy_(extent, resolution);
          this.loading = false;
          var _loop_1 = function (i, ii) {
              var extentToLoad = extentsToLoad[i];
              var alreadyLoaded = loadedExtentsRtree.forEachInExtent(extentToLoad, 
              /**
               * @param {{extent: import("../extent.js").Extent}} object Object.
               * @return {boolean} Contains.
               */
              function (object) {
                  return containsExtent(object.extent, extentToLoad);
              });
              if (!alreadyLoaded) {
                  this_1.loader_.call(this_1, extentToLoad, resolution, projection);
                  loadedExtentsRtree.insert(extentToLoad, { extent: extentToLoad.slice() });
                  this_1.loading = this_1.loader_ !== VOID;
              }
          };
          var this_1 = this;
          for (var i = 0, ii = extentsToLoad.length; i < ii; ++i) {
              _loop_1(i);
          }
      };
      VectorSource.prototype.refresh = function () {
          this.clear(true);
          this.loadedExtentsRtree_.clear();
          _super.prototype.refresh.call(this);
      };
      /**
       * Remove an extent from the list of loaded extents.
       * @param {import("../extent.js").Extent} extent Extent.
       * @api
       */
      VectorSource.prototype.removeLoadedExtent = function (extent) {
          var loadedExtentsRtree = this.loadedExtentsRtree_;
          var obj;
          loadedExtentsRtree.forEachInExtent(extent, function (object) {
              if (equals$1(object.extent, extent)) {
                  obj = object;
                  return true;
              }
          });
          if (obj) {
              loadedExtentsRtree.remove(obj);
          }
      };
      /**
       * Remove a single feature from the source.  If you want to remove all features
       * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
       * instead.
       * @param {import("../Feature.js").default<Geometry>} feature Feature to remove.
       * @api
       */
      VectorSource.prototype.removeFeature = function (feature) {
          var featureKey = getUid(feature);
          if (featureKey in this.nullGeometryFeatures_) {
              delete this.nullGeometryFeatures_[featureKey];
          }
          else {
              if (this.featuresRtree_) {
                  this.featuresRtree_.remove(feature);
              }
          }
          this.removeFeatureInternal(feature);
          this.changed();
      };
      /**
       * Remove feature without firing a `change` event.
       * @param {import("../Feature.js").default<Geometry>} feature Feature.
       * @protected
       */
      VectorSource.prototype.removeFeatureInternal = function (feature) {
          var featureKey = getUid(feature);
          this.featureChangeKeys_[featureKey].forEach(unlistenByKey);
          delete this.featureChangeKeys_[featureKey];
          var id = feature.getId();
          if (id !== undefined) {
              delete this.idIndex_[id.toString()];
          }
          delete this.uidIndex_[featureKey];
          this.dispatchEvent(new VectorSourceEvent(VectorEventType.REMOVEFEATURE, feature));
      };
      /**
       * Remove a feature from the id index.  Called internally when the feature id
       * may have changed.
       * @param {import("../Feature.js").default<Geometry>} feature The feature.
       * @return {boolean} Removed the feature from the index.
       * @private
       */
      VectorSource.prototype.removeFromIdIndex_ = function (feature) {
          var removed = false;
          for (var id in this.idIndex_) {
              if (this.idIndex_[id] === feature) {
                  delete this.idIndex_[id];
                  removed = true;
                  break;
              }
          }
          return removed;
      };
      /**
       * Set the new loader of the source. The next render cycle will use the
       * new loader.
       * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
       * @api
       */
      VectorSource.prototype.setLoader = function (loader) {
          this.loader_ = loader;
      };
      /**
       * Points the source to a new url. The next render cycle will use the new url.
       * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
       * @api
       */
      VectorSource.prototype.setUrl = function (url) {
          assert(this.format_, 7); // `format` must be set when `url` is set
          this.setLoader(xhr(url, this.format_));
      };
      return VectorSource;
  }(Source));

  var __extends$14 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @enum {string}
   */
  var SelectEventType = {
      /**
       * Triggered when feature(s) has been (de)selected.
       * @event SelectEvent#select
       * @api
       */
      SELECT: 'select',
  };
  /**
   * A function that takes an {@link module:ol/Feature} or
   * {@link module:ol/render/Feature} and an
   * {@link module:ol/layer/Layer} and returns `true` if the feature may be
   * selected or `false` otherwise.
   * @typedef {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default):boolean} FilterFunction
   */
  /**
   * @typedef {Object} Options
   * @property {import("../events/condition.js").Condition} [addCondition] A function
   * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled.
   * By default, this is {@link module:ol/events/condition~never}. Use this if you
   * want to use different events for add and remove instead of `toggle`.
   * @property {import("../events/condition.js").Condition} [condition] A function that
   * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled. This is the event
   * for the selected features as a whole. By default, this is
   * {@link module:ol/events/condition~singleClick}. Clicking on a feature selects that
   * feature and removes any that were in the selection. Clicking outside any
   * feature removes all from the selection.
   * See `toggle`, `add`, `remove` options for adding/removing extra features to/
   * from the selection.
   * @property {Array<import("../layer/Layer.js").default>|function(import("../layer/Layer.js").default): boolean} [layers]
   * A list of layers from which features should be selected. Alternatively, a
   * filter function can be provided. The function will be called for each layer
   * in the map and should return `true` for layers that you want to be
   * selectable. If the option is absent, all visible layers will be considered
   * selectable.
   * @property {import("../style/Style.js").StyleLike|null} [style]
   * Style for the selected features. By default the default edit style is used
   * (see {@link module:ol/style}). Set to `null` if this interaction should not apply
   * any style changes for selected features.
   * If set to a falsey value, the selected feature's style will not change.
   * @property {import("../events/condition.js").Condition} [removeCondition] A function
   * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled.
   * By default, this is {@link module:ol/events/condition~never}. Use this if you
   * want to use different events for add and remove instead of `toggle`.
   * @property {import("../events/condition.js").Condition} [toggleCondition] A function
   * that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled. This is in addition
   * to the `condition` event. By default,
   * {@link module:ol/events/condition~shiftKeyOnly}, i.e. pressing `shift` as
   * well as the `condition` event, adds that feature to the current selection if
   * it is not currently selected, and removes it if it is. See `add` and `remove`
   * if you want to use different events instead of a toggle.
   * @property {boolean} [multi=false] A boolean that determines if the default
   * behaviour should select only single features or all (overlapping) features at
   * the clicked map position. The default of `false` means single select.
   * @property {import("../Collection.js").default<import("../Feature.js").default>} [features]
   * Collection where the interaction will place selected features. Optional. If
   * not set the interaction will create a collection. In any case the collection
   * used by the interaction is returned by
   * {@link module:ol/interaction/Select~Select#getFeatures}.
   * @property {FilterFunction} [filter] A function
   * that takes an {@link module:ol/Feature} and an
   * {@link module:ol/layer/Layer} and returns `true` if the feature may be
   * selected or `false` otherwise.
   * @property {number} [hitTolerance=0] Hit-detection tolerance. Pixels inside
   * the radius around the given position will be checked for features.
   */
  /**
   * @classdesc
   * Events emitted by {@link module:ol/interaction/Select~Select} instances are instances of
   * this type.
   */
  var SelectEvent = /** @class */ (function (_super) {
      __extends$14(SelectEvent, _super);
      /**
       * @param {SelectEventType} type The event type.
       * @param {Array<import("../Feature.js").default>} selected Selected features.
       * @param {Array<import("../Feature.js").default>} deselected Deselected features.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Associated
       *     {@link module:ol/MapBrowserEvent}.
       */
      function SelectEvent(type, selected, deselected, mapBrowserEvent) {
          var _this = _super.call(this, type) || this;
          /**
           * Selected features array.
           * @type {Array<import("../Feature.js").default>}
           * @api
           */
          _this.selected = selected;
          /**
           * Deselected features array.
           * @type {Array<import("../Feature.js").default>}
           * @api
           */
          _this.deselected = deselected;
          /**
           * Associated {@link module:ol/MapBrowserEvent}.
           * @type {import("../MapBrowserEvent.js").default}
           * @api
           */
          _this.mapBrowserEvent = mapBrowserEvent;
          return _this;
      }
      return SelectEvent;
  }(BaseEvent));
  /**
   * Original feature styles to reset to when features are no longer selected.
   * @type {Object.<number, import("../style/Style.js").default|Array.<import("../style/Style.js").default>|import("../style/Style.js").StyleFunction>}
   */
  var originalFeatureStyles = {};
  /**
   * @classdesc
   * Interaction for selecting vector features. By default, selected features are
   * styled differently, so this interaction can be used for visual highlighting,
   * as well as selecting features for other actions, such as modification or
   * output. There are three ways of controlling which features are selected:
   * using the browser event as defined by the `condition` and optionally the
   * `toggle`, `add`/`remove`, and `multi` options; a `layers` filter; and a
   * further feature filter using the `filter` option.
   *
   * Selected features are added to an internal unmanaged layer.
   *
   * @fires SelectEvent
   * @api
   */
  var Select = /** @class */ (function (_super) {
      __extends$14(Select, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function Select(opt_options) {
          var _this = _super.call(this) || this;
          var options = opt_options ? opt_options : {};
          /**
           * @private
           */
          _this.boundAddFeature_ = _this.addFeature_.bind(_this);
          /**
           * @private
           */
          _this.boundRemoveFeature_ = _this.removeFeature_.bind(_this);
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.condition_ = options.condition ? options.condition : singleClick;
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.addCondition_ = options.addCondition ? options.addCondition : never;
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.removeCondition_ = options.removeCondition
              ? options.removeCondition
              : never;
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.toggleCondition_ = options.toggleCondition
              ? options.toggleCondition
              : shiftKeyOnly;
          /**
           * @private
           * @type {boolean}
           */
          _this.multi_ = options.multi ? options.multi : false;
          /**
           * @private
           * @type {FilterFunction}
           */
          _this.filter_ = options.filter ? options.filter : TRUE;
          /**
           * @private
           * @type {number}
           */
          _this.hitTolerance_ = options.hitTolerance ? options.hitTolerance : 0;
          /**
           * @private
           * @type {import("../style/Style.js").default|Array.<import("../style/Style.js").default>|import("../style/Style.js").StyleFunction|null}
           */
          _this.style_ =
              options.style !== undefined ? options.style : getDefaultStyleFunction();
          /**
           * @private
           * @type {import("../Collection.js").default}
           */
          _this.features_ = options.features || new Collection();
          /** @type {function(import("../layer/Layer.js").default): boolean} */
          var layerFilter;
          if (options.layers) {
              if (typeof options.layers === 'function') {
                  layerFilter = options.layers;
              }
              else {
                  var layers_1 = options.layers;
                  layerFilter = function (layer) {
                      return includes(layers_1, layer);
                  };
              }
          }
          else {
              layerFilter = TRUE;
          }
          /**
           * @private
           * @type {function(import("../layer/Layer.js").default): boolean}
           */
          _this.layerFilter_ = layerFilter;
          /**
           * An association between selected feature (key)
           * and layer (value)
           * @private
           * @type {Object<string, import("../layer/Layer.js").default>}
           */
          _this.featureLayerAssociation_ = {};
          return _this;
      }
      /**
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {import("../layer/Layer.js").default} layer Layer.
       * @private
       */
      Select.prototype.addFeatureLayerAssociation_ = function (feature, layer) {
          this.featureLayerAssociation_[getUid(feature)] = layer;
      };
      /**
       * Get the selected features.
       * @return {import("../Collection.js").default<import("../Feature.js").default>} Features collection.
       * @api
       */
      Select.prototype.getFeatures = function () {
          return this.features_;
      };
      /**
       * Returns the Hit-detection tolerance.
       * @returns {number} Hit tolerance in pixels.
       * @api
       */
      Select.prototype.getHitTolerance = function () {
          return this.hitTolerance_;
      };
      /**
       * Returns the associated {@link module:ol/layer/Vector~Vector vectorlayer} of
       * the (last) selected feature. Note that this will not work with any
       * programmatic method like pushing features to
       * {@link module:ol/interaction/Select~Select#getFeatures collection}.
       * @param {import("../Feature.js").FeatureLike} feature Feature
       * @return {import('../layer/Vector.js').default} Layer.
       * @api
       */
      Select.prototype.getLayer = function (feature) {
          return /** @type {import('../layer/Vector.js').default} */ (this
              .featureLayerAssociation_[getUid(feature)]);
      };
      /**
       * Hit-detection tolerance. Pixels inside the radius around the given position
       * will be checked for features.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @api
       */
      Select.prototype.setHitTolerance = function (hitTolerance) {
          this.hitTolerance_ = hitTolerance;
      };
      /**
       * Remove the interaction from its current map, if any,  and attach it to a new
       * map, if any. Pass `null` to just remove the interaction from the current map.
       * @param {import("../PluggableMap.js").default} map Map.
       * @api
       */
      Select.prototype.setMap = function (map) {
          var currentMap = this.getMap();
          if (currentMap && this.style_) {
              this.features_.forEach(this.restorePreviousStyle_.bind(this));
          }
          _super.prototype.setMap.call(this, map);
          if (map) {
              this.features_.addEventListener(CollectionEventType.ADD, this.boundAddFeature_);
              this.features_.addEventListener(CollectionEventType.REMOVE, this.boundRemoveFeature_);
              if (this.style_) {
                  this.features_.forEach(this.applySelectedStyle_.bind(this));
              }
          }
          else {
              this.features_.removeEventListener(CollectionEventType.ADD, this.boundAddFeature_);
              this.features_.removeEventListener(CollectionEventType.REMOVE, this.boundRemoveFeature_);
          }
      };
      /**
       * @param {import("../Collection.js").CollectionEvent} evt Event.
       * @private
       */
      Select.prototype.addFeature_ = function (evt) {
          var feature = evt.element;
          if (this.style_) {
              this.applySelectedStyle_(feature);
          }
      };
      /**
       * @param {import("../Collection.js").CollectionEvent} evt Event.
       * @private
       */
      Select.prototype.removeFeature_ = function (evt) {
          var feature = evt.element;
          if (this.style_) {
              this.restorePreviousStyle_(feature);
          }
      };
      /**
       * @return {import("../style/Style.js").StyleLike|null} Select style.
       */
      Select.prototype.getStyle = function () {
          return this.style_;
      };
      /**
       * @param {import("../Feature.js").default} feature Feature
       * @private
       */
      Select.prototype.applySelectedStyle_ = function (feature) {
          var key = getUid(feature);
          if (!(key in originalFeatureStyles)) {
              originalFeatureStyles[key] = feature.getStyle();
          }
          feature.setStyle(this.style_);
      };
      /**
       * @param {import("../Feature.js").default} feature Feature
       * @private
       */
      Select.prototype.restorePreviousStyle_ = function (feature) {
          var key = getUid(feature);
          var selectInteractions = /** @type {Array<Select>} */ (this.getMap()
              .getInteractions()
              .getArray()
              .filter(function (interaction) {
              return (interaction instanceof Select &&
                  interaction.getStyle() &&
                  interaction.getFeatures().getArray().indexOf(feature) !== -1);
          }));
          if (selectInteractions.length > 0) {
              feature.setStyle(selectInteractions[selectInteractions.length - 1].getStyle());
          }
          else {
              feature.setStyle(originalFeatureStyles[key]);
              delete originalFeatureStyles[key];
          }
      };
      /**
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @private
       */
      Select.prototype.removeFeatureLayerAssociation_ = function (feature) {
          delete this.featureLayerAssociation_[getUid(feature)];
      };
      /**
       * Handles the {@link module:ol/MapBrowserEvent map browser event} and may change the
       * selected state of features.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       * @this {Select}
       */
      Select.prototype.handleEvent = function (mapBrowserEvent) {
          if (!this.condition_(mapBrowserEvent)) {
              return true;
          }
          var add = this.addCondition_(mapBrowserEvent);
          var remove = this.removeCondition_(mapBrowserEvent);
          var toggle = this.toggleCondition_(mapBrowserEvent);
          var set = !add && !remove && !toggle;
          var map = mapBrowserEvent.map;
          var features = this.getFeatures();
          var deselected = [];
          var selected = [];
          if (set) {
              // Replace the currently selected feature(s) with the feature(s) at the
              // pixel, or clear the selected feature(s) if there is no feature at
              // the pixel.
              clear(this.featureLayerAssociation_);
              map.forEachFeatureAtPixel(mapBrowserEvent.pixel, 
              /**
               * @param {import("../Feature.js").FeatureLike} feature Feature.
               * @param {import("../layer/Layer.js").default} layer Layer.
               * @return {boolean|undefined} Continue to iterate over the features.
               */
              function (feature, layer) {
                  if (this.filter_(feature, layer)) {
                      selected.push(feature);
                      this.addFeatureLayerAssociation_(feature, layer);
                      return !this.multi_;
                  }
              }.bind(this), {
                  layerFilter: this.layerFilter_,
                  hitTolerance: this.hitTolerance_,
              });
              for (var i = features.getLength() - 1; i >= 0; --i) {
                  var feature = features.item(i);
                  var index = selected.indexOf(feature);
                  if (index > -1) {
                      // feature is already selected
                      selected.splice(index, 1);
                  }
                  else {
                      features.remove(feature);
                      deselected.push(feature);
                  }
              }
              if (selected.length !== 0) {
                  features.extend(selected);
              }
          }
          else {
              // Modify the currently selected feature(s).
              map.forEachFeatureAtPixel(mapBrowserEvent.pixel, 
              /**
               * @param {import("../Feature.js").FeatureLike} feature Feature.
               * @param {import("../layer/Layer.js").default} layer Layer.
               * @return {boolean|undefined} Continue to iterate over the features.
               */
              function (feature, layer) {
                  if (this.filter_(feature, layer)) {
                      if ((add || toggle) && !includes(features.getArray(), feature)) {
                          selected.push(feature);
                          this.addFeatureLayerAssociation_(feature, layer);
                      }
                      else if ((remove || toggle) &&
                          includes(features.getArray(), feature)) {
                          deselected.push(feature);
                          this.removeFeatureLayerAssociation_(feature);
                      }
                      return !this.multi_;
                  }
              }.bind(this), {
                  layerFilter: this.layerFilter_,
                  hitTolerance: this.hitTolerance_,
              });
              for (var j = deselected.length - 1; j >= 0; --j) {
                  features.remove(deselected[j]);
              }
              features.extend(selected);
          }
          if (selected.length > 0 || deselected.length > 0) {
              this.dispatchEvent(new SelectEvent(SelectEventType.SELECT, selected, deselected, mapBrowserEvent));
          }
          return true;
      };
      return Select;
  }(Interaction));
  /**
   * @return {import("../style/Style.js").StyleFunction} Styles.
   */
  function getDefaultStyleFunction() {
      var styles = createEditingStyle();
      extend(styles[GeometryType.POLYGON], styles[GeometryType.LINE_STRING]);
      extend(styles[GeometryType.GEOMETRY_COLLECTION], styles[GeometryType.LINE_STRING]);
      return function (feature) {
          if (!feature.getGeometry()) {
              return null;
          }
          return styles[feature.getGeometry().getType()];
      };
  }

  /**
   * @module ol/interaction
   */
  /**
   * @typedef {Object} DefaultsOptions
   * @property {boolean} [altShiftDragRotate=true] Whether Alt-Shift-drag rotate is
   * desired.
   * @property {boolean} [onFocusOnly=false] Interact only when the map has the
   * focus. This affects the `MouseWheelZoom` and `DragPan` interactions and is
   * useful when page scroll is desired for maps that do not have the browser's
   * focus.
   * @property {boolean} [doubleClickZoom=true] Whether double click zoom is
   * desired.
   * @property {boolean} [keyboard=true] Whether keyboard interaction is desired.
   * @property {boolean} [mouseWheelZoom=true] Whether mousewheel zoom is desired.
   * @property {boolean} [shiftDragZoom=true] Whether Shift-drag zoom is desired.
   * @property {boolean} [dragPan=true] Whether drag pan is desired.
   * @property {boolean} [pinchRotate=true] Whether pinch rotate is desired.
   * @property {boolean} [pinchZoom=true] Whether pinch zoom is desired.
   * @property {number} [zoomDelta] Zoom level delta when using keyboard or double click zoom.
   * @property {number} [zoomDuration] Duration of the zoom animation in
   * milliseconds.
   */
  /**
   * Set of interactions included in maps by default. Specific interactions can be
   * excluded by setting the appropriate option to false in the constructor
   * options, but the order of the interactions is fixed.  If you want to specify
   * a different order for interactions, you will need to create your own
   * {@link module:ol/interaction/Interaction} instances and insert
   * them into a {@link module:ol/Collection} in the order you want
   * before creating your {@link module:ol/Map~Map} instance. Changing the order can
   * be of interest if the event propagation needs to be stopped at a point.
   * The default set of interactions, in sequence, is:
   * * {@link module:ol/interaction/DragRotate~DragRotate}
   * * {@link module:ol/interaction/DoubleClickZoom~DoubleClickZoom}
   * * {@link module:ol/interaction/DragPan~DragPan}
   * * {@link module:ol/interaction/PinchRotate~PinchRotate}
   * * {@link module:ol/interaction/PinchZoom~PinchZoom}
   * * {@link module:ol/interaction/KeyboardPan~KeyboardPan}
   * * {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}
   * * {@link module:ol/interaction/MouseWheelZoom~MouseWheelZoom}
   * * {@link module:ol/interaction/DragZoom~DragZoom}
   *
   * @param {DefaultsOptions=} opt_options Defaults options.
   * @return {import("./Collection.js").default<import("./interaction/Interaction.js").default>}
   * A collection of interactions to be used with the {@link module:ol/Map~Map}
   * constructor's `interactions` option.
   * @api
   */
  function defaults$1(opt_options) {
      var options = opt_options ? opt_options : {};
      var interactions = new Collection();
      var kinetic = new Kinetic(-0.005, 0.05, 100);
      var altShiftDragRotate = options.altShiftDragRotate !== undefined
          ? options.altShiftDragRotate
          : true;
      if (altShiftDragRotate) {
          interactions.push(new DragRotate());
      }
      var doubleClickZoom = options.doubleClickZoom !== undefined ? options.doubleClickZoom : true;
      if (doubleClickZoom) {
          interactions.push(new DoubleClickZoom({
              delta: options.zoomDelta,
              duration: options.zoomDuration,
          }));
      }
      var dragPan = options.dragPan !== undefined ? options.dragPan : true;
      if (dragPan) {
          interactions.push(new DragPan({
              onFocusOnly: options.onFocusOnly,
              kinetic: kinetic,
          }));
      }
      var pinchRotate = options.pinchRotate !== undefined ? options.pinchRotate : true;
      if (pinchRotate) {
          interactions.push(new PinchRotate());
      }
      var pinchZoom = options.pinchZoom !== undefined ? options.pinchZoom : true;
      if (pinchZoom) {
          interactions.push(new PinchZoom({
              duration: options.zoomDuration,
          }));
      }
      var keyboard = options.keyboard !== undefined ? options.keyboard : true;
      if (keyboard) {
          interactions.push(new KeyboardPan());
          interactions.push(new KeyboardZoom({
              delta: options.zoomDelta,
              duration: options.zoomDuration,
          }));
      }
      var mouseWheelZoom = options.mouseWheelZoom !== undefined ? options.mouseWheelZoom : true;
      if (mouseWheelZoom) {
          interactions.push(new MouseWheelZoom({
              onFocusOnly: options.onFocusOnly,
              duration: options.zoomDuration,
          }));
      }
      var shiftDragZoom = options.shiftDragZoom !== undefined ? options.shiftDragZoom : true;
      if (shiftDragZoom) {
          interactions.push(new DragZoom({
              duration: options.zoomDuration,
          }));
      }
      return interactions;
  }

  var __extends$15 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * The map is the core component of OpenLayers. For a map to render, a view,
   * one or more layers, and a target container are needed:
   *
   *     import Map from 'ol/Map';
   *     import View from 'ol/View';
   *     import TileLayer from 'ol/layer/Tile';
   *     import OSM from 'ol/source/OSM';
   *
   *     var map = new Map({
   *       view: new View({
   *         center: [0, 0],
   *         zoom: 1
   *       }),
   *       layers: [
   *         new TileLayer({
   *           source: new OSM()
   *         })
   *       ],
   *       target: 'map'
   *     });
   *
   * The above snippet creates a map using a {@link module:ol/layer/Tile} to
   * display {@link module:ol/source/OSM~OSM} OSM data and render it to a DOM
   * element with the id `map`.
   *
   * The constructor places a viewport container (with CSS class name
   * `ol-viewport`) in the target element (see `getViewport()`), and then two
   * further elements within the viewport: one with CSS class name
   * `ol-overlaycontainer-stopevent` for controls and some overlays, and one with
   * CSS class name `ol-overlaycontainer` for other overlays (see the `stopEvent`
   * option of {@link module:ol/Overlay~Overlay} for the difference). The map
   * itself is placed in a further element within the viewport.
   *
   * Layers are stored as a {@link module:ol/Collection~Collection} in
   * layerGroups. A top-level group is provided by the library. This is what is
   * accessed by `getLayerGroup` and `setLayerGroup`. Layers entered in the
   * options are added to this group, and `addLayer` and `removeLayer` change the
   * layer collection in the group. `getLayers` is a convenience function for
   * `getLayerGroup().getLayers()`. Note that {@link module:ol/layer/Group~Group}
   * is a subclass of {@link module:ol/layer/Base}, so layers entered in the
   * options or added with `addLayer` can be groups, which can contain further
   * groups, and so on.
   *
   * @api
   */
  var Map = /** @class */ (function (_super) {
      __extends$15(Map, _super);
      /**
       * @param {import("./PluggableMap.js").MapOptions} options Map options.
       */
      function Map(options) {
          var _this = this;
          options = assign({}, options);
          if (!options.controls) {
              options.controls = defaults();
          }
          if (!options.interactions) {
              options.interactions = defaults$1({
                  onFocusOnly: true,
              });
          }
          _this = _super.call(this, options) || this;
          return _this;
      }
      Map.prototype.createRenderer = function () {
          return new CompositeMapRenderer(this);
      };
      return Map;
  }(PluggableMap));

  /**
   * @module ol/TileRange
   */
  /**
   * A representation of a contiguous block of tiles.  A tile range is specified
   * by its min/max tile coordinates and is inclusive of coordinates.
   */
  var TileRange = /** @class */ (function () {
      /**
       * @param {number} minX Minimum X.
       * @param {number} maxX Maximum X.
       * @param {number} minY Minimum Y.
       * @param {number} maxY Maximum Y.
       */
      function TileRange(minX, maxX, minY, maxY) {
          /**
           * @type {number}
           */
          this.minX = minX;
          /**
           * @type {number}
           */
          this.maxX = maxX;
          /**
           * @type {number}
           */
          this.minY = minY;
          /**
           * @type {number}
           */
          this.maxY = maxY;
      }
      /**
       * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @return {boolean} Contains tile coordinate.
       */
      TileRange.prototype.contains = function (tileCoord) {
          return this.containsXY(tileCoord[1], tileCoord[2]);
      };
      /**
       * @param {TileRange} tileRange Tile range.
       * @return {boolean} Contains.
       */
      TileRange.prototype.containsTileRange = function (tileRange) {
          return (this.minX <= tileRange.minX &&
              tileRange.maxX <= this.maxX &&
              this.minY <= tileRange.minY &&
              tileRange.maxY <= this.maxY);
      };
      /**
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @return {boolean} Contains coordinate.
       */
      TileRange.prototype.containsXY = function (x, y) {
          return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;
      };
      /**
       * @param {TileRange} tileRange Tile range.
       * @return {boolean} Equals.
       */
      TileRange.prototype.equals = function (tileRange) {
          return (this.minX == tileRange.minX &&
              this.minY == tileRange.minY &&
              this.maxX == tileRange.maxX &&
              this.maxY == tileRange.maxY);
      };
      /**
       * @param {TileRange} tileRange Tile range.
       */
      TileRange.prototype.extend = function (tileRange) {
          if (tileRange.minX < this.minX) {
              this.minX = tileRange.minX;
          }
          if (tileRange.maxX > this.maxX) {
              this.maxX = tileRange.maxX;
          }
          if (tileRange.minY < this.minY) {
              this.minY = tileRange.minY;
          }
          if (tileRange.maxY > this.maxY) {
              this.maxY = tileRange.maxY;
          }
      };
      /**
       * @return {number} Height.
       */
      TileRange.prototype.getHeight = function () {
          return this.maxY - this.minY + 1;
      };
      /**
       * @return {import("./size.js").Size} Size.
       */
      TileRange.prototype.getSize = function () {
          return [this.getWidth(), this.getHeight()];
      };
      /**
       * @return {number} Width.
       */
      TileRange.prototype.getWidth = function () {
          return this.maxX - this.minX + 1;
      };
      /**
       * @param {TileRange} tileRange Tile range.
       * @return {boolean} Intersects.
       */
      TileRange.prototype.intersects = function (tileRange) {
          return (this.minX <= tileRange.maxX &&
              this.maxX >= tileRange.minX &&
              this.minY <= tileRange.maxY &&
              this.maxY >= tileRange.minY);
      };
      return TileRange;
  }());
  /**
   * @param {number} minX Minimum X.
   * @param {number} maxX Maximum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxY Maximum Y.
   * @param {TileRange=} tileRange TileRange.
   * @return {TileRange} Tile range.
   */
  function createOrUpdate$1(minX, maxX, minY, maxY, tileRange) {
      if (tileRange !== undefined) {
          tileRange.minX = minX;
          tileRange.maxX = maxX;
          tileRange.minY = minY;
          tileRange.maxY = maxY;
          return tileRange;
      }
      else {
          return new TileRange(minX, maxX, minY, maxY);
      }
  }

  /**
   * @module ol/tilecoord
   */
  /**
   * An array of three numbers representing the location of a tile in a tile
   * grid. The order is `z` (zoom level), `x` (column), and `y` (row).
   * @typedef {Array<number>} TileCoord
   * @api
   */
  /**
   * @param {number} z Z.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {TileCoord=} opt_tileCoord Tile coordinate.
   * @return {TileCoord} Tile coordinate.
   */
  function createOrUpdate$2(z, x, y, opt_tileCoord) {
      if (opt_tileCoord !== undefined) {
          opt_tileCoord[0] = z;
          opt_tileCoord[1] = x;
          opt_tileCoord[2] = y;
          return opt_tileCoord;
      }
      else {
          return [z, x, y];
      }
  }
  /**
   * @param {number} z Z.
   * @param {number} x X.
   * @param {number} y Y.
   * @return {string} Key.
   */
  function getKeyZXY(z, x, y) {
      return z + '/' + x + '/' + y;
  }
  /**
   * Get the key for a tile coord.
   * @param {TileCoord} tileCoord The tile coord.
   * @return {string} Key.
   */
  function getKey$1(tileCoord) {
      return getKeyZXY(tileCoord[0], tileCoord[1], tileCoord[2]);
  }
  /**
   * Get a tile coord given a key.
   * @param {string} key The tile coord key.
   * @return {TileCoord} The tile coord.
   */
  function fromKey(key) {
      return key.split('/').map(Number);
  }
  /**
   * @param {TileCoord} tileCoord Tile coord.
   * @return {number} Hash.
   */
  function hash(tileCoord) {
      return (tileCoord[1] << tileCoord[0]) + tileCoord[2];
  }
  /**
   * @param {TileCoord} tileCoord Tile coordinate.
   * @param {!import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @return {boolean} Tile coordinate is within extent and zoom level range.
   */
  function withinExtentAndZ(tileCoord, tileGrid) {
      var z = tileCoord[0];
      var x = tileCoord[1];
      var y = tileCoord[2];
      if (tileGrid.getMinZoom() > z || z > tileGrid.getMaxZoom()) {
          return false;
      }
      var extent = tileGrid.getExtent();
      var tileRange;
      if (!extent) {
          tileRange = tileGrid.getFullTileRange(z);
      }
      else {
          tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
      }
      if (!tileRange) {
          return true;
      }
      else {
          return tileRange.containsXY(x, y);
      }
  }

  /**
   * @module ol/tilegrid/TileGrid
   */
  /**
   * @private
   * @type {import("../tilecoord.js").TileCoord}
   */
  var tmpTileCoord = [0, 0, 0];
  /**
   * @typedef {Object} Options
   * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles outside this
   * extent will be requested by {@link module:ol/source/Tile} sources. When no `origin` or
   * `origins` are configured, the `origin` will be set to the top-left corner of the extent.
   * @property {number} [minZoom=0] Minimum zoom.
   * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e. where the `x`
   * and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left to right and downwards. If not
   * specified, `extent` or `origins` must be provided.
   * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins, i.e. where
   * the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If given, the array length
   * should match the length of the `resolutions` array, i.e. each resolution can have a different
   * origin. Tile coordinates increase left to right and downwards. If not specified, `extent` or
   * `origin` must be provided.
   * @property {!Array<number>} resolutions Resolutions. The array index of each resolution needs
   * to match the zoom level. This means that even if a `minZoom` is configured, the resolutions
   * array will have a length of `maxZoom + 1`.
   * @property {Array<import("../size.js").Size>} [sizes] Number of tile rows and columns
   * of the grid for each zoom level. If specified the values
   * define each zoom level's extent together with the `origin` or `origins`.
   * A grid `extent` can be configured in addition, and will further limit the extent
   * for which tile requests are made by sources. If the bottom-left corner of
   * an extent is used as `origin` or `origins`, then the `y` value must be
   * negative because OpenLayers tile coordinates use the top left as the origin.
   * @property {number|import("../size.js").Size} [tileSize] Tile size.
   * Default is `[256, 256]`.
   * @property {Array<import("../size.js").Size>} [tileSizes] Tile sizes. If given, the array length
   * should match the length of the `resolutions` array, i.e. each resolution can have a different
   * tile size.
   */
  /**
   * @classdesc
   * Base class for setting the grid pattern for sources accessing tiled-image
   * servers.
   * @api
   */
  var TileGrid = /** @class */ (function () {
      /**
       * @param {Options} options Tile grid options.
       */
      function TileGrid(options) {
          /**
           * @protected
           * @type {number}
           */
          this.minZoom = options.minZoom !== undefined ? options.minZoom : 0;
          /**
           * @private
           * @type {!Array<number>}
           */
          this.resolutions_ = options.resolutions;
          assert(isSorted(this.resolutions_, function (a, b) {
              return b - a;
          }, true), 17); // `resolutions` must be sorted in descending order
          // check if we've got a consistent zoom factor and origin
          var zoomFactor;
          if (!options.origins) {
              for (var i = 0, ii = this.resolutions_.length - 1; i < ii; ++i) {
                  if (!zoomFactor) {
                      zoomFactor = this.resolutions_[i] / this.resolutions_[i + 1];
                  }
                  else {
                      if (this.resolutions_[i] / this.resolutions_[i + 1] !== zoomFactor) {
                          zoomFactor = undefined;
                          break;
                      }
                  }
              }
          }
          /**
           * @private
           * @type {number|undefined}
           */
          this.zoomFactor_ = zoomFactor;
          /**
           * @protected
           * @type {number}
           */
          this.maxZoom = this.resolutions_.length - 1;
          /**
           * @private
           * @type {import("../coordinate.js").Coordinate}
           */
          this.origin_ = options.origin !== undefined ? options.origin : null;
          /**
           * @private
           * @type {Array<import("../coordinate.js").Coordinate>}
           */
          this.origins_ = null;
          if (options.origins !== undefined) {
              this.origins_ = options.origins;
              assert(this.origins_.length == this.resolutions_.length, 20); // Number of `origins` and `resolutions` must be equal
          }
          var extent = options.extent;
          if (extent !== undefined && !this.origin_ && !this.origins_) {
              this.origin_ = getTopLeft(extent);
          }
          assert((!this.origin_ && this.origins_) || (this.origin_ && !this.origins_), 18); // Either `origin` or `origins` must be configured, never both
          /**
           * @private
           * @type {Array<number|import("../size.js").Size>}
           */
          this.tileSizes_ = null;
          if (options.tileSizes !== undefined) {
              this.tileSizes_ = options.tileSizes;
              assert(this.tileSizes_.length == this.resolutions_.length, 19); // Number of `tileSizes` and `resolutions` must be equal
          }
          /**
           * @private
           * @type {number|import("../size.js").Size}
           */
          this.tileSize_ =
              options.tileSize !== undefined
                  ? options.tileSize
                  : !this.tileSizes_
                      ? DEFAULT_TILE_SIZE
                      : null;
          assert((!this.tileSize_ && this.tileSizes_) ||
              (this.tileSize_ && !this.tileSizes_), 22); // Either `tileSize` or `tileSizes` must be configured, never both
          /**
           * @private
           * @type {import("../extent.js").Extent}
           */
          this.extent_ = extent !== undefined ? extent : null;
          /**
           * @private
           * @type {Array<import("../TileRange.js").default>}
           */
          this.fullTileRanges_ = null;
          /**
           * @private
           * @type {import("../size.js").Size}
           */
          this.tmpSize_ = [0, 0];
          if (options.sizes !== undefined) {
              this.fullTileRanges_ = options.sizes.map(function (size, z) {
                  var tileRange = new TileRange(Math.min(0, size[0]), Math.max(size[0] - 1, -1), Math.min(0, size[1]), Math.max(size[1] - 1, -1));
                  return tileRange;
              }, this);
          }
          else if (extent) {
              this.calculateTileRanges_(extent);
          }
      }
      /**
       * Call a function with each tile coordinate for a given extent and zoom level.
       *
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {number} zoom Integer zoom level.
       * @param {function(import("../tilecoord.js").TileCoord): void} callback Function called with each tile coordinate.
       * @api
       */
      TileGrid.prototype.forEachTileCoord = function (extent, zoom, callback) {
          var tileRange = this.getTileRangeForExtentAndZ(extent, zoom);
          for (var i = tileRange.minX, ii = tileRange.maxX; i <= ii; ++i) {
              for (var j = tileRange.minY, jj = tileRange.maxY; j <= jj; ++j) {
                  callback([zoom, i, j]);
              }
          }
      };
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {function(number, import("../TileRange.js").default): boolean} callback Callback.
       * @param {import("../TileRange.js").default=} opt_tileRange Temporary import("../TileRange.js").default object.
       * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.
       * @return {boolean} Callback succeeded.
       */
      TileGrid.prototype.forEachTileCoordParentTileRange = function (tileCoord, callback, opt_tileRange, opt_extent) {
          var tileRange, x, y;
          var tileCoordExtent = null;
          var z = tileCoord[0] - 1;
          if (this.zoomFactor_ === 2) {
              x = tileCoord[1];
              y = tileCoord[2];
          }
          else {
              tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
          }
          while (z >= this.minZoom) {
              if (this.zoomFactor_ === 2) {
                  x = Math.floor(x / 2);
                  y = Math.floor(y / 2);
                  tileRange = createOrUpdate$1(x, x, y, y, opt_tileRange);
              }
              else {
                  tileRange = this.getTileRangeForExtentAndZ(tileCoordExtent, z, opt_tileRange);
              }
              if (callback(z, tileRange)) {
                  return true;
              }
              --z;
          }
          return false;
      };
      /**
       * Get the extent for this tile grid, if it was configured.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      TileGrid.prototype.getExtent = function () {
          return this.extent_;
      };
      /**
       * Get the maximum zoom level for the grid.
       * @return {number} Max zoom.
       * @api
       */
      TileGrid.prototype.getMaxZoom = function () {
          return this.maxZoom;
      };
      /**
       * Get the minimum zoom level for the grid.
       * @return {number} Min zoom.
       * @api
       */
      TileGrid.prototype.getMinZoom = function () {
          return this.minZoom;
      };
      /**
       * Get the origin for the grid at the given zoom level.
       * @param {number} z Integer zoom level.
       * @return {import("../coordinate.js").Coordinate} Origin.
       * @api
       */
      TileGrid.prototype.getOrigin = function (z) {
          if (this.origin_) {
              return this.origin_;
          }
          else {
              return this.origins_[z];
          }
      };
      /**
       * Get the resolution for the given zoom level.
       * @param {number} z Integer zoom level.
       * @return {number} Resolution.
       * @api
       */
      TileGrid.prototype.getResolution = function (z) {
          return this.resolutions_[z];
      };
      /**
       * Get the list of resolutions for the tile grid.
       * @return {Array<number>} Resolutions.
       * @api
       */
      TileGrid.prototype.getResolutions = function () {
          return this.resolutions_;
      };
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {import("../TileRange.js").default=} opt_tileRange Temporary import("../TileRange.js").default object.
       * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.
       * @return {import("../TileRange.js").default} Tile range.
       */
      TileGrid.prototype.getTileCoordChildTileRange = function (tileCoord, opt_tileRange, opt_extent) {
          if (tileCoord[0] < this.maxZoom) {
              if (this.zoomFactor_ === 2) {
                  var minX = tileCoord[1] * 2;
                  var minY = tileCoord[2] * 2;
                  return createOrUpdate$1(minX, minX + 1, minY, minY + 1, opt_tileRange);
              }
              var tileCoordExtent = this.getTileCoordExtent(tileCoord, opt_extent);
              return this.getTileRangeForExtentAndZ(tileCoordExtent, tileCoord[0] + 1, opt_tileRange);
          }
          return null;
      };
      /**
       * Get the extent for a tile range.
       * @param {number} z Integer zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @param {import("../extent.js").Extent=} opt_extent Temporary import("../extent.js").Extent object.
       * @return {import("../extent.js").Extent} Extent.
       */
      TileGrid.prototype.getTileRangeExtent = function (z, tileRange, opt_extent) {
          var origin = this.getOrigin(z);
          var resolution = this.getResolution(z);
          var tileSize = toSize(this.getTileSize(z), this.tmpSize_);
          var minX = origin[0] + tileRange.minX * tileSize[0] * resolution;
          var maxX = origin[0] + (tileRange.maxX + 1) * tileSize[0] * resolution;
          var minY = origin[1] + tileRange.minY * tileSize[1] * resolution;
          var maxY = origin[1] + (tileRange.maxY + 1) * tileSize[1] * resolution;
          return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
      };
      /**
       * Get a tile range for the given extent and integer zoom level.
       * @param {import("../extent.js").Extent} extent Extent.
       * @param {number} z Integer zoom level.
       * @param {import("../TileRange.js").default=} opt_tileRange Temporary tile range object.
       * @return {import("../TileRange.js").default} Tile range.
       */
      TileGrid.prototype.getTileRangeForExtentAndZ = function (extent, z, opt_tileRange) {
          var tileCoord = tmpTileCoord;
          this.getTileCoordForXYAndZ_(extent[0], extent[3], z, false, tileCoord);
          var minX = tileCoord[1];
          var minY = tileCoord[2];
          this.getTileCoordForXYAndZ_(extent[2], extent[1], z, true, tileCoord);
          return createOrUpdate$1(minX, tileCoord[1], minY, tileCoord[2], opt_tileRange);
      };
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @return {import("../coordinate.js").Coordinate} Tile center.
       */
      TileGrid.prototype.getTileCoordCenter = function (tileCoord) {
          var origin = this.getOrigin(tileCoord[0]);
          var resolution = this.getResolution(tileCoord[0]);
          var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
          return [
              origin[0] + (tileCoord[1] + 0.5) * tileSize[0] * resolution,
              origin[1] - (tileCoord[2] + 0.5) * tileSize[1] * resolution,
          ];
      };
      /**
       * Get the extent of a tile coordinate.
       *
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {import("../extent.js").Extent=} opt_extent Temporary extent object.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      TileGrid.prototype.getTileCoordExtent = function (tileCoord, opt_extent) {
          var origin = this.getOrigin(tileCoord[0]);
          var resolution = this.getResolution(tileCoord[0]);
          var tileSize = toSize(this.getTileSize(tileCoord[0]), this.tmpSize_);
          var minX = origin[0] + tileCoord[1] * tileSize[0] * resolution;
          var minY = origin[1] - (tileCoord[2] + 1) * tileSize[1] * resolution;
          var maxX = minX + tileSize[0] * resolution;
          var maxY = minY + tileSize[1] * resolution;
          return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
      };
      /**
       * Get the tile coordinate for the given map coordinate and resolution.  This
       * method considers that coordinates that intersect tile boundaries should be
       * assigned the higher tile coordinate.
       *
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {number} resolution Resolution.
       * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Destination import("../tilecoord.js").TileCoord object.
       * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
       * @api
       */
      TileGrid.prototype.getTileCoordForCoordAndResolution = function (coordinate, resolution, opt_tileCoord) {
          return this.getTileCoordForXYAndResolution_(coordinate[0], coordinate[1], resolution, false, opt_tileCoord);
      };
      /**
       * Note that this method should not be called for resolutions that correspond
       * to an integer zoom level.  Instead call the `getTileCoordForXYAndZ_` method.
       * @param {number} x X.
       * @param {number} y Y.
       * @param {number} resolution Resolution (for a non-integer zoom level).
       * @param {boolean} reverseIntersectionPolicy Instead of letting edge
       *     intersections go to the higher tile coordinate, let edge intersections
       *     go to the lower tile coordinate.
       * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Temporary import("../tilecoord.js").TileCoord object.
       * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
       * @private
       */
      TileGrid.prototype.getTileCoordForXYAndResolution_ = function (x, y, resolution, reverseIntersectionPolicy, opt_tileCoord) {
          var z = this.getZForResolution(resolution);
          var scale = resolution / this.getResolution(z);
          var origin = this.getOrigin(z);
          var tileSize = toSize(this.getTileSize(z), this.tmpSize_);
          var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
          var adjustY = reverseIntersectionPolicy ? 0.5 : 0;
          var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
          var yFromOrigin = Math.floor((origin[1] - y) / resolution + adjustY);
          var tileCoordX = (scale * xFromOrigin) / tileSize[0];
          var tileCoordY = (scale * yFromOrigin) / tileSize[1];
          if (reverseIntersectionPolicy) {
              tileCoordX = Math.ceil(tileCoordX) - 1;
              tileCoordY = Math.ceil(tileCoordY) - 1;
          }
          else {
              tileCoordX = Math.floor(tileCoordX);
              tileCoordY = Math.floor(tileCoordY);
          }
          return createOrUpdate$2(z, tileCoordX, tileCoordY, opt_tileCoord);
      };
      /**
       * Although there is repetition between this method and `getTileCoordForXYAndResolution_`,
       * they should have separate implementations.  This method is for integer zoom
       * levels.  The other method should only be called for resolutions corresponding
       * to non-integer zoom levels.
       * @param {number} x Map x coordinate.
       * @param {number} y Map y coordinate.
       * @param {number} z Integer zoom level.
       * @param {boolean} reverseIntersectionPolicy Instead of letting edge
       *     intersections go to the higher tile coordinate, let edge intersections
       *     go to the lower tile coordinate.
       * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Temporary import("../tilecoord.js").TileCoord object.
       * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
       * @private
       */
      TileGrid.prototype.getTileCoordForXYAndZ_ = function (x, y, z, reverseIntersectionPolicy, opt_tileCoord) {
          var origin = this.getOrigin(z);
          var resolution = this.getResolution(z);
          var tileSize = toSize(this.getTileSize(z), this.tmpSize_);
          var adjustX = reverseIntersectionPolicy ? 0.5 : 0;
          var adjustY = reverseIntersectionPolicy ? 0.5 : 0;
          var xFromOrigin = Math.floor((x - origin[0]) / resolution + adjustX);
          var yFromOrigin = Math.floor((origin[1] - y) / resolution + adjustY);
          var tileCoordX = xFromOrigin / tileSize[0];
          var tileCoordY = yFromOrigin / tileSize[1];
          if (reverseIntersectionPolicy) {
              tileCoordX = Math.ceil(tileCoordX) - 1;
              tileCoordY = Math.ceil(tileCoordY) - 1;
          }
          else {
              tileCoordX = Math.floor(tileCoordX);
              tileCoordY = Math.floor(tileCoordY);
          }
          return createOrUpdate$2(z, tileCoordX, tileCoordY, opt_tileCoord);
      };
      /**
       * Get a tile coordinate given a map coordinate and zoom level.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {number} z Zoom level.
       * @param {import("../tilecoord.js").TileCoord=} opt_tileCoord Destination import("../tilecoord.js").TileCoord object.
       * @return {import("../tilecoord.js").TileCoord} Tile coordinate.
       * @api
       */
      TileGrid.prototype.getTileCoordForCoordAndZ = function (coordinate, z, opt_tileCoord) {
          return this.getTileCoordForXYAndZ_(coordinate[0], coordinate[1], z, false, opt_tileCoord);
      };
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @return {number} Tile resolution.
       */
      TileGrid.prototype.getTileCoordResolution = function (tileCoord) {
          return this.resolutions_[tileCoord[0]];
      };
      /**
       * Get the tile size for a zoom level. The type of the return value matches the
       * `tileSize` or `tileSizes` that the tile grid was configured with. To always
       * get an `import("../size.js").Size`, run the result through `import("../size.js").Size.toSize()`.
       * @param {number} z Z.
       * @return {number|import("../size.js").Size} Tile size.
       * @api
       */
      TileGrid.prototype.getTileSize = function (z) {
          if (this.tileSize_) {
              return this.tileSize_;
          }
          else {
              return this.tileSizes_[z];
          }
      };
      /**
       * @param {number} z Zoom level.
       * @return {import("../TileRange.js").default} Extent tile range for the specified zoom level.
       */
      TileGrid.prototype.getFullTileRange = function (z) {
          if (!this.fullTileRanges_) {
              return null;
          }
          else {
              return this.fullTileRanges_[z];
          }
      };
      /**
       * @param {number} resolution Resolution.
       * @param {number=} opt_direction If 0, the nearest resolution will be used.
       *     If 1, the nearest lower resolution will be used. If -1, the nearest
       *     higher resolution will be used. Default is 0.
       * @return {number} Z.
       * @api
       */
      TileGrid.prototype.getZForResolution = function (resolution, opt_direction) {
          var z = linearFindNearest(this.resolutions_, resolution, opt_direction || 0);
          return clamp(z, this.minZoom, this.maxZoom);
      };
      /**
       * @param {!import("../extent.js").Extent} extent Extent for this tile grid.
       * @private
       */
      TileGrid.prototype.calculateTileRanges_ = function (extent) {
          var length = this.resolutions_.length;
          var fullTileRanges = new Array(length);
          for (var z = this.minZoom; z < length; ++z) {
              fullTileRanges[z] = this.getTileRangeForExtentAndZ(extent, z);
          }
          this.fullTileRanges_ = fullTileRanges;
      };
      return TileGrid;
  }());

  /**
   * @module ol/layer/TileProperty
   */
  /**
   * @enum {string}
   */
  var TileProperty = {
      PRELOAD: 'preload',
      USE_INTERIM_TILES_ON_ERROR: 'useInterimTilesOnError',
  };

  var __extends$16 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
   * @property {number} [opacity=1] Opacity (0, 1).
   * @property {boolean} [visible=true] Visibility.
   * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
   * rendered outside of this extent.
   * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
   * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
   * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
   * method was used.
   * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
   * visible.
   * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
   * be visible.
   * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
   * visible.
   * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
   * be visible.
   * @property {number} [preload=0] Preload. Load low-resolution tiles up to `preload` levels. `0`
   * means no preloading.
   * @property {import("../source/Tile.js").default} [source] Source for this layer.
   * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
   * this layer in its layers collection, and the layer will be rendered on top. This is useful for
   * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
   * use {@link module:ol/Map#addLayer}.
   * @property {boolean} [useInterimTilesOnError=true] Use interim tiles on error.
   */
  /**
   * @classdesc
   * For layer sources that provide pre-rendered, tiled images in grids that are
   * organized by zoom levels for specific resolutions.
   * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
   * property on the layer object; for example, setting `title: 'My Title'` in the
   * options means that `title` is observable, and has get/set accessors.
   *
   * @extends {Layer<import("../source/Tile.js").default>}
   * @api
   */
  var BaseTileLayer = /** @class */ (function (_super) {
      __extends$16(BaseTileLayer, _super);
      /**
       * @param {Options=} opt_options Tile layer options.
       */
      function BaseTileLayer(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          var baseOptions = assign({}, options);
          delete baseOptions.preload;
          delete baseOptions.useInterimTilesOnError;
          _this = _super.call(this, baseOptions) || this;
          _this.setPreload(options.preload !== undefined ? options.preload : 0);
          _this.setUseInterimTilesOnError(options.useInterimTilesOnError !== undefined
              ? options.useInterimTilesOnError
              : true);
          return _this;
      }
      /**
       * Return the level as number to which we will preload tiles up to.
       * @return {number} The level to preload tiles up to.
       * @observable
       * @api
       */
      BaseTileLayer.prototype.getPreload = function () {
          return /** @type {number} */ (this.get(TileProperty.PRELOAD));
      };
      /**
       * Set the level as number to which we will preload tiles up to.
       * @param {number} preload The level to preload tiles up to.
       * @observable
       * @api
       */
      BaseTileLayer.prototype.setPreload = function (preload) {
          this.set(TileProperty.PRELOAD, preload);
      };
      /**
       * Whether we use interim tiles on error.
       * @return {boolean} Use interim tiles on error.
       * @observable
       * @api
       */
      BaseTileLayer.prototype.getUseInterimTilesOnError = function () {
          return /** @type {boolean} */ (this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR));
      };
      /**
       * Set whether we use interim tiles on error.
       * @param {boolean} useInterimTilesOnError Use interim tiles on error.
       * @observable
       * @api
       */
      BaseTileLayer.prototype.setUseInterimTilesOnError = function (useInterimTilesOnError) {
          this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, useInterimTilesOnError);
      };
      return BaseTileLayer;
  }(Layer));

  var __extends$17 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Canvas renderer for tile layers.
   * @api
   */
  var CanvasTileLayerRenderer = /** @class */ (function (_super) {
      __extends$17(CanvasTileLayerRenderer, _super);
      /**
       * @param {import("../../layer/Tile.js").default|import("../../layer/VectorTile.js").default} tileLayer Tile layer.
       */
      function CanvasTileLayerRenderer(tileLayer) {
          var _this = _super.call(this, tileLayer) || this;
          /**
           * Rendered extent has changed since the previous `renderFrame()` call
           * @type {boolean}
           */
          _this.extentChanged = true;
          /**
           * @private
           * @type {?import("../../extent.js").Extent}
           */
          _this.renderedExtent_ = null;
          /**
           * @protected
           * @type {number}
           */
          _this.renderedPixelRatio;
          /**
           * @protected
           * @type {import("../../proj/Projection.js").default}
           */
          _this.renderedProjection = null;
          /**
           * @protected
           * @type {number}
           */
          _this.renderedRevision;
          /**
           * @protected
           * @type {!Array<import("../../Tile.js").default>}
           */
          _this.renderedTiles = [];
          /**
           * @private
           * @type {boolean}
           */
          _this.newTiles_ = false;
          /**
           * @protected
           * @type {import("../../extent.js").Extent}
           */
          _this.tmpExtent = createEmpty();
          /**
           * @private
           * @type {import("../../TileRange.js").default}
           */
          _this.tmpTileRange_ = new TileRange(0, 0, 0, 0);
          return _this;
      }
      /**
       * @protected
       * @param {import("../../Tile.js").default} tile Tile.
       * @return {boolean} Tile is drawable.
       */
      CanvasTileLayerRenderer.prototype.isDrawableTile = function (tile) {
          var tileLayer = this.getLayer();
          var tileState = tile.getState();
          var useInterimTilesOnError = tileLayer.getUseInterimTilesOnError();
          return (tileState == TileState.LOADED ||
              tileState == TileState.EMPTY ||
              (tileState == TileState.ERROR && !useInterimTilesOnError));
      };
      /**
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @return {!import("../../Tile.js").default} Tile.
       */
      CanvasTileLayerRenderer.prototype.getTile = function (z, x, y, frameState) {
          var pixelRatio = frameState.pixelRatio;
          var projection = frameState.viewState.projection;
          var tileLayer = this.getLayer();
          var tileSource = tileLayer.getSource();
          var tile = tileSource.getTile(z, x, y, pixelRatio, projection);
          if (tile.getState() == TileState.ERROR) {
              if (!tileLayer.getUseInterimTilesOnError()) {
                  // When useInterimTilesOnError is false, we consider the error tile as loaded.
                  tile.setState(TileState.LOADED);
              }
              else if (tileLayer.getPreload() > 0) {
                  // Preloaded tiles for lower resolutions might have finished loading.
                  this.newTiles_ = true;
              }
          }
          if (!this.isDrawableTile(tile)) {
              tile = tile.getInterimTile();
          }
          return tile;
      };
      /**
       * @param {Object<number, Object<string, import("../../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
       * @param {number} zoom Zoom level.
       * @param {import("../../Tile.js").default} tile Tile.
       * @return {boolean|void} If `false`, the tile will not be considered loaded.
       */
      CanvasTileLayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {
          if (this.isDrawableTile(tile)) {
              return _super.prototype.loadedTileCallback.call(this, tiles, zoom, tile);
          }
          return false;
      };
      /**
       * Determine whether render should be called.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @return {boolean} Layer is ready to be rendered.
       */
      CanvasTileLayerRenderer.prototype.prepareFrame = function (frameState) {
          return !!this.getLayer().getSource();
      };
      /**
       * Render the layer.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target that may be used to render content to.
       * @return {HTMLElement} The rendered element.
       */
      CanvasTileLayerRenderer.prototype.renderFrame = function (frameState, target) {
          var layerState = frameState.layerStatesArray[frameState.layerIndex];
          var viewState = frameState.viewState;
          var projection = viewState.projection;
          var viewResolution = viewState.resolution;
          var viewCenter = viewState.center;
          var rotation = viewState.rotation;
          var pixelRatio = frameState.pixelRatio;
          var tileLayer = this.getLayer();
          var tileSource = tileLayer.getSource();
          var sourceRevision = tileSource.getRevision();
          var tileGrid = tileSource.getTileGridForProjection(projection);
          var z = tileGrid.getZForResolution(viewResolution, tileSource.zDirection);
          var tileResolution = tileGrid.getResolution(z);
          var extent = frameState.extent;
          var layerExtent = layerState.extent && fromUserExtent(layerState.extent);
          if (layerExtent) {
              extent = getIntersection(extent, fromUserExtent(layerState.extent));
          }
          var tilePixelRatio = tileSource.getTilePixelRatio(pixelRatio);
          // desired dimensions of the canvas in pixels
          var width = Math.round(frameState.size[0] * tilePixelRatio);
          var height = Math.round(frameState.size[1] * tilePixelRatio);
          if (rotation) {
              var size = Math.round(Math.sqrt(width * width + height * height));
              width = size;
              height = size;
          }
          var dx = (tileResolution * width) / 2 / tilePixelRatio;
          var dy = (tileResolution * height) / 2 / tilePixelRatio;
          var canvasExtent = [
              viewCenter[0] - dx,
              viewCenter[1] - dy,
              viewCenter[0] + dx,
              viewCenter[1] + dy,
          ];
          var tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z);
          /**
           * @type {Object<number, Object<string, import("../../Tile.js").default>>}
           */
          var tilesToDrawByZ = {};
          tilesToDrawByZ[z] = {};
          var findLoadedTiles = this.createLoadedTileFinder(tileSource, projection, tilesToDrawByZ);
          var tmpExtent = this.tmpExtent;
          var tmpTileRange = this.tmpTileRange_;
          this.newTiles_ = false;
          for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
              for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
                  var tile = this.getTile(z, x, y, frameState);
                  if (this.isDrawableTile(tile)) {
                      var uid = getUid(this);
                      if (tile.getState() == TileState.LOADED) {
                          tilesToDrawByZ[z][tile.tileCoord.toString()] = tile;
                          var inTransition = tile.inTransition(uid);
                          if (!this.newTiles_ &&
                              (inTransition || this.renderedTiles.indexOf(tile) === -1)) {
                              this.newTiles_ = true;
                          }
                      }
                      if (tile.getAlpha(uid, frameState.time) === 1) {
                          // don't look for alt tiles if alpha is 1
                          continue;
                      }
                  }
                  var childTileRange = tileGrid.getTileCoordChildTileRange(tile.tileCoord, tmpTileRange, tmpExtent);
                  var covered = false;
                  if (childTileRange) {
                      covered = findLoadedTiles(z + 1, childTileRange);
                  }
                  if (!covered) {
                      tileGrid.forEachTileCoordParentTileRange(tile.tileCoord, findLoadedTiles, tmpTileRange, tmpExtent);
                  }
              }
          }
          var canvasScale = tileResolution / viewResolution;
          // set forward and inverse pixel transforms
          compose(this.pixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / tilePixelRatio, 1 / tilePixelRatio, rotation, -width / 2, -height / 2);
          var canvasTransform = createTransformString(this.pixelTransform);
          this.useContainer(target, canvasTransform, layerState.opacity);
          var context = this.context;
          var canvas = context.canvas;
          makeInverse(this.inversePixelTransform, this.pixelTransform);
          // set scale transform for calculating tile positions on the canvas
          compose(this.tempTransform, width / 2, height / 2, canvasScale, canvasScale, 0, -width / 2, -height / 2);
          if (canvas.width != width || canvas.height != height) {
              canvas.width = width;
              canvas.height = height;
          }
          else if (!this.containerReused) {
              context.clearRect(0, 0, width, height);
          }
          if (layerExtent) {
              this.clipUnrotated(context, frameState, layerExtent);
          }
          assign(context, tileSource.getContextOptions());
          this.preRender(context, frameState);
          this.renderedTiles.length = 0;
          /** @type {Array<number>} */
          var zs = Object.keys(tilesToDrawByZ).map(Number);
          zs.sort(numberSafeCompareFunction);
          var clips, clipZs, currentClip;
          if (layerState.opacity === 1 &&
              (!this.containerReused ||
                  tileSource.getOpaque(frameState.viewState.projection))) {
              zs = zs.reverse();
          }
          else {
              clips = [];
              clipZs = [];
          }
          for (var i = zs.length - 1; i >= 0; --i) {
              var currentZ = zs[i];
              var currentTilePixelSize = tileSource.getTilePixelSize(currentZ, pixelRatio, projection);
              var currentResolution = tileGrid.getResolution(currentZ);
              var currentScale = currentResolution / tileResolution;
              var dx_1 = currentTilePixelSize[0] * currentScale * canvasScale;
              var dy_1 = currentTilePixelSize[1] * currentScale * canvasScale;
              var originTileCoord = tileGrid.getTileCoordForCoordAndZ(getTopLeft(canvasExtent), currentZ);
              var originTileExtent = tileGrid.getTileCoordExtent(originTileCoord);
              var origin_1 = apply(this.tempTransform, [
                  (tilePixelRatio * (originTileExtent[0] - canvasExtent[0])) /
                      tileResolution,
                  (tilePixelRatio * (canvasExtent[3] - originTileExtent[3])) /
                      tileResolution,
              ]);
              var tileGutter = tilePixelRatio * tileSource.getGutterForProjection(projection);
              var tilesToDraw = tilesToDrawByZ[currentZ];
              for (var tileCoordKey in tilesToDraw) {
                  var tile = /** @type {import("../../ImageTile.js").default} */ (tilesToDraw[tileCoordKey]);
                  var tileCoord = tile.tileCoord;
                  // Calculate integer positions and sizes so that tiles align
                  var floatX = origin_1[0] - (originTileCoord[1] - tileCoord[1]) * dx_1;
                  var nextX = Math.round(floatX + dx_1);
                  var floatY = origin_1[1] - (originTileCoord[2] - tileCoord[2]) * dy_1;
                  var nextY = Math.round(floatY + dy_1);
                  var x = Math.round(floatX);
                  var y = Math.round(floatY);
                  var w = nextX - x;
                  var h = nextY - y;
                  var transition = z === currentZ;
                  var inTransition = transition && tile.getAlpha(getUid(this), frameState.time) !== 1;
                  if (!inTransition) {
                      if (clips) {
                          // Clip mask for regions in this tile that already filled by a higher z tile
                          context.save();
                          currentClip = [x, y, x + w, y, x + w, y + h, x, y + h];
                          for (var i_1 = 0, ii = clips.length; i_1 < ii; ++i_1) {
                              if (z !== currentZ && currentZ < clipZs[i_1]) {
                                  var clip = clips[i_1];
                                  context.beginPath();
                                  // counter-clockwise (outer ring) for current tile
                                  context.moveTo(currentClip[0], currentClip[1]);
                                  context.lineTo(currentClip[2], currentClip[3]);
                                  context.lineTo(currentClip[4], currentClip[5]);
                                  context.lineTo(currentClip[6], currentClip[7]);
                                  // clockwise (inner ring) for higher z tile
                                  context.moveTo(clip[6], clip[7]);
                                  context.lineTo(clip[4], clip[5]);
                                  context.lineTo(clip[2], clip[3]);
                                  context.lineTo(clip[0], clip[1]);
                                  context.clip();
                              }
                          }
                          clips.push(currentClip);
                          clipZs.push(currentZ);
                      }
                      else {
                          context.clearRect(x, y, w, h);
                      }
                  }
                  this.drawTileImage(tile, frameState, x, y, w, h, tileGutter, transition, layerState.opacity);
                  if (clips && !inTransition) {
                      context.restore();
                  }
                  this.renderedTiles.push(tile);
                  this.updateUsedTiles(frameState.usedTiles, tileSource, tile);
              }
          }
          this.renderedRevision = sourceRevision;
          this.renderedResolution = tileResolution;
          this.extentChanged =
              !this.renderedExtent_ || !equals$1(this.renderedExtent_, canvasExtent);
          this.renderedExtent_ = canvasExtent;
          this.renderedPixelRatio = pixelRatio;
          this.renderedProjection = projection;
          this.manageTilePyramid(frameState, tileSource, tileGrid, pixelRatio, projection, extent, z, tileLayer.getPreload());
          this.scheduleExpireCache(frameState, tileSource);
          this.postRender(context, frameState);
          if (layerState.extent) {
              context.restore();
          }
          if (canvasTransform !== canvas.style.transform) {
              canvas.style.transform = canvasTransform;
          }
          return this.container;
      };
      /**
       * @param {import("../../ImageTile.js").default} tile Tile.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @param {number} x Left of the tile.
       * @param {number} y Top of the tile.
       * @param {number} w Width of the tile.
       * @param {number} h Height of the tile.
       * @param {number} gutter Tile gutter.
       * @param {boolean} transition Apply an alpha transition.
       * @param {number} opacity Opacity.
       */
      CanvasTileLayerRenderer.prototype.drawTileImage = function (tile, frameState, x, y, w, h, gutter, transition, opacity) {
          var image = this.getTileImage(tile);
          if (!image) {
              return;
          }
          var uid = getUid(this);
          var tileAlpha = transition ? tile.getAlpha(uid, frameState.time) : 1;
          var alpha = opacity * tileAlpha;
          var alphaChanged = alpha !== this.context.globalAlpha;
          if (alphaChanged) {
              this.context.save();
              this.context.globalAlpha = alpha;
          }
          this.context.drawImage(image, gutter, gutter, image.width - 2 * gutter, image.height - 2 * gutter, x, y, w, h);
          if (alphaChanged) {
              this.context.restore();
          }
          if (tileAlpha !== 1) {
              frameState.animate = true;
          }
          else if (transition) {
              tile.endTransition(uid);
          }
      };
      /**
       * @return {HTMLCanvasElement} Image
       */
      CanvasTileLayerRenderer.prototype.getImage = function () {
          var context = this.context;
          return context ? context.canvas : null;
      };
      /**
       * Get the image from a tile.
       * @param {import("../../ImageTile.js").default} tile Tile.
       * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
       * @protected
       */
      CanvasTileLayerRenderer.prototype.getTileImage = function (tile) {
          return tile.getImage();
      };
      /**
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @param {import("../../source/Tile.js").default} tileSource Tile source.
       * @protected
       */
      CanvasTileLayerRenderer.prototype.scheduleExpireCache = function (frameState, tileSource) {
          if (tileSource.canExpireCache()) {
              /**
               * @param {import("../../source/Tile.js").default} tileSource Tile source.
               * @param {import("../../PluggableMap.js").default} map Map.
               * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
               */
              var postRenderFunction = function (tileSource, map, frameState) {
                  var tileSourceKey = getUid(tileSource);
                  if (tileSourceKey in frameState.usedTiles) {
                      tileSource.expireCache(frameState.viewState.projection, frameState.usedTiles[tileSourceKey]);
                  }
              }.bind(null, tileSource);
              frameState.postRenderFunctions.push(
              /** @type {import("../../PluggableMap.js").PostRenderFunction} */ (postRenderFunction));
          }
      };
      /**
       * @param {!Object<string, !Object<string, boolean>>} usedTiles Used tiles.
       * @param {import("../../source/Tile.js").default} tileSource Tile source.
       * @param {import('../../Tile.js').default} tile Tile.
       * @protected
       */
      CanvasTileLayerRenderer.prototype.updateUsedTiles = function (usedTiles, tileSource, tile) {
          // FIXME should we use tilesToDrawByZ instead?
          var tileSourceKey = getUid(tileSource);
          if (!(tileSourceKey in usedTiles)) {
              usedTiles[tileSourceKey] = {};
          }
          usedTiles[tileSourceKey][tile.getKey()] = true;
      };
      /**
       * Manage tile pyramid.
       * This function performs a number of functions related to the tiles at the
       * current zoom and lower zoom levels:
       * - registers idle tiles in frameState.wantedTiles so that they are not
       *   discarded by the tile queue
       * - enqueues missing tiles
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @param {import("../../source/Tile.js").default} tileSource Tile source.
       * @param {import("../../tilegrid/TileGrid.js").default} tileGrid Tile grid.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../../proj/Projection.js").default} projection Projection.
       * @param {import("../../extent.js").Extent} extent Extent.
       * @param {number} currentZ Current Z.
       * @param {number} preload Load low resolution tiles up to 'preload' levels.
       * @param {function(import("../../Tile.js").default)=} opt_tileCallback Tile callback.
       * @protected
       */
      CanvasTileLayerRenderer.prototype.manageTilePyramid = function (frameState, tileSource, tileGrid, pixelRatio, projection, extent, currentZ, preload, opt_tileCallback) {
          var tileSourceKey = getUid(tileSource);
          if (!(tileSourceKey in frameState.wantedTiles)) {
              frameState.wantedTiles[tileSourceKey] = {};
          }
          var wantedTiles = frameState.wantedTiles[tileSourceKey];
          var tileQueue = frameState.tileQueue;
          var minZoom = tileGrid.getMinZoom();
          var tileCount = 0;
          var tile, tileRange, tileResolution, x, y, z;
          for (z = minZoom; z <= currentZ; ++z) {
              tileRange = tileGrid.getTileRangeForExtentAndZ(extent, z, tileRange);
              tileResolution = tileGrid.getResolution(z);
              for (x = tileRange.minX; x <= tileRange.maxX; ++x) {
                  for (y = tileRange.minY; y <= tileRange.maxY; ++y) {
                      if (currentZ - z <= preload) {
                          ++tileCount;
                          tile = tileSource.getTile(z, x, y, pixelRatio, projection);
                          if (tile.getState() == TileState.IDLE) {
                              wantedTiles[tile.getKey()] = true;
                              if (!tileQueue.isKeyQueued(tile.getKey())) {
                                  tileQueue.enqueue([
                                      tile,
                                      tileSourceKey,
                                      tileGrid.getTileCoordCenter(tile.tileCoord),
                                      tileResolution,
                                  ]);
                              }
                          }
                          if (opt_tileCallback !== undefined) {
                              opt_tileCallback(tile);
                          }
                      }
                      else {
                          tileSource.useTile(z, x, y, projection);
                      }
                  }
              }
          }
          tileSource.updateCacheSize(tileCount, projection);
      };
      return CanvasTileLayerRenderer;
  }(CanvasLayerRenderer));
  /**
   * @function
   * @return {import("../../layer/Tile.js").default|import("../../layer/VectorTile.js").default}
   */
  CanvasTileLayerRenderer.prototype.getLayer;

  var __extends$18 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * For layer sources that provide pre-rendered, tiled images in grids that are
   * organized by zoom levels for specific resolutions.
   * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
   * property on the layer object; for example, setting `title: 'My Title'` in the
   * options means that `title` is observable, and has get/set accessors.
   *
   * @api
   */
  var TileLayer = /** @class */ (function (_super) {
      __extends$18(TileLayer, _super);
      /**
       * @param {import("./BaseTile.js").Options=} opt_options Tile layer options.
       */
      function TileLayer(opt_options) {
          return _super.call(this, opt_options) || this;
      }
      /**
       * Create a renderer for this layer.
       * @return {import("../renderer/Layer.js").default} A layer renderer.
       * @protected
       */
      TileLayer.prototype.createRenderer = function () {
          return new CanvasTileLayerRenderer(this);
      };
      return TileLayer;
  }(BaseTileLayer));

  var __extends$19 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * A function that takes an {@link module:ol/Tile} for the tile and a
   * `{string}` for the url as arguments. The default is
   * ```js
   * source.setTileLoadFunction(function(tile, src) {
   *   tile.getImage().src = src;
   * });
   * ```
   * For more fine grained control, the load function can use fetch or XMLHttpRequest and involve
   * error handling:
   *
   * ```js
   * import TileState from 'ol/TileState';
   *
   * source.setTileLoadFunction(function(tile, src) {
   *   var xhr = new XMLHttpRequest();
   *   xhr.responseType = 'blob';
   *   xhr.addEventListener('loadend', function (evt) {
   *     var data = this.response;
   *     if (data !== undefined) {
   *       tile.getImage().src = URL.createObjectURL(data);
   *     } else {
   *       tile.setState(TileState.ERROR);
   *     }
   *   });
   *   xhr.addEventListener('error', function () {
   *     tile.setState(TileState.ERROR);
   *   });
   *   xhr.open('GET', src);
   *   xhr.send();
   * });
   * ```
   *
   * @typedef {function(Tile, string): void} LoadFunction
   * @api
   */
  /**
   * {@link module:ol/source/Tile~Tile} sources use a function of this type to get
   * the url that provides a tile for a given tile coordinate.
   *
   * This function takes an {@link module:ol/tilecoord~TileCoord} for the tile
   * coordinate, a `{number}` representing the pixel ratio and a
   * {@link module:ol/proj/Projection} for the projection  as arguments
   * and returns a `{string}` representing the tile URL, or undefined if no tile
   * should be requested for the passed tile coordinate.
   *
   * @typedef {function(import("./tilecoord.js").TileCoord, number,
   *           import("./proj/Projection.js").default): (string|undefined)} UrlFunction
   * @api
   */
  /**
   * @typedef {Object} Options
   * @property {number} [transition=250] A duration for tile opacity
   * transitions in milliseconds. A duration of 0 disables the opacity transition.
   * @api
   */
  /**
   * @classdesc
   * Base class for tiles.
   *
   * @abstract
   */
  var Tile = /** @class */ (function (_super) {
      __extends$19(Tile, _super);
      /**
       * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {import("./TileState.js").default} state State.
       * @param {Options=} opt_options Tile options.
       */
      function Tile(tileCoord, state, opt_options) {
          var _this = _super.call(this) || this;
          var options = opt_options ? opt_options : {};
          /**
           * @type {import("./tilecoord.js").TileCoord}
           */
          _this.tileCoord = tileCoord;
          /**
           * @protected
           * @type {import("./TileState.js").default}
           */
          _this.state = state;
          /**
           * An "interim" tile for this tile. The interim tile may be used while this
           * one is loading, for "smooth" transitions when changing params/dimensions
           * on the source.
           * @type {Tile}
           */
          _this.interimTile = null;
          /**
           * The tile is available at the highest possible resolution. Subclasses can
           * set this to `false` initially. Tile load listeners will not be
           * unregistered before this is set to `true` and a `#changed()` is called.
           * @type {boolean}
           */
          _this.hifi = true;
          /**
           * A key assigned to the tile. This is used by the tile source to determine
           * if this tile can effectively be used, or if a new tile should be created
           * and this one be used as an interim tile for this new tile.
           * @type {string}
           */
          _this.key = '';
          /**
           * The duration for the opacity transition.
           * @type {number}
           */
          _this.transition_ =
              options.transition === undefined ? 250 : options.transition;
          /**
           * Lookup of start times for rendering transitions.  If the start time is
           * equal to -1, the transition is complete.
           * @type {Object<string, number>}
           */
          _this.transitionStarts_ = {};
          return _this;
      }
      /**
       * @protected
       */
      Tile.prototype.changed = function () {
          this.dispatchEvent(EventType.CHANGE);
      };
      /**
       * Called by the tile cache when the tile is removed from the cache due to expiry
       */
      Tile.prototype.release = function () { };
      /**
       * @return {string} Key.
       */
      Tile.prototype.getKey = function () {
          return this.key + '/' + this.tileCoord;
      };
      /**
       * Get the interim tile most suitable for rendering using the chain of interim
       * tiles. This corresponds to the  most recent tile that has been loaded, if no
       * such tile exists, the original tile is returned.
       * @return {!Tile} Best tile for rendering.
       */
      Tile.prototype.getInterimTile = function () {
          if (!this.interimTile) {
              //empty chain
              return this;
          }
          var tile = this.interimTile;
          // find the first loaded tile and return it. Since the chain is sorted in
          // decreasing order of creation time, there is no need to search the remainder
          // of the list (all those tiles correspond to older requests and will be
          // cleaned up by refreshInterimChain)
          do {
              if (tile.getState() == TileState.LOADED) {
                  // Show tile immediately instead of fading it in after loading, because
                  // the interim tile is in place already
                  this.transition_ = 0;
                  return tile;
              }
              tile = tile.interimTile;
          } while (tile);
          // we can not find a better tile
          return this;
      };
      /**
       * Goes through the chain of interim tiles and discards sections of the chain
       * that are no longer relevant.
       */
      Tile.prototype.refreshInterimChain = function () {
          if (!this.interimTile) {
              return;
          }
          var tile = this.interimTile;
          var prev = /** @type {Tile} */ (this);
          do {
              if (tile.getState() == TileState.LOADED) {
                  //we have a loaded tile, we can discard the rest of the list
                  //we would could abort any LOADING tile request
                  //older than this tile (i.e. any LOADING tile following this entry in the chain)
                  tile.interimTile = null;
                  break;
              }
              else if (tile.getState() == TileState.LOADING) {
                  //keep this LOADING tile any loaded tiles later in the chain are
                  //older than this tile, so we're still interested in the request
                  prev = tile;
              }
              else if (tile.getState() == TileState.IDLE) {
                  //the head of the list is the most current tile, we don't need
                  //to start any other requests for this chain
                  prev.interimTile = tile.interimTile;
              }
              else {
                  prev = tile;
              }
              tile = prev.interimTile;
          } while (tile);
      };
      /**
       * Get the tile coordinate for this tile.
       * @return {import("./tilecoord.js").TileCoord} The tile coordinate.
       * @api
       */
      Tile.prototype.getTileCoord = function () {
          return this.tileCoord;
      };
      /**
       * @return {import("./TileState.js").default} State.
       */
      Tile.prototype.getState = function () {
          return this.state;
      };
      /**
       * Sets the state of this tile. If you write your own {@link module:ol/Tile~LoadFunction tileLoadFunction} ,
       * it is important to set the state correctly to {@link module:ol/TileState~ERROR}
       * when the tile cannot be loaded. Otherwise the tile cannot be removed from
       * the tile queue and will block other requests.
       * @param {import("./TileState.js").default} state State.
       * @api
       */
      Tile.prototype.setState = function (state) {
          if (this.state !== TileState.ERROR && this.state > state) {
              throw new Error('Tile load sequence violation');
          }
          this.state = state;
          this.changed();
      };
      /**
       * Load the image or retry if loading previously failed.
       * Loading is taken care of by the tile queue, and calling this method is
       * only needed for preloading or for reloading in case of an error.
       * @abstract
       * @api
       */
      Tile.prototype.load = function () {
          abstract();
      };
      /**
       * Get the alpha value for rendering.
       * @param {string} id An id for the renderer.
       * @param {number} time The render frame time.
       * @return {number} A number between 0 and 1.
       */
      Tile.prototype.getAlpha = function (id, time) {
          if (!this.transition_) {
              return 1;
          }
          var start = this.transitionStarts_[id];
          if (!start) {
              start = time;
              this.transitionStarts_[id] = start;
          }
          else if (start === -1) {
              return 1;
          }
          var delta = time - start + 1000 / 60; // avoid rendering at 0
          if (delta >= this.transition_) {
              return 1;
          }
          return easeIn(delta / this.transition_);
      };
      /**
       * Determine if a tile is in an alpha transition.  A tile is considered in
       * transition if tile.getAlpha() has not yet been called or has been called
       * and returned 1.
       * @param {string} id An id for the renderer.
       * @return {boolean} The tile is in transition.
       */
      Tile.prototype.inTransition = function (id) {
          if (!this.transition_) {
              return false;
          }
          return this.transitionStarts_[id] !== -1;
      };
      /**
       * Mark a transition as complete.
       * @param {string} id An id for the renderer.
       */
      Tile.prototype.endTransition = function (id) {
          if (this.transition_) {
              this.transitionStarts_[id] = -1;
          }
      };
      return Tile;
  }(Target));

  var __extends$1a = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var ImageTile = /** @class */ (function (_super) {
      __extends$1a(ImageTile, _super);
      /**
       * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {import("./TileState.js").default} state State.
       * @param {string} src Image source URI.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("./Tile.js").LoadFunction} tileLoadFunction Tile load function.
       * @param {import("./Tile.js").Options=} opt_options Tile options.
       */
      function ImageTile(tileCoord, state, src, crossOrigin, tileLoadFunction, opt_options) {
          var _this = _super.call(this, tileCoord, state, opt_options) || this;
          /**
           * @private
           * @type {?string}
           */
          _this.crossOrigin_ = crossOrigin;
          /**
           * Image URI
           *
           * @private
           * @type {string}
           */
          _this.src_ = src;
          /**
           * @private
           * @type {HTMLImageElement|HTMLCanvasElement}
           */
          _this.image_ = new Image();
          if (crossOrigin !== null) {
              _this.image_.crossOrigin = crossOrigin;
          }
          /**
           * @private
           * @type {?function():void}
           */
          _this.unlisten_ = null;
          /**
           * @private
           * @type {import("./Tile.js").LoadFunction}
           */
          _this.tileLoadFunction_ = tileLoadFunction;
          return _this;
      }
      /**
       * Get the HTML image element for this tile (may be a Canvas, Image, or Video).
       * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
       * @api
       */
      ImageTile.prototype.getImage = function () {
          return this.image_;
      };
      /**
       * @return {string} Key.
       */
      ImageTile.prototype.getKey = function () {
          return this.src_;
      };
      /**
       * Tracks loading or read errors.
       *
       * @private
       */
      ImageTile.prototype.handleImageError_ = function () {
          this.state = TileState.ERROR;
          this.unlistenImage_();
          this.image_ = getBlankImage();
          this.changed();
      };
      /**
       * Tracks successful image load.
       *
       * @private
       */
      ImageTile.prototype.handleImageLoad_ = function () {
          var image = /** @type {HTMLImageElement} */ (this.image_);
          if (image.naturalWidth && image.naturalHeight) {
              this.state = TileState.LOADED;
          }
          else {
              this.state = TileState.EMPTY;
          }
          this.unlistenImage_();
          this.changed();
      };
      /**
       * Load not yet loaded URI.
       * @api
       */
      ImageTile.prototype.load = function () {
          if (this.state == TileState.ERROR) {
              this.state = TileState.IDLE;
              this.image_ = new Image();
              if (this.crossOrigin_ !== null) {
                  this.image_.crossOrigin = this.crossOrigin_;
              }
          }
          if (this.state == TileState.IDLE) {
              this.state = TileState.LOADING;
              this.changed();
              this.tileLoadFunction_(this, this.src_);
              this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
          }
      };
      /**
       * Discards event handlers which listen for load completion or errors.
       *
       * @private
       */
      ImageTile.prototype.unlistenImage_ = function () {
          if (this.unlisten_) {
              this.unlisten_();
              this.unlisten_ = null;
          }
      };
      return ImageTile;
  }(Tile));
  /**
   * Get a 1-pixel blank image.
   * @return {HTMLCanvasElement} Blank image.
   */
  function getBlankImage() {
      var ctx = createCanvasContext2D(1, 1);
      ctx.fillStyle = 'rgba(0,0,0,0)';
      ctx.fillRect(0, 0, 1, 1);
      return ctx.canvas;
  }

  /**
   * @module ol/reproj/common
   */
  /**
   * Default maximum allowed threshold  (in pixels) for reprojection
   * triangulation.
   * @type {number}
   */
  var ERROR_THRESHOLD = 0.5;

  /**
   * @module ol/reproj/Triangulation
   */
  /**
   * Single triangle; consists of 3 source points and 3 target points.
   * @typedef {Object} Triangle
   * @property {Array<import("../coordinate.js").Coordinate>} source
   * @property {Array<import("../coordinate.js").Coordinate>} target
   */
  /**
   * Maximum number of subdivision steps during raster reprojection triangulation.
   * Prevents high memory usage and large number of proj4 calls (for certain
   * transformations and areas). At most `2*(2^this)` triangles are created for
   * each triangulated extent (tile/image).
   * @type {number}
   */
  var MAX_SUBDIVISION = 10;
  /**
   * Maximum allowed size of triangle relative to world width. When transforming
   * corners of world extent between certain projections, the resulting
   * triangulation seems to have zero error and no subdivision is performed. If
   * the triangle width is more than this (relative to world width; 0-1),
   * subdivison is forced (up to `MAX_SUBDIVISION`). Default is `0.25`.
   * @type {number}
   */
  var MAX_TRIANGLE_WIDTH = 0.25;
  /**
   * @classdesc
   * Class containing triangulation of the given target extent.
   * Used for determining source data and the reprojection itself.
   */
  var Triangulation = /** @class */ (function () {
      /**
       * @param {import("../proj/Projection.js").default} sourceProj Source projection.
       * @param {import("../proj/Projection.js").default} targetProj Target projection.
       * @param {import("../extent.js").Extent} targetExtent Target extent to triangulate.
       * @param {import("../extent.js").Extent} maxSourceExtent Maximal source extent that can be used.
       * @param {number} errorThreshold Acceptable error (in source units).
       * @param {?number} opt_destinationResolution The (optional) resolution of the destination.
       */
      function Triangulation(sourceProj, targetProj, targetExtent, maxSourceExtent, errorThreshold, opt_destinationResolution) {
          /**
           * @type {import("../proj/Projection.js").default}
           * @private
           */
          this.sourceProj_ = sourceProj;
          /**
           * @type {import("../proj/Projection.js").default}
           * @private
           */
          this.targetProj_ = targetProj;
          /** @type {!Object<string, import("../coordinate.js").Coordinate>} */
          var transformInvCache = {};
          var transformInv = getTransform(this.targetProj_, this.sourceProj_);
          /**
           * @param {import("../coordinate.js").Coordinate} c A coordinate.
           * @return {import("../coordinate.js").Coordinate} Transformed coordinate.
           * @private
           */
          this.transformInv_ = function (c) {
              var key = c[0] + '/' + c[1];
              if (!transformInvCache[key]) {
                  transformInvCache[key] = transformInv(c);
              }
              return transformInvCache[key];
          };
          /**
           * @type {import("../extent.js").Extent}
           * @private
           */
          this.maxSourceExtent_ = maxSourceExtent;
          /**
           * @type {number}
           * @private
           */
          this.errorThresholdSquared_ = errorThreshold * errorThreshold;
          /**
           * @type {Array<Triangle>}
           * @private
           */
          this.triangles_ = [];
          /**
           * Indicates that the triangulation crosses edge of the source projection.
           * @type {boolean}
           * @private
           */
          this.wrapsXInSource_ = false;
          /**
           * @type {boolean}
           * @private
           */
          this.canWrapXInSource_ =
              this.sourceProj_.canWrapX() &&
                  !!maxSourceExtent &&
                  !!this.sourceProj_.getExtent() &&
                  getWidth(maxSourceExtent) == getWidth(this.sourceProj_.getExtent());
          /**
           * @type {?number}
           * @private
           */
          this.sourceWorldWidth_ = this.sourceProj_.getExtent()
              ? getWidth(this.sourceProj_.getExtent())
              : null;
          /**
           * @type {?number}
           * @private
           */
          this.targetWorldWidth_ = this.targetProj_.getExtent()
              ? getWidth(this.targetProj_.getExtent())
              : null;
          var destinationTopLeft = getTopLeft(targetExtent);
          var destinationTopRight = getTopRight(targetExtent);
          var destinationBottomRight = getBottomRight(targetExtent);
          var destinationBottomLeft = getBottomLeft(targetExtent);
          var sourceTopLeft = this.transformInv_(destinationTopLeft);
          var sourceTopRight = this.transformInv_(destinationTopRight);
          var sourceBottomRight = this.transformInv_(destinationBottomRight);
          var sourceBottomLeft = this.transformInv_(destinationBottomLeft);
          /*
           * The maxSubdivision controls how many splittings of the target area can
           * be done. The idea here is to do a linear mapping of the target areas
           * but the actual overal reprojection (can be) extremely non-linear. The
           * default value of MAX_SUBDIVISION was chosen based on mapping a 256x256
           * tile size. However this function is also called to remap canvas rendered
           * layers which can be much larger. This calculation increases the maxSubdivision
           * value by the right factor so that each 256x256 pixel area has
           * MAX_SUBDIVISION divisions.
           */
          var maxSubdivision = MAX_SUBDIVISION +
              (opt_destinationResolution
                  ? Math.max(0, Math.ceil(log2(getArea(targetExtent) /
                      (opt_destinationResolution *
                          opt_destinationResolution *
                          256 *
                          256))))
                  : 0);
          this.addQuad_(destinationTopLeft, destinationTopRight, destinationBottomRight, destinationBottomLeft, sourceTopLeft, sourceTopRight, sourceBottomRight, sourceBottomLeft, maxSubdivision);
          if (this.wrapsXInSource_) {
              var leftBound_1 = Infinity;
              this.triangles_.forEach(function (triangle, i, arr) {
                  leftBound_1 = Math.min(leftBound_1, triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]);
              });
              // Shift triangles to be as close to `leftBound` as possible
              // (if the distance is more than `worldWidth / 2` it can be closer.
              this.triangles_.forEach(function (triangle) {
                  if (Math.max(triangle.source[0][0], triangle.source[1][0], triangle.source[2][0]) -
                      leftBound_1 >
                      this.sourceWorldWidth_ / 2) {
                      var newTriangle = [
                          [triangle.source[0][0], triangle.source[0][1]],
                          [triangle.source[1][0], triangle.source[1][1]],
                          [triangle.source[2][0], triangle.source[2][1]],
                      ];
                      if (newTriangle[0][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
                          newTriangle[0][0] -= this.sourceWorldWidth_;
                      }
                      if (newTriangle[1][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
                          newTriangle[1][0] -= this.sourceWorldWidth_;
                      }
                      if (newTriangle[2][0] - leftBound_1 > this.sourceWorldWidth_ / 2) {
                          newTriangle[2][0] -= this.sourceWorldWidth_;
                      }
                      // Rarely (if the extent contains both the dateline and prime meridian)
                      // the shift can in turn break some triangles.
                      // Detect this here and don't shift in such cases.
                      var minX = Math.min(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
                      var maxX = Math.max(newTriangle[0][0], newTriangle[1][0], newTriangle[2][0]);
                      if (maxX - minX < this.sourceWorldWidth_ / 2) {
                          triangle.source = newTriangle;
                      }
                  }
              }.bind(this));
          }
          transformInvCache = {};
      }
      /**
       * Adds triangle to the triangulation.
       * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
       * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
       * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
       * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
       * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
       * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
       * @private
       */
      Triangulation.prototype.addTriangle_ = function (a, b, c, aSrc, bSrc, cSrc) {
          this.triangles_.push({
              source: [aSrc, bSrc, cSrc],
              target: [a, b, c],
          });
      };
      /**
       * Adds quad (points in clock-wise order) to the triangulation
       * (and reprojects the vertices) if valid.
       * Performs quad subdivision if needed to increase precision.
       *
       * @param {import("../coordinate.js").Coordinate} a The target a coordinate.
       * @param {import("../coordinate.js").Coordinate} b The target b coordinate.
       * @param {import("../coordinate.js").Coordinate} c The target c coordinate.
       * @param {import("../coordinate.js").Coordinate} d The target d coordinate.
       * @param {import("../coordinate.js").Coordinate} aSrc The source a coordinate.
       * @param {import("../coordinate.js").Coordinate} bSrc The source b coordinate.
       * @param {import("../coordinate.js").Coordinate} cSrc The source c coordinate.
       * @param {import("../coordinate.js").Coordinate} dSrc The source d coordinate.
       * @param {number} maxSubdivision Maximal allowed subdivision of the quad.
       * @private
       */
      Triangulation.prototype.addQuad_ = function (a, b, c, d, aSrc, bSrc, cSrc, dSrc, maxSubdivision) {
          var sourceQuadExtent = boundingExtent([aSrc, bSrc, cSrc, dSrc]);
          var sourceCoverageX = this.sourceWorldWidth_
              ? getWidth(sourceQuadExtent) / this.sourceWorldWidth_
              : null;
          var sourceWorldWidth = /** @type {number} */ (this.sourceWorldWidth_);
          // when the quad is wrapped in the source projection
          // it covers most of the projection extent, but not fully
          var wrapsX = this.sourceProj_.canWrapX() &&
              sourceCoverageX > 0.5 &&
              sourceCoverageX < 1;
          var needsSubdivision = false;
          if (maxSubdivision > 0) {
              if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
                  var targetQuadExtent = boundingExtent([a, b, c, d]);
                  var targetCoverageX = getWidth(targetQuadExtent) / this.targetWorldWidth_;
                  needsSubdivision =
                      targetCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
              }
              if (!wrapsX && this.sourceProj_.isGlobal() && sourceCoverageX) {
                  needsSubdivision =
                      sourceCoverageX > MAX_TRIANGLE_WIDTH || needsSubdivision;
              }
          }
          if (!needsSubdivision && this.maxSourceExtent_) {
              if (isFinite(sourceQuadExtent[0]) &&
                  isFinite(sourceQuadExtent[1]) &&
                  isFinite(sourceQuadExtent[2]) &&
                  isFinite(sourceQuadExtent[3])) {
                  if (!intersects(sourceQuadExtent, this.maxSourceExtent_)) {
                      // whole quad outside source projection extent -> ignore
                      return;
                  }
              }
          }
          var isNotFinite = 0;
          if (!needsSubdivision) {
              if (!isFinite(aSrc[0]) ||
                  !isFinite(aSrc[1]) ||
                  !isFinite(bSrc[0]) ||
                  !isFinite(bSrc[1]) ||
                  !isFinite(cSrc[0]) ||
                  !isFinite(cSrc[1]) ||
                  !isFinite(dSrc[0]) ||
                  !isFinite(dSrc[1])) {
                  if (maxSubdivision > 0) {
                      needsSubdivision = true;
                  }
                  else {
                      // It might be the case that only 1 of the points is infinite. In this case
                      // we can draw a single triangle with the other three points
                      isNotFinite =
                          (!isFinite(aSrc[0]) || !isFinite(aSrc[1]) ? 8 : 0) +
                              (!isFinite(bSrc[0]) || !isFinite(bSrc[1]) ? 4 : 0) +
                              (!isFinite(cSrc[0]) || !isFinite(cSrc[1]) ? 2 : 0) +
                              (!isFinite(dSrc[0]) || !isFinite(dSrc[1]) ? 1 : 0);
                      if (isNotFinite != 1 &&
                          isNotFinite != 2 &&
                          isNotFinite != 4 &&
                          isNotFinite != 8) {
                          return;
                      }
                  }
              }
          }
          if (maxSubdivision > 0) {
              if (!needsSubdivision) {
                  var center = [(a[0] + c[0]) / 2, (a[1] + c[1]) / 2];
                  var centerSrc = this.transformInv_(center);
                  var dx = void 0;
                  if (wrapsX) {
                      var centerSrcEstimX = (modulo(aSrc[0], sourceWorldWidth) +
                          modulo(cSrc[0], sourceWorldWidth)) /
                          2;
                      dx = centerSrcEstimX - modulo(centerSrc[0], sourceWorldWidth);
                  }
                  else {
                      dx = (aSrc[0] + cSrc[0]) / 2 - centerSrc[0];
                  }
                  var dy = (aSrc[1] + cSrc[1]) / 2 - centerSrc[1];
                  var centerSrcErrorSquared = dx * dx + dy * dy;
                  needsSubdivision = centerSrcErrorSquared > this.errorThresholdSquared_;
              }
              if (needsSubdivision) {
                  if (Math.abs(a[0] - c[0]) <= Math.abs(a[1] - c[1])) {
                      // split horizontally (top & bottom)
                      var bc = [(b[0] + c[0]) / 2, (b[1] + c[1]) / 2];
                      var bcSrc = this.transformInv_(bc);
                      var da = [(d[0] + a[0]) / 2, (d[1] + a[1]) / 2];
                      var daSrc = this.transformInv_(da);
                      this.addQuad_(a, b, bc, da, aSrc, bSrc, bcSrc, daSrc, maxSubdivision - 1);
                      this.addQuad_(da, bc, c, d, daSrc, bcSrc, cSrc, dSrc, maxSubdivision - 1);
                  }
                  else {
                      // split vertically (left & right)
                      var ab = [(a[0] + b[0]) / 2, (a[1] + b[1]) / 2];
                      var abSrc = this.transformInv_(ab);
                      var cd = [(c[0] + d[0]) / 2, (c[1] + d[1]) / 2];
                      var cdSrc = this.transformInv_(cd);
                      this.addQuad_(a, ab, cd, d, aSrc, abSrc, cdSrc, dSrc, maxSubdivision - 1);
                      this.addQuad_(ab, b, c, cd, abSrc, bSrc, cSrc, cdSrc, maxSubdivision - 1);
                  }
                  return;
              }
          }
          if (wrapsX) {
              if (!this.canWrapXInSource_) {
                  return;
              }
              this.wrapsXInSource_ = true;
          }
          // Exactly zero or one of *Src is not finite
          // The triangles must have the diagonal line as the first side
          // This is to allow easy code in reproj.s to make it straight for broken
          // browsers that can't handle diagonal clipping
          if ((isNotFinite & 0xb) == 0) {
              this.addTriangle_(a, c, d, aSrc, cSrc, dSrc);
          }
          if ((isNotFinite & 0xe) == 0) {
              this.addTriangle_(a, c, b, aSrc, cSrc, bSrc);
          }
          if (isNotFinite) {
              // Try the other two triangles
              if ((isNotFinite & 0xd) == 0) {
                  this.addTriangle_(b, d, a, bSrc, dSrc, aSrc);
              }
              if ((isNotFinite & 0x7) == 0) {
                  this.addTriangle_(b, d, c, bSrc, dSrc, cSrc);
              }
          }
      };
      /**
       * Calculates extent of the 'source' coordinates from all the triangles.
       *
       * @return {import("../extent.js").Extent} Calculated extent.
       */
      Triangulation.prototype.calculateSourceExtent = function () {
          var extent = createEmpty();
          this.triangles_.forEach(function (triangle, i, arr) {
              var src = triangle.source;
              extendCoordinate(extent, src[0]);
              extendCoordinate(extent, src[1]);
              extendCoordinate(extent, src[2]);
          });
          return extent;
      };
      /**
       * @return {Array<Triangle>} Array of the calculated triangles.
       */
      Triangulation.prototype.getTriangles = function () {
          return this.triangles_;
      };
      return Triangulation;
  }());

  /**
   * @module ol/source/common
   */
  /**
   * Default WMS version.
   * @type {string}
   */
  var DEFAULT_WMS_VERSION = '1.3.0';
  /**
   * Context options to disable image smoothing.
   * @type {Object}
   */
  var IMAGE_SMOOTHING_DISABLED = {
      imageSmoothingEnabled: false,
      msImageSmoothingEnabled: false,
  };

  /**
   * @module ol/reproj
   */
  var brokenDiagonalRendering_;
  /**
   * This draws a small triangle into a canvas by setting the triangle as the clip region
   * and then drawing a (too large) rectangle
   *
   * @param {CanvasRenderingContext2D} ctx The context in which to draw the triangle
   * @param {number} u1 The x-coordinate of the second point. The first point is 0,0.
   * @param {number} v1 The y-coordinate of the second point.
   * @param {number} u2 The x-coordinate of the third point.
   * @param {number} v2 The y-coordinate of the third point.
   */
  function drawTestTriangle(ctx, u1, v1, u2, v2) {
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(u1, v1);
      ctx.lineTo(u2, v2);
      ctx.closePath();
      ctx.save();
      ctx.clip();
      ctx.fillRect(0, 0, Math.max(u1, u2) + 1, Math.max(v1, v2));
      ctx.restore();
  }
  /**
   * Given the data from getImageData, see if the right values appear at the provided offset.
   * Returns true if either the color or transparency is off
   *
   * @param {Uint8ClampedArray} data The data returned from getImageData
   * @param {number} offset The pixel offset from the start of data.
   * @return {boolean} true if the diagonal rendering is broken
   */
  function verifyBrokenDiagonalRendering(data, offset) {
      // the values ought to be close to the rgba(210, 0, 0, 0.75)
      return (Math.abs(data[offset * 4] - 210) > 2 ||
          Math.abs(data[offset * 4 + 3] - 0.75 * 255) > 2);
  }
  /**
   * Determines if the current browser configuration can render triangular clip regions correctly.
   * This value is cached so the function is only expensive the first time called.
   * Firefox on Windows (as of now) does not if HWA is enabled. See https://bugzilla.mozilla.org/show_bug.cgi?id=1606976
   * IE also doesn't. Chrome works, and everything seems to work on OSX and Android. This function caches the
   * result. I suppose that it is conceivably possible that a browser might flip modes while the app is
   * running, but lets hope not.
   *
   * @return {boolean} true if the Diagonal Rendering is broken.
   */
  function isBrokenDiagonalRendering() {
      if (brokenDiagonalRendering_ === undefined) {
          var ctx = document.createElement('canvas').getContext('2d');
          ctx.globalCompositeOperation = 'lighter';
          ctx.fillStyle = 'rgba(210, 0, 0, 0.75)';
          drawTestTriangle(ctx, 4, 5, 4, 0);
          drawTestTriangle(ctx, 4, 5, 0, 5);
          var data = ctx.getImageData(0, 0, 3, 3).data;
          brokenDiagonalRendering_ =
              verifyBrokenDiagonalRendering(data, 0) ||
                  verifyBrokenDiagonalRendering(data, 4) ||
                  verifyBrokenDiagonalRendering(data, 8);
      }
      return brokenDiagonalRendering_;
  }
  /**
   * Calculates ideal resolution to use from the source in order to achieve
   * pixel mapping as close as possible to 1:1 during reprojection.
   * The resolution is calculated regardless of what resolutions
   * are actually available in the dataset (TileGrid, Image, ...).
   *
   * @param {import("./proj/Projection.js").default} sourceProj Source projection.
   * @param {import("./proj/Projection.js").default} targetProj Target projection.
   * @param {import("./coordinate.js").Coordinate} targetCenter Target center.
   * @param {number} targetResolution Target resolution.
   * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
   */
  function calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution) {
      var sourceCenter = transform(targetCenter, targetProj, sourceProj);
      // calculate the ideal resolution of the source data
      var sourceResolution = getPointResolution(targetProj, targetResolution, targetCenter);
      var targetMetersPerUnit = targetProj.getMetersPerUnit();
      if (targetMetersPerUnit !== undefined) {
          sourceResolution *= targetMetersPerUnit;
      }
      var sourceMetersPerUnit = sourceProj.getMetersPerUnit();
      if (sourceMetersPerUnit !== undefined) {
          sourceResolution /= sourceMetersPerUnit;
      }
      // Based on the projection properties, the point resolution at the specified
      // coordinates may be slightly different. We need to reverse-compensate this
      // in order to achieve optimal results.
      var sourceExtent = sourceProj.getExtent();
      if (!sourceExtent || containsCoordinate(sourceExtent, sourceCenter)) {
          var compensationFactor = getPointResolution(sourceProj, sourceResolution, sourceCenter) /
              sourceResolution;
          if (isFinite(compensationFactor) && compensationFactor > 0) {
              sourceResolution /= compensationFactor;
          }
      }
      return sourceResolution;
  }
  /**
   * Calculates ideal resolution to use from the source in order to achieve
   * pixel mapping as close as possible to 1:1 during reprojection.
   * The resolution is calculated regardless of what resolutions
   * are actually available in the dataset (TileGrid, Image, ...).
   *
   * @param {import("./proj/Projection.js").default} sourceProj Source projection.
   * @param {import("./proj/Projection.js").default} targetProj Target projection.
   * @param {import("./extent.js").Extent} targetExtent Target extent
   * @param {number} targetResolution Target resolution.
   * @return {number} The best resolution to use. Can be +-Infinity, NaN or 0.
   */
  function calculateSourceExtentResolution(sourceProj, targetProj, targetExtent, targetResolution) {
      var targetCenter = getCenter(targetExtent);
      var sourceResolution = calculateSourceResolution(sourceProj, targetProj, targetCenter, targetResolution);
      if (!isFinite(sourceResolution) || sourceResolution <= 0) {
          forEachCorner(targetExtent, function (corner) {
              sourceResolution = calculateSourceResolution(sourceProj, targetProj, corner, targetResolution);
              return isFinite(sourceResolution) && sourceResolution > 0;
          });
      }
      return sourceResolution;
  }
  /**
   * Renders the source data into new canvas based on the triangulation.
   *
   * @param {number} width Width of the canvas.
   * @param {number} height Height of the canvas.
   * @param {number} pixelRatio Pixel ratio.
   * @param {number} sourceResolution Source resolution.
   * @param {import("./extent.js").Extent} sourceExtent Extent of the data source.
   * @param {number} targetResolution Target resolution.
   * @param {import("./extent.js").Extent} targetExtent Target extent.
   * @param {import("./reproj/Triangulation.js").default} triangulation
   * Calculated triangulation.
   * @param {Array<{extent: import("./extent.js").Extent,
   *                 image: (HTMLCanvasElement|HTMLImageElement|HTMLVideoElement)}>} sources
   * Array of sources.
   * @param {number} gutter Gutter of the sources.
   * @param {boolean=} opt_renderEdges Render reprojection edges.
   * @param {object=} opt_contextOptions Properties to set on the canvas context.
   * @return {HTMLCanvasElement} Canvas with reprojected data.
   */
  function render(width, height, pixelRatio, sourceResolution, sourceExtent, targetResolution, targetExtent, triangulation, sources, gutter, opt_renderEdges, opt_contextOptions) {
      var context = createCanvasContext2D(Math.round(pixelRatio * width), Math.round(pixelRatio * height));
      assign(context, opt_contextOptions);
      if (sources.length === 0) {
          return context.canvas;
      }
      context.scale(pixelRatio, pixelRatio);
      function pixelRound(value) {
          return Math.round(value * pixelRatio) / pixelRatio;
      }
      context.globalCompositeOperation = 'lighter';
      var sourceDataExtent = createEmpty();
      sources.forEach(function (src, i, arr) {
          extend$1(sourceDataExtent, src.extent);
      });
      var canvasWidthInUnits = getWidth(sourceDataExtent);
      var canvasHeightInUnits = getHeight(sourceDataExtent);
      var stitchContext = createCanvasContext2D(Math.round((pixelRatio * canvasWidthInUnits) / sourceResolution), Math.round((pixelRatio * canvasHeightInUnits) / sourceResolution));
      assign(stitchContext, opt_contextOptions);
      var stitchScale = pixelRatio / sourceResolution;
      sources.forEach(function (src, i, arr) {
          var xPos = src.extent[0] - sourceDataExtent[0];
          var yPos = -(src.extent[3] - sourceDataExtent[3]);
          var srcWidth = getWidth(src.extent);
          var srcHeight = getHeight(src.extent);
          // This test should never fail -- but it does. Need to find a fix the upstream condition
          if (src.image.width > 0 && src.image.height > 0) {
              stitchContext.drawImage(src.image, gutter, gutter, src.image.width - 2 * gutter, src.image.height - 2 * gutter, xPos * stitchScale, yPos * stitchScale, srcWidth * stitchScale, srcHeight * stitchScale);
          }
      });
      var targetTopLeft = getTopLeft(targetExtent);
      triangulation.getTriangles().forEach(function (triangle, i, arr) {
          /* Calculate affine transform (src -> dst)
           * Resulting matrix can be used to transform coordinate
           * from `sourceProjection` to destination pixels.
           *
           * To optimize number of context calls and increase numerical stability,
           * we also do the following operations:
           * trans(-topLeftExtentCorner), scale(1 / targetResolution), scale(1, -1)
           * here before solving the linear system so [ui, vi] are pixel coordinates.
           *
           * Src points: xi, yi
           * Dst points: ui, vi
           * Affine coefficients: aij
           *
           * | x0 y0 1  0  0 0 |   |a00|   |u0|
           * | x1 y1 1  0  0 0 |   |a01|   |u1|
           * | x2 y2 1  0  0 0 | x |a02| = |u2|
           * |  0  0 0 x0 y0 1 |   |a10|   |v0|
           * |  0  0 0 x1 y1 1 |   |a11|   |v1|
           * |  0  0 0 x2 y2 1 |   |a12|   |v2|
           */
          var source = triangle.source;
          var target = triangle.target;
          var x0 = source[0][0], y0 = source[0][1];
          var x1 = source[1][0], y1 = source[1][1];
          var x2 = source[2][0], y2 = source[2][1];
          // Make sure that everything is on pixel boundaries
          var u0 = pixelRound((target[0][0] - targetTopLeft[0]) / targetResolution);
          var v0 = pixelRound(-(target[0][1] - targetTopLeft[1]) / targetResolution);
          var u1 = pixelRound((target[1][0] - targetTopLeft[0]) / targetResolution);
          var v1 = pixelRound(-(target[1][1] - targetTopLeft[1]) / targetResolution);
          var u2 = pixelRound((target[2][0] - targetTopLeft[0]) / targetResolution);
          var v2 = pixelRound(-(target[2][1] - targetTopLeft[1]) / targetResolution);
          // Shift all the source points to improve numerical stability
          // of all the subsequent calculations. The [x0, y0] is used here.
          // This is also used to simplify the linear system.
          var sourceNumericalShiftX = x0;
          var sourceNumericalShiftY = y0;
          x0 = 0;
          y0 = 0;
          x1 -= sourceNumericalShiftX;
          y1 -= sourceNumericalShiftY;
          x2 -= sourceNumericalShiftX;
          y2 -= sourceNumericalShiftY;
          var augmentedMatrix = [
              [x1, y1, 0, 0, u1 - u0],
              [x2, y2, 0, 0, u2 - u0],
              [0, 0, x1, y1, v1 - v0],
              [0, 0, x2, y2, v2 - v0],
          ];
          var affineCoefs = solveLinearSystem(augmentedMatrix);
          if (!affineCoefs) {
              return;
          }
          context.save();
          context.beginPath();
          if (isBrokenDiagonalRendering() ||
              opt_contextOptions === IMAGE_SMOOTHING_DISABLED) {
              // Make sure that all lines are horizontal or vertical
              context.moveTo(u1, v1);
              // This is the diagonal line. Do it in 4 steps
              var steps = 4;
              var ud = u0 - u1;
              var vd = v0 - v1;
              for (var step = 0; step < steps; step++) {
                  // Go horizontally
                  context.lineTo(u1 + pixelRound(((step + 1) * ud) / steps), v1 + pixelRound((step * vd) / (steps - 1)));
                  // Go vertically
                  if (step != steps - 1) {
                      context.lineTo(u1 + pixelRound(((step + 1) * ud) / steps), v1 + pixelRound(((step + 1) * vd) / (steps - 1)));
                  }
              }
              // We are almost at u0r, v0r
              context.lineTo(u2, v2);
          }
          else {
              context.moveTo(u1, v1);
              context.lineTo(u0, v0);
              context.lineTo(u2, v2);
          }
          context.clip();
          context.transform(affineCoefs[0], affineCoefs[2], affineCoefs[1], affineCoefs[3], u0, v0);
          context.translate(sourceDataExtent[0] - sourceNumericalShiftX, sourceDataExtent[3] - sourceNumericalShiftY);
          context.scale(sourceResolution / pixelRatio, -sourceResolution / pixelRatio);
          context.drawImage(stitchContext.canvas, 0, 0);
          context.restore();
      });
      if (opt_renderEdges) {
          context.save();
          context.globalCompositeOperation = 'source-over';
          context.strokeStyle = 'black';
          context.lineWidth = 1;
          triangulation.getTriangles().forEach(function (triangle, i, arr) {
              var target = triangle.target;
              var u0 = (target[0][0] - targetTopLeft[0]) / targetResolution;
              var v0 = -(target[0][1] - targetTopLeft[1]) / targetResolution;
              var u1 = (target[1][0] - targetTopLeft[0]) / targetResolution;
              var v1 = -(target[1][1] - targetTopLeft[1]) / targetResolution;
              var u2 = (target[2][0] - targetTopLeft[0]) / targetResolution;
              var v2 = -(target[2][1] - targetTopLeft[1]) / targetResolution;
              context.beginPath();
              context.moveTo(u1, v1);
              context.lineTo(u0, v0);
              context.lineTo(u2, v2);
              context.closePath();
              context.stroke();
          });
          context.restore();
      }
      return context.canvas;
  }

  var __extends$1b = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {function(number, number, number, number) : import("../Tile.js").default} FunctionType
   */
  /**
   * @classdesc
   * Class encapsulating single reprojected tile.
   * See {@link module:ol/source/TileImage~TileImage}.
   *
   */
  var ReprojTile = /** @class */ (function (_super) {
      __extends$1b(ReprojTile, _super);
      /**
       * @param {import("../proj/Projection.js").default} sourceProj Source projection.
       * @param {import("../tilegrid/TileGrid.js").default} sourceTileGrid Source tile grid.
       * @param {import("../proj/Projection.js").default} targetProj Target projection.
       * @param {import("../tilegrid/TileGrid.js").default} targetTileGrid Target tile grid.
       * @param {import("../tilecoord.js").TileCoord} tileCoord Coordinate of the tile.
       * @param {import("../tilecoord.js").TileCoord} wrappedTileCoord Coordinate of the tile wrapped in X.
       * @param {number} pixelRatio Pixel ratio.
       * @param {number} gutter Gutter of the source tiles.
       * @param {FunctionType} getTileFunction
       *     Function returning source tiles (z, x, y, pixelRatio).
       * @param {number=} opt_errorThreshold Acceptable reprojection error (in px).
       * @param {boolean=} opt_renderEdges Render reprojection edges.
       * @param {object=} opt_contextOptions Properties to set on the canvas context.
       */
      function ReprojTile(sourceProj, sourceTileGrid, targetProj, targetTileGrid, tileCoord, wrappedTileCoord, pixelRatio, gutter, getTileFunction, opt_errorThreshold, opt_renderEdges, opt_contextOptions) {
          var _this = _super.call(this, tileCoord, TileState.IDLE) || this;
          /**
           * @private
           * @type {boolean}
           */
          _this.renderEdges_ = opt_renderEdges !== undefined ? opt_renderEdges : false;
          /**
           * @private
           * @type {object}
           */
          _this.contextOptions_ = opt_contextOptions;
          /**
           * @private
           * @type {number}
           */
          _this.pixelRatio_ = pixelRatio;
          /**
           * @private
           * @type {number}
           */
          _this.gutter_ = gutter;
          /**
           * @private
           * @type {HTMLCanvasElement}
           */
          _this.canvas_ = null;
          /**
           * @private
           * @type {import("../tilegrid/TileGrid.js").default}
           */
          _this.sourceTileGrid_ = sourceTileGrid;
          /**
           * @private
           * @type {import("../tilegrid/TileGrid.js").default}
           */
          _this.targetTileGrid_ = targetTileGrid;
          /**
           * @private
           * @type {import("../tilecoord.js").TileCoord}
           */
          _this.wrappedTileCoord_ = wrappedTileCoord ? wrappedTileCoord : tileCoord;
          /**
           * @private
           * @type {!Array<import("../Tile.js").default>}
           */
          _this.sourceTiles_ = [];
          /**
           * @private
           * @type {?Array<import("../events.js").EventsKey>}
           */
          _this.sourcesListenerKeys_ = null;
          /**
           * @private
           * @type {number}
           */
          _this.sourceZ_ = 0;
          var targetExtent = targetTileGrid.getTileCoordExtent(_this.wrappedTileCoord_);
          var maxTargetExtent = _this.targetTileGrid_.getExtent();
          var maxSourceExtent = _this.sourceTileGrid_.getExtent();
          var limitedTargetExtent = maxTargetExtent
              ? getIntersection(targetExtent, maxTargetExtent)
              : targetExtent;
          if (getArea(limitedTargetExtent) === 0) {
              // Tile is completely outside range -> EMPTY
              // TODO: is it actually correct that the source even creates the tile ?
              _this.state = TileState.EMPTY;
              return _this;
          }
          var sourceProjExtent = sourceProj.getExtent();
          if (sourceProjExtent) {
              if (!maxSourceExtent) {
                  maxSourceExtent = sourceProjExtent;
              }
              else {
                  maxSourceExtent = getIntersection(maxSourceExtent, sourceProjExtent);
              }
          }
          var targetResolution = targetTileGrid.getResolution(_this.wrappedTileCoord_[0]);
          var sourceResolution = calculateSourceExtentResolution(sourceProj, targetProj, limitedTargetExtent, targetResolution);
          if (!isFinite(sourceResolution) || sourceResolution <= 0) {
              // invalid sourceResolution -> EMPTY
              // probably edges of the projections when no extent is defined
              _this.state = TileState.EMPTY;
              return _this;
          }
          var errorThresholdInPixels = opt_errorThreshold !== undefined ? opt_errorThreshold : ERROR_THRESHOLD;
          /**
           * @private
           * @type {!import("./Triangulation.js").default}
           */
          _this.triangulation_ = new Triangulation(sourceProj, targetProj, limitedTargetExtent, maxSourceExtent, sourceResolution * errorThresholdInPixels, targetResolution);
          if (_this.triangulation_.getTriangles().length === 0) {
              // no valid triangles -> EMPTY
              _this.state = TileState.EMPTY;
              return _this;
          }
          _this.sourceZ_ = sourceTileGrid.getZForResolution(sourceResolution);
          var sourceExtent = _this.triangulation_.calculateSourceExtent();
          if (maxSourceExtent) {
              if (sourceProj.canWrapX()) {
                  sourceExtent[1] = clamp(sourceExtent[1], maxSourceExtent[1], maxSourceExtent[3]);
                  sourceExtent[3] = clamp(sourceExtent[3], maxSourceExtent[1], maxSourceExtent[3]);
              }
              else {
                  sourceExtent = getIntersection(sourceExtent, maxSourceExtent);
              }
          }
          if (!getArea(sourceExtent)) {
              _this.state = TileState.EMPTY;
          }
          else {
              var sourceRange = sourceTileGrid.getTileRangeForExtentAndZ(sourceExtent, _this.sourceZ_);
              for (var srcX = sourceRange.minX; srcX <= sourceRange.maxX; srcX++) {
                  for (var srcY = sourceRange.minY; srcY <= sourceRange.maxY; srcY++) {
                      var tile = getTileFunction(_this.sourceZ_, srcX, srcY, pixelRatio);
                      if (tile) {
                          _this.sourceTiles_.push(tile);
                      }
                  }
              }
              if (_this.sourceTiles_.length === 0) {
                  _this.state = TileState.EMPTY;
              }
          }
          return _this;
      }
      /**
       * Get the HTML Canvas element for this tile.
       * @return {HTMLCanvasElement} Canvas.
       */
      ReprojTile.prototype.getImage = function () {
          return this.canvas_;
      };
      /**
       * @private
       */
      ReprojTile.prototype.reproject_ = function () {
          var sources = [];
          this.sourceTiles_.forEach(function (tile, i, arr) {
              if (tile && tile.getState() == TileState.LOADED) {
                  sources.push({
                      extent: this.sourceTileGrid_.getTileCoordExtent(tile.tileCoord),
                      image: tile.getImage(),
                  });
              }
          }.bind(this));
          this.sourceTiles_.length = 0;
          if (sources.length === 0) {
              this.state = TileState.ERROR;
          }
          else {
              var z = this.wrappedTileCoord_[0];
              var size = this.targetTileGrid_.getTileSize(z);
              var width = typeof size === 'number' ? size : size[0];
              var height = typeof size === 'number' ? size : size[1];
              var targetResolution = this.targetTileGrid_.getResolution(z);
              var sourceResolution = this.sourceTileGrid_.getResolution(this.sourceZ_);
              var targetExtent = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
              this.canvas_ = render(width, height, this.pixelRatio_, sourceResolution, this.sourceTileGrid_.getExtent(), targetResolution, targetExtent, this.triangulation_, sources, this.gutter_, this.renderEdges_, this.contextOptions_);
              this.state = TileState.LOADED;
          }
          this.changed();
      };
      /**
       * Load not yet loaded URI.
       */
      ReprojTile.prototype.load = function () {
          if (this.state == TileState.IDLE) {
              this.state = TileState.LOADING;
              this.changed();
              var leftToLoad_1 = 0;
              this.sourcesListenerKeys_ = [];
              this.sourceTiles_.forEach(function (tile, i, arr) {
                  var state = tile.getState();
                  if (state == TileState.IDLE || state == TileState.LOADING) {
                      leftToLoad_1++;
                      var sourceListenKey_1 = listen(tile, EventType.CHANGE, function (e) {
                          var state = tile.getState();
                          if (state == TileState.LOADED ||
                              state == TileState.ERROR ||
                              state == TileState.EMPTY) {
                              unlistenByKey(sourceListenKey_1);
                              leftToLoad_1--;
                              if (leftToLoad_1 === 0) {
                                  this.unlistenSources_();
                                  this.reproject_();
                              }
                          }
                      }, this);
                      this.sourcesListenerKeys_.push(sourceListenKey_1);
                  }
              }.bind(this));
              this.sourceTiles_.forEach(function (tile, i, arr) {
                  var state = tile.getState();
                  if (state == TileState.IDLE) {
                      tile.load();
                  }
              });
              if (leftToLoad_1 === 0) {
                  setTimeout(this.reproject_.bind(this), 0);
              }
          }
      };
      /**
       * @private
       */
      ReprojTile.prototype.unlistenSources_ = function () {
          this.sourcesListenerKeys_.forEach(unlistenByKey);
          this.sourcesListenerKeys_ = null;
      };
      return ReprojTile;
  }(Tile));

  /**
   * @module ol/structs/LRUCache
   */
  /**
   * @typedef {Object} Entry
   * @property {string} key_
   * @property {Object} newer
   * @property {Object} older
   * @property {*} value_
   */
  /**
   * @classdesc
   * Implements a Least-Recently-Used cache where the keys do not conflict with
   * Object's properties (e.g. 'hasOwnProperty' is not allowed as a key). Expiring
   * items from the cache is the responsibility of the user.
   *
   * @fires import("../events/Event.js").default
   * @template T
   */
  var LRUCache = /** @class */ (function () {
      /**
       * @param {number=} opt_highWaterMark High water mark.
       */
      function LRUCache(opt_highWaterMark) {
          /**
           * Desired max cache size after expireCache(). If set to 0, no cache entries
           * will be pruned at all.
           * @type {number}
           */
          this.highWaterMark =
              opt_highWaterMark !== undefined ? opt_highWaterMark : 2048;
          /**
           * @private
           * @type {number}
           */
          this.count_ = 0;
          /**
           * @private
           * @type {!Object<string, Entry>}
           */
          this.entries_ = {};
          /**
           * @private
           * @type {?Entry}
           */
          this.oldest_ = null;
          /**
           * @private
           * @type {?Entry}
           */
          this.newest_ = null;
      }
      /**
       * @return {boolean} Can expire cache.
       */
      LRUCache.prototype.canExpireCache = function () {
          return this.highWaterMark > 0 && this.getCount() > this.highWaterMark;
      };
      /**
       * FIXME empty description for jsdoc
       */
      LRUCache.prototype.clear = function () {
          this.count_ = 0;
          this.entries_ = {};
          this.oldest_ = null;
          this.newest_ = null;
      };
      /**
       * @param {string} key Key.
       * @return {boolean} Contains key.
       */
      LRUCache.prototype.containsKey = function (key) {
          return this.entries_.hasOwnProperty(key);
      };
      /**
       * @param {function(T, string, LRUCache<T>): ?} f The function
       *     to call for every entry from the oldest to the newer. This function takes
       *     3 arguments (the entry value, the entry key and the LRUCache object).
       *     The return value is ignored.
       */
      LRUCache.prototype.forEach = function (f) {
          var entry = this.oldest_;
          while (entry) {
              f(entry.value_, entry.key_, this);
              entry = entry.newer;
          }
      };
      /**
       * @param {string} key Key.
       * @param {*=} opt_options Options (reserverd for subclasses).
       * @return {T} Value.
       */
      LRUCache.prototype.get = function (key, opt_options) {
          var entry = this.entries_[key];
          assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache
          if (entry === this.newest_) {
              return entry.value_;
          }
          else if (entry === this.oldest_) {
              this.oldest_ = /** @type {Entry} */ (this.oldest_.newer);
              this.oldest_.older = null;
          }
          else {
              entry.newer.older = entry.older;
              entry.older.newer = entry.newer;
          }
          entry.newer = null;
          entry.older = this.newest_;
          this.newest_.newer = entry;
          this.newest_ = entry;
          return entry.value_;
      };
      /**
       * Remove an entry from the cache.
       * @param {string} key The entry key.
       * @return {T} The removed entry.
       */
      LRUCache.prototype.remove = function (key) {
          var entry = this.entries_[key];
          assert(entry !== undefined, 15); // Tried to get a value for a key that does not exist in the cache
          if (entry === this.newest_) {
              this.newest_ = /** @type {Entry} */ (entry.older);
              if (this.newest_) {
                  this.newest_.newer = null;
              }
          }
          else if (entry === this.oldest_) {
              this.oldest_ = /** @type {Entry} */ (entry.newer);
              if (this.oldest_) {
                  this.oldest_.older = null;
              }
          }
          else {
              entry.newer.older = entry.older;
              entry.older.newer = entry.newer;
          }
          delete this.entries_[key];
          --this.count_;
          return entry.value_;
      };
      /**
       * @return {number} Count.
       */
      LRUCache.prototype.getCount = function () {
          return this.count_;
      };
      /**
       * @return {Array<string>} Keys.
       */
      LRUCache.prototype.getKeys = function () {
          var keys = new Array(this.count_);
          var i = 0;
          var entry;
          for (entry = this.newest_; entry; entry = entry.older) {
              keys[i++] = entry.key_;
          }
          return keys;
      };
      /**
       * @return {Array<T>} Values.
       */
      LRUCache.prototype.getValues = function () {
          var values = new Array(this.count_);
          var i = 0;
          var entry;
          for (entry = this.newest_; entry; entry = entry.older) {
              values[i++] = entry.value_;
          }
          return values;
      };
      /**
       * @return {T} Last value.
       */
      LRUCache.prototype.peekLast = function () {
          return this.oldest_.value_;
      };
      /**
       * @return {string} Last key.
       */
      LRUCache.prototype.peekLastKey = function () {
          return this.oldest_.key_;
      };
      /**
       * Get the key of the newest item in the cache.  Throws if the cache is empty.
       * @return {string} The newest key.
       */
      LRUCache.prototype.peekFirstKey = function () {
          return this.newest_.key_;
      };
      /**
       * @return {T} value Value.
       */
      LRUCache.prototype.pop = function () {
          var entry = this.oldest_;
          delete this.entries_[entry.key_];
          if (entry.newer) {
              entry.newer.older = null;
          }
          this.oldest_ = /** @type {Entry} */ (entry.newer);
          if (!this.oldest_) {
              this.newest_ = null;
          }
          --this.count_;
          return entry.value_;
      };
      /**
       * @param {string} key Key.
       * @param {T} value Value.
       */
      LRUCache.prototype.replace = function (key, value) {
          this.get(key); // update `newest_`
          this.entries_[key].value_ = value;
      };
      /**
       * @param {string} key Key.
       * @param {T} value Value.
       */
      LRUCache.prototype.set = function (key, value) {
          assert(!(key in this.entries_), 16); // Tried to set a value for a key that is used already
          var entry = {
              key_: key,
              newer: null,
              older: this.newest_,
              value_: value,
          };
          if (!this.newest_) {
              this.oldest_ = entry;
          }
          else {
              this.newest_.newer = entry;
          }
          this.newest_ = entry;
          this.entries_[key] = entry;
          ++this.count_;
      };
      /**
       * Set a maximum number of entries for the cache.
       * @param {number} size Cache size.
       * @api
       */
      LRUCache.prototype.setSize = function (size) {
          this.highWaterMark = size;
      };
      return LRUCache;
  }());

  var __extends$1c = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var TileCache = /** @class */ (function (_super) {
      __extends$1c(TileCache, _super);
      function TileCache() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      /**
       * @param {!Object<string, boolean>} usedTiles Used tiles.
       */
      TileCache.prototype.expireCache = function (usedTiles) {
          while (this.canExpireCache()) {
              var tile = this.peekLast();
              if (tile.getKey() in usedTiles) {
                  break;
              }
              else {
                  this.pop().release();
              }
          }
      };
      /**
       * Prune all tiles from the cache that don't have the same z as the newest tile.
       */
      TileCache.prototype.pruneExceptNewestZ = function () {
          if (this.getCount() === 0) {
              return;
          }
          var key = this.peekFirstKey();
          var tileCoord = fromKey(key);
          var z = tileCoord[0];
          this.forEach(function (tile) {
              if (tile.tileCoord[0] !== z) {
                  this.remove(getKey$1(tile.tileCoord));
                  tile.release();
              }
          }.bind(this));
      };
      return TileCache;
  }(LRUCache));

  /**
   * @module ol/source/TileEventType
   */
  /**
   * @enum {string}
   */
  var TileEventType = {
      /**
       * Triggered when a tile starts loading.
       * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
       * @api
       */
      TILELOADSTART: 'tileloadstart',
      /**
       * Triggered when a tile finishes loading, either when its data is loaded,
       * or when loading was aborted because the tile is no longer needed.
       * @event module:ol/source/Tile.TileSourceEvent#tileloadend
       * @api
       */
      TILELOADEND: 'tileloadend',
      /**
       * Triggered if tile loading results in an error.
       * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
       * @api
       */
      TILELOADERROR: 'tileloaderror',
  };

  /**
   * @module ol/tilegrid
   */
  /**
   * @param {import("./proj/Projection.js").default} projection Projection.
   * @return {!TileGrid} Default tile grid for the
   * passed projection.
   */
  function getForProjection(projection) {
      var tileGrid = projection.getDefaultTileGrid();
      if (!tileGrid) {
          tileGrid = createForProjection(projection);
          projection.setDefaultTileGrid(tileGrid);
      }
      return tileGrid;
  }
  /**
   * @param {TileGrid} tileGrid Tile grid.
   * @param {import("./tilecoord.js").TileCoord} tileCoord Tile coordinate.
   * @param {import("./proj/Projection.js").default} projection Projection.
   * @return {import("./tilecoord.js").TileCoord} Tile coordinate.
   */
  function wrapX$2(tileGrid, tileCoord, projection) {
      var z = tileCoord[0];
      var center = tileGrid.getTileCoordCenter(tileCoord);
      var projectionExtent = extentFromProjection(projection);
      if (!containsCoordinate(projectionExtent, center)) {
          var worldWidth = getWidth(projectionExtent);
          var worldsAway = Math.ceil((projectionExtent[0] - center[0]) / worldWidth);
          center[0] += worldWidth * worldsAway;
          return tileGrid.getTileCoordForCoordAndZ(center, z);
      }
      else {
          return tileCoord;
      }
  }
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number=} opt_maxZoom Maximum zoom level (default is
   *     DEFAULT_MAX_ZOOM).
   * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses
   *     DEFAULT_TILE_SIZE).
   * @param {import("./extent/Corner.js").default=} opt_corner Extent corner (default is `'top-left'`).
   * @return {!TileGrid} TileGrid instance.
   */
  function createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner) {
      var corner = opt_corner !== undefined ? opt_corner : Corner.TOP_LEFT;
      var resolutions = resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize);
      return new TileGrid({
          extent: extent,
          origin: getCorner(extent, corner),
          resolutions: resolutions,
          tileSize: opt_tileSize,
      });
  }
  /**
   * @typedef {Object} XYZOptions
   * @property {import("./extent.js").Extent} [extent] Extent for the tile grid. The origin for an XYZ tile grid is the
   * top-left corner of the extent. If `maxResolution` is not provided the zero level of the grid is defined by the resolution
   * at which one tile fits in the provided extent. If not provided, the extent of the EPSG:3857 projection is used.
   * @property {number} [maxResolution] Resolution at level zero.
   * @property {number} [maxZoom] Maximum zoom. The default is `42`. This determines the number of levels
   * in the grid set. For example, a `maxZoom` of 21 means there are 22 levels in the grid set.
   * @property {number} [minZoom=0] Minimum zoom.
   * @property {number|import("./size.js").Size} [tileSize=[256, 256]] Tile size in pixels.
   */
  /**
   * Creates a tile grid with a standard XYZ tiling scheme.
   * @param {XYZOptions=} opt_options Tile grid options.
   * @return {!TileGrid} Tile grid instance.
   * @api
   */
  function createXYZ(opt_options) {
      var xyzOptions = opt_options || {};
      var extent = xyzOptions.extent || get$2('EPSG:3857').getExtent();
      var gridOptions = {
          extent: extent,
          minZoom: xyzOptions.minZoom,
          tileSize: xyzOptions.tileSize,
          resolutions: resolutionsFromExtent(extent, xyzOptions.maxZoom, xyzOptions.tileSize, xyzOptions.maxResolution),
      };
      return new TileGrid(gridOptions);
  }
  /**
   * Create a resolutions array from an extent.  A zoom factor of 2 is assumed.
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {number=} opt_maxZoom Maximum zoom level (default is
   *     DEFAULT_MAX_ZOOM).
   * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses
   *     DEFAULT_TILE_SIZE).
   * @param {number=} opt_maxResolution Resolution at level zero.
   * @return {!Array<number>} Resolutions array.
   */
  function resolutionsFromExtent(extent, opt_maxZoom, opt_tileSize, opt_maxResolution) {
      var maxZoom = opt_maxZoom !== undefined ? opt_maxZoom : DEFAULT_MAX_ZOOM;
      var height = getHeight(extent);
      var width = getWidth(extent);
      var tileSize = toSize(opt_tileSize !== undefined ? opt_tileSize : DEFAULT_TILE_SIZE);
      var maxResolution = opt_maxResolution > 0
          ? opt_maxResolution
          : Math.max(width / tileSize[0], height / tileSize[1]);
      var length = maxZoom + 1;
      var resolutions = new Array(length);
      for (var z = 0; z < length; ++z) {
          resolutions[z] = maxResolution / Math.pow(2, z);
      }
      return resolutions;
  }
  /**
   * @param {import("./proj.js").ProjectionLike} projection Projection.
   * @param {number=} opt_maxZoom Maximum zoom level (default is
   *     DEFAULT_MAX_ZOOM).
   * @param {number|import("./size.js").Size=} opt_tileSize Tile size (default uses
   *     DEFAULT_TILE_SIZE).
   * @param {import("./extent/Corner.js").default=} opt_corner Extent corner (default is `'top-left'`).
   * @return {!TileGrid} TileGrid instance.
   */
  function createForProjection(projection, opt_maxZoom, opt_tileSize, opt_corner) {
      var extent = extentFromProjection(projection);
      return createForExtent(extent, opt_maxZoom, opt_tileSize, opt_corner);
  }
  /**
   * Generate a tile grid extent from a projection.  If the projection has an
   * extent, it is used.  If not, a global extent is assumed.
   * @param {import("./proj.js").ProjectionLike} projection Projection.
   * @return {import("./extent.js").Extent} Extent.
   */
  function extentFromProjection(projection) {
      projection = get$2(projection);
      var extent = projection.getExtent();
      if (!extent) {
          var half = (180 * METERS_PER_UNIT[Units.DEGREES]) / projection.getMetersPerUnit();
          extent = createOrUpdate(-half, -half, half, half);
      }
      return extent;
  }

  var __extends$1d = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {import("./Source.js").AttributionLike} [attributions]
   * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
   * @property {number} [cacheSize]
   * @property {boolean} [opaque=false] Whether the layer is opaque.
   * @property {number} [tilePixelRatio]
   * @property {import("../proj.js").ProjectionLike} [projection]
   * @property {import("./State.js").default} [state]
   * @property {import("../tilegrid/TileGrid.js").default} [tileGrid]
   * @property {boolean} [wrapX=true]
   * @property {number} [transition]
   * @property {string} [key]
   * @property {number} [zDirection=0]
   */
  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * Base class for sources providing images divided into a tile grid.
   * @abstract
   * @api
   */
  var TileSource = /** @class */ (function (_super) {
      __extends$1d(TileSource, _super);
      /**
       * @param {Options} options SourceTile source options.
       */
      function TileSource(options) {
          var _this = _super.call(this, {
              attributions: options.attributions,
              attributionsCollapsible: options.attributionsCollapsible,
              projection: options.projection,
              state: options.state,
              wrapX: options.wrapX,
          }) || this;
          /**
           * @private
           * @type {boolean}
           */
          _this.opaque_ = options.opaque !== undefined ? options.opaque : false;
          /**
           * @private
           * @type {number}
           */
          _this.tilePixelRatio_ =
              options.tilePixelRatio !== undefined ? options.tilePixelRatio : 1;
          /**
           * @protected
           * @type {import("../tilegrid/TileGrid.js").default}
           */
          _this.tileGrid = options.tileGrid !== undefined ? options.tileGrid : null;
          var tileSize = [256, 256];
          var tileGrid = options.tileGrid;
          if (tileGrid) {
              toSize(tileGrid.getTileSize(tileGrid.getMinZoom()), tileSize);
          }
          /**
           * @protected
           * @type {import("../TileCache.js").default}
           */
          _this.tileCache = new TileCache(options.cacheSize || 0);
          /**
           * @protected
           * @type {import("../size.js").Size}
           */
          _this.tmpSize = [0, 0];
          /**
           * @private
           * @type {string}
           */
          _this.key_ = options.key || '';
          /**
           * @protected
           * @type {import("../Tile.js").Options}
           */
          _this.tileOptions = { transition: options.transition };
          /**
           * zDirection hint, read by the renderer. Indicates which resolution should be used
           * by a renderer if the views resolution does not match any resolution of the tile source.
           * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
           * will be used. If -1, the nearest higher resolution will be used.
           * @type {number}
           */
          _this.zDirection = options.zDirection ? options.zDirection : 0;
          return _this;
      }
      /**
       * @return {boolean} Can expire cache.
       */
      TileSource.prototype.canExpireCache = function () {
          return this.tileCache.canExpireCache();
      };
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @param {!Object<string, boolean>} usedTiles Used tiles.
       */
      TileSource.prototype.expireCache = function (projection, usedTiles) {
          var tileCache = this.getTileCacheForProjection(projection);
          if (tileCache) {
              tileCache.expireCache(usedTiles);
          }
      };
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @param {number} z Zoom level.
       * @param {import("../TileRange.js").default} tileRange Tile range.
       * @param {function(import("../Tile.js").default):(boolean|void)} callback Called with each
       *     loaded tile.  If the callback returns `false`, the tile will not be
       *     considered loaded.
       * @return {boolean} The tile range is fully covered with loaded tiles.
       */
      TileSource.prototype.forEachLoadedTile = function (projection, z, tileRange, callback) {
          var tileCache = this.getTileCacheForProjection(projection);
          if (!tileCache) {
              return false;
          }
          var covered = true;
          var tile, tileCoordKey, loaded;
          for (var x = tileRange.minX; x <= tileRange.maxX; ++x) {
              for (var y = tileRange.minY; y <= tileRange.maxY; ++y) {
                  tileCoordKey = getKeyZXY(z, x, y);
                  loaded = false;
                  if (tileCache.containsKey(tileCoordKey)) {
                      tile = /** @type {!import("../Tile.js").default} */ (tileCache.get(tileCoordKey));
                      loaded = tile.getState() === TileState.LOADED;
                      if (loaded) {
                          loaded = callback(tile) !== false;
                      }
                  }
                  if (!loaded) {
                      covered = false;
                  }
              }
          }
          return covered;
      };
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {number} Gutter.
       */
      TileSource.prototype.getGutterForProjection = function (projection) {
          return 0;
      };
      /**
       * Return the key to be used for all tiles in the source.
       * @return {string} The key for all tiles.
       * @protected
       */
      TileSource.prototype.getKey = function () {
          return this.key_;
      };
      /**
       * Set the value to be used as the key for all tiles in the source.
       * @param {string} key The key for tiles.
       * @protected
       */
      TileSource.prototype.setKey = function (key) {
          if (this.key_ !== key) {
              this.key_ = key;
              this.changed();
          }
      };
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {boolean} Opaque.
       */
      TileSource.prototype.getOpaque = function (projection) {
          return this.opaque_;
      };
      /**
       * @return {Array<number>} Resolutions.
       */
      TileSource.prototype.getResolutions = function () {
          return this.tileGrid.getResolutions();
      };
      /**
       * @abstract
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {!import("../Tile.js").default} Tile.
       */
      TileSource.prototype.getTile = function (z, x, y, pixelRatio, projection) {
          return abstract();
      };
      /**
       * Return the tile grid of the tile source.
       * @return {import("../tilegrid/TileGrid.js").default} Tile grid.
       * @api
       */
      TileSource.prototype.getTileGrid = function () {
          return this.tileGrid;
      };
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
       */
      TileSource.prototype.getTileGridForProjection = function (projection) {
          if (!this.tileGrid) {
              return getForProjection(projection);
          }
          else {
              return this.tileGrid;
          }
      };
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {import("../TileCache.js").default} Tile cache.
       * @protected
       */
      TileSource.prototype.getTileCacheForProjection = function (projection) {
          var thisProj = this.getProjection();
          if (thisProj && !equivalent(thisProj, projection)) {
              return null;
          }
          else {
              return this.tileCache;
          }
      };
      /**
       * Get the tile pixel ratio for this source. Subclasses may override this
       * method, which is meant to return a supported pixel ratio that matches the
       * provided `pixelRatio` as close as possible.
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Tile pixel ratio.
       */
      TileSource.prototype.getTilePixelRatio = function (pixelRatio) {
          return this.tilePixelRatio_;
      };
      /**
       * @param {number} z Z.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {import("../size.js").Size} Tile size.
       */
      TileSource.prototype.getTilePixelSize = function (z, pixelRatio, projection) {
          var tileGrid = this.getTileGridForProjection(projection);
          var tilePixelRatio = this.getTilePixelRatio(pixelRatio);
          var tileSize = toSize(tileGrid.getTileSize(z), this.tmpSize);
          if (tilePixelRatio == 1) {
              return tileSize;
          }
          else {
              return scale$2(tileSize, tilePixelRatio, this.tmpSize);
          }
      };
      /**
       * Returns a tile coordinate wrapped around the x-axis. When the tile coordinate
       * is outside the resolution and extent range of the tile grid, `null` will be
       * returned.
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {import("../proj/Projection.js").default=} opt_projection Projection.
       * @return {import("../tilecoord.js").TileCoord} Tile coordinate to be passed to the tileUrlFunction or
       *     null if no tile URL should be created for the passed `tileCoord`.
       */
      TileSource.prototype.getTileCoordForTileUrlFunction = function (tileCoord, opt_projection) {
          var projection = opt_projection !== undefined ? opt_projection : this.getProjection();
          var tileGrid = this.getTileGridForProjection(projection);
          if (this.getWrapX() && projection.isGlobal()) {
              tileCoord = wrapX$2(tileGrid, tileCoord, projection);
          }
          return withinExtentAndZ(tileCoord, tileGrid) ? tileCoord : null;
      };
      /**
       * Remove all cached tiles from the source. The next render cycle will fetch new tiles.
       * @api
       */
      TileSource.prototype.clear = function () {
          this.tileCache.clear();
      };
      TileSource.prototype.refresh = function () {
          this.clear();
          _super.prototype.refresh.call(this);
      };
      /**
       * Increases the cache size if needed
       * @param {number} tileCount Minimum number of tiles needed.
       * @param {import("../proj/Projection.js").default} projection Projection.
       */
      TileSource.prototype.updateCacheSize = function (tileCount, projection) {
          var tileCache = this.getTileCacheForProjection(projection);
          if (tileCount > tileCache.highWaterMark) {
              tileCache.highWaterMark = tileCount;
          }
      };
      /**
       * Marks a tile coord as being used, without triggering a load.
       * @abstract
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {import("../proj/Projection.js").default} projection Projection.
       */
      TileSource.prototype.useTile = function (z, x, y, projection) { };
      return TileSource;
  }(Source));
  /**
   * @classdesc
   * Events emitted by {@link module:ol/source/Tile~TileSource} instances are instances of this
   * type.
   */
  var TileSourceEvent = /** @class */ (function (_super) {
      __extends$1d(TileSourceEvent, _super);
      /**
       * @param {string} type Type.
       * @param {import("../Tile.js").default} tile The tile.
       */
      function TileSourceEvent(type, tile) {
          var _this = _super.call(this, type) || this;
          /**
           * The tile related to the event.
           * @type {import("../Tile.js").default}
           * @api
           */
          _this.tile = tile;
          return _this;
      }
      return TileSourceEvent;
  }(BaseEvent));

  /**
   * @module ol/tileurlfunction
   */
  /**
   * @param {string} template Template.
   * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @return {import("./Tile.js").UrlFunction} Tile URL function.
   */
  function createFromTemplate(template, tileGrid) {
      var zRegEx = /\{z\}/g;
      var xRegEx = /\{x\}/g;
      var yRegEx = /\{y\}/g;
      var dashYRegEx = /\{-y\}/g;
      return (
      /**
       * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("./proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      function (tileCoord, pixelRatio, projection) {
          if (!tileCoord) {
              return undefined;
          }
          else {
              return template
                  .replace(zRegEx, tileCoord[0].toString())
                  .replace(xRegEx, tileCoord[1].toString())
                  .replace(yRegEx, tileCoord[2].toString())
                  .replace(dashYRegEx, function () {
                  var z = tileCoord[0];
                  var range = tileGrid.getFullTileRange(z);
                  assert(range, 55); // The {-y} placeholder requires a tile grid with extent
                  var y = range.getHeight() - tileCoord[2] - 1;
                  return y.toString();
              });
          }
      });
  }
  /**
   * @param {Array<string>} templates Templates.
   * @param {import("./tilegrid/TileGrid.js").default} tileGrid Tile grid.
   * @return {import("./Tile.js").UrlFunction} Tile URL function.
   */
  function createFromTemplates(templates, tileGrid) {
      var len = templates.length;
      var tileUrlFunctions = new Array(len);
      for (var i = 0; i < len; ++i) {
          tileUrlFunctions[i] = createFromTemplate(templates[i], tileGrid);
      }
      return createFromTileUrlFunctions(tileUrlFunctions);
  }
  /**
   * @param {Array<import("./Tile.js").UrlFunction>} tileUrlFunctions Tile URL Functions.
   * @return {import("./Tile.js").UrlFunction} Tile URL function.
   */
  function createFromTileUrlFunctions(tileUrlFunctions) {
      if (tileUrlFunctions.length === 1) {
          return tileUrlFunctions[0];
      }
      return (
      /**
       * @param {import("./tilecoord.js").TileCoord} tileCoord Tile Coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("./proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      function (tileCoord, pixelRatio, projection) {
          if (!tileCoord) {
              return undefined;
          }
          else {
              var h = hash(tileCoord);
              var index = modulo(h, tileUrlFunctions.length);
              return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
          }
      });
  }
  /**
   * @param {string} url URL.
   * @return {Array<string>} Array of urls.
   */
  function expandUrl(url) {
      var urls = [];
      var match = /\{([a-z])-([a-z])\}/.exec(url);
      if (match) {
          // char range
          var startCharCode = match[1].charCodeAt(0);
          var stopCharCode = match[2].charCodeAt(0);
          var charCode = void 0;
          for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
              urls.push(url.replace(match[0], String.fromCharCode(charCode)));
          }
          return urls;
      }
      match = /\{(\d+)-(\d+)\}/.exec(url);
      if (match) {
          // number range
          var stop_1 = parseInt(match[2], 10);
          for (var i = parseInt(match[1], 10); i <= stop_1; i++) {
              urls.push(url.replace(match[0], i.toString()));
          }
          return urls;
      }
      urls.push(url);
      return urls;
  }

  var __extends$1e = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {import("./Source.js").AttributionLike} [attributions]
   * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
   * @property {number} [cacheSize]
   * @property {boolean} [opaque=false] Whether the layer is opaque.
   * @property {import("../proj.js").ProjectionLike} [projection]
   * @property {import("./State.js").default} [state]
   * @property {import("../tilegrid/TileGrid.js").default} [tileGrid]
   * @property {import("../Tile.js").LoadFunction} tileLoadFunction
   * @property {number} [tilePixelRatio]
   * @property {import("../Tile.js").UrlFunction} [tileUrlFunction]
   * @property {string} [url]
   * @property {Array<string>} [urls]
   * @property {boolean} [wrapX=true]
   * @property {number} [transition]
   * @property {string} [key]
   * @property {number} [zDirection=0]
   */
  /**
   * @classdesc
   * Base class for sources providing tiles divided into a tile grid over http.
   *
   * @fires import("./Tile.js").TileSourceEvent
   */
  var UrlTile = /** @class */ (function (_super) {
      __extends$1e(UrlTile, _super);
      /**
       * @param {Options} options Image tile options.
       */
      function UrlTile(options) {
          var _this = _super.call(this, {
              attributions: options.attributions,
              cacheSize: options.cacheSize,
              opaque: options.opaque,
              projection: options.projection,
              state: options.state,
              tileGrid: options.tileGrid,
              tilePixelRatio: options.tilePixelRatio,
              wrapX: options.wrapX,
              transition: options.transition,
              key: options.key,
              attributionsCollapsible: options.attributionsCollapsible,
              zDirection: options.zDirection,
          }) || this;
          /**
           * @private
           * @type {boolean}
           */
          _this.generateTileUrlFunction_ =
              _this.tileUrlFunction === UrlTile.prototype.tileUrlFunction;
          /**
           * @protected
           * @type {import("../Tile.js").LoadFunction}
           */
          _this.tileLoadFunction = options.tileLoadFunction;
          if (options.tileUrlFunction) {
              _this.tileUrlFunction = options.tileUrlFunction.bind(_this);
          }
          /**
           * @protected
           * @type {!Array<string>|null}
           */
          _this.urls = null;
          if (options.urls) {
              _this.setUrls(options.urls);
          }
          else if (options.url) {
              _this.setUrl(options.url);
          }
          /**
           * @private
           * @type {!Object<string, boolean>}
           */
          _this.tileLoadingKeys_ = {};
          return _this;
      }
      /**
       * Return the tile load function of the source.
       * @return {import("../Tile.js").LoadFunction} TileLoadFunction
       * @api
       */
      UrlTile.prototype.getTileLoadFunction = function () {
          return this.tileLoadFunction;
      };
      /**
       * Return the tile URL function of the source.
       * @return {import("../Tile.js").UrlFunction} TileUrlFunction
       * @api
       */
      UrlTile.prototype.getTileUrlFunction = function () {
          return this.tileUrlFunction;
      };
      /**
       * Return the URLs used for this source.
       * When a tileUrlFunction is used instead of url or urls,
       * null will be returned.
       * @return {!Array<string>|null} URLs.
       * @api
       */
      UrlTile.prototype.getUrls = function () {
          return this.urls;
      };
      /**
       * Handle tile change events.
       * @param {import("../events/Event.js").default} event Event.
       * @protected
       */
      UrlTile.prototype.handleTileChange = function (event) {
          var tile = /** @type {import("../Tile.js").default} */ (event.target);
          var uid = getUid(tile);
          var tileState = tile.getState();
          var type;
          if (tileState == TileState.LOADING) {
              this.tileLoadingKeys_[uid] = true;
              type = TileEventType.TILELOADSTART;
          }
          else if (uid in this.tileLoadingKeys_) {
              delete this.tileLoadingKeys_[uid];
              type =
                  tileState == TileState.ERROR
                      ? TileEventType.TILELOADERROR
                      : tileState == TileState.LOADED
                          ? TileEventType.TILELOADEND
                          : undefined;
          }
          if (type != undefined) {
              this.dispatchEvent(new TileSourceEvent(type, tile));
          }
      };
      /**
       * Set the tile load function of the source.
       * @param {import("../Tile.js").LoadFunction} tileLoadFunction Tile load function.
       * @api
       */
      UrlTile.prototype.setTileLoadFunction = function (tileLoadFunction) {
          this.tileCache.clear();
          this.tileLoadFunction = tileLoadFunction;
          this.changed();
      };
      /**
       * Set the tile URL function of the source.
       * @param {import("../Tile.js").UrlFunction} tileUrlFunction Tile URL function.
       * @param {string=} key Optional new tile key for the source.
       * @api
       */
      UrlTile.prototype.setTileUrlFunction = function (tileUrlFunction, key) {
          this.tileUrlFunction = tileUrlFunction;
          this.tileCache.pruneExceptNewestZ();
          if (typeof key !== 'undefined') {
              this.setKey(key);
          }
          else {
              this.changed();
          }
      };
      /**
       * Set the URL to use for requests.
       * @param {string} url URL.
       * @api
       */
      UrlTile.prototype.setUrl = function (url) {
          var urls = expandUrl(url);
          this.urls = urls;
          this.setUrls(urls);
      };
      /**
       * Set the URLs to use for requests.
       * @param {Array<string>} urls URLs.
       * @api
       */
      UrlTile.prototype.setUrls = function (urls) {
          this.urls = urls;
          var key = urls.join('\n');
          if (this.generateTileUrlFunction_) {
              this.setTileUrlFunction(createFromTemplates(urls, this.tileGrid), key);
          }
          else {
              this.setKey(key);
          }
      };
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {string|undefined} Tile URL.
       */
      UrlTile.prototype.tileUrlFunction = function (tileCoord, pixelRatio, projection) {
          return undefined;
      };
      /**
       * Marks a tile coord as being used, without triggering a load.
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       */
      UrlTile.prototype.useTile = function (z, x, y) {
          var tileCoordKey = getKeyZXY(z, x, y);
          if (this.tileCache.containsKey(tileCoordKey)) {
              this.tileCache.get(tileCoordKey);
          }
      };
      return UrlTile;
  }(TileSource));

  var __extends$1f = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
   * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
   * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
   * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
   * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
   * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
   * @property {boolean} [imageSmoothing=true] Enable image smoothing.
   * @property {boolean} [opaque=false] Whether the layer is opaque.
   * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
   * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
   * Higher values can increase reprojection performance, but decrease precision.
   * @property {import("./State.js").default} [state] Source state.
   * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
   * Default is {@link module:ol/ImageTile~ImageTile}.
   * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
   * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
   * ```js
   * function(imageTile, src) {
   *   imageTile.getImage().src = src;
   * };
   * ```
   * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service. For example, if the tile
   * service advertizes 256px by 256px tiles but actually sends 512px
   * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
   * should be set to `2`.
   * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get tile URL given a tile coordinate and the projection.
   * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
   * A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`, may be
   * used instead of defining each one separately in the `urls` option.
   * @property {Array<string>} [urls] An array of URL templates.
   * @property {boolean} [wrapX] Whether to wrap the world horizontally. The default, is to
   * request out-of-bounds tiles from the server. When set to `false`, only one
   * world will be rendered. When set to `true`, tiles will be requested for one
   * world only, but they will be wrapped horizontally to render multiple worlds.
   * @property {number} [transition] Duration of the opacity transition for rendering.
   * To disable the opacity transition, pass `transition: 0`.
   * @property {string} [key] Optional tile key for proper cache fetching
   * @property {number} [zDirection=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   */
  /**
   * @classdesc
   * Base class for sources providing images divided into a tile grid.
   *
   * @fires import("./Tile.js").TileSourceEvent
   * @api
   */
  var TileImage = /** @class */ (function (_super) {
      __extends$1f(TileImage, _super);
      /**
       * @param {!Options} options Image tile options.
       */
      function TileImage(options) {
          var _this = _super.call(this, {
              attributions: options.attributions,
              cacheSize: options.cacheSize,
              opaque: options.opaque,
              projection: options.projection,
              state: options.state,
              tileGrid: options.tileGrid,
              tileLoadFunction: options.tileLoadFunction
                  ? options.tileLoadFunction
                  : defaultTileLoadFunction,
              tilePixelRatio: options.tilePixelRatio,
              tileUrlFunction: options.tileUrlFunction,
              url: options.url,
              urls: options.urls,
              wrapX: options.wrapX,
              transition: options.transition,
              key: options.key,
              attributionsCollapsible: options.attributionsCollapsible,
              zDirection: options.zDirection,
          }) || this;
          /**
           * @protected
           * @type {?string}
           */
          _this.crossOrigin =
              options.crossOrigin !== undefined ? options.crossOrigin : null;
          /**
           * @protected
           * @type {typeof ImageTile}
           */
          _this.tileClass =
              options.tileClass !== undefined ? options.tileClass : ImageTile;
          /**
           * @protected
           * @type {!Object<string, TileCache>}
           */
          _this.tileCacheForProjection = {};
          /**
           * @protected
           * @type {!Object<string, import("../tilegrid/TileGrid.js").default>}
           */
          _this.tileGridForProjection = {};
          /**
           * @private
           * @type {number|undefined}
           */
          _this.reprojectionErrorThreshold_ = options.reprojectionErrorThreshold;
          /**
           * @private
           * @type {object|undefined}
           */
          _this.contextOptions_ =
              options.imageSmoothing === false ? IMAGE_SMOOTHING_DISABLED : undefined;
          /**
           * @private
           * @type {boolean}
           */
          _this.renderReprojectionEdges_ = false;
          return _this;
      }
      /**
       * @return {boolean} Can expire cache.
       */
      TileImage.prototype.canExpireCache = function () {
          if (this.tileCache.canExpireCache()) {
              return true;
          }
          else {
              for (var key in this.tileCacheForProjection) {
                  if (this.tileCacheForProjection[key].canExpireCache()) {
                      return true;
                  }
              }
          }
          return false;
      };
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @param {!Object<string, boolean>} usedTiles Used tiles.
       */
      TileImage.prototype.expireCache = function (projection, usedTiles) {
          var usedTileCache = this.getTileCacheForProjection(projection);
          this.tileCache.expireCache(this.tileCache == usedTileCache ? usedTiles : {});
          for (var id in this.tileCacheForProjection) {
              var tileCache = this.tileCacheForProjection[id];
              tileCache.expireCache(tileCache == usedTileCache ? usedTiles : {});
          }
      };
      /**
       * @return {Object|undefined} Context options.
       */
      TileImage.prototype.getContextOptions = function () {
          return this.contextOptions_;
      };
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {number} Gutter.
       */
      TileImage.prototype.getGutterForProjection = function (projection) {
          if (
              this.getProjection() &&
              projection &&
              !equivalent(this.getProjection(), projection)) {
              return 0;
          }
          else {
              return this.getGutter();
          }
      };
      /**
       * @return {number} Gutter.
       */
      TileImage.prototype.getGutter = function () {
          return 0;
      };
      /**
       * Return the key to be used for all tiles in the source.
       * @return {string} The key for all tiles.
       * @protected
       */
      TileImage.prototype.getKey = function () {
          return (_super.prototype.getKey.call(this) +
              (this.contextOptions_ ? '\n' + JSON.stringify(this.contextOptions_) : ''));
      };
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {boolean} Opaque.
       */
      TileImage.prototype.getOpaque = function (projection) {
          if (
              this.getProjection() &&
              projection &&
              !equivalent(this.getProjection(), projection)) {
              return false;
          }
          else {
              return _super.prototype.getOpaque.call(this, projection);
          }
      };
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {!import("../tilegrid/TileGrid.js").default} Tile grid.
       */
      TileImage.prototype.getTileGridForProjection = function (projection) {
          var thisProj = this.getProjection();
          if (this.tileGrid && (!thisProj || equivalent(thisProj, projection))) {
              return this.tileGrid;
          }
          else {
              var projKey = getUid(projection);
              if (!(projKey in this.tileGridForProjection)) {
                  this.tileGridForProjection[projKey] = getForProjection(projection);
              }
              return this.tileGridForProjection[projKey];
          }
      };
      /**
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {import("../TileCache.js").default} Tile cache.
       */
      TileImage.prototype.getTileCacheForProjection = function (projection) {
          var thisProj = this.getProjection();
          if (!thisProj || equivalent(thisProj, projection)) {
              return this.tileCache;
          }
          else {
              var projKey = getUid(projection);
              if (!(projKey in this.tileCacheForProjection)) {
                  this.tileCacheForProjection[projKey] = new TileCache(this.tileCache.highWaterMark);
              }
              return this.tileCacheForProjection[projKey];
          }
      };
      /**
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @param {string} key The key set on the tile.
       * @return {!import("../Tile.js").default} Tile.
       * @private
       */
      TileImage.prototype.createTile_ = function (z, x, y, pixelRatio, projection, key) {
          var tileCoord = [z, x, y];
          var urlTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
          var tileUrl = urlTileCoord
              ? this.tileUrlFunction(urlTileCoord, pixelRatio, projection)
              : undefined;
          var tile = new this.tileClass(tileCoord, tileUrl !== undefined ? TileState.IDLE : TileState.EMPTY, tileUrl !== undefined ? tileUrl : '', this.crossOrigin, this.tileLoadFunction, this.tileOptions);
          tile.key = key;
          tile.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this));
          return tile;
      };
      /**
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @return {!import("../Tile.js").default} Tile.
       */
      TileImage.prototype.getTile = function (z, x, y, pixelRatio, projection) {
          var sourceProjection = this.getProjection();
          if (
              !sourceProjection ||
              !projection ||
              equivalent(sourceProjection, projection)) {
              return this.getTileInternal(z, x, y, pixelRatio, sourceProjection || projection);
          }
          else {
              var cache = this.getTileCacheForProjection(projection);
              var tileCoord = [z, x, y];
              var tile = void 0;
              var tileCoordKey = getKey$1(tileCoord);
              if (cache.containsKey(tileCoordKey)) {
                  tile = cache.get(tileCoordKey);
              }
              var key = this.getKey();
              if (tile && tile.key == key) {
                  return tile;
              }
              else {
                  var sourceTileGrid = this.getTileGridForProjection(sourceProjection);
                  var targetTileGrid = this.getTileGridForProjection(projection);
                  var wrappedTileCoord = this.getTileCoordForTileUrlFunction(tileCoord, projection);
                  var newTile = new ReprojTile(sourceProjection, sourceTileGrid, projection, targetTileGrid, tileCoord, wrappedTileCoord, this.getTilePixelRatio(pixelRatio), this.getGutter(), function (z, x, y, pixelRatio) {
                      return this.getTileInternal(z, x, y, pixelRatio, sourceProjection);
                  }.bind(this), this.reprojectionErrorThreshold_, this.renderReprojectionEdges_, this.contextOptions_);
                  newTile.key = key;
                  if (tile) {
                      newTile.interimTile = tile;
                      newTile.refreshInterimChain();
                      cache.replace(tileCoordKey, newTile);
                  }
                  else {
                      cache.set(tileCoordKey, newTile);
                  }
                  return newTile;
              }
          }
      };
      /**
       * @param {number} z Tile coordinate z.
       * @param {number} x Tile coordinate x.
       * @param {number} y Tile coordinate y.
       * @param {number} pixelRatio Pixel ratio.
       * @param {!import("../proj/Projection.js").default} projection Projection.
       * @return {!import("../Tile.js").default} Tile.
       * @protected
       */
      TileImage.prototype.getTileInternal = function (z, x, y, pixelRatio, projection) {
          var tile = null;
          var tileCoordKey = getKeyZXY(z, x, y);
          var key = this.getKey();
          if (!this.tileCache.containsKey(tileCoordKey)) {
              tile = this.createTile_(z, x, y, pixelRatio, projection, key);
              this.tileCache.set(tileCoordKey, tile);
          }
          else {
              tile = this.tileCache.get(tileCoordKey);
              if (tile.key != key) {
                  // The source's params changed. If the tile has an interim tile and if we
                  // can use it then we use it. Otherwise we create a new tile.  In both
                  // cases we attempt to assign an interim tile to the new tile.
                  var interimTile = tile;
                  tile = this.createTile_(z, x, y, pixelRatio, projection, key);
                  //make the new tile the head of the list,
                  if (interimTile.getState() == TileState.IDLE) {
                      //the old tile hasn't begun loading yet, and is now outdated, so we can simply discard it
                      tile.interimTile = interimTile.interimTile;
                  }
                  else {
                      tile.interimTile = interimTile;
                  }
                  tile.refreshInterimChain();
                  this.tileCache.replace(tileCoordKey, tile);
              }
          }
          return tile;
      };
      /**
       * Sets whether to render reprojection edges or not (usually for debugging).
       * @param {boolean} render Render the edges.
       * @api
       */
      TileImage.prototype.setRenderReprojectionEdges = function (render) {
          if (
              this.renderReprojectionEdges_ == render) {
              return;
          }
          this.renderReprojectionEdges_ = render;
          for (var id in this.tileCacheForProjection) {
              this.tileCacheForProjection[id].clear();
          }
          this.changed();
      };
      /**
       * Sets the tile grid to use when reprojecting the tiles to the given
       * projection instead of the default tile grid for the projection.
       *
       * This can be useful when the default tile grid cannot be created
       * (e.g. projection has no extent defined) or
       * for optimization reasons (custom tile size, resolutions, ...).
       *
       * @param {import("../proj.js").ProjectionLike} projection Projection.
       * @param {import("../tilegrid/TileGrid.js").default} tilegrid Tile grid to use for the projection.
       * @api
       */
      TileImage.prototype.setTileGridForProjection = function (projection, tilegrid) {
          {
              var proj = get$2(projection);
              if (proj) {
                  var projKey = getUid(proj);
                  if (!(projKey in this.tileGridForProjection)) {
                      this.tileGridForProjection[projKey] = tilegrid;
                  }
              }
          }
      };
      return TileImage;
  }(UrlTile));
  /**
   * @param {ImageTile} imageTile Image tile.
   * @param {string} src Source.
   */
  function defaultTileLoadFunction(imageTile, src) {
      /** @type {HTMLImageElement|HTMLVideoElement} */ (imageTile.getImage()).src = src;
  }

  /**
   * @module ol/source/WMTSRequestEncoding
   */
  /**
   * Request encoding. One of 'KVP', 'REST'.
   * @enum {string}
   */
  var WMTSRequestEncoding = {
      KVP: 'KVP',
      REST: 'REST',
  };

  /**
   * @module ol/uri
   */
  /**
   * Appends query parameters to a URI.
   *
   * @param {string} uri The original URI, which may already have query data.
   * @param {!Object} params An object where keys are URI-encoded parameter keys,
   *     and the values are arbitrary types or arrays.
   * @return {string} The new URI.
   */
  function appendParams(uri, params) {
      var keyParams = [];
      // Skip any null or undefined parameter values
      Object.keys(params).forEach(function (k) {
          if (params[k] !== null && params[k] !== undefined) {
              keyParams.push(k + '=' + encodeURIComponent(params[k]));
          }
      });
      var qs = keyParams.join('&');
      // remove any trailing ? or &
      uri = uri.replace(/[?&]$/, '');
      // append ? or & depending on whether uri has existing parameters
      uri = uri.indexOf('?') === -1 ? uri + '?' : uri + '&';
      return uri + qs;
  }

  /**
   * @module ol/tilegrid/WMTS
   */
  var __extends$1g = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {import("../extent.js").Extent} [extent] Extent for the tile grid. No tiles
   * outside this extent will be requested by {@link module:ol/source/Tile} sources.
   * When no `origin` or `origins` are configured, the `origin` will be set to the
   * top-left corner of the extent.
   * @property {import("../coordinate.js").Coordinate} [origin] The tile grid origin, i.e.
   * where the `x` and `y` axes meet (`[z, 0, 0]`). Tile coordinates increase left
   * to right and downwards. If not specified, `extent` or `origins` must be provided.
   * @property {Array<import("../coordinate.js").Coordinate>} [origins] Tile grid origins,
   * i.e. where the `x` and `y` axes meet (`[z, 0, 0]`), for each zoom level. If
   * given, the array length should match the length of the `resolutions` array, i.e.
   * each resolution can have a different origin. Tile coordinates increase left to
   * right and downwards. If not specified, `extent` or `origin` must be provided.
   * @property {!Array<number>} resolutions Resolutions. The array index of each
   * resolution needs to match the zoom level. This means that even if a `minZoom`
   * is configured, the resolutions array will have a length of `maxZoom + 1`
   * @property {!Array<string>} matrixIds matrix IDs. The length of this array needs
   * to match the length of the `resolutions` array.
   * @property {Array<import("../size.js").Size>} [sizes] Number of tile rows and columns
   * of the grid for each zoom level. The values here are the `TileMatrixWidth` and
   * `TileMatrixHeight` advertised in the GetCapabilities response of the WMTS, and
   * define each zoom level's extent together with the `origin` or `origins`.
   * A grid `extent` can be configured in addition, and will further limit the extent for
   * which tile requests are made by sources. If the bottom-left corner of
   * an extent is used as `origin` or `origins`, then the `y` value must be
   * negative because OpenLayers tile coordinates use the top left as the origin.
   * @property {number|import("../size.js").Size} [tileSize] Tile size.
   * @property {Array<import("../size.js").Size>} [tileSizes] Tile sizes. The length of
   * this array needs to match the length of the `resolutions` array.
   */
  /**
   * @classdesc
   * Set the grid pattern for sources accessing WMTS tiled-image servers.
   * @api
   */
  var WMTSTileGrid = /** @class */ (function (_super) {
      __extends$1g(WMTSTileGrid, _super);
      /**
       * @param {Options} options WMTS options.
       */
      function WMTSTileGrid(options) {
          var _this = _super.call(this, {
              extent: options.extent,
              origin: options.origin,
              origins: options.origins,
              resolutions: options.resolutions,
              tileSize: options.tileSize,
              tileSizes: options.tileSizes,
              sizes: options.sizes,
          }) || this;
          /**
           * @private
           * @type {!Array<string>}
           */
          _this.matrixIds_ = options.matrixIds;
          return _this;
      }
      /**
       * @param {number} z Z.
       * @return {string} MatrixId..
       */
      WMTSTileGrid.prototype.getMatrixId = function (z) {
          return this.matrixIds_[z];
      };
      /**
       * Get the list of matrix identifiers.
       * @return {Array<string>} MatrixIds.
       * @api
       */
      WMTSTileGrid.prototype.getMatrixIds = function () {
          return this.matrixIds_;
      };
      return WMTSTileGrid;
  }(TileGrid));
  /**
   * Create a tile grid from a WMTS capabilities matrix set and an
   * optional TileMatrixSetLimits.
   * @param {Object} matrixSet An object representing a matrixSet in the
   *     capabilities document.
   * @param {import("../extent.js").Extent=} opt_extent An optional extent to restrict the tile
   *     ranges the server provides.
   * @param {Array<Object>=} opt_matrixLimits An optional object representing
   *     the available matrices for tileGrid.
   * @return {WMTSTileGrid} WMTS tileGrid instance.
   * @api
   */
  function createFromCapabilitiesMatrixSet(matrixSet, opt_extent, opt_matrixLimits) {
      /** @type {!Array<number>} */
      var resolutions = [];
      /** @type {!Array<string>} */
      var matrixIds = [];
      /** @type {!Array<import("../coordinate.js").Coordinate>} */
      var origins = [];
      /** @type {!Array<import("../size.js").Size>} */
      var tileSizes = [];
      /** @type {!Array<import("../size.js").Size>} */
      var sizes = [];
      var matrixLimits = opt_matrixLimits !== undefined ? opt_matrixLimits : [];
      var supportedCRSPropName = 'SupportedCRS';
      var matrixIdsPropName = 'TileMatrix';
      var identifierPropName = 'Identifier';
      var scaleDenominatorPropName = 'ScaleDenominator';
      var topLeftCornerPropName = 'TopLeftCorner';
      var tileWidthPropName = 'TileWidth';
      var tileHeightPropName = 'TileHeight';
      var code = matrixSet[supportedCRSPropName];
      var projection = get$2(code.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, '$1:$3')) || get$2(code);
      var metersPerUnit = projection.getMetersPerUnit();
      // swap origin x and y coordinates if axis orientation is lat/long
      var switchOriginXY = projection.getAxisOrientation().substr(0, 2) == 'ne';
      matrixSet[matrixIdsPropName].sort(function (a, b) {
          return b[scaleDenominatorPropName] - a[scaleDenominatorPropName];
      });
      matrixSet[matrixIdsPropName].forEach(function (elt) {
          var matrixAvailable;
          // use of matrixLimits to filter TileMatrices from GetCapabilities
          // TileMatrixSet from unavailable matrix levels.
          if (matrixLimits.length > 0) {
              matrixAvailable = find(matrixLimits, function (elt_ml) {
                  if (elt[identifierPropName] == elt_ml[matrixIdsPropName]) {
                      return true;
                  }
                  // Fallback for tileMatrix identifiers that don't get prefixed
                  // by their tileMatrixSet identifiers.
                  if (elt[identifierPropName].indexOf(':') === -1) {
                      return (matrixSet[identifierPropName] + ':' + elt[identifierPropName] ===
                          elt_ml[matrixIdsPropName]);
                  }
                  return false;
              });
          }
          else {
              matrixAvailable = true;
          }
          if (matrixAvailable) {
              matrixIds.push(elt[identifierPropName]);
              var resolution = (elt[scaleDenominatorPropName] * 0.28e-3) / metersPerUnit;
              var tileWidth = elt[tileWidthPropName];
              var tileHeight = elt[tileHeightPropName];
              if (switchOriginXY) {
                  origins.push([
                      elt[topLeftCornerPropName][1],
                      elt[topLeftCornerPropName][0],
                  ]);
              }
              else {
                  origins.push(elt[topLeftCornerPropName]);
              }
              resolutions.push(resolution);
              tileSizes.push(tileWidth == tileHeight ? tileWidth : [tileWidth, tileHeight]);
              sizes.push([elt['MatrixWidth'], elt['MatrixHeight']]);
          }
      });
      return new WMTSTileGrid({
          extent: opt_extent,
          origins: origins,
          resolutions: resolutions,
          matrixIds: matrixIds,
          tileSizes: tileSizes,
          sizes: sizes,
      });
  }

  /**
   * @module ol/source/WMTS
   */
  var __extends$1h = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
   * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
   * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
   * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
   * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
   * @property {boolean} [imageSmoothing=true] Enable image smoothing.
   * @property {import("../tilegrid/WMTS.js").default} tileGrid Tile grid.
   * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
   * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
   * Higher values can increase reprojection performance, but decrease precision.
   * @property {import("./WMTSRequestEncoding.js").default|string} [requestEncoding='KVP'] Request encoding.
   * @property {string} layer Layer name as advertised in the WMTS capabilities.
   * @property {string} style Style name as advertised in the WMTS capabilities.
   * @property {typeof import("../ImageTile.js").default} [tileClass]  Class used to instantiate image tiles. Default is {@link module:ol/ImageTile~ImageTile}.
   * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
   * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
   * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
   * should be set to `2`.
   * @property {string} [format='image/jpeg'] Image format. Only used when `requestEncoding` is `'KVP'`.
   * @property {string} [version='1.0.0'] WMTS version.
   * @property {string} matrixSet Matrix set.
   * @property {!Object} [dimensions] Additional "dimensions" for tile requests.
   * This is an object with properties named like the advertised WMTS dimensions.
   * @property {string} [url]  A URL for the service.
   * For the RESTful request encoding, this is a URL
   * template.  For KVP encoding, it is normal URL. A `{?-?}` template pattern,
   * for example `subdomain{a-f}.domain.com`, may be used instead of defining
   * each one separately in the `urls` option.
   * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
   * ```js
   * function(imageTile, src) {
   *   imageTile.getImage().src = src;
   * };
   * ```
   * @property {Array<string>} [urls] An array of URLs.
   * Requests will be distributed among the URLs in this array.
   * @property {boolean} [wrapX=false] Whether to wrap the world horizontally.
   * @property {number} [transition] Duration of the opacity transition for rendering.
   * To disable the opacity transition, pass `transition: 0`.
   */
  /**
   * @classdesc
   * Layer source for tile data from WMTS servers.
   * @api
   */
  var WMTS = /** @class */ (function (_super) {
      __extends$1h(WMTS, _super);
      /**
       * @param {Options} options WMTS options.
       */
      function WMTS(options) {
          // TODO: add support for TileMatrixLimits
          var _this = this;
          var requestEncoding = options.requestEncoding !== undefined
              ? /** @type {import("./WMTSRequestEncoding.js").default} */ (options.requestEncoding)
              : WMTSRequestEncoding.KVP;
          // FIXME: should we create a default tileGrid?
          // we could issue a getCapabilities xhr to retrieve missing configuration
          var tileGrid = options.tileGrid;
          var urls = options.urls;
          if (urls === undefined && options.url !== undefined) {
              urls = expandUrl(options.url);
          }
          _this = _super.call(this, {
              attributions: options.attributions,
              cacheSize: options.cacheSize,
              crossOrigin: options.crossOrigin,
              imageSmoothing: options.imageSmoothing,
              projection: options.projection,
              reprojectionErrorThreshold: options.reprojectionErrorThreshold,
              tileClass: options.tileClass,
              tileGrid: tileGrid,
              tileLoadFunction: options.tileLoadFunction,
              tilePixelRatio: options.tilePixelRatio,
              urls: urls,
              wrapX: options.wrapX !== undefined ? options.wrapX : false,
              transition: options.transition,
          }) || this;
          /**
           * @private
           * @type {string}
           */
          _this.version_ = options.version !== undefined ? options.version : '1.0.0';
          /**
           * @private
           * @type {string}
           */
          _this.format_ = options.format !== undefined ? options.format : 'image/jpeg';
          /**
           * @private
           * @type {!Object}
           */
          _this.dimensions_ =
              options.dimensions !== undefined ? options.dimensions : {};
          /**
           * @private
           * @type {string}
           */
          _this.layer_ = options.layer;
          /**
           * @private
           * @type {string}
           */
          _this.matrixSet_ = options.matrixSet;
          /**
           * @private
           * @type {string}
           */
          _this.style_ = options.style;
          // FIXME: should we guess this requestEncoding from options.url(s)
          //        structure? that would mean KVP only if a template is not provided.
          /**
           * @private
           * @type {import("./WMTSRequestEncoding.js").default}
           */
          _this.requestEncoding_ = requestEncoding;
          _this.setKey(_this.getKeyForDimensions_());
          if (urls && urls.length > 0) {
              _this.tileUrlFunction = createFromTileUrlFunctions(urls.map(_this.createFromWMTSTemplate.bind(_this)));
          }
          return _this;
      }
      /**
       * Set the URLs to use for requests.
       * URLs may contain OGC conform URL Template Variables: {TileMatrix}, {TileRow}, {TileCol}.
       * @param {Array<string>} urls URLs.
       */
      WMTS.prototype.setUrls = function (urls) {
          this.urls = urls;
          var key = urls.join('\n');
          this.setTileUrlFunction(createFromTileUrlFunctions(urls.map(this.createFromWMTSTemplate.bind(this))), key);
      };
      /**
       * Get the dimensions, i.e. those passed to the constructor through the
       * "dimensions" option, and possibly updated using the updateDimensions
       * method.
       * @return {!Object} Dimensions.
       * @api
       */
      WMTS.prototype.getDimensions = function () {
          return this.dimensions_;
      };
      /**
       * Return the image format of the WMTS source.
       * @return {string} Format.
       * @api
       */
      WMTS.prototype.getFormat = function () {
          return this.format_;
      };
      /**
       * Return the layer of the WMTS source.
       * @return {string} Layer.
       * @api
       */
      WMTS.prototype.getLayer = function () {
          return this.layer_;
      };
      /**
       * Return the matrix set of the WMTS source.
       * @return {string} MatrixSet.
       * @api
       */
      WMTS.prototype.getMatrixSet = function () {
          return this.matrixSet_;
      };
      /**
       * Return the request encoding, either "KVP" or "REST".
       * @return {import("./WMTSRequestEncoding.js").default} Request encoding.
       * @api
       */
      WMTS.prototype.getRequestEncoding = function () {
          return this.requestEncoding_;
      };
      /**
       * Return the style of the WMTS source.
       * @return {string} Style.
       * @api
       */
      WMTS.prototype.getStyle = function () {
          return this.style_;
      };
      /**
       * Return the version of the WMTS source.
       * @return {string} Version.
       * @api
       */
      WMTS.prototype.getVersion = function () {
          return this.version_;
      };
      /**
       * @private
       * @return {string} The key for the current dimensions.
       */
      WMTS.prototype.getKeyForDimensions_ = function () {
          var i = 0;
          var res = [];
          for (var key in this.dimensions_) {
              res[i++] = key + '-' + this.dimensions_[key];
          }
          return res.join('/');
      };
      /**
       * Update the dimensions.
       * @param {Object} dimensions Dimensions.
       * @api
       */
      WMTS.prototype.updateDimensions = function (dimensions) {
          assign(this.dimensions_, dimensions);
          this.setKey(this.getKeyForDimensions_());
      };
      /**
       * @param {string} template Template.
       * @return {import("../Tile.js").UrlFunction} Tile URL function.
       */
      WMTS.prototype.createFromWMTSTemplate = function (template) {
          var requestEncoding = this.requestEncoding_;
          // context property names are lower case to allow for a case insensitive
          // replacement as some services use different naming conventions
          var context = {
              'layer': this.layer_,
              'style': this.style_,
              'tilematrixset': this.matrixSet_,
          };
          if (requestEncoding == WMTSRequestEncoding.KVP) {
              assign(context, {
                  'Service': 'WMTS',
                  'Request': 'GetTile',
                  'Version': this.version_,
                  'Format': this.format_,
              });
          }
          // TODO: we may want to create our own appendParams function so that params
          // order conforms to wmts spec guidance, and so that we can avoid to escape
          // special template params
          template =
              requestEncoding == WMTSRequestEncoding.KVP
                  ? appendParams(template, context)
                  : template.replace(/\{(\w+?)\}/g, function (m, p) {
                      return p.toLowerCase() in context ? context[p.toLowerCase()] : m;
                  });
          var tileGrid = /** @type {import("../tilegrid/WMTS.js").default} */ (this
              .tileGrid);
          var dimensions = this.dimensions_;
          return (
          /**
           * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
           * @param {number} pixelRatio Pixel ratio.
           * @param {import("../proj/Projection.js").default} projection Projection.
           * @return {string|undefined} Tile URL.
           */
          function (tileCoord, pixelRatio, projection) {
              if (!tileCoord) {
                  return undefined;
              }
              else {
                  var localContext_1 = {
                      'TileMatrix': tileGrid.getMatrixId(tileCoord[0]),
                      'TileCol': tileCoord[1],
                      'TileRow': tileCoord[2],
                  };
                  assign(localContext_1, dimensions);
                  var url = template;
                  if (requestEncoding == WMTSRequestEncoding.KVP) {
                      url = appendParams(url, localContext_1);
                  }
                  else {
                      url = url.replace(/\{(\w+?)\}/g, function (m, p) {
                          return localContext_1[p];
                      });
                  }
                  return url;
              }
          });
      };
      return WMTS;
  }(TileImage));
  /**
   * Generate source options from a capabilities object.
   * @param {Object} wmtsCap An object representing the capabilities document.
   * @param {!Object} config Configuration properties for the layer.  Defaults for
   *                  the layer will apply if not provided.
   *
   * Required config properties:
   *  - layer - {string} The layer identifier.
   *
   * Optional config properties:
   *  - matrixSet - {string} The matrix set identifier, required if there is
   *       more than one matrix set in the layer capabilities.
   *  - projection - {string} The desired CRS when no matrixSet is specified.
   *       eg: "EPSG:3857". If the desired projection is not available,
   *       an error is thrown.
   *  - requestEncoding - {string} url encoding format for the layer. Default is
   *       the first tile url format found in the GetCapabilities response.
   *  - style - {string} The name of the style
   *  - format - {string} Image format for the layer. Default is the first
   *       format returned in the GetCapabilities response.
   *  - crossOrigin - {string|null|undefined} Cross origin. Default is `undefined`.
   * @return {?Options} WMTS source options object or `null` if the layer was not found.
   * @api
   */
  function optionsFromCapabilities(wmtsCap, config) {
      var layers = wmtsCap['Contents']['Layer'];
      var l = find(layers, function (elt, index, array) {
          return elt['Identifier'] == config['layer'];
      });
      if (l === null) {
          return null;
      }
      var tileMatrixSets = wmtsCap['Contents']['TileMatrixSet'];
      var idx;
      if (l['TileMatrixSetLink'].length > 1) {
          if ('projection' in config) {
              idx = findIndex(l['TileMatrixSetLink'], function (elt, index, array) {
                  var tileMatrixSet = find(tileMatrixSets, function (el) {
                      return el['Identifier'] == elt['TileMatrixSet'];
                  });
                  var supportedCRS = tileMatrixSet['SupportedCRS'];
                  var proj1 = get$2(supportedCRS.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, '$1:$3')) || get$2(supportedCRS);
                  var proj2 = get$2(config['projection']);
                  if (proj1 && proj2) {
                      return equivalent(proj1, proj2);
                  }
                  else {
                      return supportedCRS == config['projection'];
                  }
              });
          }
          else {
              idx = findIndex(l['TileMatrixSetLink'], function (elt, index, array) {
                  return elt['TileMatrixSet'] == config['matrixSet'];
              });
          }
      }
      else {
          idx = 0;
      }
      if (idx < 0) {
          idx = 0;
      }
      var matrixSet = 
      /** @type {string} */
      (l['TileMatrixSetLink'][idx]['TileMatrixSet']);
      var matrixLimits = 
      /** @type {Array<Object>} */
      (l['TileMatrixSetLink'][idx]['TileMatrixSetLimits']);
      var format = /** @type {string} */ (l['Format'][0]);
      if ('format' in config) {
          format = config['format'];
      }
      idx = findIndex(l['Style'], function (elt, index, array) {
          if ('style' in config) {
              return elt['Title'] == config['style'];
          }
          else {
              return elt['isDefault'];
          }
      });
      if (idx < 0) {
          idx = 0;
      }
      var style = /** @type {string} */ (l['Style'][idx]['Identifier']);
      var dimensions = {};
      if ('Dimension' in l) {
          l['Dimension'].forEach(function (elt, index, array) {
              var key = elt['Identifier'];
              var value = elt['Default'];
              if (value === undefined) {
                  value = elt['Value'][0];
              }
              dimensions[key] = value;
          });
      }
      var matrixSets = wmtsCap['Contents']['TileMatrixSet'];
      var matrixSetObj = find(matrixSets, function (elt, index, array) {
          return elt['Identifier'] == matrixSet;
      });
      var projection;
      var code = matrixSetObj['SupportedCRS'];
      if (code) {
          projection =
              get$2(code.replace(/urn:ogc:def:crs:(\w+):(.*:)?(\w+)$/, '$1:$3')) || get$2(code);
      }
      if ('projection' in config) {
          var projConfig = get$2(config['projection']);
          if (projConfig) {
              if (!projection || equivalent(projConfig, projection)) {
                  projection = projConfig;
              }
          }
      }
      var wrapX = false;
      var switchOriginXY = projection.getAxisOrientation().substr(0, 2) == 'ne';
      var matrix = matrixSetObj.TileMatrix[0];
      // create default matrixLimit
      var selectedMatrixLimit = {
          MinTileCol: 0,
          MinTileRow: 0,
          // substract one to end up at tile top left
          MaxTileCol: matrix.MatrixWidth - 1,
          MaxTileRow: matrix.MatrixHeight - 1,
      };
      //in case of matrix limits, use matrix limits to calculate extent
      if (matrixLimits) {
          selectedMatrixLimit = matrixLimits[matrixLimits.length - 1];
          matrix = find(matrixSetObj.TileMatrix, function (value) { return value.Identifier === selectedMatrixLimit.TileMatrix; });
      }
      var resolution = (matrix.ScaleDenominator * 0.00028) / projection.getMetersPerUnit(); // WMTS 1.0.0: standardized rendering pixel size
      var origin = switchOriginXY
          ? [matrix.TopLeftCorner[1], matrix.TopLeftCorner[0]]
          : matrix.TopLeftCorner;
      var tileSpanX = matrix.TileWidth * resolution;
      var tileSpanY = matrix.TileHeight * resolution;
      var extent = [
          origin[0] + tileSpanX * selectedMatrixLimit.MinTileCol,
          // add one to get proper bottom/right coordinate
          origin[1] - tileSpanY * (1 + selectedMatrixLimit.MaxTileRow),
          origin[0] + tileSpanX * (1 + selectedMatrixLimit.MaxTileCol),
          origin[1] - tileSpanY * selectedMatrixLimit.MinTileRow,
      ];
      if (projection.getExtent() === null) {
          projection.setExtent(extent);
      }
      var tileGrid = createFromCapabilitiesMatrixSet(matrixSetObj, extent, matrixLimits);
      /** @type {!Array<string>} */
      var urls = [];
      var requestEncoding = config['requestEncoding'];
      requestEncoding = requestEncoding !== undefined ? requestEncoding : '';
      if ('OperationsMetadata' in wmtsCap &&
          'GetTile' in wmtsCap['OperationsMetadata']) {
          var gets = wmtsCap['OperationsMetadata']['GetTile']['DCP']['HTTP']['Get'];
          for (var i = 0, ii = gets.length; i < ii; ++i) {
              if (gets[i]['Constraint']) {
                  var constraint = find(gets[i]['Constraint'], function (element) {
                      return element['name'] == 'GetEncoding';
                  });
                  var encodings = constraint['AllowedValues']['Value'];
                  if (requestEncoding === '') {
                      // requestEncoding not provided, use the first encoding from the list
                      requestEncoding = encodings[0];
                  }
                  if (requestEncoding === WMTSRequestEncoding.KVP) {
                      if (includes(encodings, WMTSRequestEncoding.KVP)) {
                          urls.push(/** @type {string} */ (gets[i]['href']));
                      }
                  }
                  else {
                      break;
                  }
              }
              else if (gets[i]['href']) {
                  requestEncoding = WMTSRequestEncoding.KVP;
                  urls.push(/** @type {string} */ (gets[i]['href']));
              }
          }
      }
      if (urls.length === 0) {
          requestEncoding = WMTSRequestEncoding.REST;
          l['ResourceURL'].forEach(function (element) {
              if (element['resourceType'] === 'tile') {
                  format = element['format'];
                  urls.push(/** @type {string} */ (element['template']));
              }
          });
      }
      return {
          urls: urls,
          layer: config['layer'],
          matrixSet: matrixSet,
          format: format,
          projection: projection,
          requestEncoding: requestEncoding,
          tileGrid: tileGrid,
          style: style,
          dimensions: dimensions,
          wrapX: wrapX,
          crossOrigin: config['crossOrigin'],
      };
  }

  /**
   * @module ol/xml
   */
  /**
   * Recursively grab all text content of child nodes into a single string.
   * @param {Node} node Node.
   * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
   * breaks.
   * @return {string} All text content.
   * @api
   */
  function getAllTextContent(node, normalizeWhitespace) {
      return getAllTextContent_(node, normalizeWhitespace, []).join('');
  }
  /**
   * Recursively grab all text content of child nodes into a single string.
   * @param {Node} node Node.
   * @param {boolean} normalizeWhitespace Normalize whitespace: remove all line
   * breaks.
   * @param {Array<string>} accumulator Accumulator.
   * @private
   * @return {Array<string>} Accumulator.
   */
  function getAllTextContent_(node, normalizeWhitespace, accumulator) {
      if (node.nodeType == Node.CDATA_SECTION_NODE ||
          node.nodeType == Node.TEXT_NODE) {
          if (normalizeWhitespace) {
              accumulator.push(String(node.nodeValue).replace(/(\r\n|\r|\n)/g, ''));
          }
          else {
              accumulator.push(node.nodeValue);
          }
      }
      else {
          var n = void 0;
          for (n = node.firstChild; n; n = n.nextSibling) {
              getAllTextContent_(n, normalizeWhitespace, accumulator);
          }
      }
      return accumulator;
  }
  /**
   * @param {Object} object Object.
   * @return {boolean} Is a document.
   */
  function isDocument(object) {
      return 'documentElement' in object;
  }
  /**
   * Parse an XML string to an XML Document.
   * @param {string} xml XML.
   * @return {Document} Document.
   * @api
   */
  function parse(xml) {
      return new DOMParser().parseFromString(xml, 'application/xml');
  }
  /**
   * Make an array pusher function for pushing to the array at the top of the
   * object stack.
   * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.
   * @param {T=} opt_this The object to use as `this` in `valueReader`.
   * @return {Parser} Parser.
   * @template T
   */
  function makeArrayPusher(valueReader, opt_this) {
      return (
      /**
       * @param {Element} node Node.
       * @param {Array<*>} objectStack Object stack.
       */
      function (node, objectStack) {
          var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);
          if (value !== undefined) {
              var array = /** @type {Array<*>} */ (objectStack[objectStack.length - 1]);
              array.push(value);
          }
      });
  }
  /**
   * Make an object property pusher function for adding a property to the
   * object at the top of the stack.
   * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.
   * @param {string=} opt_property Property.
   * @param {T=} opt_this The object to use as `this` in `valueReader`.
   * @return {Parser} Parser.
   * @template T
   */
  function makeObjectPropertyPusher(valueReader, opt_property, opt_this) {
      return (
      /**
       * @param {Element} node Node.
       * @param {Array<*>} objectStack Object stack.
       */
      function (node, objectStack) {
          var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);
          if (value !== undefined) {
              var object = /** @type {!Object} */ (objectStack[objectStack.length - 1]);
              var property = opt_property !== undefined ? opt_property : node.localName;
              var array = void 0;
              if (property in object) {
                  array = object[property];
              }
              else {
                  array = [];
                  object[property] = array;
              }
              array.push(value);
          }
      });
  }
  /**
   * Make an object property setter function.
   * @param {function(this: T, Element, Array<*>): *} valueReader Value reader.
   * @param {string=} opt_property Property.
   * @param {T=} opt_this The object to use as `this` in `valueReader`.
   * @return {Parser} Parser.
   * @template T
   */
  function makeObjectPropertySetter(valueReader, opt_property, opt_this) {
      return (
      /**
       * @param {Element} node Node.
       * @param {Array<*>} objectStack Object stack.
       */
      function (node, objectStack) {
          var value = valueReader.call(opt_this !== undefined ? opt_this : this, node, objectStack);
          if (value !== undefined) {
              var object = /** @type {!Object} */ (objectStack[objectStack.length - 1]);
              var property = opt_property !== undefined ? opt_property : node.localName;
              object[property] = value;
          }
      });
  }
  /**
   * Create a namespaced structure, using the same values for each namespace.
   * This can be used as a starting point for versioned parsers, when only a few
   * values are version specific.
   * @param {Array<string>} namespaceURIs Namespace URIs.
   * @param {T} structure Structure.
   * @param {Object<string, T>=} opt_structureNS Namespaced structure to add to.
   * @return {Object<string, T>} Namespaced structure.
   * @template T
   */
  function makeStructureNS(namespaceURIs, structure, opt_structureNS) {
      /**
       * @type {Object<string, T>}
       */
      var structureNS = opt_structureNS !== undefined ? opt_structureNS : {};
      var i, ii;
      for (i = 0, ii = namespaceURIs.length; i < ii; ++i) {
          structureNS[namespaceURIs[i]] = structure;
      }
      return structureNS;
  }
  /**
   * Parse a node using the parsers and object stack.
   * @param {Object<string, Object<string, Parser>>} parsersNS
   *     Parsers by namespace.
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @param {*=} opt_this The object to use as `this`.
   */
  function parseNode(parsersNS, node, objectStack, opt_this) {
      var n;
      for (n = node.firstElementChild; n; n = n.nextElementSibling) {
          var parsers = parsersNS[n.namespaceURI];
          if (parsers !== undefined) {
              var parser = parsers[n.localName];
              if (parser !== undefined) {
                  parser.call(opt_this, n, objectStack);
              }
          }
      }
  }
  /**
   * Push an object on top of the stack, parse and return the popped object.
   * @param {T} object Object.
   * @param {Object<string, Object<string, Parser>>} parsersNS
   *     Parsers by namespace.
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @param {*=} opt_this The object to use as `this`.
   * @return {T} Object.
   * @template T
   */
  function pushParseAndPop(object, parsersNS, node, objectStack, opt_this) {
      objectStack.push(object);
      parseNode(parsersNS, node, objectStack, opt_this);
      return /** @type {T} */ (objectStack.pop());
  }

  /**
   * @module ol/format/XML
   */
  /**
   * @classdesc
   * Generic format for reading non-feature XML data
   *
   * @abstract
   */
  var XML = /** @class */ (function () {
      function XML() {
      }
      /**
       * Read the source document.
       *
       * @param {Document|Element|string} source The XML source.
       * @return {Object} An object representing the source.
       * @api
       */
      XML.prototype.read = function (source) {
          if (!source) {
              return null;
          }
          else if (typeof source === 'string') {
              var doc = parse(source);
              return this.readFromDocument(doc);
          }
          else if (isDocument(source)) {
              return this.readFromDocument(/** @type {Document} */ (source));
          }
          else {
              return this.readFromNode(/** @type {Element} */ (source));
          }
      };
      /**
       * @param {Document} doc Document.
       * @return {Object} Object
       */
      XML.prototype.readFromDocument = function (doc) {
          for (var n = doc.firstChild; n; n = n.nextSibling) {
              if (n.nodeType == Node.ELEMENT_NODE) {
                  return this.readFromNode(/** @type {Element} */ (n));
              }
          }
          return null;
      };
      /**
       * @abstract
       * @param {Element} node Node.
       * @return {Object} Object
       */
      XML.prototype.readFromNode = function (node) { };
      return XML;
  }());

  /**
   * @module ol/format/XLink
   */
  /**
   * @const
   * @type {string}
   */
  var NAMESPACE_URI = 'http://www.w3.org/1999/xlink';
  /**
   * @param {Element} node Node.
   * @return {string|undefined} href.
   */
  function readHref(node) {
      return node.getAttributeNS(NAMESPACE_URI, 'href');
  }

  /**
   * @module ol/format/xsd
   */
  /**
   * @param {Node} node Node.
   * @return {number|undefined} Decimal.
   */
  function readDecimal(node) {
      var s = getAllTextContent(node, false);
      return readDecimalString(s);
  }
  /**
   * @param {string} string String.
   * @return {number|undefined} Decimal.
   */
  function readDecimalString(string) {
      // FIXME check spec
      var m = /^\s*([+\-]?\d*\.?\d+(?:e[+\-]?\d+)?)\s*$/i.exec(string);
      if (m) {
          return parseFloat(m[1]);
      }
      else {
          return undefined;
      }
  }
  /**
   * @param {Node} node Node.
   * @return {number|undefined} Non negative integer.
   */
  function readNonNegativeInteger(node) {
      var s = getAllTextContent(node, false);
      return readNonNegativeIntegerString(s);
  }
  /**
   * @param {string} string String.
   * @return {number|undefined} Non negative integer.
   */
  function readNonNegativeIntegerString(string) {
      var m = /^\s*(\d+)\s*$/.exec(string);
      if (m) {
          return parseInt(m[1], 10);
      }
      else {
          return undefined;
      }
  }
  /**
   * @param {Node} node Node.
   * @return {string|undefined} String.
   */
  function readString(node) {
      return getAllTextContent(node, false).trim();
  }

  var __extends$1i = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @const
   * @type {Array<null|string>}
   */
  var NAMESPACE_URIS = [null, 'http://www.opengis.net/ows/1.1'];
  /**
   * @const
   * @type {Object<string, Object<string, import("../xml.js").Parser>>}
   */
  // @ts-ignore
  var PARSERS = makeStructureNS(NAMESPACE_URIS, {
      'ServiceIdentification': makeObjectPropertySetter(readServiceIdentification),
      'ServiceProvider': makeObjectPropertySetter(readServiceProvider),
      'OperationsMetadata': makeObjectPropertySetter(readOperationsMetadata),
  });
  var OWS = /** @class */ (function (_super) {
      __extends$1i(OWS, _super);
      function OWS() {
          return _super.call(this) || this;
      }
      /**
       * @param {Element} node Node.
       * @return {Object} Object
       */
      OWS.prototype.readFromNode = function (node) {
          var owsObject = pushParseAndPop({}, PARSERS, node, []);
          return owsObject ? owsObject : null;
      };
      return OWS;
  }(XML));
  /**
   * @const
   * @type {Object<string, Object<string, import("../xml.js").Parser>>}
   */
  // @ts-ignore
  var ADDRESS_PARSERS = makeStructureNS(NAMESPACE_URIS, {
      'DeliveryPoint': makeObjectPropertySetter(readString),
      'City': makeObjectPropertySetter(readString),
      'AdministrativeArea': makeObjectPropertySetter(readString),
      'PostalCode': makeObjectPropertySetter(readString),
      'Country': makeObjectPropertySetter(readString),
      'ElectronicMailAddress': makeObjectPropertySetter(readString),
  });
  /**
   * @const
   * @type {Object<string, Object<string, import("../xml.js").Parser>>}
   */
  // @ts-ignore
  var ALLOWED_VALUES_PARSERS = makeStructureNS(NAMESPACE_URIS, {
      'Value': makeObjectPropertyPusher(readValue),
  });
  /**
   * @const
   * @type {Object<string, Object<string, import("../xml.js").Parser>>}
   */
  // @ts-ignore
  var CONSTRAINT_PARSERS = makeStructureNS(NAMESPACE_URIS, {
      'AllowedValues': makeObjectPropertySetter(readAllowedValues),
  });
  /**
   * @const
   * @type {Object<string, Object<string, import("../xml.js").Parser>>}
   */
  // @ts-ignore
  var CONTACT_INFO_PARSERS = makeStructureNS(NAMESPACE_URIS, {
      'Phone': makeObjectPropertySetter(readPhone),
      'Address': makeObjectPropertySetter(readAddress),
  });
  /**
   * @const
   * @type {Object<string, Object<string, import("../xml.js").Parser>>}
   */
  // @ts-ignore
  var DCP_PARSERS = makeStructureNS(NAMESPACE_URIS, {
      'HTTP': makeObjectPropertySetter(readHttp),
  });
  /**
   * @const
   * @type {Object<string, Object<string, import("../xml.js").Parser>>}
   */
  // @ts-ignore
  var HTTP_PARSERS = makeStructureNS(NAMESPACE_URIS, {
      'Get': makeObjectPropertyPusher(readGet),
      'Post': undefined,
  });
  /**
   * @const
   * @type {Object<string, Object<string, import("../xml.js").Parser>>}
   */
  // @ts-ignore
  var OPERATION_PARSERS = makeStructureNS(NAMESPACE_URIS, {
      'DCP': makeObjectPropertySetter(readDcp),
  });
  /**
   * @const
   * @type {Object<string, Object<string, import("../xml.js").Parser>>}
   */
  // @ts-ignore
  var OPERATIONS_METADATA_PARSERS = makeStructureNS(NAMESPACE_URIS, {
      'Operation': readOperation,
  });
  /**
   * @const
   * @type {Object<string, Object<string, import("../xml.js").Parser>>}
   */
  // @ts-ignore
  var PHONE_PARSERS = makeStructureNS(NAMESPACE_URIS, {
      'Voice': makeObjectPropertySetter(readString),
      'Facsimile': makeObjectPropertySetter(readString),
  });
  /**
   * @const
   * @type {Object<string, Object<string, import("../xml.js").Parser>>}
   */
  // @ts-ignore
  var REQUEST_METHOD_PARSERS = makeStructureNS(NAMESPACE_URIS, {
      'Constraint': makeObjectPropertyPusher(readConstraint),
  });
  /**
   * @const
   * @type {Object<string, Object<string, import("../xml.js").Parser>>}
   */
  // @ts-ignore
  var SERVICE_CONTACT_PARSERS = makeStructureNS(NAMESPACE_URIS, {
      'IndividualName': makeObjectPropertySetter(readString),
      'PositionName': makeObjectPropertySetter(readString),
      'ContactInfo': makeObjectPropertySetter(readContactInfo),
  });
  /**
   * @const
   * @type {Object<string, Object<string, import("../xml.js").Parser>>}
   */
  // @ts-ignore
  var SERVICE_IDENTIFICATION_PARSERS = makeStructureNS(NAMESPACE_URIS, {
      'Abstract': makeObjectPropertySetter(readString),
      'AccessConstraints': makeObjectPropertySetter(readString),
      'Fees': makeObjectPropertySetter(readString),
      'Title': makeObjectPropertySetter(readString),
      'ServiceTypeVersion': makeObjectPropertySetter(readString),
      'ServiceType': makeObjectPropertySetter(readString),
  });
  /**
   * @const
   * @type {Object<string, Object<string, import("../xml.js").Parser>>}
   */
  // @ts-ignore
  var SERVICE_PROVIDER_PARSERS = makeStructureNS(NAMESPACE_URIS, {
      'ProviderName': makeObjectPropertySetter(readString),
      'ProviderSite': makeObjectPropertySetter(readHref),
      'ServiceContact': makeObjectPropertySetter(readServiceContact),
  });
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Object|undefined} The address.
   */
  function readAddress(node, objectStack) {
      return pushParseAndPop({}, ADDRESS_PARSERS, node, objectStack);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Object|undefined} The values.
   */
  function readAllowedValues(node, objectStack) {
      return pushParseAndPop({}, ALLOWED_VALUES_PARSERS, node, objectStack);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Object|undefined} The constraint.
   */
  function readConstraint(node, objectStack) {
      var name = node.getAttribute('name');
      if (!name) {
          return undefined;
      }
      return pushParseAndPop({ 'name': name }, CONSTRAINT_PARSERS, node, objectStack);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Object|undefined} The contact info.
   */
  function readContactInfo(node, objectStack) {
      return pushParseAndPop({}, CONTACT_INFO_PARSERS, node, objectStack);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Object|undefined} The DCP.
   */
  function readDcp(node, objectStack) {
      return pushParseAndPop({}, DCP_PARSERS, node, objectStack);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Object|undefined} The GET object.
   */
  function readGet(node, objectStack) {
      var href = readHref(node);
      if (!href) {
          return undefined;
      }
      return pushParseAndPop({ 'href': href }, REQUEST_METHOD_PARSERS, node, objectStack);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Object|undefined} The HTTP object.
   */
  function readHttp(node, objectStack) {
      return pushParseAndPop({}, HTTP_PARSERS, node, objectStack);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Object|undefined} The operation.
   */
  function readOperation(node, objectStack) {
      var name = node.getAttribute('name');
      var value = pushParseAndPop({}, OPERATION_PARSERS, node, objectStack);
      if (!value) {
          return undefined;
      }
      var object = /** @type {Object} */ (objectStack[objectStack.length - 1]);
      object[name] = value;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Object|undefined} The operations metadata.
   */
  function readOperationsMetadata(node, objectStack) {
      return pushParseAndPop({}, OPERATIONS_METADATA_PARSERS, node, objectStack);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Object|undefined} The phone.
   */
  function readPhone(node, objectStack) {
      return pushParseAndPop({}, PHONE_PARSERS, node, objectStack);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Object|undefined} The service identification.
   */
  function readServiceIdentification(node, objectStack) {
      return pushParseAndPop({}, SERVICE_IDENTIFICATION_PARSERS, node, objectStack);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Object|undefined} The service contact.
   */
  function readServiceContact(node, objectStack) {
      return pushParseAndPop({}, SERVICE_CONTACT_PARSERS, node, objectStack);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Object|undefined} The service provider.
   */
  function readServiceProvider(node, objectStack) {
      return pushParseAndPop({}, SERVICE_PROVIDER_PARSERS, node, objectStack);
  }
  /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {string|undefined} The value.
   */
  function readValue(node, objectStack) {
      return readString(node);
  }

  var __extends$1j = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @const
   * @type {Array<null|string>}
   */
  var NAMESPACE_URIS$1 = [null, 'http://www.opengis.net/wmts/1.0'];
  /**
   * @const
   * @type {Array<null|string>}
   */
  var OWS_NAMESPACE_URIS = [null, 'http://www.opengis.net/ows/1.1'];
  /**
   * @const
   * @type {Object<string, Object<string, import("../xml.js").Parser>>}
   */
  // @ts-ignore
  var PARSERS$1 = makeStructureNS(NAMESPACE_URIS$1, {
      'Contents': makeObjectPropertySetter(readContents),
  });
  /**
   * @classdesc
   * Format for reading WMTS capabilities data.
   *
   * @api
   */
  var WMTSCapabilities = /** @class */ (function (_super) {
      __extends$1j(WMTSCapabilities, _super);
      function WMTSCapabilities() {
          var _this = _super.call(this) || this;
          /**
           * @type {OWS}
           * @private
           */
          _this.owsParser_ = new OWS();
          return _this;
      }
      /**
       * @param {Element} node Node.
       * @return {Object} Object
       */
      WMTSCapabilities.prototype.readFromNode = function (node) {
          var version = node.getAttribute('version');
          if (version) {
              version = version.trim();
          }
          var WMTSCapabilityObject = this.owsParser_.readFromNode(node);
          if (!WMTSCapabilityObject) {
              return null;
          }
          WMTSCapabilityObject['version'] = version;
          WMTSCapabilityObject = pushParseAndPop(WMTSCapabilityObject, PARSERS$1, node, []);
          return WMTSCapabilityObject ? WMTSCapabilityObject : null;
      };
      return WMTSCapabilities;
  }(XML));
  /**
   * @const
   * @type {Object<string, Object<string, import("../xml.js").Parser>>}
   */
  // @ts-ignore
  var CONTENTS_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
      'Layer': makeObjectPropertyPusher(readLayer),
      'TileMatrixSet': makeObjectPropertyPusher(readTileMatrixSet),
  });
  /**
   * @const
   * @type {Object<string, Object<string, import("../xml.js").Parser>>}
   */
  // @ts-ignore
  var LAYER_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
      'Style': makeObjectPropertyPusher(readStyle),
      'Format': makeObjectPropertyPusher(readString),
      'TileMatrixSetLink': makeObjectPropertyPusher(readTileMatrixSetLink),
      'Dimension': makeObjectPropertyPusher(readDimensions),
      'ResourceURL': makeObjectPropertyPusher(readResourceUrl),
  }, makeStructureNS(OWS_NAMESPACE_URIS, {
      'Title': makeObjectPropertySetter(readString),
      'Abstract': makeObjectPropertySetter(readString),
      'WGS84BoundingBox': makeObjectPropertySetter(readWgs84BoundingBox),
      'Identifier': makeObjectPropertySetter(readString),
  }));
  /**
   * @const
   * @type {Object<string, Object<string, import("../xml.js").Parser>>}
   */
  // @ts-ignore
  var STYLE_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
      'LegendURL': makeObjectPropertyPusher(readLegendUrl),
  }, makeStructureNS(OWS_NAMESPACE_URIS, {
      'Title': makeObjectPropertySetter(readString),
      'Identifier': makeObjectPropertySetter(readString),
  }));
  /**
   * @const
   * @type {Object<string, Object<string, import("../xml.js").Parser>>}
   */
  // @ts-ignore
  var TMS_LINKS_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
      'TileMatrixSet': makeObjectPropertySetter(readString),
      'TileMatrixSetLimits': makeObjectPropertySetter(readTileMatrixLimitsList),
  });
  /**
   * @const
   * @type {Object<string, Object<string, import("../xml.js").Parser>>}
   */
  // @ts-ignore
  var TMS_LIMITS_LIST_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
      'TileMatrixLimits': makeArrayPusher(readTileMatrixLimits),
  });
  /**
   * @const
   * @type {Object<string, Object<string, import("../xml.js").Parser>>}
   */
  // @ts-ignore
  var TMS_LIMITS_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
      'TileMatrix': makeObjectPropertySetter(readString),
      'MinTileRow': makeObjectPropertySetter(readNonNegativeInteger),
      'MaxTileRow': makeObjectPropertySetter(readNonNegativeInteger),
      'MinTileCol': makeObjectPropertySetter(readNonNegativeInteger),
      'MaxTileCol': makeObjectPropertySetter(readNonNegativeInteger),
  });
  /**
   * @const
   * @type {Object<string, Object<string, import("../xml.js").Parser>>}
   */
  // @ts-ignore
  var DIMENSION_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
      'Default': makeObjectPropertySetter(readString),
      'Value': makeObjectPropertyPusher(readString),
  }, makeStructureNS(OWS_NAMESPACE_URIS, {
      'Identifier': makeObjectPropertySetter(readString),
  }));
  /**
   * @const
   * @type {Object<string, Object<string, import("../xml.js").Parser>>}
   */
  // @ts-ignore
  var WGS84_BBOX_READERS = makeStructureNS(OWS_NAMESPACE_URIS, {
      'LowerCorner': makeArrayPusher(readCoordinates),
      'UpperCorner': makeArrayPusher(readCoordinates),
  });
  /**
   * @const
   * @type {Object<string, Object<string, import("../xml.js").Parser>>}
   */
  // @ts-ignore
  var TMS_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
      'WellKnownScaleSet': makeObjectPropertySetter(readString),
      'TileMatrix': makeObjectPropertyPusher(readTileMatrix),
  }, makeStructureNS(OWS_NAMESPACE_URIS, {
      'SupportedCRS': makeObjectPropertySetter(readString),
      'Identifier': makeObjectPropertySetter(readString),
  }));
  /**
   * @const
   * @type {Object<string, Object<string, import("../xml.js").Parser>>}
   */
  // @ts-ignore
  var TM_PARSERS = makeStructureNS(NAMESPACE_URIS$1, {
      'TopLeftCorner': makeObjectPropertySetter(readCoordinates),
      'ScaleDenominator': makeObjectPropertySetter(readDecimal),
      'TileWidth': makeObjectPropertySetter(readNonNegativeInteger),
      'TileHeight': makeObjectPropertySetter(readNonNegativeInteger),
      'MatrixWidth': makeObjectPropertySetter(readNonNegativeInteger),
      'MatrixHeight': makeObjectPropertySetter(readNonNegativeInteger),
  }, makeStructureNS(OWS_NAMESPACE_URIS, {
      'Identifier': makeObjectPropertySetter(readString),
  }));
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Object|undefined} Attribution object.
   */
  function readContents(node, objectStack) {
      return pushParseAndPop({}, CONTENTS_PARSERS, node, objectStack);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Object|undefined} Layers object.
   */
  function readLayer(node, objectStack) {
      return pushParseAndPop({}, LAYER_PARSERS, node, objectStack);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Object|undefined} Tile Matrix Set object.
   */
  function readTileMatrixSet(node, objectStack) {
      return pushParseAndPop({}, TMS_PARSERS, node, objectStack);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Object|undefined} Style object.
   */
  function readStyle(node, objectStack) {
      var style = pushParseAndPop({}, STYLE_PARSERS, node, objectStack);
      if (!style) {
          return undefined;
      }
      var isDefault = node.getAttribute('isDefault') === 'true';
      style['isDefault'] = isDefault;
      return style;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Object|undefined} Tile Matrix Set Link object.
   */
  function readTileMatrixSetLink(node, objectStack) {
      return pushParseAndPop({}, TMS_LINKS_PARSERS, node, objectStack);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Object|undefined} Dimension object.
   */
  function readDimensions(node, objectStack) {
      return pushParseAndPop({}, DIMENSION_PARSERS, node, objectStack);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Object|undefined} Resource URL object.
   */
  function readResourceUrl(node, objectStack) {
      var format = node.getAttribute('format');
      var template = node.getAttribute('template');
      var resourceType = node.getAttribute('resourceType');
      var resource = {};
      if (format) {
          resource['format'] = format;
      }
      if (template) {
          resource['template'] = template;
      }
      if (resourceType) {
          resource['resourceType'] = resourceType;
      }
      return resource;
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Object|undefined} WGS84 BBox object.
   */
  function readWgs84BoundingBox(node, objectStack) {
      var coordinates = pushParseAndPop([], WGS84_BBOX_READERS, node, objectStack);
      if (coordinates.length != 2) {
          return undefined;
      }
      return boundingExtent(coordinates);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Object|undefined} Legend object.
   */
  function readLegendUrl(node, objectStack) {
      var legend = {};
      legend['format'] = node.getAttribute('format');
      legend['href'] = readHref(node);
      return legend;
  }
  /**
   * @param {Node} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Object|undefined} Coordinates object.
   */
  function readCoordinates(node, objectStack) {
      var coordinates = readString(node).split(/\s+/);
      if (!coordinates || coordinates.length != 2) {
          return undefined;
      }
      var x = +coordinates[0];
      var y = +coordinates[1];
      if (isNaN(x) || isNaN(y)) {
          return undefined;
      }
      return [x, y];
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Object|undefined} TileMatrix object.
   */
  function readTileMatrix(node, objectStack) {
      return pushParseAndPop({}, TM_PARSERS, node, objectStack);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Object|undefined} TileMatrixSetLimits Object.
   */
  function readTileMatrixLimitsList(node, objectStack) {
      return pushParseAndPop([], TMS_LIMITS_LIST_PARSERS, node, objectStack);
  }
  /**
   * @param {Element} node Node.
   * @param {Array<*>} objectStack Object stack.
   * @return {Object|undefined} TileMatrixLimits Array.
   */
  function readTileMatrixLimits(node, objectStack) {
      return pushParseAndPop({}, TMS_LIMITS_PARSERS, node, objectStack);
  }

  function globals(defs) {
    defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
    defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
    defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");

    defs.WGS84 = defs['EPSG:4326'];
    defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
    defs.GOOGLE = defs['EPSG:3857'];
    defs['EPSG:900913'] = defs['EPSG:3857'];
    defs['EPSG:102113'] = defs['EPSG:3857'];
  }

  var PJD_3PARAM = 1;
  var PJD_7PARAM = 2;
  var PJD_WGS84 = 4; // WGS84 or equivalent
  var PJD_NODATUM = 5; // WGS84 or equivalent
  var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
  var HALF_PI = Math.PI/2;
  // ellipoid pj_set_ell.c
  var SIXTH = 0.1666666666666666667;
  /* 1/6 */
  var RA4 = 0.04722222222222222222;
  /* 17/360 */
  var RA6 = 0.02215608465608465608;
  var EPSLN = 1.0e-10;
  // you'd think you could use Number.EPSILON above but that makes
  // Mollweide get into an infinate loop.

  var D2R = 0.01745329251994329577;
  var R2D = 57.29577951308232088;
  var FORTPI = Math.PI/4;
  var TWO_PI = Math.PI * 2;
  // SPI is slightly greater than Math.PI, so values that exceed the -180..180
  // degree range by a tiny amount don't get wrapped. This prevents points that
  // have drifted from their original location along the 180th meridian (due to
  // floating point error) from changing their sign.
  var SPI = 3.14159265359;

  var exports$1 = {};

  exports$1.greenwich = 0.0; //"0dE",
  exports$1.lisbon = -9.131906111111; //"9d07'54.862\"W",
  exports$1.paris = 2.337229166667; //"2d20'14.025\"E",
  exports$1.bogota = -74.080916666667; //"74d04'51.3\"W",
  exports$1.madrid = -3.687938888889; //"3d41'16.58\"W",
  exports$1.rome = 12.452333333333; //"12d27'8.4\"E",
  exports$1.bern = 7.439583333333; //"7d26'22.5\"E",
  exports$1.jakarta = 106.807719444444; //"106d48'27.79\"E",
  exports$1.ferro = -17.666666666667; //"17d40'W",
  exports$1.brussels = 4.367975; //"4d22'4.71\"E",
  exports$1.stockholm = 18.058277777778; //"18d3'29.8\"E",
  exports$1.athens = 23.7163375; //"23d42'58.815\"E",
  exports$1.oslo = 10.722916666667; //"10d43'22.5\"E"

  var units = {
    ft: {to_meter: 0.3048},
    'us-ft': {to_meter: 1200 / 3937}
  };

  var ignoredChar = /[\s_\-\/\(\)]/g;
  function match(obj, key) {
    if (obj[key]) {
      return obj[key];
    }
    var keys = Object.keys(obj);
    var lkey = key.toLowerCase().replace(ignoredChar, '');
    var i = -1;
    var testkey, processedKey;
    while (++i < keys.length) {
      testkey = keys[i];
      processedKey = testkey.toLowerCase().replace(ignoredChar, '');
      if (processedKey === lkey) {
        return obj[testkey];
      }
    }
  }

  function projStr(defData) {
    var self = {};
    var paramObj = defData.split('+').map(function(v) {
      return v.trim();
    }).filter(function(a) {
      return a;
    }).reduce(function(p, a) {
      var split = a.split('=');
      split.push(true);
      p[split[0].toLowerCase()] = split[1];
      return p;
    }, {});
    var paramName, paramVal, paramOutname;
    var params = {
      proj: 'projName',
      datum: 'datumCode',
      rf: function(v) {
        self.rf = parseFloat(v);
      },
      lat_0: function(v) {
        self.lat0 = v * D2R;
      },
      lat_1: function(v) {
        self.lat1 = v * D2R;
      },
      lat_2: function(v) {
        self.lat2 = v * D2R;
      },
      lat_ts: function(v) {
        self.lat_ts = v * D2R;
      },
      lon_0: function(v) {
        self.long0 = v * D2R;
      },
      lon_1: function(v) {
        self.long1 = v * D2R;
      },
      lon_2: function(v) {
        self.long2 = v * D2R;
      },
      alpha: function(v) {
        self.alpha = parseFloat(v) * D2R;
      },
      lonc: function(v) {
        self.longc = v * D2R;
      },
      x_0: function(v) {
        self.x0 = parseFloat(v);
      },
      y_0: function(v) {
        self.y0 = parseFloat(v);
      },
      k_0: function(v) {
        self.k0 = parseFloat(v);
      },
      k: function(v) {
        self.k0 = parseFloat(v);
      },
      a: function(v) {
        self.a = parseFloat(v);
      },
      b: function(v) {
        self.b = parseFloat(v);
      },
      r_a: function() {
        self.R_A = true;
      },
      zone: function(v) {
        self.zone = parseInt(v, 10);
      },
      south: function() {
        self.utmSouth = true;
      },
      towgs84: function(v) {
        self.datum_params = v.split(",").map(function(a) {
          return parseFloat(a);
        });
      },
      to_meter: function(v) {
        self.to_meter = parseFloat(v);
      },
      units: function(v) {
        self.units = v;
        var unit = match(units, v);
        if (unit) {
          self.to_meter = unit.to_meter;
        }
      },
      from_greenwich: function(v) {
        self.from_greenwich = v * D2R;
      },
      pm: function(v) {
        var pm = match(exports$1, v);
        self.from_greenwich = (pm ? pm : parseFloat(v)) * D2R;
      },
      nadgrids: function(v) {
        if (v === '@null') {
          self.datumCode = 'none';
        }
        else {
          self.nadgrids = v;
        }
      },
      axis: function(v) {
        var legalAxis = "ewnsud";
        if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
          self.axis = v;
        }
      }
    };
    for (paramName in paramObj) {
      paramVal = paramObj[paramName];
      if (paramName in params) {
        paramOutname = params[paramName];
        if (typeof paramOutname === 'function') {
          paramOutname(paramVal);
        }
        else {
          self[paramOutname] = paramVal;
        }
      }
      else {
        self[paramName] = paramVal;
      }
    }
    if(typeof self.datumCode === 'string' && self.datumCode !== "WGS84"){
      self.datumCode = self.datumCode.toLowerCase();
    }
    return self;
  }

  var NEUTRAL = 1;
  var KEYWORD = 2;
  var NUMBER = 3;
  var QUOTED = 4;
  var AFTERQUOTE = 5;
  var ENDED = -1;
  var whitespace = /\s/;
  var latin = /[A-Za-z]/;
  var keyword = /[A-Za-z84]/;
  var endThings = /[,\]]/;
  var digets = /[\d\.E\-\+]/;
  // const ignoredChar = /[\s_\-\/\(\)]/g;
  function Parser(text) {
    if (typeof text !== 'string') {
      throw new Error('not a string');
    }
    this.text = text.trim();
    this.level = 0;
    this.place = 0;
    this.root = null;
    this.stack = [];
    this.currentObject = null;
    this.state = NEUTRAL;
  }
  Parser.prototype.readCharicter = function() {
    var char = this.text[this.place++];
    if (this.state !== QUOTED) {
      while (whitespace.test(char)) {
        if (this.place >= this.text.length) {
          return;
        }
        char = this.text[this.place++];
      }
    }
    switch (this.state) {
      case NEUTRAL:
        return this.neutral(char);
      case KEYWORD:
        return this.keyword(char)
      case QUOTED:
        return this.quoted(char);
      case AFTERQUOTE:
        return this.afterquote(char);
      case NUMBER:
        return this.number(char);
      case ENDED:
        return;
    }
  };
  Parser.prototype.afterquote = function(char) {
    if (char === '"') {
      this.word += '"';
      this.state = QUOTED;
      return;
    }
    if (endThings.test(char)) {
      this.word = this.word.trim();
      this.afterItem(char);
      return;
    }
    throw new Error('havn\'t handled "' +char + '" in afterquote yet, index ' + this.place);
  };
  Parser.prototype.afterItem = function(char) {
    if (char === ',') {
      if (this.word !== null) {
        this.currentObject.push(this.word);
      }
      this.word = null;
      this.state = NEUTRAL;
      return;
    }
    if (char === ']') {
      this.level--;
      if (this.word !== null) {
        this.currentObject.push(this.word);
        this.word = null;
      }
      this.state = NEUTRAL;
      this.currentObject = this.stack.pop();
      if (!this.currentObject) {
        this.state = ENDED;
      }

      return;
    }
  };
  Parser.prototype.number = function(char) {
    if (digets.test(char)) {
      this.word += char;
      return;
    }
    if (endThings.test(char)) {
      this.word = parseFloat(this.word);
      this.afterItem(char);
      return;
    }
    throw new Error('havn\'t handled "' +char + '" in number yet, index ' + this.place);
  };
  Parser.prototype.quoted = function(char) {
    if (char === '"') {
      this.state = AFTERQUOTE;
      return;
    }
    this.word += char;
    return;
  };
  Parser.prototype.keyword = function(char) {
    if (keyword.test(char)) {
      this.word += char;
      return;
    }
    if (char === '[') {
      var newObjects = [];
      newObjects.push(this.word);
      this.level++;
      if (this.root === null) {
        this.root = newObjects;
      } else {
        this.currentObject.push(newObjects);
      }
      this.stack.push(this.currentObject);
      this.currentObject = newObjects;
      this.state = NEUTRAL;
      return;
    }
    if (endThings.test(char)) {
      this.afterItem(char);
      return;
    }
    throw new Error('havn\'t handled "' +char + '" in keyword yet, index ' + this.place);
  };
  Parser.prototype.neutral = function(char) {
    if (latin.test(char)) {
      this.word = char;
      this.state = KEYWORD;
      return;
    }
    if (char === '"') {
      this.word = '';
      this.state = QUOTED;
      return;
    }
    if (digets.test(char)) {
      this.word = char;
      this.state = NUMBER;
      return;
    }
    if (endThings.test(char)) {
      this.afterItem(char);
      return;
    }
    throw new Error('havn\'t handled "' +char + '" in neutral yet, index ' + this.place);
  };
  Parser.prototype.output = function() {
    while (this.place < this.text.length) {
      this.readCharicter();
    }
    if (this.state === ENDED) {
      return this.root;
    }
    throw new Error('unable to parse string "' +this.text + '". State is ' + this.state);
  };

  function parseString(txt) {
    var parser = new Parser(txt);
    return parser.output();
  }

  function mapit(obj, key, value) {
    if (Array.isArray(key)) {
      value.unshift(key);
      key = null;
    }
    var thing = key ? {} : obj;

    var out = value.reduce(function(newObj, item) {
      sExpr(item, newObj);
      return newObj
    }, thing);
    if (key) {
      obj[key] = out;
    }
  }

  function sExpr(v, obj) {
    if (!Array.isArray(v)) {
      obj[v] = true;
      return;
    }
    var key = v.shift();
    if (key === 'PARAMETER') {
      key = v.shift();
    }
    if (v.length === 1) {
      if (Array.isArray(v[0])) {
        obj[key] = {};
        sExpr(v[0], obj[key]);
        return;
      }
      obj[key] = v[0];
      return;
    }
    if (!v.length) {
      obj[key] = true;
      return;
    }
    if (key === 'TOWGS84') {
      obj[key] = v;
      return;
    }
    if (key === 'AXIS') {
      if (!(key in obj)) {
        obj[key] = [];
      }
      obj[key].push(v);
      return;
    }
    if (!Array.isArray(key)) {
      obj[key] = {};
    }

    var i;
    switch (key) {
      case 'UNIT':
      case 'PRIMEM':
      case 'VERT_DATUM':
        obj[key] = {
          name: v[0].toLowerCase(),
          convert: v[1]
        };
        if (v.length === 3) {
          sExpr(v[2], obj[key]);
        }
        return;
      case 'SPHEROID':
      case 'ELLIPSOID':
        obj[key] = {
          name: v[0],
          a: v[1],
          rf: v[2]
        };
        if (v.length === 4) {
          sExpr(v[3], obj[key]);
        }
        return;
      case 'PROJECTEDCRS':
      case 'PROJCRS':
      case 'GEOGCS':
      case 'GEOCCS':
      case 'PROJCS':
      case 'LOCAL_CS':
      case 'GEODCRS':
      case 'GEODETICCRS':
      case 'GEODETICDATUM':
      case 'EDATUM':
      case 'ENGINEERINGDATUM':
      case 'VERT_CS':
      case 'VERTCRS':
      case 'VERTICALCRS':
      case 'COMPD_CS':
      case 'COMPOUNDCRS':
      case 'ENGINEERINGCRS':
      case 'ENGCRS':
      case 'FITTED_CS':
      case 'LOCAL_DATUM':
      case 'DATUM':
        v[0] = ['name', v[0]];
        mapit(obj, key, v);
        return;
      default:
        i = -1;
        while (++i < v.length) {
          if (!Array.isArray(v[i])) {
            return sExpr(v, obj[key]);
          }
        }
        return mapit(obj, key, v);
    }
  }

  var D2R$1 = 0.01745329251994329577;



  function rename(obj, params) {
    var outName = params[0];
    var inName = params[1];
    if (!(outName in obj) && (inName in obj)) {
      obj[outName] = obj[inName];
      if (params.length === 3) {
        obj[outName] = params[2](obj[outName]);
      }
    }
  }

  function d2r(input) {
    return input * D2R$1;
  }

  function cleanWKT(wkt) {
    if (wkt.type === 'GEOGCS') {
      wkt.projName = 'longlat';
    } else if (wkt.type === 'LOCAL_CS') {
      wkt.projName = 'identity';
      wkt.local = true;
    } else {
      if (typeof wkt.PROJECTION === 'object') {
        wkt.projName = Object.keys(wkt.PROJECTION)[0];
      } else {
        wkt.projName = wkt.PROJECTION;
      }
    }
    if (wkt.AXIS) {
      var axisOrder = '';
      for (var i = 0, ii = wkt.AXIS.length; i < ii; ++i) {
        var axis = wkt.AXIS[i];
        var descriptor = axis[0].toLowerCase();
        if (descriptor.indexOf('north') !== -1) {
          axisOrder += 'n';
        } else if (descriptor.indexOf('south') !== -1) {
          axisOrder += 's';
        } else if (descriptor.indexOf('east') !== -1) {
          axisOrder += 'e';
        } else if (descriptor.indexOf('west') !== -1) {
          axisOrder += 'w';
        }
      }
      if (axisOrder.length === 2) {
        axisOrder += 'u';
      }
      if (axisOrder.length === 3) {
        wkt.axis = axisOrder;
      }
    }
    if (wkt.UNIT) {
      wkt.units = wkt.UNIT.name.toLowerCase();
      if (wkt.units === 'metre') {
        wkt.units = 'meter';
      }
      if (wkt.UNIT.convert) {
        if (wkt.type === 'GEOGCS') {
          if (wkt.DATUM && wkt.DATUM.SPHEROID) {
            wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;
          }
        } else {
          wkt.to_meter = wkt.UNIT.convert;
        }
      }
    }
    var geogcs = wkt.GEOGCS;
    if (wkt.type === 'GEOGCS') {
      geogcs = wkt;
    }
    if (geogcs) {
      //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
      //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
      //}
      if (geogcs.DATUM) {
        wkt.datumCode = geogcs.DATUM.name.toLowerCase();
      } else {
        wkt.datumCode = geogcs.name.toLowerCase();
      }
      if (wkt.datumCode.slice(0, 2) === 'd_') {
        wkt.datumCode = wkt.datumCode.slice(2);
      }
      if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
        wkt.datumCode = 'nzgd49';
      }
      if (wkt.datumCode === 'wgs_1984' || wkt.datumCode === 'world_geodetic_system_1984') {
        if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
          wkt.sphere = true;
        }
        wkt.datumCode = 'wgs84';
      }
      if (wkt.datumCode.slice(-6) === '_ferro') {
        wkt.datumCode = wkt.datumCode.slice(0, - 6);
      }
      if (wkt.datumCode.slice(-8) === '_jakarta') {
        wkt.datumCode = wkt.datumCode.slice(0, - 8);
      }
      if (~wkt.datumCode.indexOf('belge')) {
        wkt.datumCode = 'rnb72';
      }
      if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
        wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
        if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
          wkt.ellps = 'intl';
        }

        wkt.a = geogcs.DATUM.SPHEROID.a;
        wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
      }

      if (geogcs.DATUM && geogcs.DATUM.TOWGS84) {
        wkt.datum_params = geogcs.DATUM.TOWGS84;
      }
      if (~wkt.datumCode.indexOf('osgb_1936')) {
        wkt.datumCode = 'osgb36';
      }
      if (~wkt.datumCode.indexOf('osni_1952')) {
        wkt.datumCode = 'osni52';
      }
      if (~wkt.datumCode.indexOf('tm65')
        || ~wkt.datumCode.indexOf('geodetic_datum_of_1965')) {
        wkt.datumCode = 'ire65';
      }
      if (wkt.datumCode === 'ch1903+') {
        wkt.datumCode = 'ch1903';
      }
      if (~wkt.datumCode.indexOf('israel')) {
        wkt.datumCode = 'isr93';
      }
    }
    if (wkt.b && !isFinite(wkt.b)) {
      wkt.b = wkt.a;
    }

    function toMeter(input) {
      var ratio = wkt.to_meter || 1;
      return input * ratio;
    }
    var renamer = function(a) {
      return rename(wkt, a);
    };
    var list = [
      ['standard_parallel_1', 'Standard_Parallel_1'],
      ['standard_parallel_2', 'Standard_Parallel_2'],
      ['false_easting', 'False_Easting'],
      ['false_northing', 'False_Northing'],
      ['central_meridian', 'Central_Meridian'],
      ['latitude_of_origin', 'Latitude_Of_Origin'],
      ['latitude_of_origin', 'Central_Parallel'],
      ['scale_factor', 'Scale_Factor'],
      ['k0', 'scale_factor'],
      ['latitude_of_center', 'Latitude_Of_Center'],
      ['latitude_of_center', 'Latitude_of_center'],
      ['lat0', 'latitude_of_center', d2r],
      ['longitude_of_center', 'Longitude_Of_Center'],
      ['longitude_of_center', 'Longitude_of_center'],
      ['longc', 'longitude_of_center', d2r],
      ['x0', 'false_easting', toMeter],
      ['y0', 'false_northing', toMeter],
      ['long0', 'central_meridian', d2r],
      ['lat0', 'latitude_of_origin', d2r],
      ['lat0', 'standard_parallel_1', d2r],
      ['lat1', 'standard_parallel_1', d2r],
      ['lat2', 'standard_parallel_2', d2r],
      ['azimuth', 'Azimuth'],
      ['alpha', 'azimuth', d2r],
      ['srsCode', 'name']
    ];
    list.forEach(renamer);
    if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
      wkt.long0 = wkt.longc;
    }
    if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
      wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
      wkt.lat_ts = wkt.lat1;
    }
  }
  function wkt(wkt) {
    var lisp = parseString(wkt);
    var type = lisp.shift();
    var name = lisp.shift();
    lisp.unshift(['name', name]);
    lisp.unshift(['type', type]);
    var obj = {};
    sExpr(lisp, obj);
    cleanWKT(obj);
    return obj;
  }

  function defs(name) {
    /*global console*/
    var that = this;
    if (arguments.length === 2) {
      var def = arguments[1];
      if (typeof def === 'string') {
        if (def.charAt(0) === '+') {
          defs[name] = projStr(arguments[1]);
        }
        else {
          defs[name] = wkt(arguments[1]);
        }
      } else {
        defs[name] = def;
      }
    }
    else if (arguments.length === 1) {
      if (Array.isArray(name)) {
        return name.map(function(v) {
          if (Array.isArray(v)) {
            defs.apply(that, v);
          }
          else {
            defs(v);
          }
        });
      }
      else if (typeof name === 'string') {
        if (name in defs) {
          return defs[name];
        }
      }
      else if ('EPSG' in name) {
        defs['EPSG:' + name.EPSG] = name;
      }
      else if ('ESRI' in name) {
        defs['ESRI:' + name.ESRI] = name;
      }
      else if ('IAU2000' in name) {
        defs['IAU2000:' + name.IAU2000] = name;
      }
      else {
        console.log(name);
      }
      return;
    }


  }
  globals(defs);

  function testObj(code){
    return typeof code === 'string';
  }
  function testDef(code){
    return code in defs;
  }
   var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS','GEOCCS','PROJCS','LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS'];
  function testWKT(code){
    return codeWords.some(function (word) {
      return code.indexOf(word) > -1;
    });
  }
  var codes = ['3857', '900913', '3785', '102113'];
  function checkMercator(item) {
    var auth = match(item, 'authority');
    if (!auth) {
      return;
    }
    var code = match(auth, 'epsg');
    return code && codes.indexOf(code) > -1;
  }
  function checkProjStr(item) {
    var ext = match(item, 'extension');
    if (!ext) {
      return;
    }
    return match(ext, 'proj4');
  }
  function testProj(code){
    return code[0] === '+';
  }
  function parse$1(code){
    if (testObj(code)) {
      //check to see if this is a WKT string
      if (testDef(code)) {
        return defs[code];
      }
      if (testWKT(code)) {
        var out = wkt(code);
        // test of spetial case, due to this being a very common and often malformed
        if (checkMercator(out)) {
          return defs['EPSG:3857'];
        }
        var maybeProjStr = checkProjStr(out);
        if (maybeProjStr) {
          return projStr(maybeProjStr);
        }
        return out;
      }
      if (testProj(code)) {
        return projStr(code);
      }
    }else {
      return code;
    }
  }

  function extend$2(destination, source) {
    destination = destination || {};
    var value, property;
    if (!source) {
      return destination;
    }
    for (property in source) {
      value = source[property];
      if (value !== undefined) {
        destination[property] = value;
      }
    }
    return destination;
  }

  function msfnz(eccent, sinphi, cosphi) {
    var con = eccent * sinphi;
    return cosphi / (Math.sqrt(1 - con * con));
  }

  function sign(x) {
    return x<0 ? -1 : 1;
  }

  function adjust_lon(x) {
    return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));
  }

  function tsfnz(eccent, phi, sinphi) {
    var con = eccent * sinphi;
    var com = 0.5 * eccent;
    con = Math.pow(((1 - con) / (1 + con)), com);
    return (Math.tan(0.5 * (HALF_PI - phi)) / con);
  }

  function phi2z(eccent, ts) {
    var eccnth = 0.5 * eccent;
    var con, dphi;
    var phi = HALF_PI - 2 * Math.atan(ts);
    for (var i = 0; i <= 15; i++) {
      con = eccent * Math.sin(phi);
      dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
      phi += dphi;
      if (Math.abs(dphi) <= 0.0000000001) {
        return phi;
      }
    }
    //console.log("phi2z has NoConvergence");
    return -9999;
  }

  function init() {
    var con = this.b / this.a;
    this.es = 1 - con * con;
    if(!('x0' in this)){
      this.x0 = 0;
    }
    if(!('y0' in this)){
      this.y0 = 0;
    }
    this.e = Math.sqrt(this.es);
    if (this.lat_ts) {
      if (this.sphere) {
        this.k0 = Math.cos(this.lat_ts);
      }
      else {
        this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
      }
    }
    else {
      if (!this.k0) {
        if (this.k) {
          this.k0 = this.k;
        }
        else {
          this.k0 = 1;
        }
      }
    }
  }

  /* Mercator forward equations--mapping lat,long to x,y
    --------------------------------------------------*/

  function forward(p) {
    var lon = p.x;
    var lat = p.y;
    // convert to radians
    if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
      return null;
    }

    var x, y;
    if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
      return null;
    }
    else {
      if (this.sphere) {
        x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
        y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
      }
      else {
        var sinphi = Math.sin(lat);
        var ts = tsfnz(this.e, lat, sinphi);
        x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
        y = this.y0 - this.a * this.k0 * Math.log(ts);
      }
      p.x = x;
      p.y = y;
      return p;
    }
  }

  /* Mercator inverse equations--mapping x,y to lat/long
    --------------------------------------------------*/
  function inverse(p) {

    var x = p.x - this.x0;
    var y = p.y - this.y0;
    var lon, lat;

    if (this.sphere) {
      lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
    }
    else {
      var ts = Math.exp(-y / (this.a * this.k0));
      lat = phi2z(this.e, ts);
      if (lat === -9999) {
        return null;
      }
    }
    lon = adjust_lon(this.long0 + x / (this.a * this.k0));

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
  var merc = {
    init: init,
    forward: forward,
    inverse: inverse,
    names: names
  };

  function init$1() {
    //no-op for longlat
  }

  function identity(pt) {
    return pt;
  }
  var names$1 = ["longlat", "identity"];
  var longlat = {
    init: init$1,
    forward: identity,
    inverse: identity,
    names: names$1
  };

  var projs = [merc, longlat];
  var names$2 = {};
  var projStore = [];

  function add$3(proj, i) {
    var len = projStore.length;
    if (!proj.names) {
      console.log(i);
      return true;
    }
    projStore[len] = proj;
    proj.names.forEach(function(n) {
      names$2[n.toLowerCase()] = len;
    });
    return this;
  }

  function get$4(name) {
    if (!name) {
      return false;
    }
    var n = name.toLowerCase();
    if (typeof names$2[n] !== 'undefined' && projStore[names$2[n]]) {
      return projStore[names$2[n]];
    }
  }

  function start() {
    projs.forEach(add$3);
  }
  var projections = {
    start: start,
    add: add$3,
    get: get$4
  };

  var exports$2 = {};
  exports$2.MERIT = {
    a: 6378137.0,
    rf: 298.257,
    ellipseName: "MERIT 1983"
  };

  exports$2.SGS85 = {
    a: 6378136.0,
    rf: 298.257,
    ellipseName: "Soviet Geodetic System 85"
  };

  exports$2.GRS80 = {
    a: 6378137.0,
    rf: 298.257222101,
    ellipseName: "GRS 1980(IUGG, 1980)"
  };

  exports$2.IAU76 = {
    a: 6378140.0,
    rf: 298.257,
    ellipseName: "IAU 1976"
  };

  exports$2.airy = {
    a: 6377563.396,
    b: 6356256.910,
    ellipseName: "Airy 1830"
  };

  exports$2.APL4 = {
    a: 6378137,
    rf: 298.25,
    ellipseName: "Appl. Physics. 1965"
  };

  exports$2.NWL9D = {
    a: 6378145.0,
    rf: 298.25,
    ellipseName: "Naval Weapons Lab., 1965"
  };

  exports$2.mod_airy = {
    a: 6377340.189,
    b: 6356034.446,
    ellipseName: "Modified Airy"
  };

  exports$2.andrae = {
    a: 6377104.43,
    rf: 300.0,
    ellipseName: "Andrae 1876 (Den., Iclnd.)"
  };

  exports$2.aust_SA = {
    a: 6378160.0,
    rf: 298.25,
    ellipseName: "Australian Natl & S. Amer. 1969"
  };

  exports$2.GRS67 = {
    a: 6378160.0,
    rf: 298.2471674270,
    ellipseName: "GRS 67(IUGG 1967)"
  };

  exports$2.bessel = {
    a: 6377397.155,
    rf: 299.1528128,
    ellipseName: "Bessel 1841"
  };

  exports$2.bess_nam = {
    a: 6377483.865,
    rf: 299.1528128,
    ellipseName: "Bessel 1841 (Namibia)"
  };

  exports$2.clrk66 = {
    a: 6378206.4,
    b: 6356583.8,
    ellipseName: "Clarke 1866"
  };

  exports$2.clrk80 = {
    a: 6378249.145,
    rf: 293.4663,
    ellipseName: "Clarke 1880 mod."
  };

  exports$2.clrk58 = {
    a: 6378293.645208759,
    rf: 294.2606763692654,
    ellipseName: "Clarke 1858"
  };

  exports$2.CPM = {
    a: 6375738.7,
    rf: 334.29,
    ellipseName: "Comm. des Poids et Mesures 1799"
  };

  exports$2.delmbr = {
    a: 6376428.0,
    rf: 311.5,
    ellipseName: "Delambre 1810 (Belgium)"
  };

  exports$2.engelis = {
    a: 6378136.05,
    rf: 298.2566,
    ellipseName: "Engelis 1985"
  };

  exports$2.evrst30 = {
    a: 6377276.345,
    rf: 300.8017,
    ellipseName: "Everest 1830"
  };

  exports$2.evrst48 = {
    a: 6377304.063,
    rf: 300.8017,
    ellipseName: "Everest 1948"
  };

  exports$2.evrst56 = {
    a: 6377301.243,
    rf: 300.8017,
    ellipseName: "Everest 1956"
  };

  exports$2.evrst69 = {
    a: 6377295.664,
    rf: 300.8017,
    ellipseName: "Everest 1969"
  };

  exports$2.evrstSS = {
    a: 6377298.556,
    rf: 300.8017,
    ellipseName: "Everest (Sabah & Sarawak)"
  };

  exports$2.fschr60 = {
    a: 6378166.0,
    rf: 298.3,
    ellipseName: "Fischer (Mercury Datum) 1960"
  };

  exports$2.fschr60m = {
    a: 6378155.0,
    rf: 298.3,
    ellipseName: "Fischer 1960"
  };

  exports$2.fschr68 = {
    a: 6378150.0,
    rf: 298.3,
    ellipseName: "Fischer 1968"
  };

  exports$2.helmert = {
    a: 6378200.0,
    rf: 298.3,
    ellipseName: "Helmert 1906"
  };

  exports$2.hough = {
    a: 6378270.0,
    rf: 297.0,
    ellipseName: "Hough"
  };

  exports$2.intl = {
    a: 6378388.0,
    rf: 297.0,
    ellipseName: "International 1909 (Hayford)"
  };

  exports$2.kaula = {
    a: 6378163.0,
    rf: 298.24,
    ellipseName: "Kaula 1961"
  };

  exports$2.lerch = {
    a: 6378139.0,
    rf: 298.257,
    ellipseName: "Lerch 1979"
  };

  exports$2.mprts = {
    a: 6397300.0,
    rf: 191.0,
    ellipseName: "Maupertius 1738"
  };

  exports$2.new_intl = {
    a: 6378157.5,
    b: 6356772.2,
    ellipseName: "New International 1967"
  };

  exports$2.plessis = {
    a: 6376523.0,
    rf: 6355863.0,
    ellipseName: "Plessis 1817 (France)"
  };

  exports$2.krass = {
    a: 6378245.0,
    rf: 298.3,
    ellipseName: "Krassovsky, 1942"
  };

  exports$2.SEasia = {
    a: 6378155.0,
    b: 6356773.3205,
    ellipseName: "Southeast Asia"
  };

  exports$2.walbeck = {
    a: 6376896.0,
    b: 6355834.8467,
    ellipseName: "Walbeck"
  };

  exports$2.WGS60 = {
    a: 6378165.0,
    rf: 298.3,
    ellipseName: "WGS 60"
  };

  exports$2.WGS66 = {
    a: 6378145.0,
    rf: 298.25,
    ellipseName: "WGS 66"
  };

  exports$2.WGS7 = {
    a: 6378135.0,
    rf: 298.26,
    ellipseName: "WGS 72"
  };

  var WGS84 = exports$2.WGS84 = {
    a: 6378137.0,
    rf: 298.257223563,
    ellipseName: "WGS 84"
  };

  exports$2.sphere = {
    a: 6370997.0,
    b: 6370997.0,
    ellipseName: "Normal Sphere (r=6370997)"
  };

  function eccentricity(a, b, rf, R_A) {
    var a2 = a * a; // used in geocentric
    var b2 = b * b; // used in geocentric
    var es = (a2 - b2) / a2; // e ^ 2
    var e = 0;
    if (R_A) {
      a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
      a2 = a * a;
      es = 0;
    } else {
      e = Math.sqrt(es); // eccentricity
    }
    var ep2 = (a2 - b2) / b2; // used in geocentric
    return {
      es: es,
      e: e,
      ep2: ep2
    };
  }
  function sphere(a, b, rf, ellps, sphere) {
    if (!a) { // do we have an ellipsoid?
      var ellipse = match(exports$2, ellps);
      if (!ellipse) {
        ellipse = WGS84;
      }
      a = ellipse.a;
      b = ellipse.b;
      rf = ellipse.rf;
    }

    if (rf && !b) {
      b = (1.0 - 1.0 / rf) * a;
    }
    if (rf === 0 || Math.abs(a - b) < EPSLN) {
      sphere = true;
      b = a;
    }
    return {
      a: a,
      b: b,
      rf: rf,
      sphere: sphere
    };
  }

  var exports$3 = {};
  exports$3.wgs84 = {
    towgs84: "0,0,0",
    ellipse: "WGS84",
    datumName: "WGS84"
  };

  exports$3.ch1903 = {
    towgs84: "674.374,15.056,405.346",
    ellipse: "bessel",
    datumName: "swiss"
  };

  exports$3.ggrs87 = {
    towgs84: "-199.87,74.79,246.62",
    ellipse: "GRS80",
    datumName: "Greek_Geodetic_Reference_System_1987"
  };

  exports$3.nad83 = {
    towgs84: "0,0,0",
    ellipse: "GRS80",
    datumName: "North_American_Datum_1983"
  };

  exports$3.nad27 = {
    nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
    ellipse: "clrk66",
    datumName: "North_American_Datum_1927"
  };

  exports$3.potsdam = {
    towgs84: "606.0,23.0,413.0",
    ellipse: "bessel",
    datumName: "Potsdam Rauenberg 1950 DHDN"
  };

  exports$3.carthage = {
    towgs84: "-263.0,6.0,431.0",
    ellipse: "clark80",
    datumName: "Carthage 1934 Tunisia"
  };

  exports$3.hermannskogel = {
    towgs84: "653.0,-212.0,449.0",
    ellipse: "bessel",
    datumName: "Hermannskogel"
  };

  exports$3.osni52 = {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "airy",
    datumName: "Irish National"
  };

  exports$3.ire65 = {
    towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
    ellipse: "mod_airy",
    datumName: "Ireland 1965"
  };

  exports$3.rassadiran = {
    towgs84: "-133.63,-157.5,-158.62",
    ellipse: "intl",
    datumName: "Rassadiran"
  };

  exports$3.nzgd49 = {
    towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
    ellipse: "intl",
    datumName: "New Zealand Geodetic Datum 1949"
  };

  exports$3.osgb36 = {
    towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
    ellipse: "airy",
    datumName: "Airy 1830"
  };

  exports$3.s_jtsk = {
    towgs84: "589,76,480",
    ellipse: 'bessel',
    datumName: 'S-JTSK (Ferro)'
  };

  exports$3.beduaram = {
    towgs84: '-106,-87,188',
    ellipse: 'clrk80',
    datumName: 'Beduaram'
  };

  exports$3.gunung_segara = {
    towgs84: '-403,684,41',
    ellipse: 'bessel',
    datumName: 'Gunung Segara Jakarta'
  };

  exports$3.rnb72 = {
    towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
    ellipse: "intl",
    datumName: "Reseau National Belge 1972"
  };

  function datum(datumCode, datum_params, a, b, es, ep2) {
    var out = {};

    if (datumCode === undefined || datumCode === 'none') {
      out.datum_type = PJD_NODATUM;
    } else {
      out.datum_type = PJD_WGS84;
    }

    if (datum_params) {
      out.datum_params = datum_params.map(parseFloat);
      if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
        out.datum_type = PJD_3PARAM;
      }
      if (out.datum_params.length > 3) {
        if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
          out.datum_type = PJD_7PARAM;
          out.datum_params[3] *= SEC_TO_RAD;
          out.datum_params[4] *= SEC_TO_RAD;
          out.datum_params[5] *= SEC_TO_RAD;
          out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;
        }
      }
    }

    out.a = a; //datum object also uses these values
    out.b = b;
    out.es = es;
    out.ep2 = ep2;
    return out;
  }

  function Projection$1(srsCode,callback) {
    if (!(this instanceof Projection$1)) {
      return new Projection$1(srsCode);
    }
    callback = callback || function(error){
      if(error){
        throw error;
      }
    };
    var json = parse$1(srsCode);
    if(typeof json !== 'object'){
      callback(srsCode);
      return;
    }
    var ourProj = Projection$1.projections.get(json.projName);
    if(!ourProj){
      callback(srsCode);
      return;
    }
    if (json.datumCode && json.datumCode !== 'none') {
      var datumDef = match(exports$3, json.datumCode);
      if (datumDef) {
        json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;
        json.ellps = datumDef.ellipse;
        json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
      }
    }
    json.k0 = json.k0 || 1.0;
    json.axis = json.axis || 'enu';
    json.ellps = json.ellps || 'wgs84';
    var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
    var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
    var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2);

    extend$2(this, json); // transfer everything over from the projection because we don't know what we'll need
    extend$2(this, ourProj); // transfer all the methods from the projection

    // copy the 4 things over we calulated in deriveConstants.sphere
    this.a = sphere_.a;
    this.b = sphere_.b;
    this.rf = sphere_.rf;
    this.sphere = sphere_.sphere;

    // copy the 3 things we calculated in deriveConstants.eccentricity
    this.es = ecc.es;
    this.e = ecc.e;
    this.ep2 = ecc.ep2;

    // add in the datum object
    this.datum = datumObj;

    // init the projection
    this.init();

    // legecy callback from back in the day when it went to spatialreference.org
    callback(null, this);

  }
  Projection$1.projections = projections;
  Projection$1.projections.start();

  function compareDatums(source, dest) {
    if (source.datum_type !== dest.datum_type) {
      return false; // false, datums are not equal
    } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {
      // the tolerance for es is to ensure that GRS80 and WGS84
      // are considered identical
      return false;
    } else if (source.datum_type === PJD_3PARAM) {
      return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);
    } else if (source.datum_type === PJD_7PARAM) {
      return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);
    } else {
      return true; // datums are equal
    }
  } // cs_compare_datums()

  /*
   * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
   * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
   * according to the current ellipsoid parameters.
   *
   *    Latitude  : Geodetic latitude in radians                     (input)
   *    Longitude : Geodetic longitude in radians                    (input)
   *    Height    : Geodetic height, in meters                       (input)
   *    X         : Calculated Geocentric X coordinate, in meters    (output)
   *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
   *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
   *
   */
  function geodeticToGeocentric(p, es, a) {
    var Longitude = p.x;
    var Latitude = p.y;
    var Height = p.z ? p.z : 0; //Z value not always supplied

    var Rn; /*  Earth radius at location  */
    var Sin_Lat; /*  Math.sin(Latitude)  */
    var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
    var Cos_Lat; /*  Math.cos(Latitude)  */

    /*
     ** Don't blow up if Latitude is just a little out of the value
     ** range as it may just be a rounding issue.  Also removed longitude
     ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
     */
    if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
      Latitude = -HALF_PI;
    } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
      Latitude = HALF_PI;
    } else if (Latitude < -HALF_PI) {
      /* Latitude out of range */
      //..reportError('geocent:lat out of range:' + Latitude);
      return { x: -Infinity, y: -Infinity, z: p.z };
    } else if (Latitude > HALF_PI) {
      /* Latitude out of range */
      return { x: Infinity, y: Infinity, z: p.z };
    }

    if (Longitude > Math.PI) {
      Longitude -= (2 * Math.PI);
    }
    Sin_Lat = Math.sin(Latitude);
    Cos_Lat = Math.cos(Latitude);
    Sin2_Lat = Sin_Lat * Sin_Lat;
    Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));
    return {
      x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
      y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
      z: ((Rn * (1 - es)) + Height) * Sin_Lat
    };
  } // cs_geodetic_to_geocentric()

  function geocentricToGeodetic(p, es, a, b) {
    /* local defintions and variables */
    /* end-criterium of loop, accuracy of sin(Latitude) */
    var genau = 1e-12;
    var genau2 = (genau * genau);
    var maxiter = 30;

    var P; /* distance between semi-minor axis and location */
    var RR; /* distance between center and location */
    var CT; /* sin of geocentric latitude */
    var ST; /* cos of geocentric latitude */
    var RX;
    var RK;
    var RN; /* Earth radius at location */
    var CPHI0; /* cos of start or old geodetic latitude in iterations */
    var SPHI0; /* sin of start or old geodetic latitude in iterations */
    var CPHI; /* cos of searched geodetic latitude */
    var SPHI; /* sin of searched geodetic latitude */
    var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
    var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */

    var X = p.x;
    var Y = p.y;
    var Z = p.z ? p.z : 0.0; //Z value not always supplied
    var Longitude;
    var Latitude;
    var Height;

    P = Math.sqrt(X * X + Y * Y);
    RR = Math.sqrt(X * X + Y * Y + Z * Z);

    /*      special cases for latitude and longitude */
    if (P / a < genau) {

      /*  special case, if P=0. (X=0., Y=0.) */
      Longitude = 0.0;

      /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
       *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
      if (RR / a < genau) {
        Latitude = HALF_PI;
        Height = -b;
        return {
          x: p.x,
          y: p.y,
          z: p.z
        };
      }
    } else {
      /*  ellipsoidal (geodetic) longitude
       *  interval: -PI < Longitude <= +PI */
      Longitude = Math.atan2(Y, X);
    }

    /* --------------------------------------------------------------
     * Following iterative algorithm was developped by
     * "Institut for Erdmessung", University of Hannover, July 1988.
     * Internet: www.ife.uni-hannover.de
     * Iterative computation of CPHI,SPHI and Height.
     * Iteration of CPHI and SPHI to 10**-12 radian resp.
     * 2*10**-7 arcsec.
     * --------------------------------------------------------------
     */
    CT = Z / RR;
    ST = P / RR;
    RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);
    CPHI0 = ST * (1.0 - es) * RX;
    SPHI0 = CT * RX;
    iter = 0;

    /* loop to find sin(Latitude) resp. Latitude
     * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
    do {
      iter++;
      RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);

      /*  ellipsoidal (geodetic) height */
      Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);

      RK = es * RN / (RN + Height);
      RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
      CPHI = ST * (1.0 - RK) * RX;
      SPHI = CT * RX;
      SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
      CPHI0 = CPHI;
      SPHI0 = SPHI;
    }
    while (SDPHI * SDPHI > genau2 && iter < maxiter);

    /*      ellipsoidal (geodetic) latitude */
    Latitude = Math.atan(SPHI / Math.abs(CPHI));
    return {
      x: Longitude,
      y: Latitude,
      z: Height
    };
  } // cs_geocentric_to_geodetic()

  /****************************************************************/
  // pj_geocentic_to_wgs84( p )
  //  p = point to transform in geocentric coordinates (x,y,z)


  /** point object, nothing fancy, just allows values to be
      passed back and forth by reference rather than by value.
      Other point classes may be used as long as they have
      x and y properties, which will get modified in the transform method.
  */
  function geocentricToWgs84(p, datum_type, datum_params) {

    if (datum_type === PJD_3PARAM) {
      // if( x[io] === HUGE_VAL )
      //    continue;
      return {
        x: p.x + datum_params[0],
        y: p.y + datum_params[1],
        z: p.z + datum_params[2],
      };
    } else if (datum_type === PJD_7PARAM) {
      var Dx_BF = datum_params[0];
      var Dy_BF = datum_params[1];
      var Dz_BF = datum_params[2];
      var Rx_BF = datum_params[3];
      var Ry_BF = datum_params[4];
      var Rz_BF = datum_params[5];
      var M_BF = datum_params[6];
      // if( x[io] === HUGE_VAL )
      //    continue;
      return {
        x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
        y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
        z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
      };
    }
  } // cs_geocentric_to_wgs84

  /****************************************************************/
  // pj_geocentic_from_wgs84()
  //  coordinate system definition,
  //  point to transform in geocentric coordinates (x,y,z)
  function geocentricFromWgs84(p, datum_type, datum_params) {

    if (datum_type === PJD_3PARAM) {
      //if( x[io] === HUGE_VAL )
      //    continue;
      return {
        x: p.x - datum_params[0],
        y: p.y - datum_params[1],
        z: p.z - datum_params[2],
      };

    } else if (datum_type === PJD_7PARAM) {
      var Dx_BF = datum_params[0];
      var Dy_BF = datum_params[1];
      var Dz_BF = datum_params[2];
      var Rx_BF = datum_params[3];
      var Ry_BF = datum_params[4];
      var Rz_BF = datum_params[5];
      var M_BF = datum_params[6];
      var x_tmp = (p.x - Dx_BF) / M_BF;
      var y_tmp = (p.y - Dy_BF) / M_BF;
      var z_tmp = (p.z - Dz_BF) / M_BF;
      //if( x[io] === HUGE_VAL )
      //    continue;

      return {
        x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
        y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
        z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
      };
    } //cs_geocentric_from_wgs84()
  }

  function checkParams(type) {
    return (type === PJD_3PARAM || type === PJD_7PARAM);
  }

  function datum_transform(source, dest, point) {
    // Short cut if the datums are identical.
    if (compareDatums(source, dest)) {
      return point; // in this case, zero is sucess,
      // whereas cs_compare_datums returns 1 to indicate TRUE
      // confusing, should fix this
    }

    // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
    if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
      return point;
    }

    // If this datum requires grid shifts, then apply it to geodetic coordinates.

    // Do we need to go through geocentric coordinates?
    if (source.es === dest.es && source.a === dest.a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {
      return point;
    }

    // Convert to geocentric coordinates.
    point = geodeticToGeocentric(point, source.es, source.a);
    // Convert between datums
    if (checkParams(source.datum_type)) {
      point = geocentricToWgs84(point, source.datum_type, source.datum_params);
    }
    if (checkParams(dest.datum_type)) {
      point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
    }
    return geocentricToGeodetic(point, dest.es, dest.a, dest.b);

  }

  function adjust_axis(crs, denorm, point) {
    var xin = point.x,
      yin = point.y,
      zin = point.z || 0.0;
    var v, t, i;
    var out = {};
    for (i = 0; i < 3; i++) {
      if (denorm && i === 2 && point.z === undefined) {
        continue;
      }
      if (i === 0) {
        v = xin;
        if ("ew".indexOf(crs.axis[i]) !== -1) {
          t = 'x';
        } else {
          t = 'y';
        }

      }
      else if (i === 1) {
        v = yin;
        if ("ns".indexOf(crs.axis[i]) !== -1) {
          t = 'y';
        } else {
          t = 'x';
        }
      }
      else {
        v = zin;
        t = 'z';
      }
      switch (crs.axis[i]) {
      case 'e':
      case 'w':
      case 'n':
      case 's':
        out[t] = v;
        break;
      case 'u':
        if (point[t] !== undefined) {
          out.z = v;
        }
        break;
      case 'd':
        if (point[t] !== undefined) {
          out.z = -v;
        }
        break;
      default:
        //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
        return null;
      }
    }
    return out;
  }

  function common (array){
    var out = {
      x: array[0],
      y: array[1]
    };
    if (array.length>2) {
      out.z = array[2];
    }
    if (array.length>3) {
      out.m = array[3];
    }
    return out;
  }

  function checkSanity (point) {
    checkCoord(point.x);
    checkCoord(point.y);
  }
  function checkCoord(num) {
    if (typeof Number.isFinite === 'function') {
      if (Number.isFinite(num)) {
        return;
      }
      throw new TypeError('coordinates must be finite numbers');
    }
    if (typeof num !== 'number' || num !== num || !isFinite(num)) {
      throw new TypeError('coordinates must be finite numbers');
    }
  }

  function checkNotWGS(source, dest) {
    return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84');
  }

  function transform$1(source, dest, point) {
    var wgs84;
    if (Array.isArray(point)) {
      point = common(point);
    }
    checkSanity(point);
    // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
    if (source.datum && dest.datum && checkNotWGS(source, dest)) {
      wgs84 = new Projection$1('WGS84');
      point = transform$1(source, wgs84, point);
      source = wgs84;
    }
    // DGR, 2010/11/12
    if (source.axis !== 'enu') {
      point = adjust_axis(source, false, point);
    }
    // Transform source points to long/lat, if they aren't already.
    if (source.projName === 'longlat') {
      point = {
        x: point.x * D2R,
        y: point.y * D2R,
        z: point.z || 0
      };
    } else {
      if (source.to_meter) {
        point = {
          x: point.x * source.to_meter,
          y: point.y * source.to_meter,
          z: point.z || 0
        };
      }
      point = source.inverse(point); // Convert Cartesian to longlat
      if (!point) {
        return;
      }
    }
    // Adjust for the prime meridian if necessary
    if (source.from_greenwich) {
      point.x += source.from_greenwich;
    }

    // Convert datums if needed, and if possible.
    point = datum_transform(source.datum, dest.datum, point);

    // Adjust for the prime meridian if necessary
    if (dest.from_greenwich) {
      point = {
        x: point.x - dest.from_greenwich,
        y: point.y,
        z: point.z || 0
      };
    }

    if (dest.projName === 'longlat') {
      // convert radians to decimal degrees
      point = {
        x: point.x * R2D,
        y: point.y * R2D,
        z: point.z || 0
      };
    } else { // else project
      point = dest.forward(point);
      if (dest.to_meter) {
        point = {
          x: point.x / dest.to_meter,
          y: point.y / dest.to_meter,
          z: point.z || 0
        };
      }
    }

    // DGR, 2010/11/12
    if (dest.axis !== 'enu') {
      return adjust_axis(dest, true, point);
    }

    return point;
  }

  var wgs84 = Projection$1('WGS84');

  function transformer(from, to, coords) {
    var transformedArray, out, keys;
    if (Array.isArray(coords)) {
      transformedArray = transform$1(from, to, coords) || {x: NaN, y: NaN};
      if (coords.length > 2) {
        if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
          if (typeof transformedArray.z === 'number') {
            return [transformedArray.x, transformedArray.y, transformedArray.z].concat(coords.splice(3));
          } else {
            return [transformedArray.x, transformedArray.y, coords[2]].concat(coords.splice(3));
          }
        } else {
          return [transformedArray.x, transformedArray.y].concat(coords.splice(2));
        }
      } else {
        return [transformedArray.x, transformedArray.y];
      }
    } else {
      out = transform$1(from, to, coords);
      keys = Object.keys(coords);
      if (keys.length === 2) {
        return out;
      }
      keys.forEach(function (key) {
        if ((typeof from.name !== 'undefined' && from.name === 'geocent') || (typeof to.name !== 'undefined' && to.name === 'geocent')) {
          if (key === 'x' || key === 'y' || key === 'z') {
            return;
          }
        } else {
          if (key === 'x' || key === 'y') {
            return;
          }
        }
        out[key] = coords[key];
      });
      return out;
    }
  }

  function checkProj(item) {
    if (item instanceof Projection$1) {
      return item;
    }
    if (item.oProj) {
      return item.oProj;
    }
    return Projection$1(item);
  }

  function proj4(fromProj, toProj, coord) {
    fromProj = checkProj(fromProj);
    var single = false;
    var obj;
    if (typeof toProj === 'undefined') {
      toProj = fromProj;
      fromProj = wgs84;
      single = true;
    } else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
      coord = toProj;
      toProj = fromProj;
      fromProj = wgs84;
      single = true;
    }
    toProj = checkProj(toProj);
    if (coord) {
      return transformer(fromProj, toProj, coord);
    } else {
      obj = {
        forward: function (coords) {
          return transformer(fromProj, toProj, coords);
        },
        inverse: function (coords) {
          return transformer(toProj, fromProj, coords);
        }
      };
      if (single) {
        obj.oProj = toProj;
      }
      return obj;
    }
  }

  /**
   * UTM zones are grouped, and assigned to one of a group of 6
   * sets.
   *
   * {int} @private
   */
  var NUM_100K_SETS = 6;

  /**
   * The column letters (for easting) of the lower left value, per
   * set.
   *
   * {string} @private
   */
  var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';

  /**
   * The row letters (for northing) of the lower left value, per
   * set.
   *
   * {string} @private
   */
  var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';

  var A = 65; // A
  var I = 73; // I
  var O = 79; // O
  var V = 86; // V
  var Z = 90; // Z
  var mgrs = {
    forward: forward$1,
    inverse: inverse$1,
    toPoint: toPoint
  };
  /**
   * Conversion of lat/lon to MGRS.
   *
   * @param {object} ll Object literal with lat and lon properties on a
   *     WGS84 ellipsoid.
   * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
   *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
   * @return {string} the MGRS string for the given location and accuracy.
   */
  function forward$1(ll, accuracy) {
    accuracy = accuracy || 5; // default accuracy 1m
    return encode(LLtoUTM({
      lat: ll[1],
      lon: ll[0]
    }), accuracy);
  }
  /**
   * Conversion of MGRS to lat/lon.
   *
   * @param {string} mgrs MGRS string.
   * @return {array} An array with left (longitude), bottom (latitude), right
   *     (longitude) and top (latitude) values in WGS84, representing the
   *     bounding box for the provided MGRS reference.
   */
  function inverse$1(mgrs) {
    var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
    if (bbox.lat && bbox.lon) {
      return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
    }
    return [bbox.left, bbox.bottom, bbox.right, bbox.top];
  }
  function toPoint(mgrs) {
    var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
    if (bbox.lat && bbox.lon) {
      return [bbox.lon, bbox.lat];
    }
    return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
  }/**
   * Conversion from degrees to radians.
   *
   * @private
   * @param {number} deg the angle in degrees.
   * @return {number} the angle in radians.
   */
  function degToRad(deg) {
    return (deg * (Math.PI / 180.0));
  }

  /**
   * Conversion from radians to degrees.
   *
   * @private
   * @param {number} rad the angle in radians.
   * @return {number} the angle in degrees.
   */
  function radToDeg(rad) {
    return (180.0 * (rad / Math.PI));
  }

  /**
   * Converts a set of Longitude and Latitude co-ordinates to UTM
   * using the WGS84 ellipsoid.
   *
   * @private
   * @param {object} ll Object literal with lat and lon properties
   *     representing the WGS84 coordinate to be converted.
   * @return {object} Object literal containing the UTM value with easting,
   *     northing, zoneNumber and zoneLetter properties, and an optional
   *     accuracy property in digits. Returns null if the conversion failed.
   */
  function LLtoUTM(ll) {
    var Lat = ll.lat;
    var Long = ll.lon;
    var a = 6378137.0; //ellip.radius;
    var eccSquared = 0.00669438; //ellip.eccsq;
    var k0 = 0.9996;
    var LongOrigin;
    var eccPrimeSquared;
    var N, T, C, A, M;
    var LatRad = degToRad(Lat);
    var LongRad = degToRad(Long);
    var LongOriginRad;
    var ZoneNumber;
    // (int)
    ZoneNumber = Math.floor((Long + 180) / 6) + 1;

    //Make sure the longitude 180.00 is in Zone 60
    if (Long === 180) {
      ZoneNumber = 60;
    }

    // Special zone for Norway
    if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
      ZoneNumber = 32;
    }

    // Special zones for Svalbard
    if (Lat >= 72.0 && Lat < 84.0) {
      if (Long >= 0.0 && Long < 9.0) {
        ZoneNumber = 31;
      }
      else if (Long >= 9.0 && Long < 21.0) {
        ZoneNumber = 33;
      }
      else if (Long >= 21.0 && Long < 33.0) {
        ZoneNumber = 35;
      }
      else if (Long >= 33.0 && Long < 42.0) {
        ZoneNumber = 37;
      }
    }

    LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
    // in middle of
    // zone
    LongOriginRad = degToRad(LongOrigin);

    eccPrimeSquared = (eccSquared) / (1 - eccSquared);

    N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
    T = Math.tan(LatRad) * Math.tan(LatRad);
    C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
    A = Math.cos(LatRad) * (LongRad - LongOriginRad);

    M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));

    var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);

    var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));
    if (Lat < 0.0) {
      UTMNorthing += 10000000.0; //10000000 meter offset for
      // southern hemisphere
    }

    return {
      northing: Math.round(UTMNorthing),
      easting: Math.round(UTMEasting),
      zoneNumber: ZoneNumber,
      zoneLetter: getLetterDesignator(Lat)
    };
  }

  /**
   * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
   * class where the Zone can be specified as a single string eg."60N" which
   * is then broken down into the ZoneNumber and ZoneLetter.
   *
   * @private
   * @param {object} utm An object literal with northing, easting, zoneNumber
   *     and zoneLetter properties. If an optional accuracy property is
   *     provided (in meters), a bounding box will be returned instead of
   *     latitude and longitude.
   * @return {object} An object literal containing either lat and lon values
   *     (if no accuracy was provided), or top, right, bottom and left values
   *     for the bounding box calculated according to the provided accuracy.
   *     Returns null if the conversion failed.
   */
  function UTMtoLL(utm) {

    var UTMNorthing = utm.northing;
    var UTMEasting = utm.easting;
    var zoneLetter = utm.zoneLetter;
    var zoneNumber = utm.zoneNumber;
    // check the ZoneNummber is valid
    if (zoneNumber < 0 || zoneNumber > 60) {
      return null;
    }

    var k0 = 0.9996;
    var a = 6378137.0; //ellip.radius;
    var eccSquared = 0.00669438; //ellip.eccsq;
    var eccPrimeSquared;
    var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
    var N1, T1, C1, R1, D, M;
    var LongOrigin;
    var mu, phi1Rad;

    // remove 500,000 meter offset for longitude
    var x = UTMEasting - 500000.0;
    var y = UTMNorthing;

    // We must know somehow if we are in the Northern or Southern
    // hemisphere, this is the only time we use the letter So even
    // if the Zone letter isn't exactly correct it should indicate
    // the hemisphere correctly
    if (zoneLetter < 'N') {
      y -= 10000000.0; // remove 10,000,000 meter offset used
      // for southern hemisphere
    }

    // There are 60 zones with zone 1 being at West -180 to -174
    LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
    // in middle of
    // zone

    eccPrimeSquared = (eccSquared) / (1 - eccSquared);

    M = y / k0;
    mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));

    phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);
    // double phi1 = ProjMath.radToDeg(phi1Rad);

    N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
    T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
    C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
    R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
    D = x / (N1 * k0);

    var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
    lat = radToDeg(lat);

    var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
    lon = LongOrigin + radToDeg(lon);

    var result;
    if (utm.accuracy) {
      var topRight = UTMtoLL({
        northing: utm.northing + utm.accuracy,
        easting: utm.easting + utm.accuracy,
        zoneLetter: utm.zoneLetter,
        zoneNumber: utm.zoneNumber
      });
      result = {
        top: topRight.lat,
        right: topRight.lon,
        bottom: lat,
        left: lon
      };
    }
    else {
      result = {
        lat: lat,
        lon: lon
      };
    }
    return result;
  }

  /**
   * Calculates the MGRS letter designator for the given latitude.
   *
   * @private
   * @param {number} lat The latitude in WGS84 to get the letter designator
   *     for.
   * @return {char} The letter designator.
   */
  function getLetterDesignator(lat) {
    //This is here as an error flag to show that the Latitude is
    //outside MGRS limits
    var LetterDesignator = 'Z';

    if ((84 >= lat) && (lat >= 72)) {
      LetterDesignator = 'X';
    }
    else if ((72 > lat) && (lat >= 64)) {
      LetterDesignator = 'W';
    }
    else if ((64 > lat) && (lat >= 56)) {
      LetterDesignator = 'V';
    }
    else if ((56 > lat) && (lat >= 48)) {
      LetterDesignator = 'U';
    }
    else if ((48 > lat) && (lat >= 40)) {
      LetterDesignator = 'T';
    }
    else if ((40 > lat) && (lat >= 32)) {
      LetterDesignator = 'S';
    }
    else if ((32 > lat) && (lat >= 24)) {
      LetterDesignator = 'R';
    }
    else if ((24 > lat) && (lat >= 16)) {
      LetterDesignator = 'Q';
    }
    else if ((16 > lat) && (lat >= 8)) {
      LetterDesignator = 'P';
    }
    else if ((8 > lat) && (lat >= 0)) {
      LetterDesignator = 'N';
    }
    else if ((0 > lat) && (lat >= -8)) {
      LetterDesignator = 'M';
    }
    else if ((-8 > lat) && (lat >= -16)) {
      LetterDesignator = 'L';
    }
    else if ((-16 > lat) && (lat >= -24)) {
      LetterDesignator = 'K';
    }
    else if ((-24 > lat) && (lat >= -32)) {
      LetterDesignator = 'J';
    }
    else if ((-32 > lat) && (lat >= -40)) {
      LetterDesignator = 'H';
    }
    else if ((-40 > lat) && (lat >= -48)) {
      LetterDesignator = 'G';
    }
    else if ((-48 > lat) && (lat >= -56)) {
      LetterDesignator = 'F';
    }
    else if ((-56 > lat) && (lat >= -64)) {
      LetterDesignator = 'E';
    }
    else if ((-64 > lat) && (lat >= -72)) {
      LetterDesignator = 'D';
    }
    else if ((-72 > lat) && (lat >= -80)) {
      LetterDesignator = 'C';
    }
    return LetterDesignator;
  }

  /**
   * Encodes a UTM location as MGRS string.
   *
   * @private
   * @param {object} utm An object literal with easting, northing,
   *     zoneLetter, zoneNumber
   * @param {number} accuracy Accuracy in digits (1-5).
   * @return {string} MGRS string for the given UTM location.
   */
  function encode(utm, accuracy) {
    // prepend with leading zeroes
    var seasting = "00000" + utm.easting,
      snorthing = "00000" + utm.northing;

    return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
  }

  /**
   * Get the two letter 100k designator for a given UTM easting,
   * northing and zone number value.
   *
   * @private
   * @param {number} easting
   * @param {number} northing
   * @param {number} zoneNumber
   * @return the two letter 100k designator for the given UTM location.
   */
  function get100kID(easting, northing, zoneNumber) {
    var setParm = get100kSetForZone(zoneNumber);
    var setColumn = Math.floor(easting / 100000);
    var setRow = Math.floor(northing / 100000) % 20;
    return getLetter100kID(setColumn, setRow, setParm);
  }

  /**
   * Given a UTM zone number, figure out the MGRS 100K set it is in.
   *
   * @private
   * @param {number} i An UTM zone number.
   * @return {number} the 100k set the UTM zone is in.
   */
  function get100kSetForZone(i) {
    var setParm = i % NUM_100K_SETS;
    if (setParm === 0) {
      setParm = NUM_100K_SETS;
    }

    return setParm;
  }

  /**
   * Get the two-letter MGRS 100k designator given information
   * translated from the UTM northing, easting and zone number.
   *
   * @private
   * @param {number} column the column index as it relates to the MGRS
   *        100k set spreadsheet, created from the UTM easting.
   *        Values are 1-8.
   * @param {number} row the row index as it relates to the MGRS 100k set
   *        spreadsheet, created from the UTM northing value. Values
   *        are from 0-19.
   * @param {number} parm the set block, as it relates to the MGRS 100k set
   *        spreadsheet, created from the UTM zone. Values are from
   *        1-60.
   * @return two letter MGRS 100k code.
   */
  function getLetter100kID(column, row, parm) {
    // colOrigin and rowOrigin are the letters at the origin of the set
    var index = parm - 1;
    var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
    var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);

    // colInt and rowInt are the letters to build to return
    var colInt = colOrigin + column - 1;
    var rowInt = rowOrigin + row;
    var rollover = false;

    if (colInt > Z) {
      colInt = colInt - Z + A - 1;
      rollover = true;
    }

    if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {
      colInt++;
    }

    if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {
      colInt++;

      if (colInt === I) {
        colInt++;
      }
    }

    if (colInt > Z) {
      colInt = colInt - Z + A - 1;
    }

    if (rowInt > V) {
      rowInt = rowInt - V + A - 1;
      rollover = true;
    }
    else {
      rollover = false;
    }

    if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {
      rowInt++;
    }

    if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {
      rowInt++;

      if (rowInt === I) {
        rowInt++;
      }
    }

    if (rowInt > V) {
      rowInt = rowInt - V + A - 1;
    }

    var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
    return twoLetter;
  }

  /**
   * Decode the UTM parameters from a MGRS string.
   *
   * @private
   * @param {string} mgrsString an UPPERCASE coordinate string is expected.
   * @return {object} An object literal with easting, northing, zoneLetter,
   *     zoneNumber and accuracy (in meters) properties.
   */
  function decode(mgrsString) {

    if (mgrsString && mgrsString.length === 0) {
      throw ("MGRSPoint coverting from nothing");
    }

    var length = mgrsString.length;

    var hunK = null;
    var sb = "";
    var testChar;
    var i = 0;

    // get Zone number
    while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {
      if (i >= 2) {
        throw ("MGRSPoint bad conversion from: " + mgrsString);
      }
      sb += testChar;
      i++;
    }

    var zoneNumber = parseInt(sb, 10);

    if (i === 0 || i + 3 > length) {
      // A good MGRS string has to be 4-5 digits long,
      // ##AAA/#AAA at least.
      throw ("MGRSPoint bad conversion from: " + mgrsString);
    }

    var zoneLetter = mgrsString.charAt(i++);

    // Should we check the zone letter here? Why not.
    if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
      throw ("MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString);
    }

    hunK = mgrsString.substring(i, i += 2);

    var set = get100kSetForZone(zoneNumber);

    var east100k = getEastingFromChar(hunK.charAt(0), set);
    var north100k = getNorthingFromChar(hunK.charAt(1), set);

    // We have a bug where the northing may be 2000000 too low.
    // How
    // do we know when to roll over?

    while (north100k < getMinNorthing(zoneLetter)) {
      north100k += 2000000;
    }

    // calculate the char index for easting/northing separator
    var remainder = length - i;

    if (remainder % 2 !== 0) {
      throw ("MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString);
    }

    var sep = remainder / 2;

    var sepEasting = 0.0;
    var sepNorthing = 0.0;
    var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
    if (sep > 0) {
      accuracyBonus = 100000.0 / Math.pow(10, sep);
      sepEastingString = mgrsString.substring(i, i + sep);
      sepEasting = parseFloat(sepEastingString) * accuracyBonus;
      sepNorthingString = mgrsString.substring(i + sep);
      sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
    }

    easting = sepEasting + east100k;
    northing = sepNorthing + north100k;

    return {
      easting: easting,
      northing: northing,
      zoneLetter: zoneLetter,
      zoneNumber: zoneNumber,
      accuracy: accuracyBonus
    };
  }

  /**
   * Given the first letter from a two-letter MGRS 100k zone, and given the
   * MGRS table set for the zone number, figure out the easting value that
   * should be added to the other, secondary easting value.
   *
   * @private
   * @param {char} e The first letter from a two-letter MGRS 100´k zone.
   * @param {number} set The MGRS table set for the zone number.
   * @return {number} The easting value for the given letter and set.
   */
  function getEastingFromChar(e, set) {
    // colOrigin is the letter at the origin of the set for the
    // column
    var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
    var eastingValue = 100000.0;
    var rewindMarker = false;

    while (curCol !== e.charCodeAt(0)) {
      curCol++;
      if (curCol === I) {
        curCol++;
      }
      if (curCol === O) {
        curCol++;
      }
      if (curCol > Z) {
        if (rewindMarker) {
          throw ("Bad character: " + e);
        }
        curCol = A;
        rewindMarker = true;
      }
      eastingValue += 100000.0;
    }

    return eastingValue;
  }

  /**
   * Given the second letter from a two-letter MGRS 100k zone, and given the
   * MGRS table set for the zone number, figure out the northing value that
   * should be added to the other, secondary northing value. You have to
   * remember that Northings are determined from the equator, and the vertical
   * cycle of letters mean a 2000000 additional northing meters. This happens
   * approx. every 18 degrees of latitude. This method does *NOT* count any
   * additional northings. You have to figure out how many 2000000 meters need
   * to be added for the zone letter of the MGRS coordinate.
   *
   * @private
   * @param {char} n Second letter of the MGRS 100k zone
   * @param {number} set The MGRS table set number, which is dependent on the
   *     UTM zone number.
   * @return {number} The northing value for the given letter and set.
   */
  function getNorthingFromChar(n, set) {

    if (n > 'V') {
      throw ("MGRSPoint given invalid Northing " + n);
    }

    // rowOrigin is the letter at the origin of the set for the
    // column
    var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
    var northingValue = 0.0;
    var rewindMarker = false;

    while (curRow !== n.charCodeAt(0)) {
      curRow++;
      if (curRow === I) {
        curRow++;
      }
      if (curRow === O) {
        curRow++;
      }
      // fixing a bug making whole application hang in this loop
      // when 'n' is a wrong character
      if (curRow > V) {
        if (rewindMarker) { // making sure that this loop ends
          throw ("Bad character: " + n);
        }
        curRow = A;
        rewindMarker = true;
      }
      northingValue += 100000.0;
    }

    return northingValue;
  }

  /**
   * The function getMinNorthing returns the minimum northing value of a MGRS
   * zone.
   *
   * Ported from Geotrans' c Lattitude_Band_Value structure table.
   *
   * @private
   * @param {char} zoneLetter The MGRS zone to get the min northing for.
   * @return {number}
   */
  function getMinNorthing(zoneLetter) {
    var northing;
    switch (zoneLetter) {
    case 'C':
      northing = 1100000.0;
      break;
    case 'D':
      northing = 2000000.0;
      break;
    case 'E':
      northing = 2800000.0;
      break;
    case 'F':
      northing = 3700000.0;
      break;
    case 'G':
      northing = 4600000.0;
      break;
    case 'H':
      northing = 5500000.0;
      break;
    case 'J':
      northing = 6400000.0;
      break;
    case 'K':
      northing = 7300000.0;
      break;
    case 'L':
      northing = 8200000.0;
      break;
    case 'M':
      northing = 9100000.0;
      break;
    case 'N':
      northing = 0.0;
      break;
    case 'P':
      northing = 800000.0;
      break;
    case 'Q':
      northing = 1700000.0;
      break;
    case 'R':
      northing = 2600000.0;
      break;
    case 'S':
      northing = 3500000.0;
      break;
    case 'T':
      northing = 4400000.0;
      break;
    case 'U':
      northing = 5300000.0;
      break;
    case 'V':
      northing = 6200000.0;
      break;
    case 'W':
      northing = 7000000.0;
      break;
    case 'X':
      northing = 7900000.0;
      break;
    default:
      northing = -1.0;
    }
    if (northing >= 0.0) {
      return northing;
    }
    else {
      throw ("Invalid zone letter: " + zoneLetter);
    }

  }

  function Point$1(x, y, z) {
    if (!(this instanceof Point$1)) {
      return new Point$1(x, y, z);
    }
    if (Array.isArray(x)) {
      this.x = x[0];
      this.y = x[1];
      this.z = x[2] || 0.0;
    } else if(typeof x === 'object') {
      this.x = x.x;
      this.y = x.y;
      this.z = x.z || 0.0;
    } else if (typeof x === 'string' && typeof y === 'undefined') {
      var coords = x.split(',');
      this.x = parseFloat(coords[0], 10);
      this.y = parseFloat(coords[1], 10);
      this.z = parseFloat(coords[2], 10) || 0.0;
    } else {
      this.x = x;
      this.y = y;
      this.z = z || 0.0;
    }
    console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
  }

  Point$1.fromMGRS = function(mgrsStr) {
    return new Point$1(toPoint(mgrsStr));
  };
  Point$1.prototype.toMGRS = function(accuracy) {
    return forward$1([this.x, this.y], accuracy);
  };

  var C00 = 1;
  var C02 = 0.25;
  var C04 = 0.046875;
  var C06 = 0.01953125;
  var C08 = 0.01068115234375;
  var C22 = 0.75;
  var C44 = 0.46875;
  var C46 = 0.01302083333333333333;
  var C48 = 0.00712076822916666666;
  var C66 = 0.36458333333333333333;
  var C68 = 0.00569661458333333333;
  var C88 = 0.3076171875;

  function pj_enfn(es) {
    var en = [];
    en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
    en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
    var t = es * es;
    en[2] = t * (C44 - es * (C46 + es * C48));
    t *= es;
    en[3] = t * (C66 - es * C68);
    en[4] = t * es * C88;
    return en;
  }

  function pj_mlfn(phi, sphi, cphi, en) {
    cphi *= sphi;
    sphi *= sphi;
    return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));
  }

  var MAX_ITER = 20;

  function pj_inv_mlfn(arg, es, en) {
    var k = 1 / (1 - es);
    var phi = arg;
    for (var i = MAX_ITER; i; --i) { /* rarely goes over 2 iterations */
      var s = Math.sin(phi);
      var t = 1 - es * s * s;
      //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
      //phi -= t * (t * Math.sqrt(t)) * k;
      t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
      phi -= t;
      if (Math.abs(t) < EPSLN) {
        return phi;
      }
    }
    //..reportError("cass:pj_inv_mlfn: Convergence error");
    return phi;
  }

  // Heavily based on this tmerc projection implementation

  function init$2() {
    this.x0 = this.x0 !== undefined ? this.x0 : 0;
    this.y0 = this.y0 !== undefined ? this.y0 : 0;
    this.long0 = this.long0 !== undefined ? this.long0 : 0;
    this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

    if (this.es) {
      this.en = pj_enfn(this.es);
      this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
    }
  }

  /**
      Transverse Mercator Forward  - long/lat to x/y
      long/lat in radians
    */
  function forward$2(p) {
    var lon = p.x;
    var lat = p.y;

    var delta_lon = adjust_lon(lon - this.long0);
    var con;
    var x, y;
    var sin_phi = Math.sin(lat);
    var cos_phi = Math.cos(lat);

    if (!this.es) {
      var b = cos_phi * Math.sin(delta_lon);

      if ((Math.abs(Math.abs(b) - 1)) < EPSLN) {
        return (93);
      }
      else {
        x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
        y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
        b = Math.abs(y);

        if (b >= 1) {
          if ((b - 1) > EPSLN) {
            return (93);
          }
          else {
            y = 0;
          }
        }
        else {
          y = Math.acos(y);
        }

        if (lat < 0) {
          y = -y;
        }

        y = this.a * this.k0 * (y - this.lat0) + this.y0;
      }
    }
    else {
      var al = cos_phi * delta_lon;
      var als = Math.pow(al, 2);
      var c = this.ep2 * Math.pow(cos_phi, 2);
      var cs = Math.pow(c, 2);
      var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
      var t = Math.pow(tq, 2);
      var ts = Math.pow(t, 2);
      con = 1 - this.es * Math.pow(sin_phi, 2);
      al = al / Math.sqrt(con);
      var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);

      x = this.a * (this.k0 * al * (1 +
        als / 6 * (1 - t + c +
        als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c +
        als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) +
        this.x0;

      y = this.a * (this.k0 * (ml - this.ml0 +
        sin_phi * delta_lon * al / 2 * (1 +
        als / 12 * (5 - t + 9 * c + 4 * cs +
        als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c +
        als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) +
        this.y0;
    }

    p.x = x;
    p.y = y;

    return p;
  }

  /**
      Transverse Mercator Inverse  -  x/y to long/lat
    */
  function inverse$2(p) {
    var con, phi;
    var lat, lon;
    var x = (p.x - this.x0) * (1 / this.a);
    var y = (p.y - this.y0) * (1 / this.a);

    if (!this.es) {
      var f = Math.exp(x / this.k0);
      var g = 0.5 * (f - 1 / f);
      var temp = this.lat0 + y / this.k0;
      var h = Math.cos(temp);
      con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
      lat = Math.asin(con);

      if (y < 0) {
        lat = -lat;
      }

      if ((g === 0) && (h === 0)) {
        lon = 0;
      }
      else {
        lon = adjust_lon(Math.atan2(g, h) + this.long0);
      }
    }
    else { // ellipsoidal form
      con = this.ml0 + y / this.k0;
      phi = pj_inv_mlfn(con, this.es, this.en);

      if (Math.abs(phi) < HALF_PI) {
        var sin_phi = Math.sin(phi);
        var cos_phi = Math.cos(phi);
        var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
        var c = this.ep2 * Math.pow(cos_phi, 2);
        var cs = Math.pow(c, 2);
        var t = Math.pow(tan_phi, 2);
        var ts = Math.pow(t, 2);
        con = 1 - this.es * Math.pow(sin_phi, 2);
        var d = x * Math.sqrt(con) / this.k0;
        var ds = Math.pow(d, 2);
        con = con * tan_phi;

        lat = phi - (con * ds / (1 - this.es)) * 0.5 * (1 -
          ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs -
          ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c -
          ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));

        lon = adjust_lon(this.long0 + (d * (1 -
          ds / 6 * (1 + 2 * t + c -
          ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c -
          ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi));
      }
      else {
        lat = HALF_PI * sign(y);
        lon = 0;
      }
    }

    p.x = lon;
    p.y = lat;

    return p;
  }

  var names$3 = ["Transverse_Mercator", "Transverse Mercator", "tmerc"];
  var tmerc = {
    init: init$2,
    forward: forward$2,
    inverse: inverse$2,
    names: names$3
  };

  function sinh(x) {
    var r = Math.exp(x);
    r = (r - 1 / r) / 2;
    return r;
  }

  function hypot(x, y) {
    x = Math.abs(x);
    y = Math.abs(y);
    var a = Math.max(x, y);
    var b = Math.min(x, y) / (a ? a : 1);

    return a * Math.sqrt(1 + Math.pow(b, 2));
  }

  function log1py(x) {
    var y = 1 + x;
    var z = y - 1;

    return z === 0 ? x : x * Math.log(y) / z;
  }

  function asinhy(x) {
    var y = Math.abs(x);
    y = log1py(y * (1 + y / (hypot(1, y) + 1)));

    return x < 0 ? -y : y;
  }

  function gatg(pp, B) {
    var cos_2B = 2 * Math.cos(2 * B);
    var i = pp.length - 1;
    var h1 = pp[i];
    var h2 = 0;
    var h;

    while (--i >= 0) {
      h = -h2 + cos_2B * h1 + pp[i];
      h2 = h1;
      h1 = h;
    }

    return (B + h * Math.sin(2 * B));
  }

  function clens(pp, arg_r) {
    var r = 2 * Math.cos(arg_r);
    var i = pp.length - 1;
    var hr1 = pp[i];
    var hr2 = 0;
    var hr;

    while (--i >= 0) {
      hr = -hr2 + r * hr1 + pp[i];
      hr2 = hr1;
      hr1 = hr;
    }

    return Math.sin(arg_r) * hr;
  }

  function cosh$1(x) {
    var r = Math.exp(x);
    r = (r + 1 / r) / 2;
    return r;
  }

  function clens_cmplx(pp, arg_r, arg_i) {
    var sin_arg_r = Math.sin(arg_r);
    var cos_arg_r = Math.cos(arg_r);
    var sinh_arg_i = sinh(arg_i);
    var cosh_arg_i = cosh$1(arg_i);
    var r = 2 * cos_arg_r * cosh_arg_i;
    var i = -2 * sin_arg_r * sinh_arg_i;
    var j = pp.length - 1;
    var hr = pp[j];
    var hi1 = 0;
    var hr1 = 0;
    var hi = 0;
    var hr2;
    var hi2;

    while (--j >= 0) {
      hr2 = hr1;
      hi2 = hi1;
      hr1 = hr;
      hi1 = hi;
      hr = -hr2 + r * hr1 - i * hi1 + pp[j];
      hi = -hi2 + i * hr1 + r * hi1;
    }

    r = sin_arg_r * cosh_arg_i;
    i = cos_arg_r * sinh_arg_i;

    return [r * hr - i * hi, r * hi + i * hr];
  }

  // Heavily based on this etmerc projection implementation

  function init$3() {
    if (this.es === undefined || this.es <= 0) {
      throw new Error('incorrect elliptical usage');
    }

    this.x0 = this.x0 !== undefined ? this.x0 : 0;
    this.y0 = this.y0 !== undefined ? this.y0 : 0;
    this.long0 = this.long0 !== undefined ? this.long0 : 0;
    this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;

    this.cgb = [];
    this.cbg = [];
    this.utg = [];
    this.gtu = [];

    var f = this.es / (1 + Math.sqrt(1 - this.es));
    var n = f / (2 - f);
    var np = n;

    this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675 ))))));
    this.cbg[0] = n * (-2 + n * ( 2 / 3 + n * ( 4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));

    np = np * n;
    this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
    this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * ( -13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));

    np = np * n;
    this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
    this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));

    np = np * n;
    this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
    this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * ( -24832 / 14175)));

    np = np * n;
    this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
    this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));

    np = np * n;
    this.cgb[5] = np * (601676 / 22275);
    this.cbg[5] = np * (444337 / 155925);

    np = Math.pow(n, 2);
    this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));

    this.utg[0] = n * (-0.5 + n * ( 2 / 3 + n * (-37 / 96 + n * ( 1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
    this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));

    this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
    this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));

    np = np * n;
    this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720 ))));
    this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));

    np = np * n;
    this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
    this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));

    np = np * n;
    this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
    this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));

    np = np * n;
    this.utg[5] = np * (-20648693 / 638668800);
    this.gtu[5] = np * (212378941 / 319334400);

    var Z = gatg(this.cbg, this.lat0);
    this.Zb = -this.Qn * (Z + clens(this.gtu, 2 * Z));
  }

  function forward$3(p) {
    var Ce = adjust_lon(p.x - this.long0);
    var Cn = p.y;

    Cn = gatg(this.cbg, Cn);
    var sin_Cn = Math.sin(Cn);
    var cos_Cn = Math.cos(Cn);
    var sin_Ce = Math.sin(Ce);
    var cos_Ce = Math.cos(Ce);

    Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
    Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
    Ce = asinhy(Math.tan(Ce));

    var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);

    Cn = Cn + tmp[0];
    Ce = Ce + tmp[1];

    var x;
    var y;

    if (Math.abs(Ce) <= 2.623395162778) {
      x = this.a * (this.Qn * Ce) + this.x0;
      y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
    }
    else {
      x = Infinity;
      y = Infinity;
    }

    p.x = x;
    p.y = y;

    return p;
  }

  function inverse$3(p) {
    var Ce = (p.x - this.x0) * (1 / this.a);
    var Cn = (p.y - this.y0) * (1 / this.a);

    Cn = (Cn - this.Zb) / this.Qn;
    Ce = Ce / this.Qn;

    var lon;
    var lat;

    if (Math.abs(Ce) <= 2.623395162778) {
      var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);

      Cn = Cn + tmp[0];
      Ce = Ce + tmp[1];
      Ce = Math.atan(sinh(Ce));

      var sin_Cn = Math.sin(Cn);
      var cos_Cn = Math.cos(Cn);
      var sin_Ce = Math.sin(Ce);
      var cos_Ce = Math.cos(Ce);

      Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
      Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);

      lon = adjust_lon(Ce + this.long0);
      lat = gatg(this.cgb, Cn);
    }
    else {
      lon = Infinity;
      lat = Infinity;
    }

    p.x = lon;
    p.y = lat;

    return p;
  }

  var names$4 = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc"];
  var etmerc = {
    init: init$3,
    forward: forward$3,
    inverse: inverse$3,
    names: names$4
  };

  function adjust_zone(zone, lon) {
    if (zone === undefined) {
      zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;

      if (zone < 0) {
        return 0;
      } else if (zone > 60) {
        return 60;
      }
    }
    return zone;
  }

  var dependsOn = 'etmerc';


  function init$4() {
    var zone = adjust_zone(this.zone, this.long0);
    if (zone === undefined) {
      throw new Error('unknown utm zone');
    }
    this.lat0 = 0;
    this.long0 =  ((6 * Math.abs(zone)) - 183) * D2R;
    this.x0 = 500000;
    this.y0 = this.utmSouth ? 10000000 : 0;
    this.k0 = 0.9996;

    etmerc.init.apply(this);
    this.forward = etmerc.forward;
    this.inverse = etmerc.inverse;
  }

  var names$5 = ["Universal Transverse Mercator System", "utm"];
  var utm = {
    init: init$4,
    names: names$5,
    dependsOn: dependsOn
  };

  function srat(esinp, exp) {
    return (Math.pow((1 - esinp) / (1 + esinp), exp));
  }

  var MAX_ITER$1 = 20;

  function init$5() {
    var sphi = Math.sin(this.lat0);
    var cphi = Math.cos(this.lat0);
    cphi *= cphi;
    this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
    this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
    this.phic0 = Math.asin(sphi / this.C);
    this.ratexp = 0.5 * this.C * this.e;
    this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
  }

  function forward$4(p) {
    var lon = p.x;
    var lat = p.y;

    p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
    p.x = this.C * lon;
    return p;
  }

  function inverse$4(p) {
    var DEL_TOL = 1e-14;
    var lon = p.x / this.C;
    var lat = p.y;
    var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
    for (var i = MAX_ITER$1; i > 0; --i) {
      lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;
      if (Math.abs(lat - p.y) < DEL_TOL) {
        break;
      }
      p.y = lat;
    }
    /* convergence failed */
    if (!i) {
      return null;
    }
    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$6 = ["gauss"];
  var gauss = {
    init: init$5,
    forward: forward$4,
    inverse: inverse$4,
    names: names$6
  };

  function init$6() {
    gauss.init.apply(this);
    if (!this.rc) {
      return;
    }
    this.sinc0 = Math.sin(this.phic0);
    this.cosc0 = Math.cos(this.phic0);
    this.R2 = 2 * this.rc;
    if (!this.title) {
      this.title = "Oblique Stereographic Alternative";
    }
  }

  function forward$5(p) {
    var sinc, cosc, cosl, k;
    p.x = adjust_lon(p.x - this.long0);
    gauss.forward.apply(this, [p]);
    sinc = Math.sin(p.y);
    cosc = Math.cos(p.y);
    cosl = Math.cos(p.x);
    k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
    p.x = k * cosc * Math.sin(p.x);
    p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
    p.x = this.a * p.x + this.x0;
    p.y = this.a * p.y + this.y0;
    return p;
  }

  function inverse$5(p) {
    var sinc, cosc, lon, lat, rho;
    p.x = (p.x - this.x0) / this.a;
    p.y = (p.y - this.y0) / this.a;

    p.x /= this.k0;
    p.y /= this.k0;
    if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {
      var c = 2 * Math.atan2(rho, this.R2);
      sinc = Math.sin(c);
      cosc = Math.cos(c);
      lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
      lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
    }
    else {
      lat = this.phic0;
      lon = 0;
    }

    p.x = lon;
    p.y = lat;
    gauss.inverse.apply(this, [p]);
    p.x = adjust_lon(p.x + this.long0);
    return p;
  }

  var names$7 = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea","Oblique Stereographic Alternative","Double_Stereographic"];
  var sterea = {
    init: init$6,
    forward: forward$5,
    inverse: inverse$5,
    names: names$7
  };

  function ssfn_(phit, sinphi, eccen) {
    sinphi *= eccen;
    return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));
  }

  function init$7() {
    this.coslat0 = Math.cos(this.lat0);
    this.sinlat0 = Math.sin(this.lat0);
    if (this.sphere) {
      if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
        this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
      }
    }
    else {
      if (Math.abs(this.coslat0) <= EPSLN) {
        if (this.lat0 > 0) {
          //North pole
          //trace('stere:north pole');
          this.con = 1;
        }
        else {
          //South pole
          //trace('stere:south pole');
          this.con = -1;
        }
      }
      this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
      if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
        this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
      }
      this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
      this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
      this.cosX0 = Math.cos(this.X0);
      this.sinX0 = Math.sin(this.X0);
    }
  }

  // Stereographic forward equations--mapping lat,long to x,y
  function forward$6(p) {
    var lon = p.x;
    var lat = p.y;
    var sinlat = Math.sin(lat);
    var coslat = Math.cos(lat);
    var A, X, sinX, cosX, ts, rh;
    var dlon = adjust_lon(lon - this.long0);

    if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
      //case of the origine point
      //trace('stere:this is the origin point');
      p.x = NaN;
      p.y = NaN;
      return p;
    }
    if (this.sphere) {
      //trace('stere:sphere case');
      A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
      p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
      p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
      return p;
    }
    else {
      X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
      cosX = Math.cos(X);
      sinX = Math.sin(X);
      if (Math.abs(this.coslat0) <= EPSLN) {
        ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
        rh = 2 * this.a * this.k0 * ts / this.cons;
        p.x = this.x0 + rh * Math.sin(lon - this.long0);
        p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
        //trace(p.toString());
        return p;
      }
      else if (Math.abs(this.sinlat0) < EPSLN) {
        //Eq
        //trace('stere:equateur');
        A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
        p.y = A * sinX;
      }
      else {
        //other case
        //trace('stere:normal case');
        A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
        p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
      }
      p.x = A * cosX * Math.sin(dlon) + this.x0;
    }
    //trace(p.toString());
    return p;
  }

  //* Stereographic inverse equations--mapping x,y to lat/long
  function inverse$6(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var lon, lat, ts, ce, Chi;
    var rh = Math.sqrt(p.x * p.x + p.y * p.y);
    if (this.sphere) {
      var c = 2 * Math.atan(rh / (2 * this.a * this.k0));
      lon = this.long0;
      lat = this.lat0;
      if (rh <= EPSLN) {
        p.x = lon;
        p.y = lat;
        return p;
      }
      lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
      if (Math.abs(this.coslat0) < EPSLN) {
        if (this.lat0 > 0) {
          lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
        }
        else {
          lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
        }
      }
      else {
        lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
      }
      p.x = lon;
      p.y = lat;
      return p;
    }
    else {
      if (Math.abs(this.coslat0) <= EPSLN) {
        if (rh <= EPSLN) {
          lat = this.lat0;
          lon = this.long0;
          p.x = lon;
          p.y = lat;
          //trace(p.toString());
          return p;
        }
        p.x *= this.con;
        p.y *= this.con;
        ts = rh * this.cons / (2 * this.a * this.k0);
        lat = this.con * phi2z(this.e, ts);
        lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));
      }
      else {
        ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
        lon = this.long0;
        if (rh <= EPSLN) {
          Chi = this.X0;
        }
        else {
          Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
          lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
        }
        lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
      }
    }
    p.x = lon;
    p.y = lat;

    //trace(p.toString());
    return p;

  }

  var names$8 = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
  var stere = {
    init: init$7,
    forward: forward$6,
    inverse: inverse$6,
    names: names$8,
    ssfn_: ssfn_
  };

  /*
    references:
      Formules et constantes pour le Calcul pour la
      projection cylindrique conforme à axe oblique et pour la transformation entre
      des systèmes de référence.
      http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
    */

  function init$8() {
    var phy0 = this.lat0;
    this.lambda0 = this.long0;
    var sinPhy0 = Math.sin(phy0);
    var semiMajorAxis = this.a;
    var invF = this.rf;
    var flattening = 1 / invF;
    var e2 = 2 * flattening - Math.pow(flattening, 2);
    var e = this.e = Math.sqrt(e2);
    this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
    this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
    this.b0 = Math.asin(sinPhy0 / this.alpha);
    var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
    var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
    var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
    this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
  }

  function forward$7(p) {
    var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
    var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
    var S = -this.alpha * (Sa1 + Sa2) + this.K;

    // spheric latitude
    var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);

    // spheric longitude
    var I = this.alpha * (p.x - this.lambda0);

    // psoeudo equatorial rotation
    var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));

    var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));

    p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
    p.x = this.R * rotI + this.x0;
    return p;
  }

  function inverse$7(p) {
    var Y = p.x - this.x0;
    var X = p.y - this.y0;

    var rotI = Y / this.R;
    var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);

    var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
    var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));

    var lambda = this.lambda0 + I / this.alpha;

    var S = 0;
    var phy = b;
    var prevPhy = -1000;
    var iteration = 0;
    while (Math.abs(phy - prevPhy) > 0.0000001) {
      if (++iteration > 20) {
        //...reportError("omercFwdInfinity");
        return;
      }
      //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
      S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
      prevPhy = phy;
      phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
    }

    p.x = lambda;
    p.y = phy;
    return p;
  }

  var names$9 = ["somerc"];
  var somerc = {
    init: init$8,
    forward: forward$7,
    inverse: inverse$7,
    names: names$9
  };

  /* Initialize the Oblique Mercator  projection
      ------------------------------------------*/
  function init$9() {
    this.no_off = this.no_off || false;
    this.no_rot = this.no_rot || false;

    if (isNaN(this.k0)) {
      this.k0 = 1;
    }
    var sinlat = Math.sin(this.lat0);
    var coslat = Math.cos(this.lat0);
    var con = this.e * sinlat;

    this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(coslat, 4));
    this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - con * con);
    var t0 = tsfnz(this.e, this.lat0, sinlat);
    var dl = this.bl / coslat * Math.sqrt((1 - this.es) / (1 - con * con));
    if (dl * dl < 1) {
      dl = 1;
    }
    var fl;
    var gl;
    if (!isNaN(this.longc)) {
      //Central point and azimuth method

      if (this.lat0 >= 0) {
        fl = dl + Math.sqrt(dl * dl - 1);
      }
      else {
        fl = dl - Math.sqrt(dl * dl - 1);
      }
      this.el = fl * Math.pow(t0, this.bl);
      gl = 0.5 * (fl - 1 / fl);
      this.gamma0 = Math.asin(Math.sin(this.alpha) / dl);
      this.long0 = this.longc - Math.asin(gl * Math.tan(this.gamma0)) / this.bl;

    }
    else {
      //2 points method
      var t1 = tsfnz(this.e, this.lat1, Math.sin(this.lat1));
      var t2 = tsfnz(this.e, this.lat2, Math.sin(this.lat2));
      if (this.lat0 >= 0) {
        this.el = (dl + Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
      }
      else {
        this.el = (dl - Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
      }
      var hl = Math.pow(t1, this.bl);
      var ll = Math.pow(t2, this.bl);
      fl = this.el / hl;
      gl = 0.5 * (fl - 1 / fl);
      var jl = (this.el * this.el - ll * hl) / (this.el * this.el + ll * hl);
      var pl = (ll - hl) / (ll + hl);
      var dlon12 = adjust_lon(this.long1 - this.long2);
      this.long0 = 0.5 * (this.long1 + this.long2) - Math.atan(jl * Math.tan(0.5 * this.bl * (dlon12)) / pl) / this.bl;
      this.long0 = adjust_lon(this.long0);
      var dlon10 = adjust_lon(this.long1 - this.long0);
      this.gamma0 = Math.atan(Math.sin(this.bl * (dlon10)) / gl);
      this.alpha = Math.asin(dl * Math.sin(this.gamma0));
    }

    if (this.no_off) {
      this.uc = 0;
    }
    else {
      if (this.lat0 >= 0) {
        this.uc = this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
      }
      else {
        this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
      }
    }

  }

  /* Oblique Mercator forward equations--mapping lat,long to x,y
      ----------------------------------------------------------*/
  function forward$8(p) {
    var lon = p.x;
    var lat = p.y;
    var dlon = adjust_lon(lon - this.long0);
    var us, vs;
    var con;
    if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
      if (lat > 0) {
        con = -1;
      }
      else {
        con = 1;
      }
      vs = this.al / this.bl * Math.log(Math.tan(FORTPI + con * this.gamma0 * 0.5));
      us = -1 * con * HALF_PI * this.al / this.bl;
    }
    else {
      var t = tsfnz(this.e, lat, Math.sin(lat));
      var ql = this.el / Math.pow(t, this.bl);
      var sl = 0.5 * (ql - 1 / ql);
      var tl = 0.5 * (ql + 1 / ql);
      var vl = Math.sin(this.bl * (dlon));
      var ul = (sl * Math.sin(this.gamma0) - vl * Math.cos(this.gamma0)) / tl;
      if (Math.abs(Math.abs(ul) - 1) <= EPSLN) {
        vs = Number.POSITIVE_INFINITY;
      }
      else {
        vs = 0.5 * this.al * Math.log((1 - ul) / (1 + ul)) / this.bl;
      }
      if (Math.abs(Math.cos(this.bl * (dlon))) <= EPSLN) {
        us = this.al * this.bl * (dlon);
      }
      else {
        us = this.al * Math.atan2(sl * Math.cos(this.gamma0) + vl * Math.sin(this.gamma0), Math.cos(this.bl * dlon)) / this.bl;
      }
    }

    if (this.no_rot) {
      p.x = this.x0 + us;
      p.y = this.y0 + vs;
    }
    else {

      us -= this.uc;
      p.x = this.x0 + vs * Math.cos(this.alpha) + us * Math.sin(this.alpha);
      p.y = this.y0 + us * Math.cos(this.alpha) - vs * Math.sin(this.alpha);
    }
    return p;
  }

  function inverse$8(p) {
    var us, vs;
    if (this.no_rot) {
      vs = p.y - this.y0;
      us = p.x - this.x0;
    }
    else {
      vs = (p.x - this.x0) * Math.cos(this.alpha) - (p.y - this.y0) * Math.sin(this.alpha);
      us = (p.y - this.y0) * Math.cos(this.alpha) + (p.x - this.x0) * Math.sin(this.alpha);
      us += this.uc;
    }
    var qp = Math.exp(-1 * this.bl * vs / this.al);
    var sp = 0.5 * (qp - 1 / qp);
    var tp = 0.5 * (qp + 1 / qp);
    var vp = Math.sin(this.bl * us / this.al);
    var up = (vp * Math.cos(this.gamma0) + sp * Math.sin(this.gamma0)) / tp;
    var ts = Math.pow(this.el / Math.sqrt((1 + up) / (1 - up)), 1 / this.bl);
    if (Math.abs(up - 1) < EPSLN) {
      p.x = this.long0;
      p.y = HALF_PI;
    }
    else if (Math.abs(up + 1) < EPSLN) {
      p.x = this.long0;
      p.y = -1 * HALF_PI;
    }
    else {
      p.y = phi2z(this.e, ts);
      p.x = adjust_lon(this.long0 - Math.atan2(sp * Math.cos(this.gamma0) - vp * Math.sin(this.gamma0), Math.cos(this.bl * us / this.al)) / this.bl);
    }
    return p;
  }

  var names$a = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "omerc"];
  var omerc = {
    init: init$9,
    forward: forward$8,
    inverse: inverse$8,
    names: names$a
  };

  function init$a() {

    // array of:  r_maj,r_min,lat1,lat2,c_lon,c_lat,false_east,false_north
    //double c_lat;                   /* center latitude                      */
    //double c_lon;                   /* center longitude                     */
    //double lat1;                    /* first standard parallel              */
    //double lat2;                    /* second standard parallel             */
    //double r_maj;                   /* major axis                           */
    //double r_min;                   /* minor axis                           */
    //double false_east;              /* x offset in meters                   */
    //double false_north;             /* y offset in meters                   */

    if (!this.lat2) {
      this.lat2 = this.lat1;
    } //if lat2 is not defined
    if (!this.k0) {
      this.k0 = 1;
    }
    this.x0 = this.x0 || 0;
    this.y0 = this.y0 || 0;
    // Standard Parallels cannot be equal and on opposite sides of the equator
    if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
      return;
    }

    var temp = this.b / this.a;
    this.e = Math.sqrt(1 - temp * temp);

    var sin1 = Math.sin(this.lat1);
    var cos1 = Math.cos(this.lat1);
    var ms1 = msfnz(this.e, sin1, cos1);
    var ts1 = tsfnz(this.e, this.lat1, sin1);

    var sin2 = Math.sin(this.lat2);
    var cos2 = Math.cos(this.lat2);
    var ms2 = msfnz(this.e, sin2, cos2);
    var ts2 = tsfnz(this.e, this.lat2, sin2);

    var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));

    if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
      this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
    }
    else {
      this.ns = sin1;
    }
    if (isNaN(this.ns)) {
      this.ns = sin1;
    }
    this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
    this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
    if (!this.title) {
      this.title = "Lambert Conformal Conic";
    }
  }

  // Lambert Conformal conic forward equations--mapping lat,long to x,y
  // -----------------------------------------------------------------
  function forward$9(p) {

    var lon = p.x;
    var lat = p.y;

    // singular cases :
    if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
      lat = sign(lat) * (HALF_PI - 2 * EPSLN);
    }

    var con = Math.abs(Math.abs(lat) - HALF_PI);
    var ts, rh1;
    if (con > EPSLN) {
      ts = tsfnz(this.e, lat, Math.sin(lat));
      rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
    }
    else {
      con = lat * this.ns;
      if (con <= 0) {
        return null;
      }
      rh1 = 0;
    }
    var theta = this.ns * adjust_lon(lon - this.long0);
    p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
    p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;

    return p;
  }

  // Lambert Conformal Conic inverse equations--mapping x,y to lat/long
  // -----------------------------------------------------------------
  function inverse$9(p) {

    var rh1, con, ts;
    var lat, lon;
    var x = (p.x - this.x0) / this.k0;
    var y = (this.rh - (p.y - this.y0) / this.k0);
    if (this.ns > 0) {
      rh1 = Math.sqrt(x * x + y * y);
      con = 1;
    }
    else {
      rh1 = -Math.sqrt(x * x + y * y);
      con = -1;
    }
    var theta = 0;
    if (rh1 !== 0) {
      theta = Math.atan2((con * x), (con * y));
    }
    if ((rh1 !== 0) || (this.ns > 0)) {
      con = 1 / this.ns;
      ts = Math.pow((rh1 / (this.a * this.f0)), con);
      lat = phi2z(this.e, ts);
      if (lat === -9999) {
        return null;
      }
    }
    else {
      lat = -HALF_PI;
    }
    lon = adjust_lon(theta / this.ns + this.long0);

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$b = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_2SP", "lcc"];
  var lcc = {
    init: init$a,
    forward: forward$9,
    inverse: inverse$9,
    names: names$b
  };

  function init$b() {
    this.a = 6377397.155;
    this.es = 0.006674372230614;
    this.e = Math.sqrt(this.es);
    if (!this.lat0) {
      this.lat0 = 0.863937979737193;
    }
    if (!this.long0) {
      this.long0 = 0.7417649320975901 - 0.308341501185665;
    }
    /* if scale not set default to 0.9999 */
    if (!this.k0) {
      this.k0 = 0.9999;
    }
    this.s45 = 0.785398163397448; /* 45 */
    this.s90 = 2 * this.s45;
    this.fi0 = this.lat0;
    this.e2 = this.es;
    this.e = Math.sqrt(this.e2);
    this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));
    this.uq = 1.04216856380474;
    this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
    this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
    this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
    this.k1 = this.k0;
    this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
    this.s0 = 1.37008346281555;
    this.n = Math.sin(this.s0);
    this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
    this.ad = this.s90 - this.uq;
  }

  /* ellipsoid */
  /* calculate xy from lat/lon */
  /* Constants, identical to inverse transform function */
  function forward$a(p) {
    var gfi, u, deltav, s, d, eps, ro;
    var lon = p.x;
    var lat = p.y;
    var delta_lon = adjust_lon(lon - this.long0);
    /* Transformation */
    gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));
    u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
    deltav = -delta_lon * this.alfa;
    s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
    d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
    eps = this.n * d;
    ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
    p.y = ro * Math.cos(eps) / 1;
    p.x = ro * Math.sin(eps) / 1;

    if (!this.czech) {
      p.y *= -1;
      p.x *= -1;
    }
    return (p);
  }

  /* calculate lat/lon from xy */
  function inverse$a(p) {
    var u, deltav, s, d, eps, ro, fi1;
    var ok;

    /* Transformation */
    /* revert y, x*/
    var tmp = p.x;
    p.x = p.y;
    p.y = tmp;
    if (!this.czech) {
      p.y *= -1;
      p.x *= -1;
    }
    ro = Math.sqrt(p.x * p.x + p.y * p.y);
    eps = Math.atan2(p.y, p.x);
    d = eps / Math.sin(this.s0);
    s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
    u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
    deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
    p.x = this.long0 - deltav / this.alfa;
    fi1 = u;
    ok = 0;
    var iter = 0;
    do {
      p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
      if (Math.abs(fi1 - p.y) < 0.0000000001) {
        ok = 1;
      }
      fi1 = p.y;
      iter += 1;
    } while (ok === 0 && iter < 15);
    if (iter >= 15) {
      return null;
    }

    return (p);
  }

  var names$c = ["Krovak", "krovak"];
  var krovak = {
    init: init$b,
    forward: forward$a,
    inverse: inverse$a,
    names: names$c
  };

  function mlfn(e0, e1, e2, e3, phi) {
    return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));
  }

  function e0fn(x) {
    return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));
  }

  function e1fn(x) {
    return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));
  }

  function e2fn(x) {
    return (0.05859375 * x * x * (1 + 0.75 * x));
  }

  function e3fn(x) {
    return (x * x * x * (35 / 3072));
  }

  function gN(a, e, sinphi) {
    var temp = e * sinphi;
    return a / Math.sqrt(1 - temp * temp);
  }

  function adjust_lat(x) {
    return (Math.abs(x) < HALF_PI) ? x : (x - (sign(x) * Math.PI));
  }

  function imlfn(ml, e0, e1, e2, e3) {
    var phi;
    var dphi;

    phi = ml / e0;
    for (var i = 0; i < 15; i++) {
      dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
      phi += dphi;
      if (Math.abs(dphi) <= 0.0000000001) {
        return phi;
      }
    }

    //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
    return NaN;
  }

  function init$c() {
    if (!this.sphere) {
      this.e0 = e0fn(this.es);
      this.e1 = e1fn(this.es);
      this.e2 = e2fn(this.es);
      this.e3 = e3fn(this.es);
      this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
    }
  }

  /* Cassini forward equations--mapping lat,long to x,y
    -----------------------------------------------------------------------*/
  function forward$b(p) {

    /* Forward equations
        -----------------*/
    var x, y;
    var lam = p.x;
    var phi = p.y;
    lam = adjust_lon(lam - this.long0);

    if (this.sphere) {
      x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
      y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
    }
    else {
      //ellipsoid
      var sinphi = Math.sin(phi);
      var cosphi = Math.cos(phi);
      var nl = gN(this.a, this.e, sinphi);
      var tl = Math.tan(phi) * Math.tan(phi);
      var al = lam * Math.cos(phi);
      var asq = al * al;
      var cl = this.es * cosphi * cosphi / (1 - this.es);
      var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);

      x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
      y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);


    }

    p.x = x + this.x0;
    p.y = y + this.y0;
    return p;
  }

  /* Inverse equations
    -----------------*/
  function inverse$b(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var x = p.x / this.a;
    var y = p.y / this.a;
    var phi, lam;

    if (this.sphere) {
      var dd = y + this.lat0;
      phi = Math.asin(Math.sin(dd) * Math.cos(x));
      lam = Math.atan2(Math.tan(x), Math.cos(dd));
    }
    else {
      /* ellipsoid */
      var ml1 = this.ml0 / this.a + y;
      var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
      if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
        p.x = this.long0;
        p.y = HALF_PI;
        if (y < 0) {
          p.y *= -1;
        }
        return p;
      }
      var nl1 = gN(this.a, this.e, Math.sin(phi1));

      var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
      var tl1 = Math.pow(Math.tan(phi1), 2);
      var dl = x * this.a / nl1;
      var dsq = dl * dl;
      phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
      lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);

    }

    p.x = adjust_lon(lam + this.long0);
    p.y = adjust_lat(phi);
    return p;

  }

  var names$d = ["Cassini", "Cassini_Soldner", "cass"];
  var cass = {
    init: init$c,
    forward: forward$b,
    inverse: inverse$b,
    names: names$d
  };

  function qsfnz(eccent, sinphi) {
    var con;
    if (eccent > 1.0e-7) {
      con = eccent * sinphi;
      return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));
    }
    else {
      return (2 * sinphi);
    }
  }

  /*
    reference
      "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
      The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
    */

  var S_POLE = 1;

  var N_POLE = 2;
  var EQUIT = 3;
  var OBLIQ = 4;

  /* Initialize the Lambert Azimuthal Equal Area projection
    ------------------------------------------------------*/
  function init$d() {
    var t = Math.abs(this.lat0);
    if (Math.abs(t - HALF_PI) < EPSLN) {
      this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
    }
    else if (Math.abs(t) < EPSLN) {
      this.mode = this.EQUIT;
    }
    else {
      this.mode = this.OBLIQ;
    }
    if (this.es > 0) {
      var sinphi;

      this.qp = qsfnz(this.e, 1);
      this.mmf = 0.5 / (1 - this.es);
      this.apa = authset(this.es);
      switch (this.mode) {
      case this.N_POLE:
        this.dd = 1;
        break;
      case this.S_POLE:
        this.dd = 1;
        break;
      case this.EQUIT:
        this.rq = Math.sqrt(0.5 * this.qp);
        this.dd = 1 / this.rq;
        this.xmf = 1;
        this.ymf = 0.5 * this.qp;
        break;
      case this.OBLIQ:
        this.rq = Math.sqrt(0.5 * this.qp);
        sinphi = Math.sin(this.lat0);
        this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
        this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
        this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
        this.ymf = (this.xmf = this.rq) / this.dd;
        this.xmf *= this.dd;
        break;
      }
    }
    else {
      if (this.mode === this.OBLIQ) {
        this.sinph0 = Math.sin(this.lat0);
        this.cosph0 = Math.cos(this.lat0);
      }
    }
  }

  /* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
    -----------------------------------------------------------------------*/
  function forward$c(p) {

    /* Forward equations
        -----------------*/
    var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
    var lam = p.x;
    var phi = p.y;

    lam = adjust_lon(lam - this.long0);
    if (this.sphere) {
      sinphi = Math.sin(phi);
      cosphi = Math.cos(phi);
      coslam = Math.cos(lam);
      if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
        if (y <= EPSLN) {
          return null;
        }
        y = Math.sqrt(2 / y);
        x = y * cosphi * Math.sin(lam);
        y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
      }
      else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
        if (this.mode === this.N_POLE) {
          coslam = -coslam;
        }
        if (Math.abs(phi + this.lat0) < EPSLN) {
          return null;
        }
        y = FORTPI - phi * 0.5;
        y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));
        x = y * Math.sin(lam);
        y *= coslam;
      }
    }
    else {
      sinb = 0;
      cosb = 0;
      b = 0;
      coslam = Math.cos(lam);
      sinlam = Math.sin(lam);
      sinphi = Math.sin(phi);
      q = qsfnz(this.e, sinphi);
      if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        sinb = q / this.qp;
        cosb = Math.sqrt(1 - sinb * sinb);
      }
      switch (this.mode) {
      case this.OBLIQ:
        b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
        break;
      case this.EQUIT:
        b = 1 + cosb * coslam;
        break;
      case this.N_POLE:
        b = HALF_PI + phi;
        q = this.qp - q;
        break;
      case this.S_POLE:
        b = phi - HALF_PI;
        q = this.qp + q;
        break;
      }
      if (Math.abs(b) < EPSLN) {
        return null;
      }
      switch (this.mode) {
      case this.OBLIQ:
      case this.EQUIT:
        b = Math.sqrt(2 / b);
        if (this.mode === this.OBLIQ) {
          y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
        }
        else {
          y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
        }
        x = this.xmf * b * cosb * sinlam;
        break;
      case this.N_POLE:
      case this.S_POLE:
        if (q >= 0) {
          x = (b = Math.sqrt(q)) * sinlam;
          y = coslam * ((this.mode === this.S_POLE) ? b : -b);
        }
        else {
          x = y = 0;
        }
        break;
      }
    }

    p.x = this.a * x + this.x0;
    p.y = this.a * y + this.y0;
    return p;
  }

  /* Inverse equations
    -----------------*/
  function inverse$c(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var x = p.x / this.a;
    var y = p.y / this.a;
    var lam, phi, cCe, sCe, q, rho, ab;
    if (this.sphere) {
      var cosz = 0,
        rh, sinz = 0;

      rh = Math.sqrt(x * x + y * y);
      phi = rh * 0.5;
      if (phi > 1) {
        return null;
      }
      phi = 2 * Math.asin(phi);
      if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        sinz = Math.sin(phi);
        cosz = Math.cos(phi);
      }
      switch (this.mode) {
      case this.EQUIT:
        phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);
        x *= sinz;
        y = cosz * rh;
        break;
      case this.OBLIQ:
        phi = (Math.abs(rh) <= EPSLN) ? this.lat0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
        x *= sinz * this.cosph0;
        y = (cosz - Math.sin(phi) * this.sinph0) * rh;
        break;
      case this.N_POLE:
        y = -y;
        phi = HALF_PI - phi;
        break;
      case this.S_POLE:
        phi -= HALF_PI;
        break;
      }
      lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);
    }
    else {
      ab = 0;
      if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
        x /= this.dd;
        y *= this.dd;
        rho = Math.sqrt(x * x + y * y);
        if (rho < EPSLN) {
          p.x = this.long0;
          p.y = this.lat0;
          return p;
        }
        sCe = 2 * Math.asin(0.5 * rho / this.rq);
        cCe = Math.cos(sCe);
        x *= (sCe = Math.sin(sCe));
        if (this.mode === this.OBLIQ) {
          ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
          q = this.qp * ab;
          y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
        }
        else {
          ab = y * sCe / rho;
          q = this.qp * ab;
          y = rho * cCe;
        }
      }
      else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
        if (this.mode === this.N_POLE) {
          y = -y;
        }
        q = (x * x + y * y);
        if (!q) {
          p.x = this.long0;
          p.y = this.lat0;
          return p;
        }
        ab = 1 - q / this.qp;
        if (this.mode === this.S_POLE) {
          ab = -ab;
        }
      }
      lam = Math.atan2(x, y);
      phi = authlat(Math.asin(ab), this.apa);
    }

    p.x = adjust_lon(this.long0 + lam);
    p.y = phi;
    return p;
  }

  /* determine latitude from authalic latitude */
  var P00 = 0.33333333333333333333;

  var P01 = 0.17222222222222222222;
  var P02 = 0.10257936507936507936;
  var P10 = 0.06388888888888888888;
  var P11 = 0.06640211640211640211;
  var P20 = 0.01641501294219154443;

  function authset(es) {
    var t;
    var APA = [];
    APA[0] = es * P00;
    t = es * es;
    APA[0] += t * P01;
    APA[1] = t * P10;
    t *= es;
    APA[0] += t * P02;
    APA[1] += t * P11;
    APA[2] = t * P20;
    return APA;
  }

  function authlat(beta, APA) {
    var t = beta + beta;
    return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));
  }

  var names$e = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
  var laea = {
    init: init$d,
    forward: forward$c,
    inverse: inverse$c,
    names: names$e,
    S_POLE: S_POLE,
    N_POLE: N_POLE,
    EQUIT: EQUIT,
    OBLIQ: OBLIQ
  };

  function asinz(x) {
    if (Math.abs(x) > 1) {
      x = (x > 1) ? 1 : -1;
    }
    return Math.asin(x);
  }

  function init$e() {

    if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
      return;
    }
    this.temp = this.b / this.a;
    this.es = 1 - Math.pow(this.temp, 2);
    this.e3 = Math.sqrt(this.es);

    this.sin_po = Math.sin(this.lat1);
    this.cos_po = Math.cos(this.lat1);
    this.t1 = this.sin_po;
    this.con = this.sin_po;
    this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
    this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);

    this.sin_po = Math.sin(this.lat2);
    this.cos_po = Math.cos(this.lat2);
    this.t2 = this.sin_po;
    this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
    this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);

    this.sin_po = Math.sin(this.lat0);
    this.cos_po = Math.cos(this.lat0);
    this.t3 = this.sin_po;
    this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);

    if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
      this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
    }
    else {
      this.ns0 = this.con;
    }
    this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
    this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
  }

  /* Albers Conical Equal Area forward equations--mapping lat,long to x,y
    -------------------------------------------------------------------*/
  function forward$d(p) {

    var lon = p.x;
    var lat = p.y;

    this.sin_phi = Math.sin(lat);
    this.cos_phi = Math.cos(lat);

    var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
    var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
    var theta = this.ns0 * adjust_lon(lon - this.long0);
    var x = rh1 * Math.sin(theta) + this.x0;
    var y = this.rh - rh1 * Math.cos(theta) + this.y0;

    p.x = x;
    p.y = y;
    return p;
  }

  function inverse$d(p) {
    var rh1, qs, con, theta, lon, lat;

    p.x -= this.x0;
    p.y = this.rh - p.y + this.y0;
    if (this.ns0 >= 0) {
      rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
      con = 1;
    }
    else {
      rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
      con = -1;
    }
    theta = 0;
    if (rh1 !== 0) {
      theta = Math.atan2(con * p.x, con * p.y);
    }
    con = rh1 * this.ns0 / this.a;
    if (this.sphere) {
      lat = Math.asin((this.c - con * con) / (2 * this.ns0));
    }
    else {
      qs = (this.c - con * con) / this.ns0;
      lat = this.phi1z(this.e3, qs);
    }

    lon = adjust_lon(theta / this.ns0 + this.long0);
    p.x = lon;
    p.y = lat;
    return p;
  }

  /* Function to compute phi1, the latitude for the inverse of the
     Albers Conical Equal-Area projection.
  -------------------------------------------*/
  function phi1z(eccent, qs) {
    var sinphi, cosphi, con, com, dphi;
    var phi = asinz(0.5 * qs);
    if (eccent < EPSLN) {
      return phi;
    }

    var eccnts = eccent * eccent;
    for (var i = 1; i <= 25; i++) {
      sinphi = Math.sin(phi);
      cosphi = Math.cos(phi);
      con = eccent * sinphi;
      com = 1 - con * con;
      dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
      phi = phi + dphi;
      if (Math.abs(dphi) <= 1e-7) {
        return phi;
      }
    }
    return null;
  }

  var names$f = ["Albers_Conic_Equal_Area", "Albers", "aea"];
  var aea = {
    init: init$e,
    forward: forward$d,
    inverse: inverse$d,
    names: names$f,
    phi1z: phi1z
  };

  /*
    reference:
      Wolfram Mathworld "Gnomonic Projection"
      http://mathworld.wolfram.com/GnomonicProjection.html
      Accessed: 12th November 2009
    */
  function init$f() {

    /* Place parameters in static storage for common use
        -------------------------------------------------*/
    this.sin_p14 = Math.sin(this.lat0);
    this.cos_p14 = Math.cos(this.lat0);
    // Approximation for projecting points to the horizon (infinity)
    this.infinity_dist = 1000 * this.a;
    this.rc = 1;
  }

  /* Gnomonic forward equations--mapping lat,long to x,y
      ---------------------------------------------------*/
  function forward$e(p) {
    var sinphi, cosphi; /* sin and cos value        */
    var dlon; /* delta longitude value      */
    var coslon; /* cos of longitude        */
    var ksp; /* scale factor          */
    var g;
    var x, y;
    var lon = p.x;
    var lat = p.y;
    /* Forward equations
        -----------------*/
    dlon = adjust_lon(lon - this.long0);

    sinphi = Math.sin(lat);
    cosphi = Math.cos(lat);

    coslon = Math.cos(dlon);
    g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
    ksp = 1;
    if ((g > 0) || (Math.abs(g) <= EPSLN)) {
      x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
      y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
    }
    else {

      // Point is in the opposing hemisphere and is unprojectable
      // We still need to return a reasonable point, so we project
      // to infinity, on a bearing
      // equivalent to the northern hemisphere equivalent
      // This is a reasonable approximation for short shapes and lines that
      // straddle the horizon.

      x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
      y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);

    }
    p.x = x;
    p.y = y;
    return p;
  }

  function inverse$e(p) {
    var rh; /* Rho */
    var sinc, cosc;
    var c;
    var lon, lat;

    /* Inverse equations
        -----------------*/
    p.x = (p.x - this.x0) / this.a;
    p.y = (p.y - this.y0) / this.a;

    p.x /= this.k0;
    p.y /= this.k0;

    if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {
      c = Math.atan2(rh, this.rc);
      sinc = Math.sin(c);
      cosc = Math.cos(c);

      lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);
      lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
      lon = adjust_lon(this.long0 + lon);
    }
    else {
      lat = this.phic0;
      lon = 0;
    }

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$g = ["gnom"];
  var gnom = {
    init: init$f,
    forward: forward$e,
    inverse: inverse$e,
    names: names$g
  };

  function iqsfnz(eccent, q) {
    var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
    if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
      if (q < 0) {
        return (-1 * HALF_PI);
      }
      else {
        return HALF_PI;
      }
    }
    //var phi = 0.5* q/(1-eccent*eccent);
    var phi = Math.asin(0.5 * q);
    var dphi;
    var sin_phi;
    var cos_phi;
    var con;
    for (var i = 0; i < 30; i++) {
      sin_phi = Math.sin(phi);
      cos_phi = Math.cos(phi);
      con = eccent * sin_phi;
      dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
      phi += dphi;
      if (Math.abs(dphi) <= 0.0000000001) {
        return phi;
      }
    }

    //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
    return NaN;
  }

  /*
    reference:
      "Cartographic Projection Procedures for the UNIX Environment-
      A User's Manual" by Gerald I. Evenden,
      USGS Open File Report 90-284and Release 4 Interim Reports (2003)
  */
  function init$g() {
    //no-op
    if (!this.sphere) {
      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
    }
  }

  /* Cylindrical Equal Area forward equations--mapping lat,long to x,y
      ------------------------------------------------------------*/
  function forward$f(p) {
    var lon = p.x;
    var lat = p.y;
    var x, y;
    /* Forward equations
        -----------------*/
    var dlon = adjust_lon(lon - this.long0);
    if (this.sphere) {
      x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
      y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
    }
    else {
      var qs = qsfnz(this.e, Math.sin(lat));
      x = this.x0 + this.a * this.k0 * dlon;
      y = this.y0 + this.a * qs * 0.5 / this.k0;
    }

    p.x = x;
    p.y = y;
    return p;
  }

  /* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
      ------------------------------------------------------------*/
  function inverse$f(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var lon, lat;

    if (this.sphere) {
      lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));
      lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));
    }
    else {
      lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
      lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
    }

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$h = ["cea"];
  var cea = {
    init: init$g,
    forward: forward$f,
    inverse: inverse$f,
    names: names$h
  };

  function init$h() {

    this.x0 = this.x0 || 0;
    this.y0 = this.y0 || 0;
    this.lat0 = this.lat0 || 0;
    this.long0 = this.long0 || 0;
    this.lat_ts = this.lat_ts || 0;
    this.title = this.title || "Equidistant Cylindrical (Plate Carre)";

    this.rc = Math.cos(this.lat_ts);
  }

  // forward equations--mapping lat,long to x,y
  // -----------------------------------------------------------------
  function forward$g(p) {

    var lon = p.x;
    var lat = p.y;

    var dlon = adjust_lon(lon - this.long0);
    var dlat = adjust_lat(lat - this.lat0);
    p.x = this.x0 + (this.a * dlon * this.rc);
    p.y = this.y0 + (this.a * dlat);
    return p;
  }

  // inverse equations--mapping x,y to lat/long
  // -----------------------------------------------------------------
  function inverse$g(p) {

    var x = p.x;
    var y = p.y;

    p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));
    p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));
    return p;
  }

  var names$i = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
  var eqc = {
    init: init$h,
    forward: forward$g,
    inverse: inverse$g,
    names: names$i
  };

  var MAX_ITER$2 = 20;

  function init$i() {
    /* Place parameters in static storage for common use
        -------------------------------------------------*/
    this.temp = this.b / this.a;
    this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
    this.e = Math.sqrt(this.es);
    this.e0 = e0fn(this.es);
    this.e1 = e1fn(this.es);
    this.e2 = e2fn(this.es);
    this.e3 = e3fn(this.es);
    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
  }

  /* Polyconic forward equations--mapping lat,long to x,y
      ---------------------------------------------------*/
  function forward$h(p) {
    var lon = p.x;
    var lat = p.y;
    var x, y, el;
    var dlon = adjust_lon(lon - this.long0);
    el = dlon * Math.sin(lat);
    if (this.sphere) {
      if (Math.abs(lat) <= EPSLN) {
        x = this.a * dlon;
        y = -1 * this.a * this.lat0;
      }
      else {
        x = this.a * Math.sin(el) / Math.tan(lat);
        y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
      }
    }
    else {
      if (Math.abs(lat) <= EPSLN) {
        x = this.a * dlon;
        y = -1 * this.ml0;
      }
      else {
        var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
        x = nl * Math.sin(el);
        y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
      }

    }
    p.x = x + this.x0;
    p.y = y + this.y0;
    return p;
  }

  /* Inverse equations
    -----------------*/
  function inverse$h(p) {
    var lon, lat, x, y, i;
    var al, bl;
    var phi, dphi;
    x = p.x - this.x0;
    y = p.y - this.y0;

    if (this.sphere) {
      if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
        lon = adjust_lon(x / this.a + this.long0);
        lat = 0;
      }
      else {
        al = this.lat0 + y / this.a;
        bl = x * x / this.a / this.a + al * al;
        phi = al;
        var tanphi;
        for (i = MAX_ITER$2; i; --i) {
          tanphi = Math.tan(phi);
          dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
          phi += dphi;
          if (Math.abs(dphi) <= EPSLN) {
            lat = phi;
            break;
          }
        }
        lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));
      }
    }
    else {
      if (Math.abs(y + this.ml0) <= EPSLN) {
        lat = 0;
        lon = adjust_lon(this.long0 + x / this.a);
      }
      else {

        al = (this.ml0 + y) / this.a;
        bl = x * x / this.a / this.a + al * al;
        phi = al;
        var cl, mln, mlnp, ma;
        var con;
        for (i = MAX_ITER$2; i; --i) {
          con = this.e * Math.sin(phi);
          cl = Math.sqrt(1 - con * con) * Math.tan(phi);
          mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
          mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
          ma = mln / this.a;
          dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
          phi -= dphi;
          if (Math.abs(dphi) <= EPSLN) {
            lat = phi;
            break;
          }
        }

        //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
        cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
        lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
      }
    }

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$j = ["Polyconic", "poly"];
  var poly = {
    init: init$i,
    forward: forward$h,
    inverse: inverse$h,
    names: names$j
  };

  function init$j() {
    this.A = [];
    this.A[1] = 0.6399175073;
    this.A[2] = -0.1358797613;
    this.A[3] = 0.063294409;
    this.A[4] = -0.02526853;
    this.A[5] = 0.0117879;
    this.A[6] = -0.0055161;
    this.A[7] = 0.0026906;
    this.A[8] = -0.001333;
    this.A[9] = 0.00067;
    this.A[10] = -0.00034;

    this.B_re = [];
    this.B_im = [];
    this.B_re[1] = 0.7557853228;
    this.B_im[1] = 0;
    this.B_re[2] = 0.249204646;
    this.B_im[2] = 0.003371507;
    this.B_re[3] = -0.001541739;
    this.B_im[3] = 0.041058560;
    this.B_re[4] = -0.10162907;
    this.B_im[4] = 0.01727609;
    this.B_re[5] = -0.26623489;
    this.B_im[5] = -0.36249218;
    this.B_re[6] = -0.6870983;
    this.B_im[6] = -1.1651967;

    this.C_re = [];
    this.C_im = [];
    this.C_re[1] = 1.3231270439;
    this.C_im[1] = 0;
    this.C_re[2] = -0.577245789;
    this.C_im[2] = -0.007809598;
    this.C_re[3] = 0.508307513;
    this.C_im[3] = -0.112208952;
    this.C_re[4] = -0.15094762;
    this.C_im[4] = 0.18200602;
    this.C_re[5] = 1.01418179;
    this.C_im[5] = 1.64497696;
    this.C_re[6] = 1.9660549;
    this.C_im[6] = 2.5127645;

    this.D = [];
    this.D[1] = 1.5627014243;
    this.D[2] = 0.5185406398;
    this.D[3] = -0.03333098;
    this.D[4] = -0.1052906;
    this.D[5] = -0.0368594;
    this.D[6] = 0.007317;
    this.D[7] = 0.01220;
    this.D[8] = 0.00394;
    this.D[9] = -0.0013;
  }

  /**
      New Zealand Map Grid Forward  - long/lat to x/y
      long/lat in radians
    */
  function forward$i(p) {
    var n;
    var lon = p.x;
    var lat = p.y;

    var delta_lat = lat - this.lat0;
    var delta_lon = lon - this.long0;

    // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
    // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
    var d_phi = delta_lat / SEC_TO_RAD * 1E-5;
    var d_lambda = delta_lon;
    var d_phi_n = 1; // d_phi^0

    var d_psi = 0;
    for (n = 1; n <= 10; n++) {
      d_phi_n = d_phi_n * d_phi;
      d_psi = d_psi + this.A[n] * d_phi_n;
    }

    // 2. Calculate theta
    var th_re = d_psi;
    var th_im = d_lambda;

    // 3. Calculate z
    var th_n_re = 1;
    var th_n_im = 0; // theta^0
    var th_n_re1;
    var th_n_im1;

    var z_re = 0;
    var z_im = 0;
    for (n = 1; n <= 6; n++) {
      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
      th_n_re = th_n_re1;
      th_n_im = th_n_im1;
      z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
      z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
    }

    // 4. Calculate easting and northing
    p.x = (z_im * this.a) + this.x0;
    p.y = (z_re * this.a) + this.y0;

    return p;
  }

  /**
      New Zealand Map Grid Inverse  -  x/y to long/lat
    */
  function inverse$i(p) {
    var n;
    var x = p.x;
    var y = p.y;

    var delta_x = x - this.x0;
    var delta_y = y - this.y0;

    // 1. Calculate z
    var z_re = delta_y / this.a;
    var z_im = delta_x / this.a;

    // 2a. Calculate theta - first approximation gives km accuracy
    var z_n_re = 1;
    var z_n_im = 0; // z^0
    var z_n_re1;
    var z_n_im1;

    var th_re = 0;
    var th_im = 0;
    for (n = 1; n <= 6; n++) {
      z_n_re1 = z_n_re * z_re - z_n_im * z_im;
      z_n_im1 = z_n_im * z_re + z_n_re * z_im;
      z_n_re = z_n_re1;
      z_n_im = z_n_im1;
      th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
      th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
    }

    // 2b. Iterate to refine the accuracy of the calculation
    //        0 iterations gives km accuracy
    //        1 iteration gives m accuracy -- good enough for most mapping applications
    //        2 iterations bives mm accuracy
    for (var i = 0; i < this.iterations; i++) {
      var th_n_re = th_re;
      var th_n_im = th_im;
      var th_n_re1;
      var th_n_im1;

      var num_re = z_re;
      var num_im = z_im;
      for (n = 2; n <= 6; n++) {
        th_n_re1 = th_n_re * th_re - th_n_im * th_im;
        th_n_im1 = th_n_im * th_re + th_n_re * th_im;
        th_n_re = th_n_re1;
        th_n_im = th_n_im1;
        num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
        num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
      }

      th_n_re = 1;
      th_n_im = 0;
      var den_re = this.B_re[1];
      var den_im = this.B_im[1];
      for (n = 2; n <= 6; n++) {
        th_n_re1 = th_n_re * th_re - th_n_im * th_im;
        th_n_im1 = th_n_im * th_re + th_n_re * th_im;
        th_n_re = th_n_re1;
        th_n_im = th_n_im1;
        den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
        den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
      }

      // Complex division
      var den2 = den_re * den_re + den_im * den_im;
      th_re = (num_re * den_re + num_im * den_im) / den2;
      th_im = (num_im * den_re - num_re * den_im) / den2;
    }

    // 3. Calculate d_phi              ...                                    // and d_lambda
    var d_psi = th_re;
    var d_lambda = th_im;
    var d_psi_n = 1; // d_psi^0

    var d_phi = 0;
    for (n = 1; n <= 9; n++) {
      d_psi_n = d_psi_n * d_psi;
      d_phi = d_phi + this.D[n] * d_psi_n;
    }

    // 4. Calculate latitude and longitude
    // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
    var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);
    var lon = this.long0 + d_lambda;

    p.x = lon;
    p.y = lat;

    return p;
  }

  var names$k = ["New_Zealand_Map_Grid", "nzmg"];
  var nzmg = {
    init: init$j,
    forward: forward$i,
    inverse: inverse$i,
    names: names$k
  };

  /*
    reference
      "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
      The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
    */


  /* Initialize the Miller Cylindrical projection
    -------------------------------------------*/
  function init$k() {
    //no-op
  }

  /* Miller Cylindrical forward equations--mapping lat,long to x,y
      ------------------------------------------------------------*/
  function forward$j(p) {
    var lon = p.x;
    var lat = p.y;
    /* Forward equations
        -----------------*/
    var dlon = adjust_lon(lon - this.long0);
    var x = this.x0 + this.a * dlon;
    var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;

    p.x = x;
    p.y = y;
    return p;
  }

  /* Miller Cylindrical inverse equations--mapping x,y to lat/long
      ------------------------------------------------------------*/
  function inverse$j(p) {
    p.x -= this.x0;
    p.y -= this.y0;

    var lon = adjust_lon(this.long0 + p.x / this.a);
    var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$l = ["Miller_Cylindrical", "mill"];
  var mill = {
    init: init$k,
    forward: forward$j,
    inverse: inverse$j,
    names: names$l
  };

  var MAX_ITER$3 = 20;


  function init$l() {
    /* Place parameters in static storage for common use
      -------------------------------------------------*/


    if (!this.sphere) {
      this.en = pj_enfn(this.es);
    }
    else {
      this.n = 1;
      this.m = 0;
      this.es = 0;
      this.C_y = Math.sqrt((this.m + 1) / this.n);
      this.C_x = this.C_y / (this.m + 1);
    }

  }

  /* Sinusoidal forward equations--mapping lat,long to x,y
    -----------------------------------------------------*/
  function forward$k(p) {
    var x, y;
    var lon = p.x;
    var lat = p.y;
    /* Forward equations
      -----------------*/
    lon = adjust_lon(lon - this.long0);

    if (this.sphere) {
      if (!this.m) {
        lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
      }
      else {
        var k = this.n * Math.sin(lat);
        for (var i = MAX_ITER$3; i; --i) {
          var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
          lat -= V;
          if (Math.abs(V) < EPSLN) {
            break;
          }
        }
      }
      x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
      y = this.a * this.C_y * lat;

    }
    else {

      var s = Math.sin(lat);
      var c = Math.cos(lat);
      y = this.a * pj_mlfn(lat, s, c, this.en);
      x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
    }

    p.x = x;
    p.y = y;
    return p;
  }

  function inverse$k(p) {
    var lat, temp, lon, s;

    p.x -= this.x0;
    lon = p.x / this.a;
    p.y -= this.y0;
    lat = p.y / this.a;

    if (this.sphere) {
      lat /= this.C_y;
      lon = lon / (this.C_x * (this.m + Math.cos(lat)));
      if (this.m) {
        lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
      }
      else if (this.n !== 1) {
        lat = asinz(Math.sin(lat) / this.n);
      }
      lon = adjust_lon(lon + this.long0);
      lat = adjust_lat(lat);
    }
    else {
      lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
      s = Math.abs(lat);
      if (s < HALF_PI) {
        s = Math.sin(lat);
        temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
        //temp = this.long0 + p.x / (this.a * Math.cos(lat));
        lon = adjust_lon(temp);
      }
      else if ((s - EPSLN) < HALF_PI) {
        lon = this.long0;
      }
    }
    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$m = ["Sinusoidal", "sinu"];
  var sinu = {
    init: init$l,
    forward: forward$k,
    inverse: inverse$k,
    names: names$m
  };

  function init$m() {}
  /* Mollweide forward equations--mapping lat,long to x,y
      ----------------------------------------------------*/
  function forward$l(p) {

    /* Forward equations
        -----------------*/
    var lon = p.x;
    var lat = p.y;

    var delta_lon = adjust_lon(lon - this.long0);
    var theta = lat;
    var con = Math.PI * Math.sin(lat);

    /* Iterate using the Newton-Raphson method to find theta
        -----------------------------------------------------*/
    while (true) {
      var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
      theta += delta_theta;
      if (Math.abs(delta_theta) < EPSLN) {
        break;
      }
    }
    theta /= 2;

    /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
         this is done here because of precision problems with "cos(theta)"
         --------------------------------------------------------------------------*/
    if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
      delta_lon = 0;
    }
    var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
    var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;

    p.x = x;
    p.y = y;
    return p;
  }

  function inverse$l(p) {
    var theta;
    var arg;

    /* Inverse equations
        -----------------*/
    p.x -= this.x0;
    p.y -= this.y0;
    arg = p.y / (1.4142135623731 * this.a);

    /* Because of division by zero problems, 'arg' can not be 1.  Therefore
         a number very close to one is used instead.
         -------------------------------------------------------------------*/
    if (Math.abs(arg) > 0.999999999999) {
      arg = 0.999999999999;
    }
    theta = Math.asin(arg);
    var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));
    if (lon < (-Math.PI)) {
      lon = -Math.PI;
    }
    if (lon > Math.PI) {
      lon = Math.PI;
    }
    arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
    if (Math.abs(arg) > 1) {
      arg = 1;
    }
    var lat = Math.asin(arg);

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$n = ["Mollweide", "moll"];
  var moll = {
    init: init$m,
    forward: forward$l,
    inverse: inverse$l,
    names: names$n
  };

  function init$n() {

    /* Place parameters in static storage for common use
        -------------------------------------------------*/
    // Standard Parallels cannot be equal and on opposite sides of the equator
    if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
      return;
    }
    this.lat2 = this.lat2 || this.lat1;
    this.temp = this.b / this.a;
    this.es = 1 - Math.pow(this.temp, 2);
    this.e = Math.sqrt(this.es);
    this.e0 = e0fn(this.es);
    this.e1 = e1fn(this.es);
    this.e2 = e2fn(this.es);
    this.e3 = e3fn(this.es);

    this.sinphi = Math.sin(this.lat1);
    this.cosphi = Math.cos(this.lat1);

    this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
    this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);

    if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
      this.ns = this.sinphi;
    }
    else {
      this.sinphi = Math.sin(this.lat2);
      this.cosphi = Math.cos(this.lat2);
      this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
      this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
      this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
    }
    this.g = this.ml1 + this.ms1 / this.ns;
    this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
    this.rh = this.a * (this.g - this.ml0);
  }

  /* Equidistant Conic forward equations--mapping lat,long to x,y
    -----------------------------------------------------------*/
  function forward$m(p) {
    var lon = p.x;
    var lat = p.y;
    var rh1;

    /* Forward equations
        -----------------*/
    if (this.sphere) {
      rh1 = this.a * (this.g - lat);
    }
    else {
      var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
      rh1 = this.a * (this.g - ml);
    }
    var theta = this.ns * adjust_lon(lon - this.long0);
    var x = this.x0 + rh1 * Math.sin(theta);
    var y = this.y0 + this.rh - rh1 * Math.cos(theta);
    p.x = x;
    p.y = y;
    return p;
  }

  /* Inverse equations
    -----------------*/
  function inverse$m(p) {
    p.x -= this.x0;
    p.y = this.rh - p.y + this.y0;
    var con, rh1, lat, lon;
    if (this.ns >= 0) {
      rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
      con = 1;
    }
    else {
      rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
      con = -1;
    }
    var theta = 0;
    if (rh1 !== 0) {
      theta = Math.atan2(con * p.x, con * p.y);
    }

    if (this.sphere) {
      lon = adjust_lon(this.long0 + theta / this.ns);
      lat = adjust_lat(this.g - rh1 / this.a);
      p.x = lon;
      p.y = lat;
      return p;
    }
    else {
      var ml = this.g - rh1 / this.a;
      lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
      lon = adjust_lon(this.long0 + theta / this.ns);
      p.x = lon;
      p.y = lat;
      return p;
    }

  }

  var names$o = ["Equidistant_Conic", "eqdc"];
  var eqdc = {
    init: init$n,
    forward: forward$m,
    inverse: inverse$m,
    names: names$o
  };

  /* Initialize the Van Der Grinten projection
    ----------------------------------------*/
  function init$o() {
    //this.R = 6370997; //Radius of earth
    this.R = this.a;
  }

  function forward$n(p) {

    var lon = p.x;
    var lat = p.y;

    /* Forward equations
      -----------------*/
    var dlon = adjust_lon(lon - this.long0);
    var x, y;

    if (Math.abs(lat) <= EPSLN) {
      x = this.x0 + this.R * dlon;
      y = this.y0;
    }
    var theta = asinz(2 * Math.abs(lat / Math.PI));
    if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {
      x = this.x0;
      if (lat >= 0) {
        y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
      }
      else {
        y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
      }
      //  return(OK);
    }
    var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));
    var asq = al * al;
    var sinth = Math.sin(theta);
    var costh = Math.cos(theta);

    var g = costh / (sinth + costh - 1);
    var gsq = g * g;
    var m = g * (2 / sinth - 1);
    var msq = m * m;
    var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
    if (dlon < 0) {
      con = -con;
    }
    x = this.x0 + con;
    //con = Math.abs(con / (Math.PI * this.R));
    var q = asq + g;
    con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
    if (lat >= 0) {
      //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
      y = this.y0 + con;
    }
    else {
      //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
      y = this.y0 - con;
    }
    p.x = x;
    p.y = y;
    return p;
  }

  /* Van Der Grinten inverse equations--mapping x,y to lat/long
    ---------------------------------------------------------*/
  function inverse$n(p) {
    var lon, lat;
    var xx, yy, xys, c1, c2, c3;
    var a1;
    var m1;
    var con;
    var th1;
    var d;

    /* inverse equations
      -----------------*/
    p.x -= this.x0;
    p.y -= this.y0;
    con = Math.PI * this.R;
    xx = p.x / con;
    yy = p.y / con;
    xys = xx * xx + yy * yy;
    c1 = -Math.abs(yy) * (1 + xys);
    c2 = c1 - 2 * yy * yy + xx * xx;
    c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
    d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
    a1 = (c1 - c2 * c2 / 3 / c3) / c3;
    m1 = 2 * Math.sqrt(-a1 / 3);
    con = ((3 * d) / a1) / m1;
    if (Math.abs(con) > 1) {
      if (con >= 0) {
        con = 1;
      }
      else {
        con = -1;
      }
    }
    th1 = Math.acos(con) / 3;
    if (p.y >= 0) {
      lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
    }
    else {
      lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
    }

    if (Math.abs(xx) < EPSLN) {
      lon = this.long0;
    }
    else {
      lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
    }

    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$p = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
  var vandg = {
    init: init$o,
    forward: forward$n,
    inverse: inverse$n,
    names: names$p
  };

  function init$p() {
    this.sin_p12 = Math.sin(this.lat0);
    this.cos_p12 = Math.cos(this.lat0);
  }

  function forward$o(p) {
    var lon = p.x;
    var lat = p.y;
    var sinphi = Math.sin(p.y);
    var cosphi = Math.cos(p.y);
    var dlon = adjust_lon(lon - this.long0);
    var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
    if (this.sphere) {
      if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
        //North Pole case
        p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
        p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
        return p;
      }
      else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
        //South Pole case
        p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
        p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
        return p;
      }
      else {
        //default case
        cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
        c = Math.acos(cos_c);
        kp = c ? c / Math.sin(c) : 1;
        p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
        p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
        return p;
      }
    }
    else {
      e0 = e0fn(this.es);
      e1 = e1fn(this.es);
      e2 = e2fn(this.es);
      e3 = e3fn(this.es);
      if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
        //North Pole case
        Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
        Ml = this.a * mlfn(e0, e1, e2, e3, lat);
        p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
        p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
        return p;
      }
      else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
        //South Pole case
        Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
        Ml = this.a * mlfn(e0, e1, e2, e3, lat);
        p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
        p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
        return p;
      }
      else {
        //Default case
        tanphi = sinphi / cosphi;
        Nl1 = gN(this.a, this.e, this.sin_p12);
        Nl = gN(this.a, this.e, sinphi);
        psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
        Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
        if (Az === 0) {
          s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
        }
        else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
          s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
        }
        else {
          s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
        }
        G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
        H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
        GH = G * H;
        Hs = H * H;
        s2 = s * s;
        s3 = s2 * s;
        s4 = s3 * s;
        s5 = s4 * s;
        c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
        p.x = this.x0 + c * Math.sin(Az);
        p.y = this.y0 + c * Math.cos(Az);
        return p;
      }
    }


  }

  function inverse$o(p) {
    p.x -= this.x0;
    p.y -= this.y0;
    var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F, sinpsi;
    if (this.sphere) {
      rh = Math.sqrt(p.x * p.x + p.y * p.y);
      if (rh > (2 * HALF_PI * this.a)) {
        return;
      }
      z = rh / this.a;

      sinz = Math.sin(z);
      cosz = Math.cos(z);

      lon = this.long0;
      if (Math.abs(rh) <= EPSLN) {
        lat = this.lat0;
      }
      else {
        lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);
        con = Math.abs(this.lat0) - HALF_PI;
        if (Math.abs(con) <= EPSLN) {
          if (this.lat0 >= 0) {
            lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
          }
          else {
            lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
          }
        }
        else {
          /*con = cosz - this.sin_p12 * Math.sin(lat);
          if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
            //no-op, just keep the lon value as is
          } else {
            var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
            lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
          }*/
          lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
        }
      }

      p.x = lon;
      p.y = lat;
      return p;
    }
    else {
      e0 = e0fn(this.es);
      e1 = e1fn(this.es);
      e2 = e2fn(this.es);
      e3 = e3fn(this.es);
      if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
        //North pole case
        Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
        rh = Math.sqrt(p.x * p.x + p.y * p.y);
        M = Mlp - rh;
        lat = imlfn(M / this.a, e0, e1, e2, e3);
        lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
        p.x = lon;
        p.y = lat;
        return p;
      }
      else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
        //South pole case
        Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
        rh = Math.sqrt(p.x * p.x + p.y * p.y);
        M = rh - Mlp;

        lat = imlfn(M / this.a, e0, e1, e2, e3);
        lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
        p.x = lon;
        p.y = lat;
        return p;
      }
      else {
        //default case
        rh = Math.sqrt(p.x * p.x + p.y * p.y);
        Az = Math.atan2(p.x, p.y);
        N1 = gN(this.a, this.e, this.sin_p12);
        cosAz = Math.cos(Az);
        tmp = this.e * this.cos_p12 * cosAz;
        A = -tmp * tmp / (1 - this.es);
        B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
        D = rh / N1;
        Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
        F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
        psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
        lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
        sinpsi = Math.sin(psi);
        lat = Math.atan2((sinpsi - this.es * F * this.sin_p12) * Math.tan(psi), sinpsi * (1 - this.es));
        p.x = lon;
        p.y = lat;
        return p;
      }
    }

  }

  var names$q = ["Azimuthal_Equidistant", "aeqd"];
  var aeqd = {
    init: init$p,
    forward: forward$o,
    inverse: inverse$o,
    names: names$q
  };

  function init$q() {
    //double temp;      /* temporary variable    */

    /* Place parameters in static storage for common use
        -------------------------------------------------*/
    this.sin_p14 = Math.sin(this.lat0);
    this.cos_p14 = Math.cos(this.lat0);
  }

  /* Orthographic forward equations--mapping lat,long to x,y
      ---------------------------------------------------*/
  function forward$p(p) {
    var sinphi, cosphi; /* sin and cos value        */
    var dlon; /* delta longitude value      */
    var coslon; /* cos of longitude        */
    var ksp; /* scale factor          */
    var g, x, y;
    var lon = p.x;
    var lat = p.y;
    /* Forward equations
        -----------------*/
    dlon = adjust_lon(lon - this.long0);

    sinphi = Math.sin(lat);
    cosphi = Math.cos(lat);

    coslon = Math.cos(dlon);
    g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
    ksp = 1;
    if ((g > 0) || (Math.abs(g) <= EPSLN)) {
      x = this.a * ksp * cosphi * Math.sin(dlon);
      y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
    }
    p.x = x;
    p.y = y;
    return p;
  }

  function inverse$p(p) {
    var rh; /* height above ellipsoid      */
    var z; /* angle          */
    var sinz, cosz; /* sin of z and cos of z      */
    var con;
    var lon, lat;
    /* Inverse equations
        -----------------*/
    p.x -= this.x0;
    p.y -= this.y0;
    rh = Math.sqrt(p.x * p.x + p.y * p.y);
    z = asinz(rh / this.a);

    sinz = Math.sin(z);
    cosz = Math.cos(z);

    lon = this.long0;
    if (Math.abs(rh) <= EPSLN) {
      lat = this.lat0;
      p.x = lon;
      p.y = lat;
      return p;
    }
    lat = asinz(cosz * this.sin_p14 + (p.y * sinz * this.cos_p14) / rh);
    con = Math.abs(this.lat0) - HALF_PI;
    if (Math.abs(con) <= EPSLN) {
      if (this.lat0 >= 0) {
        lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
      }
      else {
        lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
      }
      p.x = lon;
      p.y = lat;
      return p;
    }
    lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz), rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
    p.x = lon;
    p.y = lat;
    return p;
  }

  var names$r = ["ortho"];
  var ortho = {
    init: init$q,
    forward: forward$p,
    inverse: inverse$p,
    names: names$r
  };

  // QSC projection rewritten from the original PROJ4

  /* constants */
  var FACE_ENUM = {
      FRONT: 1,
      RIGHT: 2,
      BACK: 3,
      LEFT: 4,
      TOP: 5,
      BOTTOM: 6
  };

  var AREA_ENUM = {
      AREA_0: 1,
      AREA_1: 2,
      AREA_2: 3,
      AREA_3: 4
  };

  function init$r() {

    this.x0 = this.x0 || 0;
    this.y0 = this.y0 || 0;
    this.lat0 = this.lat0 || 0;
    this.long0 = this.long0 || 0;
    this.lat_ts = this.lat_ts || 0;
    this.title = this.title || "Quadrilateralized Spherical Cube";

    /* Determine the cube face from the center of projection. */
    if (this.lat0 >= HALF_PI - FORTPI / 2.0) {
      this.face = FACE_ENUM.TOP;
    } else if (this.lat0 <= -(HALF_PI - FORTPI / 2.0)) {
      this.face = FACE_ENUM.BOTTOM;
    } else if (Math.abs(this.long0) <= FORTPI) {
      this.face = FACE_ENUM.FRONT;
    } else if (Math.abs(this.long0) <= HALF_PI + FORTPI) {
      this.face = this.long0 > 0.0 ? FACE_ENUM.RIGHT : FACE_ENUM.LEFT;
    } else {
      this.face = FACE_ENUM.BACK;
    }

    /* Fill in useful values for the ellipsoid <-> sphere shift
     * described in [LK12]. */
    if (this.es !== 0) {
      this.one_minus_f = 1 - (this.a - this.b) / this.a;
      this.one_minus_f_squared = this.one_minus_f * this.one_minus_f;
    }
  }

  // QSC forward equations--mapping lat,long to x,y
  // -----------------------------------------------------------------
  function forward$q(p) {
    var xy = {x: 0, y: 0};
    var lat, lon;
    var theta, phi;
    var t, mu;
    /* nu; */
    var area = {value: 0};

    // move lon according to projection's lon
    p.x -= this.long0;

    /* Convert the geodetic latitude to a geocentric latitude.
     * This corresponds to the shift from the ellipsoid to the sphere
     * described in [LK12]. */
    if (this.es !== 0) {//if (P->es != 0) {
      lat = Math.atan(this.one_minus_f_squared * Math.tan(p.y));
    } else {
      lat = p.y;
    }

    /* Convert the input lat, lon into theta, phi as used by QSC.
     * This depends on the cube face and the area on it.
     * For the top and bottom face, we can compute theta and phi
     * directly from phi, lam. For the other faces, we must use
     * unit sphere cartesian coordinates as an intermediate step. */
    lon = p.x; //lon = lp.lam;
    if (this.face === FACE_ENUM.TOP) {
      phi = HALF_PI - lat;
      if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
        area.value = AREA_ENUM.AREA_0;
        theta = lon - HALF_PI;
      } else if (lon > HALF_PI + FORTPI || lon <= -(HALF_PI + FORTPI)) {
        area.value = AREA_ENUM.AREA_1;
        theta = (lon > 0.0 ? lon - SPI : lon + SPI);
      } else if (lon > -(HALF_PI + FORTPI) && lon <= -FORTPI) {
        area.value = AREA_ENUM.AREA_2;
        theta = lon + HALF_PI;
      } else {
        area.value = AREA_ENUM.AREA_3;
        theta = lon;
      }
    } else if (this.face === FACE_ENUM.BOTTOM) {
      phi = HALF_PI + lat;
      if (lon >= FORTPI && lon <= HALF_PI + FORTPI) {
        area.value = AREA_ENUM.AREA_0;
        theta = -lon + HALF_PI;
      } else if (lon < FORTPI && lon >= -FORTPI) {
        area.value = AREA_ENUM.AREA_1;
        theta = -lon;
      } else if (lon < -FORTPI && lon >= -(HALF_PI + FORTPI)) {
        area.value = AREA_ENUM.AREA_2;
        theta = -lon - HALF_PI;
      } else {
        area.value = AREA_ENUM.AREA_3;
        theta = (lon > 0.0 ? -lon + SPI : -lon - SPI);
      }
    } else {
      var q, r, s;
      var sinlat, coslat;
      var sinlon, coslon;

      if (this.face === FACE_ENUM.RIGHT) {
        lon = qsc_shift_lon_origin(lon, +HALF_PI);
      } else if (this.face === FACE_ENUM.BACK) {
        lon = qsc_shift_lon_origin(lon, +SPI);
      } else if (this.face === FACE_ENUM.LEFT) {
        lon = qsc_shift_lon_origin(lon, -HALF_PI);
      }
      sinlat = Math.sin(lat);
      coslat = Math.cos(lat);
      sinlon = Math.sin(lon);
      coslon = Math.cos(lon);
      q = coslat * coslon;
      r = coslat * sinlon;
      s = sinlat;

      if (this.face === FACE_ENUM.FRONT) {
        phi = Math.acos(q);
        theta = qsc_fwd_equat_face_theta(phi, s, r, area);
      } else if (this.face === FACE_ENUM.RIGHT) {
        phi = Math.acos(r);
        theta = qsc_fwd_equat_face_theta(phi, s, -q, area);
      } else if (this.face === FACE_ENUM.BACK) {
        phi = Math.acos(-q);
        theta = qsc_fwd_equat_face_theta(phi, s, -r, area);
      } else if (this.face === FACE_ENUM.LEFT) {
        phi = Math.acos(-r);
        theta = qsc_fwd_equat_face_theta(phi, s, q, area);
      } else {
        /* Impossible */
        phi = theta = 0;
        area.value = AREA_ENUM.AREA_0;
      }
    }

    /* Compute mu and nu for the area of definition.
     * For mu, see Eq. (3-21) in [OL76], but note the typos:
     * compare with Eq. (3-14). For nu, see Eq. (3-38). */
    mu = Math.atan((12 / SPI) * (theta + Math.acos(Math.sin(theta) * Math.cos(FORTPI)) - HALF_PI));
    t = Math.sqrt((1 - Math.cos(phi)) / (Math.cos(mu) * Math.cos(mu)) / (1 - Math.cos(Math.atan(1 / Math.cos(theta)))));

    /* Apply the result to the real area. */
    if (area.value === AREA_ENUM.AREA_1) {
      mu += HALF_PI;
    } else if (area.value === AREA_ENUM.AREA_2) {
      mu += SPI;
    } else if (area.value === AREA_ENUM.AREA_3) {
      mu += 1.5 * SPI;
    }

    /* Now compute x, y from mu and nu */
    xy.x = t * Math.cos(mu);
    xy.y = t * Math.sin(mu);
    xy.x = xy.x * this.a + this.x0;
    xy.y = xy.y * this.a + this.y0;

    p.x = xy.x;
    p.y = xy.y;
    return p;
  }

  // QSC inverse equations--mapping x,y to lat/long
  // -----------------------------------------------------------------
  function inverse$q(p) {
    var lp = {lam: 0, phi: 0};
    var mu, nu, cosmu, tannu;
    var tantheta, theta, cosphi, phi;
    var t;
    var area = {value: 0};

    /* de-offset */
    p.x = (p.x - this.x0) / this.a;
    p.y = (p.y - this.y0) / this.a;

    /* Convert the input x, y to the mu and nu angles as used by QSC.
     * This depends on the area of the cube face. */
    nu = Math.atan(Math.sqrt(p.x * p.x + p.y * p.y));
    mu = Math.atan2(p.y, p.x);
    if (p.x >= 0.0 && p.x >= Math.abs(p.y)) {
      area.value = AREA_ENUM.AREA_0;
    } else if (p.y >= 0.0 && p.y >= Math.abs(p.x)) {
      area.value = AREA_ENUM.AREA_1;
      mu -= HALF_PI;
    } else if (p.x < 0.0 && -p.x >= Math.abs(p.y)) {
      area.value = AREA_ENUM.AREA_2;
      mu = (mu < 0.0 ? mu + SPI : mu - SPI);
    } else {
      area.value = AREA_ENUM.AREA_3;
      mu += HALF_PI;
    }

    /* Compute phi and theta for the area of definition.
     * The inverse projection is not described in the original paper, but some
     * good hints can be found here (as of 2011-12-14):
     * http://fits.gsfc.nasa.gov/fitsbits/saf.93/saf.9302
     * (search for "Message-Id: <9302181759.AA25477 at fits.cv.nrao.edu>") */
    t = (SPI / 12) * Math.tan(mu);
    tantheta = Math.sin(t) / (Math.cos(t) - (1 / Math.sqrt(2)));
    theta = Math.atan(tantheta);
    cosmu = Math.cos(mu);
    tannu = Math.tan(nu);
    cosphi = 1 - cosmu * cosmu * tannu * tannu * (1 - Math.cos(Math.atan(1 / Math.cos(theta))));
    if (cosphi < -1) {
      cosphi = -1;
    } else if (cosphi > +1) {
      cosphi = +1;
    }

    /* Apply the result to the real area on the cube face.
     * For the top and bottom face, we can compute phi and lam directly.
     * For the other faces, we must use unit sphere cartesian coordinates
     * as an intermediate step. */
    if (this.face === FACE_ENUM.TOP) {
      phi = Math.acos(cosphi);
      lp.phi = HALF_PI - phi;
      if (area.value === AREA_ENUM.AREA_0) {
        lp.lam = theta + HALF_PI;
      } else if (area.value === AREA_ENUM.AREA_1) {
        lp.lam = (theta < 0.0 ? theta + SPI : theta - SPI);
      } else if (area.value === AREA_ENUM.AREA_2) {
        lp.lam = theta - HALF_PI;
      } else /* area.value == AREA_ENUM.AREA_3 */ {
        lp.lam = theta;
      }
    } else if (this.face === FACE_ENUM.BOTTOM) {
      phi = Math.acos(cosphi);
      lp.phi = phi - HALF_PI;
      if (area.value === AREA_ENUM.AREA_0) {
        lp.lam = -theta + HALF_PI;
      } else if (area.value === AREA_ENUM.AREA_1) {
        lp.lam = -theta;
      } else if (area.value === AREA_ENUM.AREA_2) {
        lp.lam = -theta - HALF_PI;
      } else /* area.value == AREA_ENUM.AREA_3 */ {
        lp.lam = (theta < 0.0 ? -theta - SPI : -theta + SPI);
      }
    } else {
      /* Compute phi and lam via cartesian unit sphere coordinates. */
      var q, r, s;
      q = cosphi;
      t = q * q;
      if (t >= 1) {
        s = 0;
      } else {
        s = Math.sqrt(1 - t) * Math.sin(theta);
      }
      t += s * s;
      if (t >= 1) {
        r = 0;
      } else {
        r = Math.sqrt(1 - t);
      }
      /* Rotate q,r,s into the correct area. */
      if (area.value === AREA_ENUM.AREA_1) {
        t = r;
        r = -s;
        s = t;
      } else if (area.value === AREA_ENUM.AREA_2) {
        r = -r;
        s = -s;
      } else if (area.value === AREA_ENUM.AREA_3) {
        t = r;
        r = s;
        s = -t;
      }
      /* Rotate q,r,s into the correct cube face. */
      if (this.face === FACE_ENUM.RIGHT) {
        t = q;
        q = -r;
        r = t;
      } else if (this.face === FACE_ENUM.BACK) {
        q = -q;
        r = -r;
      } else if (this.face === FACE_ENUM.LEFT) {
        t = q;
        q = r;
        r = -t;
      }
      /* Now compute phi and lam from the unit sphere coordinates. */
      lp.phi = Math.acos(-s) - HALF_PI;
      lp.lam = Math.atan2(r, q);
      if (this.face === FACE_ENUM.RIGHT) {
        lp.lam = qsc_shift_lon_origin(lp.lam, -HALF_PI);
      } else if (this.face === FACE_ENUM.BACK) {
        lp.lam = qsc_shift_lon_origin(lp.lam, -SPI);
      } else if (this.face === FACE_ENUM.LEFT) {
        lp.lam = qsc_shift_lon_origin(lp.lam, +HALF_PI);
      }
    }

    /* Apply the shift from the sphere to the ellipsoid as described
     * in [LK12]. */
    if (this.es !== 0) {
      var invert_sign;
      var tanphi, xa;
      invert_sign = (lp.phi < 0 ? 1 : 0);
      tanphi = Math.tan(lp.phi);
      xa = this.b / Math.sqrt(tanphi * tanphi + this.one_minus_f_squared);
      lp.phi = Math.atan(Math.sqrt(this.a * this.a - xa * xa) / (this.one_minus_f * xa));
      if (invert_sign) {
        lp.phi = -lp.phi;
      }
    }

    lp.lam += this.long0;
    p.x = lp.lam;
    p.y = lp.phi;
    return p;
  }

  /* Helper function for forward projection: compute the theta angle
   * and determine the area number. */
  function qsc_fwd_equat_face_theta(phi, y, x, area) {
    var theta;
    if (phi < EPSLN) {
      area.value = AREA_ENUM.AREA_0;
      theta = 0.0;
    } else {
      theta = Math.atan2(y, x);
      if (Math.abs(theta) <= FORTPI) {
        area.value = AREA_ENUM.AREA_0;
      } else if (theta > FORTPI && theta <= HALF_PI + FORTPI) {
        area.value = AREA_ENUM.AREA_1;
        theta -= HALF_PI;
      } else if (theta > HALF_PI + FORTPI || theta <= -(HALF_PI + FORTPI)) {
        area.value = AREA_ENUM.AREA_2;
        theta = (theta >= 0.0 ? theta - SPI : theta + SPI);
      } else {
        area.value = AREA_ENUM.AREA_3;
        theta += HALF_PI;
      }
    }
    return theta;
  }

  /* Helper function: shift the longitude. */
  function qsc_shift_lon_origin(lon, offset) {
    var slon = lon + offset;
    if (slon < -SPI) {
      slon += TWO_PI;
    } else if (slon > +SPI) {
      slon -= TWO_PI;
    }
    return slon;
  }

  var names$s = ["Quadrilateralized Spherical Cube", "Quadrilateralized_Spherical_Cube", "qsc"];
  var qsc = {
    init: init$r,
    forward: forward$q,
    inverse: inverse$q,
    names: names$s
  };

  // Robinson projection

  var COEFS_X = [
      [1.0000, 2.2199e-17, -7.15515e-05, 3.1103e-06],
      [0.9986, -0.000482243, -2.4897e-05, -1.3309e-06],
      [0.9954, -0.00083103, -4.48605e-05, -9.86701e-07],
      [0.9900, -0.00135364, -5.9661e-05, 3.6777e-06],
      [0.9822, -0.00167442, -4.49547e-06, -5.72411e-06],
      [0.9730, -0.00214868, -9.03571e-05, 1.8736e-08],
      [0.9600, -0.00305085, -9.00761e-05, 1.64917e-06],
      [0.9427, -0.00382792, -6.53386e-05, -2.6154e-06],
      [0.9216, -0.00467746, -0.00010457, 4.81243e-06],
      [0.8962, -0.00536223, -3.23831e-05, -5.43432e-06],
      [0.8679, -0.00609363, -0.000113898, 3.32484e-06],
      [0.8350, -0.00698325, -6.40253e-05, 9.34959e-07],
      [0.7986, -0.00755338, -5.00009e-05, 9.35324e-07],
      [0.7597, -0.00798324, -3.5971e-05, -2.27626e-06],
      [0.7186, -0.00851367, -7.01149e-05, -8.6303e-06],
      [0.6732, -0.00986209, -0.000199569, 1.91974e-05],
      [0.6213, -0.010418, 8.83923e-05, 6.24051e-06],
      [0.5722, -0.00906601, 0.000182, 6.24051e-06],
      [0.5322, -0.00677797, 0.000275608, 6.24051e-06]
  ];

  var COEFS_Y = [
      [-5.20417e-18, 0.0124, 1.21431e-18, -8.45284e-11],
      [0.0620, 0.0124, -1.26793e-09, 4.22642e-10],
      [0.1240, 0.0124, 5.07171e-09, -1.60604e-09],
      [0.1860, 0.0123999, -1.90189e-08, 6.00152e-09],
      [0.2480, 0.0124002, 7.10039e-08, -2.24e-08],
      [0.3100, 0.0123992, -2.64997e-07, 8.35986e-08],
      [0.3720, 0.0124029, 9.88983e-07, -3.11994e-07],
      [0.4340, 0.0123893, -3.69093e-06, -4.35621e-07],
      [0.4958, 0.0123198, -1.02252e-05, -3.45523e-07],
      [0.5571, 0.0121916, -1.54081e-05, -5.82288e-07],
      [0.6176, 0.0119938, -2.41424e-05, -5.25327e-07],
      [0.6769, 0.011713, -3.20223e-05, -5.16405e-07],
      [0.7346, 0.0113541, -3.97684e-05, -6.09052e-07],
      [0.7903, 0.0109107, -4.89042e-05, -1.04739e-06],
      [0.8435, 0.0103431, -6.4615e-05, -1.40374e-09],
      [0.8936, 0.00969686, -6.4636e-05, -8.547e-06],
      [0.9394, 0.00840947, -0.000192841, -4.2106e-06],
      [0.9761, 0.00616527, -0.000256, -4.2106e-06],
      [1.0000, 0.00328947, -0.000319159, -4.2106e-06]
  ];

  var FXC = 0.8487;
  var FYC = 1.3523;
  var C1 = R2D/5; // rad to 5-degree interval
  var RC1 = 1/C1;
  var NODES = 18;

  var poly3_val = function(coefs, x) {
      return coefs[0] + x * (coefs[1] + x * (coefs[2] + x * coefs[3]));
  };

  var poly3_der = function(coefs, x) {
      return coefs[1] + x * (2 * coefs[2] + x * 3 * coefs[3]);
  };

  function newton_rapshon(f_df, start, max_err, iters) {
      var x = start;
      for (; iters; --iters) {
          var upd = f_df(x);
          x -= upd;
          if (Math.abs(upd) < max_err) {
              break;
          }
      }
      return x;
  }

  function init$s() {
      this.x0 = this.x0 || 0;
      this.y0 = this.y0 || 0;
      this.long0 = this.long0 || 0;
      this.es = 0;
      this.title = this.title || "Robinson";
  }

  function forward$r(ll) {
      var lon = adjust_lon(ll.x - this.long0);

      var dphi = Math.abs(ll.y);
      var i = Math.floor(dphi * C1);
      if (i < 0) {
          i = 0;
      } else if (i >= NODES) {
          i = NODES - 1;
      }
      dphi = R2D * (dphi - RC1 * i);
      var xy = {
          x: poly3_val(COEFS_X[i], dphi) * lon,
          y: poly3_val(COEFS_Y[i], dphi)
      };
      if (ll.y < 0) {
          xy.y = -xy.y;
      }

      xy.x = xy.x * this.a * FXC + this.x0;
      xy.y = xy.y * this.a * FYC + this.y0;
      return xy;
  }

  function inverse$r(xy) {
      var ll = {
          x: (xy.x - this.x0) / (this.a * FXC),
          y: Math.abs(xy.y - this.y0) / (this.a * FYC)
      };

      if (ll.y >= 1) { // pathologic case
          ll.x /= COEFS_X[NODES][0];
          ll.y = xy.y < 0 ? -HALF_PI : HALF_PI;
      } else {
          // find table interval
          var i = Math.floor(ll.y * NODES);
          if (i < 0) {
              i = 0;
          } else if (i >= NODES) {
              i = NODES - 1;
          }
          for (;;) {
              if (COEFS_Y[i][0] > ll.y) {
                  --i;
              } else if (COEFS_Y[i+1][0] <= ll.y) {
                  ++i;
              } else {
                  break;
              }
          }
          // linear interpolation in 5 degree interval
          var coefs = COEFS_Y[i];
          var t = 5 * (ll.y - coefs[0]) / (COEFS_Y[i+1][0] - coefs[0]);
          // find t so that poly3_val(coefs, t) = ll.y
          t = newton_rapshon(function(x) {
              return (poly3_val(coefs, x) - ll.y) / poly3_der(coefs, x);
          }, t, EPSLN, 100);

          ll.x /= poly3_val(COEFS_X[i], t);
          ll.y = (5 * i + t) * D2R;
          if (xy.y < 0) {
              ll.y = -ll.y;
          }
      }

      ll.x = adjust_lon(ll.x + this.long0);
      return ll;
  }

  var names$t = ["Robinson", "robin"];
  var robin = {
    init: init$s,
    forward: forward$r,
    inverse: inverse$r,
    names: names$t
  };

  function init$t() {
      this.name = 'geocent';

  }

  function forward$s(p) {
      var point = geodeticToGeocentric(p, this.es, this.a);
      return point;
  }

  function inverse$s(p) {
      var point = geocentricToGeodetic(p, this.es, this.a, this.b);
      return point;
  }

  var names$u = ["Geocentric", 'geocentric', "geocent", "Geocent"];
  var geocent = {
      init: init$t,
      forward: forward$s,
      inverse: inverse$s,
      names: names$u
  };

  function includedProjections(proj4){
    proj4.Proj.projections.add(tmerc);
    proj4.Proj.projections.add(etmerc);
    proj4.Proj.projections.add(utm);
    proj4.Proj.projections.add(sterea);
    proj4.Proj.projections.add(stere);
    proj4.Proj.projections.add(somerc);
    proj4.Proj.projections.add(omerc);
    proj4.Proj.projections.add(lcc);
    proj4.Proj.projections.add(krovak);
    proj4.Proj.projections.add(cass);
    proj4.Proj.projections.add(laea);
    proj4.Proj.projections.add(aea);
    proj4.Proj.projections.add(gnom);
    proj4.Proj.projections.add(cea);
    proj4.Proj.projections.add(eqc);
    proj4.Proj.projections.add(poly);
    proj4.Proj.projections.add(nzmg);
    proj4.Proj.projections.add(mill);
    proj4.Proj.projections.add(sinu);
    proj4.Proj.projections.add(moll);
    proj4.Proj.projections.add(eqdc);
    proj4.Proj.projections.add(vandg);
    proj4.Proj.projections.add(aeqd);
    proj4.Proj.projections.add(ortho);
    proj4.Proj.projections.add(qsc);
    proj4.Proj.projections.add(robin);
    proj4.Proj.projections.add(geocent);
  }

  proj4.defaultDatum = 'WGS84'; //default datum
  proj4.Proj = Projection$1;
  proj4.WGS84 = new proj4.Proj('WGS84');
  proj4.Point = Point$1;
  proj4.toPoint = common;
  proj4.defs = defs;
  proj4.transform = transform$1;
  proj4.mgrs = mgrs;
  proj4.version = '__VERSION__';
  includedProjections(proj4);

  /**
   * @module ol/source/XYZ
   */
  var __extends$1k = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
   * @property {boolean} [attributionsCollapsible=true] Attributions are collapsible.
   * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
   * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
   * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
   * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
   * @property {boolean} [imageSmoothing=true] Enable image smoothing.
   * @property {boolean} [opaque=false] Whether the layer is opaque.
   * @property {import("../proj.js").ProjectionLike} [projection='EPSG:3857'] Projection.
   * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
   * Higher values can increase reprojection performance, but decrease precision.
   * @property {number} [maxZoom=42] Optional max zoom level. Not used if `tileGrid` is provided.
   * @property {number} [minZoom=0] Optional min zoom level. Not used if `tileGrid` is provided.
   * @property {number} [maxResolution] Optional tile grid resolution at level zero. Not used if `tileGrid` is provided.
   * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid.
   * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
   * ```js
   * function(imageTile, src) {
   *   imageTile.getImage().src = src;
   * };
   * ```
   * @property {number} [tilePixelRatio=1] The pixel ratio used by the tile service.
   * For example, if the tile service advertizes 256px by 256px tiles but actually sends 512px
   * by 512px images (for retina/hidpi devices) then `tilePixelRatio`
   * should be set to `2`.
   * @property {number|import("../size.js").Size} [tileSize=[256, 256]] The tile size used by the tile service.
   * Not used if `tileGrid` is provided.
   * @property {import("../Tile.js").UrlFunction} [tileUrlFunction] Optional function to get
   * tile URL given a tile coordinate and the projection.
   * Required if `url` or `urls` are not provided.
   * @property {string} [url] URL template. Must include `{x}`, `{y}` or `{-y}`,
   * and `{z}` placeholders. A `{?-?}` template pattern, for example `subdomain{a-f}.domain.com`,
   * may be used instead of defining each one separately in the `urls` option.
   * @property {Array<string>} [urls] An array of URL templates.
   * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
   * @property {number} [transition] Duration of the opacity transition for rendering.
   * To disable the opacity transition, pass `transition: 0`.
   * @property {number} [zDirection=0] Indicate which resolution should be used
   * by a renderer if the view resolution does not match any resolution of the tile source.
   * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
   * will be used. If -1, the nearest higher resolution will be used.
   */
  /**
   * @classdesc
   * Layer source for tile data with URLs in a set XYZ format that are
   * defined in a URL template. By default, this follows the widely-used
   * Google grid where `x` 0 and `y` 0 are in the top left. Grids like
   * TMS where `x` 0 and `y` 0 are in the bottom left can be used by
   * using the `{-y}` placeholder in the URL template, so long as the
   * source does not have a custom tile grid. In this case,
   * {@link module:ol/source/TileImage} can be used with a `tileUrlFunction`
   * such as:
   *
   *  tileUrlFunction: function(coordinate) {
   *    return 'http://mapserver.com/' + coordinate[0] + '/' +
   *        coordinate[1] + '/' + coordinate[2] + '.png';
   *    }
   *
   * @api
   */
  var XYZ = /** @class */ (function (_super) {
      __extends$1k(XYZ, _super);
      /**
       * @param {Options=} opt_options XYZ options.
       */
      function XYZ(opt_options) {
          var _this = this;
          var options = opt_options || {};
          var projection = options.projection !== undefined ? options.projection : 'EPSG:3857';
          var tileGrid = options.tileGrid !== undefined
              ? options.tileGrid
              : createXYZ({
                  extent: extentFromProjection(projection),
                  maxResolution: options.maxResolution,
                  maxZoom: options.maxZoom,
                  minZoom: options.minZoom,
                  tileSize: options.tileSize,
              });
          _this = _super.call(this, {
              attributions: options.attributions,
              cacheSize: options.cacheSize,
              crossOrigin: options.crossOrigin,
              imageSmoothing: options.imageSmoothing,
              opaque: options.opaque,
              projection: projection,
              reprojectionErrorThreshold: options.reprojectionErrorThreshold,
              tileGrid: tileGrid,
              tileLoadFunction: options.tileLoadFunction,
              tilePixelRatio: options.tilePixelRatio,
              tileUrlFunction: options.tileUrlFunction,
              url: options.url,
              urls: options.urls,
              wrapX: options.wrapX !== undefined ? options.wrapX : true,
              transition: options.transition,
              attributionsCollapsible: options.attributionsCollapsible,
              zDirection: options.zDirection,
          }) || this;
          return _this;
      }
      return XYZ;
  }(TileImage));

  /**
   * @module ol/source/WMSServerType
   */
  /**
   * Available server types: `'carmentaserver'`, `'geoserver'`, `'mapserver'`,
   *     `'qgis'`. These are servers that have vendor parameters beyond the WMS
   *     specification that OpenLayers can make use of.
   * @enum {string}
   */
  var WMSServerType = {
      /**
       * HiDPI support for [Carmenta Server](https://www.carmenta.com/en/products/carmenta-server)
       * @api
       */
      CARMENTA_SERVER: 'carmentaserver',
      /**
       * HiDPI support for [GeoServer](https://geoserver.org/)
       * @api
       */
      GEOSERVER: 'geoserver',
      /**
       * HiDPI support for [MapServer](https://mapserver.org/)
       * @api
       */
      MAPSERVER: 'mapserver',
      /**
       * HiDPI support for [QGIS](https://qgis.org/)
       * @api
       */
      QGIS: 'qgis',
  };

  /**
   * @module ol/source/OSM
   */
  var __extends$1l = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * The attribution containing a link to the OpenStreetMap Copyright and License
   * page.
   * @const
   * @type {string}
   * @api
   */
  var ATTRIBUTION = '&#169; ' +
      '<a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> ' +
      'contributors.';
  /**
   * @typedef {Object} Options
   * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
   * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
   * @property {null|string} [crossOrigin='anonymous'] The `crossOrigin` attribute for loaded images.  Note that
   * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
   * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
   * @property {boolean} [imageSmoothing=true] Enable image smoothing.
   * @property {number} [maxZoom=19] Max zoom.
   * @property {boolean} [opaque=true] Whether the layer is opaque.
   * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
   * Higher values can increase reprojection performance, but decrease precision.
   * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
   * ```js
   * function(imageTile, src) {
   *   imageTile.getImage().src = src;
   * };
   * ```
   * @property {string} [url='https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png'] URL template.
   * Must include `{x}`, `{y}` or `{-y}`, and `{z}` placeholders.
   * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
   */
  /**
   * @classdesc
   * Layer source for the OpenStreetMap tile server.
   * @api
   */
  var OSM = /** @class */ (function (_super) {
      __extends$1l(OSM, _super);
      /**
       * @param {Options=} [opt_options] Open Street Map options.
       */
      function OSM(opt_options) {
          var _this = this;
          var options = opt_options || {};
          var attributions;
          if (options.attributions !== undefined) {
              attributions = options.attributions;
          }
          else {
              attributions = [ATTRIBUTION];
          }
          var crossOrigin = options.crossOrigin !== undefined ? options.crossOrigin : 'anonymous';
          var url = options.url !== undefined
              ? options.url
              : 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png';
          _this = _super.call(this, {
              attributions: attributions,
              cacheSize: options.cacheSize,
              crossOrigin: crossOrigin,
              imageSmoothing: options.imageSmoothing,
              opaque: options.opaque !== undefined ? options.opaque : true,
              maxZoom: options.maxZoom !== undefined ? options.maxZoom : 19,
              reprojectionErrorThreshold: options.reprojectionErrorThreshold,
              tileLoadFunction: options.tileLoadFunction,
              url: url,
              wrapX: options.wrapX,
              attributionsCollapsible: false,
          }) || this;
          return _this;
      }
      return OSM;
  }(XYZ));

  /**
   * @module ol/source/TileWMS
   */
  var __extends$1m = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {import("./Source.js").AttributionLike} [attributions] Attributions.
   * @property {number} [cacheSize] Initial tile cache size. Will auto-grow to hold at least the number of tiles in the viewport.
   * @property {null|string} [crossOrigin] The `crossOrigin` attribute for loaded images.  Note that
   * you must provide a `crossOrigin` value if you want to access pixel data with the Canvas renderer.
   * See https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image for more detail.
   * @property {boolean} [imageSmoothing=true] Enable image smoothing.
   * @property {Object<string,*>} params WMS request parameters.
   * At least a `LAYERS` param is required. `STYLES` is
   * `''` by default. `VERSION` is `1.3.0` by default. `WIDTH`, `HEIGHT`, `BBOX`
   * and `CRS` (`SRS` for WMS version < 1.3.0) will be set dynamically.
   * @property {number} [gutter=0]
   * The size in pixels of the gutter around image tiles to ignore. By setting
   * this property to a non-zero value, images will be requested that are wider
   * and taller than the tile size by a value of `2 x gutter`.
   * Using a non-zero value allows artifacts of rendering at tile edges to be
   * ignored. If you control the WMS service it is recommended to address
   * "artifacts at tile edges" issues by properly configuring the WMS service. For
   * example, MapServer has a `tile_map_edge_buffer` configuration parameter for
   * this. See http://mapserver.org/output/tile_mode.html.
   * @property {boolean} [hidpi=true] Use the `ol/Map#pixelRatio` value when requesting
   * the image from the remote server.
   * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
   * @property {number} [reprojectionErrorThreshold=0.5] Maximum allowed reprojection error (in pixels).
   * Higher values can increase reprojection performance, but decrease precision.
   * @property {typeof import("../ImageTile.js").default} [tileClass] Class used to instantiate image tiles.
   * Default is {@link module:ol/ImageTile~ImageTile}.
   * @property {import("../tilegrid/TileGrid.js").default} [tileGrid] Tile grid. Base this on the resolutions,
   * tilesize and extent supported by the server.
   * If this is not defined, a default grid will be used: if there is a projection
   * extent, the grid will be based on that; if not, a grid based on a global
   * extent with origin at 0,0 will be used..
   * @property {import("./WMSServerType.js").default|string} [serverType]
   * The type of the remote WMS server. Currently only used when `hidpi` is
   * `true`.
   * @property {import("../Tile.js").LoadFunction} [tileLoadFunction] Optional function to load a tile given a URL. The default is
   * ```js
   * function(imageTile, src) {
   *   imageTile.getImage().src = src;
   * };
   * ```
   * @property {string} [url] WMS service URL.
   * @property {Array<string>} [urls] WMS service urls.
   * Use this instead of `url` when the WMS supports multiple urls for GetMap requests.
   * @property {boolean} [wrapX=true] Whether to wrap the world horizontally.
   * When set to `false`, only one world
   * will be rendered. When `true`, tiles will be requested for one world only,
   * but they will be wrapped horizontally to render multiple worlds.
   * @property {number} [transition] Duration of the opacity transition for rendering.
   * To disable the opacity transition, pass `transition: 0`.
   */
  /**
   * @classdesc
   * Layer source for tile data from WMS servers.
   * @api
   */
  var TileWMS = /** @class */ (function (_super) {
      __extends$1m(TileWMS, _super);
      /**
       * @param {Options=} [opt_options] Tile WMS options.
       */
      function TileWMS(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : /** @type {Options} */ ({});
          var params = options.params || {};
          var transparent = 'TRANSPARENT' in params ? params['TRANSPARENT'] : true;
          _this = _super.call(this, {
              attributions: options.attributions,
              cacheSize: options.cacheSize,
              crossOrigin: options.crossOrigin,
              imageSmoothing: options.imageSmoothing,
              opaque: !transparent,
              projection: options.projection,
              reprojectionErrorThreshold: options.reprojectionErrorThreshold,
              tileClass: options.tileClass,
              tileGrid: options.tileGrid,
              tileLoadFunction: options.tileLoadFunction,
              url: options.url,
              urls: options.urls,
              wrapX: options.wrapX !== undefined ? options.wrapX : true,
              transition: options.transition,
          }) || this;
          /**
           * @private
           * @type {number}
           */
          _this.gutter_ = options.gutter !== undefined ? options.gutter : 0;
          /**
           * @private
           * @type {!Object}
           */
          _this.params_ = params;
          /**
           * @private
           * @type {boolean}
           */
          _this.v13_ = true;
          /**
           * @private
           * @type {import("./WMSServerType.js").default|undefined}
           */
          _this.serverType_ = /** @type {import("./WMSServerType.js").default|undefined} */ (options.serverType);
          /**
           * @private
           * @type {boolean}
           */
          _this.hidpi_ = options.hidpi !== undefined ? options.hidpi : true;
          /**
           * @private
           * @type {import("../extent.js").Extent}
           */
          _this.tmpExtent_ = createEmpty();
          _this.updateV13_();
          _this.setKey(_this.getKeyForParams_());
          return _this;
      }
      /**
       * Return the GetFeatureInfo URL for the passed coordinate, resolution, and
       * projection. Return `undefined` if the GetFeatureInfo URL cannot be
       * constructed.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {number} resolution Resolution.
       * @param {import("../proj.js").ProjectionLike} projection Projection.
       * @param {!Object} params GetFeatureInfo params. `INFO_FORMAT` at least should
       *     be provided. If `QUERY_LAYERS` is not provided then the layers specified
       *     in the `LAYERS` parameter will be used. `VERSION` should not be
       *     specified here.
       * @return {string|undefined} GetFeatureInfo URL.
       * @api
       */
      TileWMS.prototype.getFeatureInfoUrl = function (coordinate, resolution, projection, params) {
          var projectionObj = get$2(projection);
          var sourceProjectionObj = this.getProjection();
          var tileGrid = this.getTileGrid();
          if (!tileGrid) {
              tileGrid = this.getTileGridForProjection(projectionObj);
          }
          var z = tileGrid.getZForResolution(resolution, this.zDirection);
          var tileCoord = tileGrid.getTileCoordForCoordAndZ(coordinate, z);
          if (tileGrid.getResolutions().length <= tileCoord[0]) {
              return undefined;
          }
          var tileResolution = tileGrid.getResolution(tileCoord[0]);
          var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
          var tileSize = toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
          var gutter = this.gutter_;
          if (gutter !== 0) {
              tileSize = buffer$1(tileSize, gutter, this.tmpSize);
              tileExtent = buffer(tileExtent, tileResolution * gutter, tileExtent);
          }
          if (sourceProjectionObj && sourceProjectionObj !== projectionObj) {
              tileResolution = calculateSourceResolution(sourceProjectionObj, projectionObj, coordinate, tileResolution);
              tileExtent = transformExtent(tileExtent, projectionObj, sourceProjectionObj);
              coordinate = transform(coordinate, projectionObj, sourceProjectionObj);
          }
          var baseParams = {
              'SERVICE': 'WMS',
              'VERSION': DEFAULT_WMS_VERSION,
              'REQUEST': 'GetFeatureInfo',
              'FORMAT': 'image/png',
              'TRANSPARENT': true,
              'QUERY_LAYERS': this.params_['LAYERS'],
          };
          assign(baseParams, this.params_, params);
          var x = Math.floor((coordinate[0] - tileExtent[0]) / tileResolution);
          var y = Math.floor((tileExtent[3] - coordinate[1]) / tileResolution);
          baseParams[this.v13_ ? 'I' : 'X'] = x;
          baseParams[this.v13_ ? 'J' : 'Y'] = y;
          return this.getRequestUrl_(tileCoord, tileSize, tileExtent, 1, sourceProjectionObj || projectionObj, baseParams);
      };
      /**
       * Return the GetLegendGraphic URL, optionally optimized for the passed
       * resolution and possibly including any passed specific parameters. Returns
       * `undefined` if the GetLegendGraphic URL cannot be constructed.
       *
       * @param {number} [resolution] Resolution. If set to undefined, `SCALE`
       *     will not be calculated and included in URL.
       * @param {Object} [params] GetLegendGraphic params. If `LAYER` is set, the
       *     request is generated for this wms layer, else it will try to use the
       *     configured wms layer. Default `FORMAT` is `image/png`.
       *     `VERSION` should not be specified here.
       * @return {string|undefined} GetLegendGraphic URL.
       * @api
       */
      TileWMS.prototype.getLegendUrl = function (resolution, params) {
          if (this.urls[0] === undefined) {
              return undefined;
          }
          var baseParams = {
              'SERVICE': 'WMS',
              'VERSION': DEFAULT_WMS_VERSION,
              'REQUEST': 'GetLegendGraphic',
              'FORMAT': 'image/png',
          };
          if (params === undefined || params['LAYER'] === undefined) {
              var layers = this.params_.LAYERS;
              var isSingleLayer = !Array.isArray(layers) || layers.length === 1;
              if (!isSingleLayer) {
                  return undefined;
              }
              baseParams['LAYER'] = layers;
          }
          if (resolution !== undefined) {
              var mpu = this.getProjection()
                  ? this.getProjection().getMetersPerUnit()
                  : 1;
              var dpi = 25.4 / 0.28;
              var inchesPerMeter = 39.37;
              baseParams['SCALE'] = resolution * mpu * inchesPerMeter * dpi;
          }
          assign(baseParams, params);
          return appendParams(/** @type {string} */ (this.urls[0]), baseParams);
      };
      /**
       * @return {number} Gutter.
       */
      TileWMS.prototype.getGutter = function () {
          return this.gutter_;
      };
      /**
       * Get the user-provided params, i.e. those passed to the constructor through
       * the "params" option, and possibly updated using the updateParams method.
       * @return {Object} Params.
       * @api
       */
      TileWMS.prototype.getParams = function () {
          return this.params_;
      };
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord Tile coordinate.
       * @param {import("../size.js").Size} tileSize Tile size.
       * @param {import("../extent.js").Extent} tileExtent Tile extent.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../proj/Projection.js").default} projection Projection.
       * @param {Object} params Params.
       * @return {string|undefined} Request URL.
       * @private
       */
      TileWMS.prototype.getRequestUrl_ = function (tileCoord, tileSize, tileExtent, pixelRatio, projection, params) {
          var urls = this.urls;
          if (!urls) {
              return undefined;
          }
          params['WIDTH'] = tileSize[0];
          params['HEIGHT'] = tileSize[1];
          params[this.v13_ ? 'CRS' : 'SRS'] = projection.getCode();
          if (!('STYLES' in this.params_)) {
              params['STYLES'] = '';
          }
          if (pixelRatio != 1) {
              switch (this.serverType_) {
                  case WMSServerType.GEOSERVER:
                      var dpi = (90 * pixelRatio + 0.5) | 0;
                      if ('FORMAT_OPTIONS' in params) {
                          params['FORMAT_OPTIONS'] += ';dpi:' + dpi;
                      }
                      else {
                          params['FORMAT_OPTIONS'] = 'dpi:' + dpi;
                      }
                      break;
                  case WMSServerType.MAPSERVER:
                      params['MAP_RESOLUTION'] = 90 * pixelRatio;
                      break;
                  case WMSServerType.CARMENTA_SERVER:
                  case WMSServerType.QGIS:
                      params['DPI'] = 90 * pixelRatio;
                      break;
                  default:
                      assert(false, 52); // Unknown `serverType` configured
                      break;
              }
          }
          var axisOrientation = projection.getAxisOrientation();
          var bbox = tileExtent;
          if (this.v13_ && axisOrientation.substr(0, 2) == 'ne') {
              var tmp = void 0;
              tmp = tileExtent[0];
              bbox[0] = tileExtent[1];
              bbox[1] = tmp;
              tmp = tileExtent[2];
              bbox[2] = tileExtent[3];
              bbox[3] = tmp;
          }
          params['BBOX'] = bbox.join(',');
          var url;
          if (urls.length == 1) {
              url = urls[0];
          }
          else {
              var index = modulo(hash(tileCoord), urls.length);
              url = urls[index];
          }
          return appendParams(url, params);
      };
      /**
       * Get the tile pixel ratio for this source.
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Tile pixel ratio.
       */
      TileWMS.prototype.getTilePixelRatio = function (pixelRatio) {
          return !this.hidpi_ || this.serverType_ === undefined ? 1 : pixelRatio;
      };
      /**
       * @private
       * @return {string} The key for the current params.
       */
      TileWMS.prototype.getKeyForParams_ = function () {
          var i = 0;
          var res = [];
          for (var key in this.params_) {
              res[i++] = key + '-' + this.params_[key];
          }
          return res.join('/');
      };
      /**
       * Update the user-provided params.
       * @param {Object} params Params.
       * @api
       */
      TileWMS.prototype.updateParams = function (params) {
          assign(this.params_, params);
          this.updateV13_();
          this.setKey(this.getKeyForParams_());
      };
      /**
       * @private
       */
      TileWMS.prototype.updateV13_ = function () {
          var version = this.params_['VERSION'] || DEFAULT_WMS_VERSION;
          this.v13_ = compareVersions(version, '1.3') >= 0;
      };
      /**
       * @param {import("../tilecoord.js").TileCoord} tileCoord The tile coordinate
       * @param {number} pixelRatio The pixel ratio
       * @param {import("../proj/Projection.js").default} projection The projection
       * @return {string|undefined} The tile URL
       * @override
       */
      TileWMS.prototype.tileUrlFunction = function (tileCoord, pixelRatio, projection) {
          var tileGrid = this.getTileGrid();
          if (!tileGrid) {
              tileGrid = this.getTileGridForProjection(projection);
          }
          if (tileGrid.getResolutions().length <= tileCoord[0]) {
              return undefined;
          }
          if (pixelRatio != 1 && (!this.hidpi_ || this.serverType_ === undefined)) {
              pixelRatio = 1;
          }
          var tileResolution = tileGrid.getResolution(tileCoord[0]);
          var tileExtent = tileGrid.getTileCoordExtent(tileCoord, this.tmpExtent_);
          var tileSize = toSize(tileGrid.getTileSize(tileCoord[0]), this.tmpSize);
          var gutter = this.gutter_;
          if (gutter !== 0) {
              tileSize = buffer$1(tileSize, gutter, this.tmpSize);
              tileExtent = buffer(tileExtent, tileResolution * gutter, tileExtent);
          }
          if (pixelRatio != 1) {
              tileSize = scale$2(tileSize, pixelRatio, this.tmpSize);
          }
          var baseParams = {
              'SERVICE': 'WMS',
              'VERSION': DEFAULT_WMS_VERSION,
              'REQUEST': 'GetMap',
              'FORMAT': 'image/png',
              'TRANSPARENT': true,
          };
          assign(baseParams, this.params_);
          return this.getRequestUrl_(tileCoord, tileSize, tileExtent, pixelRatio, projection, baseParams);
      };
      return TileWMS;
  }(TileImage));

  /**
   * @module ol/proj/proj4
   */
  /**
   * Make projections defined in proj4 (with `proj4.defs()`) available in
   * OpenLayers.
   *
   * This function should be called whenever changes are made to the proj4
   * registry, e.g. after calling `proj4.defs()`. Existing transforms will not be
   * modified by this function.
   *
   * @param {?} proj4 Proj4.
   * @api
   */
  function register(proj4) {
      var projCodes = Object.keys(proj4.defs);
      var len = projCodes.length;
      var i, j;
      for (i = 0; i < len; ++i) {
          var code = projCodes[i];
          if (!get$2(code)) {
              var def = proj4.defs(code);
              addProjection(new Projection({
                  code: code,
                  axisOrientation: def.axis,
                  metersPerUnit: def.to_meter,
                  units: def.units,
              }));
          }
      }
      for (i = 0; i < len; ++i) {
          var code1 = projCodes[i];
          var proj1 = get$2(code1);
          for (j = 0; j < len; ++j) {
              var code2 = projCodes[j];
              var proj2 = get$2(code2);
              if (!get$1(code1, code2)) {
                  var def1 = proj4.defs(code1);
                  var def2 = proj4.defs(code2);
                  if (def1 === def2) {
                      addEquivalentProjections([proj1, proj2]);
                  }
                  else {
                      // Reset axis because OpenLayers always uses x, y axis order
                      var transform = proj4(assign({}, def1, { axis: undefined }), assign({}, def2, { axis: undefined }));
                      addCoordinateTransforms(proj1, proj2, createSafeCoordinateTransform(proj1, proj2, transform.forward), createSafeCoordinateTransform(proj2, proj1, transform.inverse));
                  }
              }
          }
      }
  }

  /**
   * @module ol/format/Feature
   */
  /**
   * @typedef {Object} ReadOptions
   * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are reading.
   * If not provided, the projection will be derived from the data (where possible) or
   * the `dataProjection` of the format is assigned (where set). If the projection
   * can not be derived from the data and if no `dataProjection` is set for a format,
   * the features will not be reprojected.
   * @property {import("../extent.js").Extent} [extent] Tile extent in map units of the tile being read.
   * This is only required when reading data with tile pixels as geometry units. When configured,
   * a `dataProjection` with `TILE_PIXELS` as `units` and the tile's pixel extent as `extent` needs to be
   * provided.
   * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries
   * created by the format reader. If not provided, features will be returned in the
   * `dataProjection`.
   */
  /**
   * @typedef {Object} WriteOptions
   * @property {import("../proj.js").ProjectionLike} [dataProjection] Projection of the data we are writing.
   * If not provided, the `dataProjection` of the format is assigned (where set).
   * If no `dataProjection` is set for a format, the features will be returned
   * in the `featureProjection`.
   * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection of the feature geometries
   * that will be serialized by the format writer. If not provided, geometries are assumed
   * to be in the `dataProjection` if that is set; in other words, they are not transformed.
   * @property {boolean} [rightHanded] When writing geometries, follow the right-hand
   * rule for linear ring orientation.  This means that polygons will have counter-clockwise
   * exterior rings and clockwise interior rings.  By default, coordinates are serialized
   * as they are provided at construction.  If `true`, the right-hand rule will
   * be applied.  If `false`, the left-hand rule will be applied (clockwise for
   * exterior and counter-clockwise for interior rings).  Note that not all
   * formats support this.  The GeoJSON format does use this property when writing
   * geometries.
   * @property {number} [decimals] Maximum number of decimal places for coordinates.
   * Coordinates are stored internally as floats, but floating-point arithmetic can create
   * coordinates with a large number of decimal places, not generally wanted on output.
   * Set a number here to round coordinates. Can also be used to ensure that
   * coordinates read in can be written back out with the same number of decimals.
   * Default is no rounding.
   */
  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * Base class for feature formats.
   * {@link module:ol/format/Feature~FeatureFormat} subclasses provide the ability to decode and encode
   * {@link module:ol/Feature~Feature} objects from a variety of commonly used geospatial
   * file formats.  See the documentation for each format for more details.
   *
   * @abstract
   * @api
   */
  var FeatureFormat = /** @class */ (function () {
      function FeatureFormat() {
          /**
           * @protected
           * @type {import("../proj/Projection.js").default}
           */
          this.dataProjection = null;
          /**
           * @protected
           * @type {import("../proj/Projection.js").default}
           */
          this.defaultFeatureProjection = null;
      }
      /**
       * Adds the data projection to the read options.
       * @param {Document|Element|Object|string} source Source.
       * @param {ReadOptions=} opt_options Options.
       * @return {ReadOptions|undefined} Options.
       * @protected
       */
      FeatureFormat.prototype.getReadOptions = function (source, opt_options) {
          var options;
          if (opt_options) {
              var dataProjection = opt_options.dataProjection
                  ? get$2(opt_options.dataProjection)
                  : this.readProjection(source);
              if (opt_options.extent &&
                  dataProjection &&
                  dataProjection.getUnits() === Units.TILE_PIXELS) {
                  dataProjection = get$2(dataProjection);
                  dataProjection.setWorldExtent(opt_options.extent);
              }
              options = {
                  dataProjection: dataProjection,
                  featureProjection: opt_options.featureProjection,
              };
          }
          return this.adaptOptions(options);
      };
      /**
       * Sets the `dataProjection` on the options, if no `dataProjection`
       * is set.
       * @param {WriteOptions|ReadOptions|undefined} options
       *     Options.
       * @protected
       * @return {WriteOptions|ReadOptions|undefined}
       *     Updated options.
       */
      FeatureFormat.prototype.adaptOptions = function (options) {
          return assign({
              dataProjection: this.dataProjection,
              featureProjection: this.defaultFeatureProjection,
          }, options);
      };
      /**
       * @abstract
       * @return {import("./FormatType.js").default} Format.
       */
      FeatureFormat.prototype.getType = function () {
          return abstract();
      };
      /**
       * Read a single feature from a source.
       *
       * @abstract
       * @param {Document|Element|Object|string} source Source.
       * @param {ReadOptions=} opt_options Read options.
       * @return {import("../Feature.js").FeatureLike} Feature.
       */
      FeatureFormat.prototype.readFeature = function (source, opt_options) {
          return abstract();
      };
      /**
       * Read all features from a source.
       *
       * @abstract
       * @param {Document|Element|ArrayBuffer|Object|string} source Source.
       * @param {ReadOptions=} opt_options Read options.
       * @return {Array<import("../Feature.js").FeatureLike>} Features.
       */
      FeatureFormat.prototype.readFeatures = function (source, opt_options) {
          return abstract();
      };
      /**
       * Read a single geometry from a source.
       *
       * @abstract
       * @param {Document|Element|Object|string} source Source.
       * @param {ReadOptions=} opt_options Read options.
       * @return {import("../geom/Geometry.js").default} Geometry.
       */
      FeatureFormat.prototype.readGeometry = function (source, opt_options) {
          return abstract();
      };
      /**
       * Read the projection from a source.
       *
       * @abstract
       * @param {Document|Element|Object|string} source Source.
       * @return {import("../proj/Projection.js").default} Projection.
       */
      FeatureFormat.prototype.readProjection = function (source) {
          return abstract();
      };
      /**
       * Encode a feature in this format.
       *
       * @abstract
       * @param {import("../Feature.js").default} feature Feature.
       * @param {WriteOptions=} opt_options Write options.
       * @return {string} Result.
       */
      FeatureFormat.prototype.writeFeature = function (feature, opt_options) {
          return abstract();
      };
      /**
       * Encode an array of features in this format.
       *
       * @abstract
       * @param {Array<import("../Feature.js").default>} features Features.
       * @param {WriteOptions=} opt_options Write options.
       * @return {string} Result.
       */
      FeatureFormat.prototype.writeFeatures = function (features, opt_options) {
          return abstract();
      };
      /**
       * Write a single geometry in this format.
       *
       * @abstract
       * @param {import("../geom/Geometry.js").default} geometry Geometry.
       * @param {WriteOptions=} opt_options Write options.
       * @return {string} Result.
       */
      FeatureFormat.prototype.writeGeometry = function (geometry, opt_options) {
          return abstract();
      };
      return FeatureFormat;
  }());
  /**
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {boolean} write Set to true for writing, false for reading.
   * @param {(WriteOptions|ReadOptions)=} opt_options Options.
   * @return {import("../geom/Geometry.js").default} Transformed geometry.
   */
  function transformGeometryWithOptions(geometry, write, opt_options) {
      var featureProjection = opt_options
          ? get$2(opt_options.featureProjection)
          : null;
      var dataProjection = opt_options
          ? get$2(opt_options.dataProjection)
          : null;
      var transformed;
      if (featureProjection &&
          dataProjection &&
          !equivalent(featureProjection, dataProjection)) {
          transformed = (write ? geometry.clone() : geometry).transform(write ? featureProjection : dataProjection, write ? dataProjection : featureProjection);
      }
      else {
          transformed = geometry;
      }
      if (write &&
          opt_options &&
          /** @type {WriteOptions} */ (opt_options).decimals !== undefined) {
          var power_1 = Math.pow(10, 
          /** @type {WriteOptions} */ (opt_options).decimals);
          // if decimals option on write, round each coordinate appropriately
          /**
           * @param {Array<number>} coordinates Coordinates.
           * @return {Array<number>} Transformed coordinates.
           */
          var transform = function (coordinates) {
              for (var i = 0, ii = coordinates.length; i < ii; ++i) {
                  coordinates[i] = Math.round(coordinates[i] * power_1) / power_1;
              }
              return coordinates;
          };
          if (transformed === geometry) {
              transformed = geometry.clone();
          }
          transformed.applyTransform(transform);
      }
      return transformed;
  }

  var __extends$1n = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * An array of {@link module:ol/geom/Geometry} objects.
   *
   * @api
   */
  var GeometryCollection = /** @class */ (function (_super) {
      __extends$1n(GeometryCollection, _super);
      /**
       * @param {Array<Geometry>=} opt_geometries Geometries.
       */
      function GeometryCollection(opt_geometries) {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {Array<Geometry>}
           */
          _this.geometries_ = opt_geometries ? opt_geometries : null;
          /**
           * @type {Array<import("../events.js").EventsKey>}
           */
          _this.changeEventsKeys_ = [];
          _this.listenGeometriesChange_();
          return _this;
      }
      /**
       * @private
       */
      GeometryCollection.prototype.unlistenGeometriesChange_ = function () {
          this.changeEventsKeys_.forEach(unlistenByKey);
          this.changeEventsKeys_.length = 0;
      };
      /**
       * @private
       */
      GeometryCollection.prototype.listenGeometriesChange_ = function () {
          if (!this.geometries_) {
              return;
          }
          for (var i = 0, ii = this.geometries_.length; i < ii; ++i) {
              this.changeEventsKeys_.push(listen(this.geometries_[i], EventType.CHANGE, this.changed, this));
          }
      };
      /**
       * Make a complete copy of the geometry.
       * @return {!GeometryCollection} Clone.
       * @api
       */
      GeometryCollection.prototype.clone = function () {
          var geometryCollection = new GeometryCollection(null);
          geometryCollection.setGeometries(this.geometries_);
          return geometryCollection;
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      GeometryCollection.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
          if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
          }
          var geometries = this.geometries_;
          for (var i = 0, ii = geometries.length; i < ii; ++i) {
              minSquaredDistance = geometries[i].closestPointXY(x, y, closestPoint, minSquaredDistance);
          }
          return minSquaredDistance;
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */
      GeometryCollection.prototype.containsXY = function (x, y) {
          var geometries = this.geometries_;
          for (var i = 0, ii = geometries.length; i < ii; ++i) {
              if (geometries[i].containsXY(x, y)) {
                  return true;
              }
          }
          return false;
      };
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */
      GeometryCollection.prototype.computeExtent = function (extent) {
          createOrUpdateEmpty(extent);
          var geometries = this.geometries_;
          for (var i = 0, ii = geometries.length; i < ii; ++i) {
              extend$1(extent, geometries[i].getExtent());
          }
          return extent;
      };
      /**
       * Return the geometries that make up this geometry collection.
       * @return {Array<Geometry>} Geometries.
       * @api
       */
      GeometryCollection.prototype.getGeometries = function () {
          return cloneGeometries(this.geometries_);
      };
      /**
       * @return {Array<Geometry>} Geometries.
       */
      GeometryCollection.prototype.getGeometriesArray = function () {
          return this.geometries_;
      };
      /**
       * @return {Array<Geometry>} Geometries.
       */
      GeometryCollection.prototype.getGeometriesArrayRecursive = function () {
          /** @type {Array<Geometry>} */
          var geometriesArray = [];
          var geometries = this.geometries_;
          for (var i = 0, ii = geometries.length; i < ii; ++i) {
              if (geometries[i].getType() === this.getType()) {
                  geometriesArray = geometriesArray.concat(
                  /** @type {GeometryCollection} */ (geometries[i]).getGeometriesArrayRecursive());
              }
              else {
                  geometriesArray.push(geometries[i]);
              }
          }
          return geometriesArray;
      };
      /**
       * Create a simplified version of this geometry using the Douglas Peucker algorithm.
       * @param {number} squaredTolerance Squared tolerance.
       * @return {GeometryCollection} Simplified GeometryCollection.
       */
      GeometryCollection.prototype.getSimplifiedGeometry = function (squaredTolerance) {
          if (this.simplifiedGeometryRevision !== this.getRevision()) {
              this.simplifiedGeometryMaxMinSquaredTolerance = 0;
              this.simplifiedGeometryRevision = this.getRevision();
          }
          if (squaredTolerance < 0 ||
              (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&
                  squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance)) {
              return this;
          }
          var simplifiedGeometries = [];
          var geometries = this.geometries_;
          var simplified = false;
          for (var i = 0, ii = geometries.length; i < ii; ++i) {
              var geometry = geometries[i];
              var simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
              simplifiedGeometries.push(simplifiedGeometry);
              if (simplifiedGeometry !== geometry) {
                  simplified = true;
              }
          }
          if (simplified) {
              var simplifiedGeometryCollection = new GeometryCollection(null);
              simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);
              return simplifiedGeometryCollection;
          }
          else {
              this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
              return this;
          }
      };
      /**
       * Get the type of this geometry.
       * @return {import("./GeometryType.js").default} Geometry type.
       * @api
       */
      GeometryCollection.prototype.getType = function () {
          return GeometryType.GEOMETRY_COLLECTION;
      };
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      GeometryCollection.prototype.intersectsExtent = function (extent) {
          var geometries = this.geometries_;
          for (var i = 0, ii = geometries.length; i < ii; ++i) {
              if (geometries[i].intersectsExtent(extent)) {
                  return true;
              }
          }
          return false;
      };
      /**
       * @return {boolean} Is empty.
       */
      GeometryCollection.prototype.isEmpty = function () {
          return this.geometries_.length === 0;
      };
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @param {number} angle Rotation angle in radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       */
      GeometryCollection.prototype.rotate = function (angle, anchor) {
          var geometries = this.geometries_;
          for (var i = 0, ii = geometries.length; i < ii; ++i) {
              geometries[i].rotate(angle, anchor);
          }
          this.changed();
      };
      /**
       * Scale the geometry (with an optional origin).  This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} sx The scaling factor in the x-direction.
       * @param {number=} opt_sy The scaling factor in the y-direction (defaults to sx).
       * @param {import("../coordinate.js").Coordinate=} opt_anchor The scale origin (defaults to the center
       *     of the geometry extent).
       * @api
       */
      GeometryCollection.prototype.scale = function (sx, opt_sy, opt_anchor) {
          var anchor = opt_anchor;
          if (!anchor) {
              anchor = getCenter(this.getExtent());
          }
          var geometries = this.geometries_;
          for (var i = 0, ii = geometries.length; i < ii; ++i) {
              geometries[i].scale(sx, opt_sy, anchor);
          }
          this.changed();
      };
      /**
       * Set the geometries that make up this geometry collection.
       * @param {Array<Geometry>} geometries Geometries.
       * @api
       */
      GeometryCollection.prototype.setGeometries = function (geometries) {
          this.setGeometriesArray(cloneGeometries(geometries));
      };
      /**
       * @param {Array<Geometry>} geometries Geometries.
       */
      GeometryCollection.prototype.setGeometriesArray = function (geometries) {
          this.unlistenGeometriesChange_();
          this.geometries_ = geometries;
          this.listenGeometriesChange_();
          this.changed();
      };
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       * Called with a flat array of geometry coordinates.
       * @api
       */
      GeometryCollection.prototype.applyTransform = function (transformFn) {
          var geometries = this.geometries_;
          for (var i = 0, ii = geometries.length; i < ii; ++i) {
              geometries[i].applyTransform(transformFn);
          }
          this.changed();
      };
      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       */
      GeometryCollection.prototype.translate = function (deltaX, deltaY) {
          var geometries = this.geometries_;
          for (var i = 0, ii = geometries.length; i < ii; ++i) {
              geometries[i].translate(deltaX, deltaY);
          }
          this.changed();
      };
      /**
       * Clean up.
       */
      GeometryCollection.prototype.disposeInternal = function () {
          this.unlistenGeometriesChange_();
          _super.prototype.disposeInternal.call(this);
      };
      return GeometryCollection;
  }(Geometry));
  /**
   * @param {Array<Geometry>} geometries Geometries.
   * @return {Array<Geometry>} Cloned geometries.
   */
  function cloneGeometries(geometries) {
      var clonedGeometries = [];
      for (var i = 0, ii = geometries.length; i < ii; ++i) {
          clonedGeometries.push(geometries[i].clone());
      }
      return clonedGeometries;
  }

  var __extends$1o = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * Base class for JSON feature formats.
   *
   * @abstract
   */
  var JSONFeature = /** @class */ (function (_super) {
      __extends$1o(JSONFeature, _super);
      function JSONFeature() {
          return _super.call(this) || this;
      }
      /**
       * @return {import("./FormatType.js").default} Format.
       */
      JSONFeature.prototype.getType = function () {
          return FormatType.JSON;
      };
      /**
       * Read a feature.  Only works for a single feature. Use `readFeatures` to
       * read a feature collection.
       *
       * @param {ArrayBuffer|Document|Element|Object|string} source Source.
       * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
       * @return {import("../Feature.js").default} Feature.
       * @api
       */
      JSONFeature.prototype.readFeature = function (source, opt_options) {
          return this.readFeatureFromObject(getObject(source), this.getReadOptions(source, opt_options));
      };
      /**
       * Read all features.  Works with both a single feature and a feature
       * collection.
       *
       * @param {ArrayBuffer|Document|Element|Object|string} source Source.
       * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
       * @return {Array<import("../Feature.js").default>} Features.
       * @api
       */
      JSONFeature.prototype.readFeatures = function (source, opt_options) {
          return this.readFeaturesFromObject(getObject(source), this.getReadOptions(source, opt_options));
      };
      /**
       * @abstract
       * @param {Object} object Object.
       * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
       * @protected
       * @return {import("../Feature.js").default} Feature.
       */
      JSONFeature.prototype.readFeatureFromObject = function (object, opt_options) {
          return abstract();
      };
      /**
       * @abstract
       * @param {Object} object Object.
       * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
       * @protected
       * @return {Array<import("../Feature.js").default>} Features.
       */
      JSONFeature.prototype.readFeaturesFromObject = function (object, opt_options) {
          return abstract();
      };
      /**
       * Read a geometry.
       *
       * @param {ArrayBuffer|Document|Element|Object|string} source Source.
       * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
       * @return {import("../geom/Geometry.js").default} Geometry.
       * @api
       */
      JSONFeature.prototype.readGeometry = function (source, opt_options) {
          return this.readGeometryFromObject(getObject(source), this.getReadOptions(source, opt_options));
      };
      /**
       * @abstract
       * @param {Object} object Object.
       * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
       * @protected
       * @return {import("../geom/Geometry.js").default} Geometry.
       */
      JSONFeature.prototype.readGeometryFromObject = function (object, opt_options) {
          return abstract();
      };
      /**
       * Read the projection.
       *
       * @param {ArrayBuffer|Document|Element|Object|string} source Source.
       * @return {import("../proj/Projection.js").default} Projection.
       * @api
       */
      JSONFeature.prototype.readProjection = function (source) {
          return this.readProjectionFromObject(getObject(source));
      };
      /**
       * @abstract
       * @param {Object} object Object.
       * @protected
       * @return {import("../proj/Projection.js").default} Projection.
       */
      JSONFeature.prototype.readProjectionFromObject = function (object) {
          return abstract();
      };
      /**
       * Encode a feature as string.
       *
       * @param {import("../Feature.js").default} feature Feature.
       * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
       * @return {string} Encoded feature.
       * @api
       */
      JSONFeature.prototype.writeFeature = function (feature, opt_options) {
          return JSON.stringify(this.writeFeatureObject(feature, opt_options));
      };
      /**
       * @abstract
       * @param {import("../Feature.js").default} feature Feature.
       * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
       * @return {Object} Object.
       */
      JSONFeature.prototype.writeFeatureObject = function (feature, opt_options) {
          return abstract();
      };
      /**
       * Encode an array of features as string.
       *
       * @param {Array<import("../Feature.js").default>} features Features.
       * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
       * @return {string} Encoded features.
       * @api
       */
      JSONFeature.prototype.writeFeatures = function (features, opt_options) {
          return JSON.stringify(this.writeFeaturesObject(features, opt_options));
      };
      /**
       * @abstract
       * @param {Array<import("../Feature.js").default>} features Features.
       * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
       * @return {Object} Object.
       */
      JSONFeature.prototype.writeFeaturesObject = function (features, opt_options) {
          return abstract();
      };
      /**
       * Encode a geometry as string.
       *
       * @param {import("../geom/Geometry.js").default} geometry Geometry.
       * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
       * @return {string} Encoded geometry.
       * @api
       */
      JSONFeature.prototype.writeGeometry = function (geometry, opt_options) {
          return JSON.stringify(this.writeGeometryObject(geometry, opt_options));
      };
      /**
       * @abstract
       * @param {import("../geom/Geometry.js").default} geometry Geometry.
       * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
       * @return {Object} Object.
       */
      JSONFeature.prototype.writeGeometryObject = function (geometry, opt_options) {
          return abstract();
      };
      return JSONFeature;
  }(FeatureFormat));
  /**
   * @param {Document|Element|Object|string} source Source.
   * @return {Object} Object.
   */
  function getObject(source) {
      if (typeof source === 'string') {
          var object = JSON.parse(source);
          return object ? /** @type {Object} */ (object) : null;
      }
      else if (source !== null) {
          return source;
      }
      else {
          return null;
      }
  }

  /**
   * @module ol/format/GeoJSON
   */
  var __extends$1p = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {import("geojson").GeoJSON} GeoJSONObject
   * @typedef {import("geojson").Feature} GeoJSONFeature
   * @typedef {import("geojson").FeatureCollection} GeoJSONFeatureCollection
   * @typedef {import("geojson").Geometry} GeoJSONGeometry
   * @typedef {import("geojson").Point} GeoJSONPoint
   * @typedef {import("geojson").LineString} GeoJSONLineString
   * @typedef {import("geojson").Polygon} GeoJSONPolygon
   * @typedef {import("geojson").MultiPoint} GeoJSONMultiPoint
   * @typedef {import("geojson").MultiLineString} GeoJSONMultiLineString
   * @typedef {import("geojson").MultiPolygon} GeoJSONMultiPolygon
   * @typedef {import("geojson").GeometryCollection} GeoJSONGeometryCollection
   */
  /**
   * @typedef {Object} Options
   * @property {import("../proj.js").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.
   * @property {import("../proj.js").ProjectionLike} [featureProjection] Projection for features read or
   * written by the format.  Options passed to read or write methods will take precedence.
   * @property {string} [geometryName] Geometry name to use when creating features.
   * @property {boolean} [extractGeometryName=false] Certain GeoJSON providers include
   * the geometry_name field in the feature GeoJSON. If set to `true` the GeoJSON reader
   * will look for that field to set the geometry name. If both this field is set to `true`
   * and a `geometryName` is provided, the `geometryName` will take precedence.
   */
  /**
   * @classdesc
   * Feature format for reading and writing data in the GeoJSON format.
   *
   * @api
   */
  var GeoJSON = /** @class */ (function (_super) {
      __extends$1p(GeoJSON, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function GeoJSON(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this) || this;
          /**
           * @type {import("../proj/Projection.js").default}
           */
          _this.dataProjection = get$2(options.dataProjection ? options.dataProjection : 'EPSG:4326');
          if (options.featureProjection) {
              _this.defaultFeatureProjection = get$2(options.featureProjection);
          }
          /**
           * Name of the geometry attribute for features.
           * @type {string|undefined}
           * @private
           */
          _this.geometryName_ = options.geometryName;
          /**
           * Look for the geometry name in the feature GeoJSON
           * @type {boolean|undefined}
           * @private
           */
          _this.extractGeometryName_ = options.extractGeometryName;
          return _this;
      }
      /**
       * @param {Object} object Object.
       * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
       * @protected
       * @return {import("../Feature.js").default} Feature.
       */
      GeoJSON.prototype.readFeatureFromObject = function (object, opt_options) {
          /**
           * @type {GeoJSONFeature}
           */
          var geoJSONFeature = null;
          if (object['type'] === 'Feature') {
              geoJSONFeature = /** @type {GeoJSONFeature} */ (object);
          }
          else {
              geoJSONFeature = {
                  'type': 'Feature',
                  'geometry': /** @type {GeoJSONGeometry} */ (object),
                  'properties': null,
              };
          }
          var geometry = readGeometry(geoJSONFeature['geometry'], opt_options);
          var feature = new Feature();
          if (this.geometryName_) {
              feature.setGeometryName(this.geometryName_);
          }
          else if (this.extractGeometryName_ &&
              'geometry_name' in geoJSONFeature !== undefined) {
              feature.setGeometryName(geoJSONFeature['geometry_name']);
          }
          feature.setGeometry(geometry);
          if ('id' in geoJSONFeature) {
              feature.setId(geoJSONFeature['id']);
          }
          if (geoJSONFeature['properties']) {
              feature.setProperties(geoJSONFeature['properties'], true);
          }
          return feature;
      };
      /**
       * @param {Object} object Object.
       * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
       * @protected
       * @return {Array<Feature>} Features.
       */
      GeoJSON.prototype.readFeaturesFromObject = function (object, opt_options) {
          var geoJSONObject = /** @type {GeoJSONObject} */ (object);
          /** @type {Array<import("../Feature.js").default>} */
          var features = null;
          if (geoJSONObject['type'] === 'FeatureCollection') {
              var geoJSONFeatureCollection = /** @type {GeoJSONFeatureCollection} */ (object);
              features = [];
              var geoJSONFeatures = geoJSONFeatureCollection['features'];
              for (var i = 0, ii = geoJSONFeatures.length; i < ii; ++i) {
                  features.push(this.readFeatureFromObject(geoJSONFeatures[i], opt_options));
              }
          }
          else {
              features = [this.readFeatureFromObject(object, opt_options)];
          }
          return features;
      };
      /**
       * @param {GeoJSONGeometry} object Object.
       * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
       * @protected
       * @return {import("../geom/Geometry.js").default} Geometry.
       */
      GeoJSON.prototype.readGeometryFromObject = function (object, opt_options) {
          return readGeometry(object, opt_options);
      };
      /**
       * @param {Object} object Object.
       * @protected
       * @return {import("../proj/Projection.js").default} Projection.
       */
      GeoJSON.prototype.readProjectionFromObject = function (object) {
          var crs = object['crs'];
          var projection;
          if (crs) {
              if (crs['type'] == 'name') {
                  projection = get$2(crs['properties']['name']);
              }
              else if (crs['type'] === 'EPSG') {
                  projection = get$2('EPSG:' + crs['properties']['code']);
              }
              else {
                  assert(false, 36); // Unknown SRS type
              }
          }
          else {
              projection = this.dataProjection;
          }
          return /** @type {import("../proj/Projection.js").default} */ (projection);
      };
      /**
       * Encode a feature as a GeoJSON Feature object.
       *
       * @param {import("../Feature.js").default} feature Feature.
       * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
       * @return {GeoJSONFeature} Object.
       * @api
       */
      GeoJSON.prototype.writeFeatureObject = function (feature, opt_options) {
          opt_options = this.adaptOptions(opt_options);
          /** @type {GeoJSONFeature} */
          var object = {
              'type': 'Feature',
              geometry: null,
              properties: null,
          };
          var id = feature.getId();
          if (id !== undefined) {
              object.id = id;
          }
          if (!feature.hasProperties()) {
              return object;
          }
          var properties = feature.getProperties();
          var geometry = feature.getGeometry();
          if (geometry) {
              object.geometry = writeGeometry(geometry, opt_options);
              delete properties[feature.getGeometryName()];
          }
          if (!isEmpty$1(properties)) {
              object.properties = properties;
          }
          return object;
      };
      /**
       * Encode an array of features as a GeoJSON object.
       *
       * @param {Array<import("../Feature.js").default>} features Features.
       * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
       * @return {GeoJSONFeatureCollection} GeoJSON Object.
       * @api
       */
      GeoJSON.prototype.writeFeaturesObject = function (features, opt_options) {
          opt_options = this.adaptOptions(opt_options);
          var objects = [];
          for (var i = 0, ii = features.length; i < ii; ++i) {
              objects.push(this.writeFeatureObject(features[i], opt_options));
          }
          return {
              type: 'FeatureCollection',
              features: objects,
          };
      };
      /**
       * Encode a geometry as a GeoJSON object.
       *
       * @param {import("../geom/Geometry.js").default} geometry Geometry.
       * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
       * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
       * @api
       */
      GeoJSON.prototype.writeGeometryObject = function (geometry, opt_options) {
          return writeGeometry(geometry, this.adaptOptions(opt_options));
      };
      return GeoJSON;
  }(JSONFeature));
  /**
   * @param {GeoJSONGeometry|GeoJSONGeometryCollection} object Object.
   * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
   * @return {import("../geom/Geometry.js").default} Geometry.
   */
  function readGeometry(object, opt_options) {
      if (!object) {
          return null;
      }
      /**
       * @type {import("../geom/Geometry.js").default}
       */
      var geometry;
      switch (object['type']) {
          case GeometryType.POINT: {
              geometry = readPointGeometry(/** @type {GeoJSONPoint} */ (object));
              break;
          }
          case GeometryType.LINE_STRING: {
              geometry = readLineStringGeometry(
              /** @type {GeoJSONLineString} */ (object));
              break;
          }
          case GeometryType.POLYGON: {
              geometry = readPolygonGeometry(/** @type {GeoJSONPolygon} */ (object));
              break;
          }
          case GeometryType.MULTI_POINT: {
              geometry = readMultiPointGeometry(
              /** @type {GeoJSONMultiPoint} */ (object));
              break;
          }
          case GeometryType.MULTI_LINE_STRING: {
              geometry = readMultiLineStringGeometry(
              /** @type {GeoJSONMultiLineString} */ (object));
              break;
          }
          case GeometryType.MULTI_POLYGON: {
              geometry = readMultiPolygonGeometry(
              /** @type {GeoJSONMultiPolygon} */ (object));
              break;
          }
          case GeometryType.GEOMETRY_COLLECTION: {
              geometry = readGeometryCollectionGeometry(
              /** @type {GeoJSONGeometryCollection} */ (object));
              break;
          }
          default: {
              throw new Error('Unsupported GeoJSON type: ' + object.type);
          }
      }
      return transformGeometryWithOptions(geometry, false, opt_options);
  }
  /**
   * @param {GeoJSONGeometryCollection} object Object.
   * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
   * @return {GeometryCollection} Geometry collection.
   */
  function readGeometryCollectionGeometry(object, opt_options) {
      var geometries = object['geometries'].map(
      /**
       * @param {GeoJSONGeometry} geometry Geometry.
       * @return {import("../geom/Geometry.js").default} geometry Geometry.
       */
      function (geometry) {
          return readGeometry(geometry, opt_options);
      });
      return new GeometryCollection(geometries);
  }
  /**
   * @param {GeoJSONPoint} object Object.
   * @return {Point} Point.
   */
  function readPointGeometry(object) {
      return new Point(object['coordinates']);
  }
  /**
   * @param {GeoJSONLineString} object Object.
   * @return {LineString} LineString.
   */
  function readLineStringGeometry(object) {
      return new LineString(object['coordinates']);
  }
  /**
   * @param {GeoJSONMultiLineString} object Object.
   * @return {MultiLineString} MultiLineString.
   */
  function readMultiLineStringGeometry(object) {
      return new MultiLineString(object['coordinates']);
  }
  /**
   * @param {GeoJSONMultiPoint} object Object.
   * @return {MultiPoint} MultiPoint.
   */
  function readMultiPointGeometry(object) {
      return new MultiPoint(object['coordinates']);
  }
  /**
   * @param {GeoJSONMultiPolygon} object Object.
   * @return {MultiPolygon} MultiPolygon.
   */
  function readMultiPolygonGeometry(object) {
      return new MultiPolygon(object['coordinates']);
  }
  /**
   * @param {GeoJSONPolygon} object Object.
   * @return {Polygon} Polygon.
   */
  function readPolygonGeometry(object) {
      return new Polygon(object['coordinates']);
  }
  /**
   * @param {import("../geom/Geometry.js").default} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
   * @return {GeoJSONGeometry} GeoJSON geometry.
   */
  function writeGeometry(geometry, opt_options) {
      geometry = transformGeometryWithOptions(geometry, true, opt_options);
      var type = geometry.getType();
      /** @type {GeoJSONGeometry} */
      var geoJSON;
      switch (type) {
          case GeometryType.POINT: {
              geoJSON = writePointGeometry(
              /** @type {Point} */ (geometry));
              break;
          }
          case GeometryType.LINE_STRING: {
              geoJSON = writeLineStringGeometry(
              /** @type {LineString} */ (geometry));
              break;
          }
          case GeometryType.POLYGON: {
              geoJSON = writePolygonGeometry(
              /** @type {Polygon} */ (geometry), opt_options);
              break;
          }
          case GeometryType.MULTI_POINT: {
              geoJSON = writeMultiPointGeometry(
              /** @type {MultiPoint} */ (geometry));
              break;
          }
          case GeometryType.MULTI_LINE_STRING: {
              geoJSON = writeMultiLineStringGeometry(
              /** @type {MultiLineString} */ (geometry));
              break;
          }
          case GeometryType.MULTI_POLYGON: {
              geoJSON = writeMultiPolygonGeometry(
              /** @type {MultiPolygon} */ (geometry), opt_options);
              break;
          }
          case GeometryType.GEOMETRY_COLLECTION: {
              geoJSON = writeGeometryCollectionGeometry(
              /** @type {GeometryCollection} */ (geometry), opt_options);
              break;
          }
          case GeometryType.CIRCLE: {
              geoJSON = {
                  type: 'GeometryCollection',
                  geometries: [],
              };
              break;
          }
          default: {
              throw new Error('Unsupported geometry type: ' + type);
          }
      }
      return geoJSON;
  }
  /**
   * @param {GeometryCollection} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
   * @return {GeoJSONGeometryCollection} GeoJSON geometry collection.
   */
  function writeGeometryCollectionGeometry(geometry, opt_options) {
      var geometries = geometry.getGeometriesArray().map(function (geometry) {
          var options = assign({}, opt_options);
          delete options.featureProjection;
          return writeGeometry(geometry, options);
      });
      return {
          type: 'GeometryCollection',
          geometries: geometries,
      };
  }
  /**
   * @param {LineString} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
   * @return {GeoJSONGeometry} GeoJSON geometry.
   */
  function writeLineStringGeometry(geometry, opt_options) {
      return {
          type: 'LineString',
          coordinates: geometry.getCoordinates(),
      };
  }
  /**
   * @param {MultiLineString} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
   * @return {GeoJSONGeometry} GeoJSON geometry.
   */
  function writeMultiLineStringGeometry(geometry, opt_options) {
      return {
          type: 'MultiLineString',
          coordinates: geometry.getCoordinates(),
      };
  }
  /**
   * @param {MultiPoint} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
   * @return {GeoJSONGeometry} GeoJSON geometry.
   */
  function writeMultiPointGeometry(geometry, opt_options) {
      return {
          type: 'MultiPoint',
          coordinates: geometry.getCoordinates(),
      };
  }
  /**
   * @param {MultiPolygon} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
   * @return {GeoJSONGeometry} GeoJSON geometry.
   */
  function writeMultiPolygonGeometry(geometry, opt_options) {
      var right;
      if (opt_options) {
          right = opt_options.rightHanded;
      }
      return {
          type: 'MultiPolygon',
          coordinates: geometry.getCoordinates(right),
      };
  }
  /**
   * @param {Point} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
   * @return {GeoJSONGeometry} GeoJSON geometry.
   */
  function writePointGeometry(geometry, opt_options) {
      return {
          type: 'Point',
          coordinates: geometry.getCoordinates(),
      };
  }
  /**
   * @param {Polygon} geometry Geometry.
   * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
   * @return {GeoJSONGeometry} GeoJSON geometry.
   */
  function writePolygonGeometry(geometry, opt_options) {
      var right;
      if (opt_options) {
          right = opt_options.rightHanded;
      }
      return {
          type: 'Polygon',
          coordinates: geometry.getCoordinates(right),
      };
  }

  var __extends$1q = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * Base class for text feature formats.
   *
   * @abstract
   */
  var TextFeature = /** @class */ (function (_super) {
      __extends$1q(TextFeature, _super);
      function TextFeature() {
          return _super.call(this) || this;
      }
      /**
       * @return {import("./FormatType.js").default} Format.
       */
      TextFeature.prototype.getType = function () {
          return FormatType.TEXT;
      };
      /**
       * Read the feature from the source.
       *
       * @param {Document|Element|Object|string} source Source.
       * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
       * @return {import("../Feature.js").default} Feature.
       * @api
       */
      TextFeature.prototype.readFeature = function (source, opt_options) {
          return this.readFeatureFromText(getText(source), this.adaptOptions(opt_options));
      };
      /**
       * @abstract
       * @param {string} text Text.
       * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
       * @protected
       * @return {import("../Feature.js").default} Feature.
       */
      TextFeature.prototype.readFeatureFromText = function (text, opt_options) {
          return abstract();
      };
      /**
       * Read the features from the source.
       *
       * @param {Document|Element|Object|string} source Source.
       * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
       * @return {Array<import("../Feature.js").default>} Features.
       * @api
       */
      TextFeature.prototype.readFeatures = function (source, opt_options) {
          return this.readFeaturesFromText(getText(source), this.adaptOptions(opt_options));
      };
      /**
       * @abstract
       * @param {string} text Text.
       * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
       * @protected
       * @return {Array<import("../Feature.js").default>} Features.
       */
      TextFeature.prototype.readFeaturesFromText = function (text, opt_options) {
          return abstract();
      };
      /**
       * Read the geometry from the source.
       *
       * @param {Document|Element|Object|string} source Source.
       * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
       * @return {import("../geom/Geometry.js").default} Geometry.
       * @api
       */
      TextFeature.prototype.readGeometry = function (source, opt_options) {
          return this.readGeometryFromText(getText(source), this.adaptOptions(opt_options));
      };
      /**
       * @abstract
       * @param {string} text Text.
       * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
       * @protected
       * @return {import("../geom/Geometry.js").default} Geometry.
       */
      TextFeature.prototype.readGeometryFromText = function (text, opt_options) {
          return abstract();
      };
      /**
       * Read the projection from the source.
       *
       * @param {Document|Element|Object|string} source Source.
       * @return {import("../proj/Projection.js").default} Projection.
       * @api
       */
      TextFeature.prototype.readProjection = function (source) {
          return this.readProjectionFromText(getText(source));
      };
      /**
       * @param {string} text Text.
       * @protected
       * @return {import("../proj/Projection.js").default} Projection.
       */
      TextFeature.prototype.readProjectionFromText = function (text) {
          return this.dataProjection;
      };
      /**
       * Encode a feature as a string.
       *
       * @param {import("../Feature.js").default} feature Feature.
       * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
       * @return {string} Encoded feature.
       * @api
       */
      TextFeature.prototype.writeFeature = function (feature, opt_options) {
          return this.writeFeatureText(feature, this.adaptOptions(opt_options));
      };
      /**
       * @abstract
       * @param {import("../Feature.js").default} feature Features.
       * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
       * @protected
       * @return {string} Text.
       */
      TextFeature.prototype.writeFeatureText = function (feature, opt_options) {
          return abstract();
      };
      /**
       * Encode an array of features as string.
       *
       * @param {Array<import("../Feature.js").default>} features Features.
       * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
       * @return {string} Encoded features.
       * @api
       */
      TextFeature.prototype.writeFeatures = function (features, opt_options) {
          return this.writeFeaturesText(features, this.adaptOptions(opt_options));
      };
      /**
       * @abstract
       * @param {Array<import("../Feature.js").default>} features Features.
       * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
       * @protected
       * @return {string} Text.
       */
      TextFeature.prototype.writeFeaturesText = function (features, opt_options) {
          return abstract();
      };
      /**
       * Write a single geometry.
       *
       * @param {import("../geom/Geometry.js").default} geometry Geometry.
       * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
       * @return {string} Geometry.
       * @api
       */
      TextFeature.prototype.writeGeometry = function (geometry, opt_options) {
          return this.writeGeometryText(geometry, this.adaptOptions(opt_options));
      };
      /**
       * @abstract
       * @param {import("../geom/Geometry.js").default} geometry Geometry.
       * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
       * @protected
       * @return {string} Text.
       */
      TextFeature.prototype.writeGeometryText = function (geometry, opt_options) {
          return abstract();
      };
      return TextFeature;
  }(FeatureFormat));
  /**
   * @param {Document|Element|Object|string} source Source.
   * @return {string} Text.
   */
  function getText(source) {
      if (typeof source === 'string') {
          return source;
      }
      else {
          return '';
      }
  }

  var __extends$1r = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {import("topojson-specification").Topology} TopoJSONTopology
   * @typedef {import("topojson-specification").GeometryCollection} TopoJSONGeometryCollection
   * @typedef {import("topojson-specification").GeometryObject} TopoJSONGeometry
   * @typedef {import("topojson-specification").Point} TopoJSONPoint
   * @typedef {import("topojson-specification").MultiPoint} TopoJSONMultiPoint
   * @typedef {import("topojson-specification").LineString} TopoJSONLineString
   * @typedef {import("topojson-specification").MultiLineString} TopoJSONMultiLineString
   * @typedef {import("topojson-specification").Polygon} TopoJSONPolygon
   * @typedef {import("topojson-specification").MultiPolygon} TopoJSONMultiPolygon
   */
  /**
   * @typedef {Object} Options
   * @property {import("../proj.js").ProjectionLike} [dataProjection='EPSG:4326'] Default data projection.
   * @property {string} [layerName] Set the name of the TopoJSON topology
   * `objects`'s children as feature property with the specified name. This means
   * that when set to `'layer'`, a topology like
   * ```
   * {
   *   "type": "Topology",
   *   "objects": {
   *     "example": {
   *       "type": "GeometryCollection",
   *       "geometries": []
   *     }
   *   }
   * }
   * ```
   * will result in features that have a property `'layer'` set to `'example'`.
   * When not set, no property will be added to features.
   * @property {Array<string>} [layers] Names of the TopoJSON topology's
   * `objects`'s children to read features from.  If not provided, features will
   * be read from all children.
   */
  /**
   * @classdesc
   * Feature format for reading data in the TopoJSON format.
   *
   * @api
   */
  var TopoJSON = /** @class */ (function (_super) {
      __extends$1r(TopoJSON, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function TopoJSON(opt_options) {
          var _this = _super.call(this) || this;
          var options = opt_options ? opt_options : {};
          /**
           * @private
           * @type {string|undefined}
           */
          _this.layerName_ = options.layerName;
          /**
           * @private
           * @type {?Array<string>}
           */
          _this.layers_ = options.layers ? options.layers : null;
          /**
           * @type {import("../proj/Projection.js").default}
           */
          _this.dataProjection = get$2(options.dataProjection ? options.dataProjection : 'EPSG:4326');
          return _this;
      }
      /**
       * @param {Object} object Object.
       * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
       * @protected
       * @return {Array<Feature>} Features.
       */
      TopoJSON.prototype.readFeaturesFromObject = function (object, opt_options) {
          if (object.type == 'Topology') {
              var topoJSONTopology = /** @type {TopoJSONTopology} */ (object);
              var transform = void 0, scale = null, translate = null;
              if (topoJSONTopology['transform']) {
                  transform = topoJSONTopology['transform'];
                  scale = transform['scale'];
                  translate = transform['translate'];
              }
              var arcs = topoJSONTopology['arcs'];
              if (transform) {
                  transformArcs(arcs, scale, translate);
              }
              /** @type {Array<Feature>} */
              var features = [];
              var topoJSONFeatures = topoJSONTopology['objects'];
              var property = this.layerName_;
              var feature = void 0;
              for (var objectName in topoJSONFeatures) {
                  if (this.layers_ && this.layers_.indexOf(objectName) == -1) {
                      continue;
                  }
                  if (topoJSONFeatures[objectName].type === 'GeometryCollection') {
                      feature = /** @type {TopoJSONGeometryCollection} */ (topoJSONFeatures[objectName]);
                      features.push.apply(features, readFeaturesFromGeometryCollection(feature, arcs, scale, translate, property, objectName, opt_options));
                  }
                  else {
                      feature = /** @type {TopoJSONGeometry} */ (topoJSONFeatures[objectName]);
                      features.push(readFeatureFromGeometry(feature, arcs, scale, translate, property, objectName, opt_options));
                  }
              }
              return features;
          }
          else {
              return [];
          }
      };
      /**
       * @param {Object} object Object.
       * @protected
       * @return {import("../proj/Projection.js").default} Projection.
       */
      TopoJSON.prototype.readProjectionFromObject = function (object) {
          return this.dataProjection;
      };
      return TopoJSON;
  }(JSONFeature));
  /**
   * @const
   * @type {Object<string, function(TopoJSONGeometry, Array, ...Array=): import("../geom/Geometry.js").default>}
   */
  var GEOMETRY_READERS = {
      'Point': readPointGeometry$1,
      'LineString': readLineStringGeometry$1,
      'Polygon': readPolygonGeometry$1,
      'MultiPoint': readMultiPointGeometry$1,
      'MultiLineString': readMultiLineStringGeometry$1,
      'MultiPolygon': readMultiPolygonGeometry$1,
  };
  /**
   * Concatenate arcs into a coordinate array.
   * @param {Array<number>} indices Indices of arcs to concatenate.  Negative
   *     values indicate arcs need to be reversed.
   * @param {Array<Array<import("../coordinate.js").Coordinate>>} arcs Array of arcs (already
   *     transformed).
   * @return {Array<import("../coordinate.js").Coordinate>} Coordinates array.
   */
  function concatenateArcs(indices, arcs) {
      /** @type {Array<import("../coordinate.js").Coordinate>} */
      var coordinates = [];
      var index, arc;
      for (var i = 0, ii = indices.length; i < ii; ++i) {
          index = indices[i];
          if (i > 0) {
              // splicing together arcs, discard last point
              coordinates.pop();
          }
          if (index >= 0) {
              // forward arc
              arc = arcs[index];
          }
          else {
              // reverse arc
              arc = arcs[~index].slice().reverse();
          }
          coordinates.push.apply(coordinates, arc);
      }
      // provide fresh copies of coordinate arrays
      for (var j = 0, jj = coordinates.length; j < jj; ++j) {
          coordinates[j] = coordinates[j].slice();
      }
      return coordinates;
  }
  /**
   * Create a point from a TopoJSON geometry object.
   *
   * @param {TopoJSONPoint} object TopoJSON object.
   * @param {Array<number>} scale Scale for each dimension.
   * @param {Array<number>} translate Translation for each dimension.
   * @return {Point} Geometry.
   */
  function readPointGeometry$1(object, scale, translate) {
      var coordinates = object['coordinates'];
      if (scale && translate) {
          transformVertex(coordinates, scale, translate);
      }
      return new Point(coordinates);
  }
  /**
   * Create a multi-point from a TopoJSON geometry object.
   *
   * @param {TopoJSONMultiPoint} object TopoJSON object.
   * @param {Array<number>} scale Scale for each dimension.
   * @param {Array<number>} translate Translation for each dimension.
   * @return {MultiPoint} Geometry.
   */
  function readMultiPointGeometry$1(object, scale, translate) {
      var coordinates = object['coordinates'];
      if (scale && translate) {
          for (var i = 0, ii = coordinates.length; i < ii; ++i) {
              transformVertex(coordinates[i], scale, translate);
          }
      }
      return new MultiPoint(coordinates);
  }
  /**
   * Create a linestring from a TopoJSON geometry object.
   *
   * @param {TopoJSONLineString} object TopoJSON object.
   * @param {Array<Array<import("../coordinate.js").Coordinate>>} arcs Array of arcs.
   * @return {LineString} Geometry.
   */
  function readLineStringGeometry$1(object, arcs) {
      var coordinates = concatenateArcs(object['arcs'], arcs);
      return new LineString(coordinates);
  }
  /**
   * Create a multi-linestring from a TopoJSON geometry object.
   *
   * @param {TopoJSONMultiLineString} object TopoJSON object.
   * @param {Array<Array<import("../coordinate.js").Coordinate>>} arcs Array of arcs.
   * @return {MultiLineString} Geometry.
   */
  function readMultiLineStringGeometry$1(object, arcs) {
      var coordinates = [];
      for (var i = 0, ii = object['arcs'].length; i < ii; ++i) {
          coordinates[i] = concatenateArcs(object['arcs'][i], arcs);
      }
      return new MultiLineString(coordinates);
  }
  /**
   * Create a polygon from a TopoJSON geometry object.
   *
   * @param {TopoJSONPolygon} object TopoJSON object.
   * @param {Array<Array<import("../coordinate.js").Coordinate>>} arcs Array of arcs.
   * @return {Polygon} Geometry.
   */
  function readPolygonGeometry$1(object, arcs) {
      var coordinates = [];
      for (var i = 0, ii = object['arcs'].length; i < ii; ++i) {
          coordinates[i] = concatenateArcs(object['arcs'][i], arcs);
      }
      return new Polygon(coordinates);
  }
  /**
   * Create a multi-polygon from a TopoJSON geometry object.
   *
   * @param {TopoJSONMultiPolygon} object TopoJSON object.
   * @param {Array<Array<import("../coordinate.js").Coordinate>>} arcs Array of arcs.
   * @return {MultiPolygon} Geometry.
   */
  function readMultiPolygonGeometry$1(object, arcs) {
      var coordinates = [];
      for (var i = 0, ii = object['arcs'].length; i < ii; ++i) {
          // for each polygon
          var polyArray = object['arcs'][i];
          var ringCoords = [];
          for (var j = 0, jj = polyArray.length; j < jj; ++j) {
              // for each ring
              ringCoords[j] = concatenateArcs(polyArray[j], arcs);
          }
          coordinates[i] = ringCoords;
      }
      return new MultiPolygon(coordinates);
  }
  /**
   * Create features from a TopoJSON GeometryCollection object.
   *
   * @param {TopoJSONGeometryCollection} collection TopoJSON Geometry
   *     object.
   * @param {Array<Array<import("../coordinate.js").Coordinate>>} arcs Array of arcs.
   * @param {Array<number>} scale Scale for each dimension.
   * @param {Array<number>} translate Translation for each dimension.
   * @param {string|undefined} property Property to set the `GeometryCollection`'s parent
   *     object to.
   * @param {string} name Name of the `Topology`'s child object.
   * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
   * @return {Array<Feature>} Array of features.
   */
  function readFeaturesFromGeometryCollection(collection, arcs, scale, translate, property, name, opt_options) {
      var geometries = collection['geometries'];
      var features = [];
      for (var i = 0, ii = geometries.length; i < ii; ++i) {
          features[i] = readFeatureFromGeometry(geometries[i], arcs, scale, translate, property, name, opt_options);
      }
      return features;
  }
  /**
   * Create a feature from a TopoJSON geometry object.
   *
   * @param {TopoJSONGeometry} object TopoJSON geometry object.
   * @param {Array<Array<import("../coordinate.js").Coordinate>>} arcs Array of arcs.
   * @param {Array<number>} scale Scale for each dimension.
   * @param {Array<number>} translate Translation for each dimension.
   * @param {string|undefined} property Property to set the `GeometryCollection`'s parent
   *     object to.
   * @param {string} name Name of the `Topology`'s child object.
   * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
   * @return {Feature} Feature.
   */
  function readFeatureFromGeometry(object, arcs, scale, translate, property, name, opt_options) {
      var geometry;
      var type = object.type;
      var geometryReader = GEOMETRY_READERS[type];
      if (type === 'Point' || type === 'MultiPoint') {
          geometry = geometryReader(object, scale, translate);
      }
      else {
          geometry = geometryReader(object, arcs);
      }
      var feature = new Feature();
      feature.setGeometry(transformGeometryWithOptions(geometry, false, opt_options));
      if (object.id !== undefined) {
          feature.setId(object.id);
      }
      var properties = object.properties;
      if (property) {
          if (!properties) {
              properties = {};
          }
          properties[property] = name;
      }
      if (properties) {
          feature.setProperties(properties, true);
      }
      return feature;
  }
  /**
   * Apply a linear transform to array of arcs.  The provided array of arcs is
   * modified in place.
   *
   * @param {Array<Array<import("../coordinate.js").Coordinate>>} arcs Array of arcs.
   * @param {Array<number>} scale Scale for each dimension.
   * @param {Array<number>} translate Translation for each dimension.
   */
  function transformArcs(arcs, scale, translate) {
      for (var i = 0, ii = arcs.length; i < ii; ++i) {
          transformArc(arcs[i], scale, translate);
      }
  }
  /**
   * Apply a linear transform to an arc.  The provided arc is modified in place.
   *
   * @param {Array<import("../coordinate.js").Coordinate>} arc Arc.
   * @param {Array<number>} scale Scale for each dimension.
   * @param {Array<number>} translate Translation for each dimension.
   */
  function transformArc(arc, scale, translate) {
      var x = 0;
      var y = 0;
      for (var i = 0, ii = arc.length; i < ii; ++i) {
          var vertex = arc[i];
          x += vertex[0];
          y += vertex[1];
          vertex[0] = x;
          vertex[1] = y;
          transformVertex(vertex, scale, translate);
      }
  }
  /**
   * Apply a linear transform to a vertex.  The provided vertex is modified in
   * place.
   *
   * @param {import("../coordinate.js").Coordinate} vertex Vertex.
   * @param {Array<number>} scale Scale for each dimension.
   * @param {Array<number>} translate Translation for each dimension.
   */
  function transformVertex(vertex, scale, translate) {
      vertex[0] = vertex[0] * scale[0] + translate[0];
      vertex[1] = vertex[1] * scale[1] + translate[1];
  }

  var __extends$1s = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * Geometry constructors
   * @enum {function (new:import("../geom/Geometry.js").default, Array, import("../geom/GeometryLayout.js").default)}
   */
  var GeometryConstructor = {
      'POINT': Point,
      'LINESTRING': LineString,
      'POLYGON': Polygon,
      'MULTIPOINT': MultiPoint,
      'MULTILINESTRING': MultiLineString,
      'MULTIPOLYGON': MultiPolygon,
  };
  /**
   * @typedef {Object} Options
   * @property {boolean} [splitCollection=false] Whether to split GeometryCollections into
   * multiple features on reading.
   */
  /**
   * @typedef {Object} Token
   * @property {number} type
   * @property {number|string} [value]
   * @property {number} position
   */
  /**
   * @const
   * @type {string}
   */
  var EMPTY = 'EMPTY';
  /**
   * @const
   * @type {string}
   */
  var Z$1 = 'Z';
  /**
   * @const
   * @type {string}
   */
  var M = 'M';
  /**
   * @const
   * @type {string}
   */
  var ZM = 'ZM';
  /**
   * @const
   * @enum {number}
   */
  var TokenType = {
      TEXT: 1,
      LEFT_PAREN: 2,
      RIGHT_PAREN: 3,
      NUMBER: 4,
      COMMA: 5,
      EOF: 6,
  };
  /**
   * @const
   * @type {Object<string, string>}
   */
  var WKTGeometryType = {};
  for (var type in GeometryType) {
      WKTGeometryType[type] = GeometryType[type].toUpperCase();
  }
  /**
   * Class to tokenize a WKT string.
   */
  var Lexer = /** @class */ (function () {
      /**
       * @param {string} wkt WKT string.
       */
      function Lexer(wkt) {
          /**
           * @type {string}
           */
          this.wkt = wkt;
          /**
           * @type {number}
           * @private
           */
          this.index_ = -1;
      }
      /**
       * @param {string} c Character.
       * @return {boolean} Whether the character is alphabetic.
       * @private
       */
      Lexer.prototype.isAlpha_ = function (c) {
          return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z');
      };
      /**
       * @param {string} c Character.
       * @param {boolean=} opt_decimal Whether the string number
       *     contains a dot, i.e. is a decimal number.
       * @return {boolean} Whether the character is numeric.
       * @private
       */
      Lexer.prototype.isNumeric_ = function (c, opt_decimal) {
          var decimal = opt_decimal !== undefined ? opt_decimal : false;
          return (c >= '0' && c <= '9') || (c == '.' && !decimal);
      };
      /**
       * @param {string} c Character.
       * @return {boolean} Whether the character is whitespace.
       * @private
       */
      Lexer.prototype.isWhiteSpace_ = function (c) {
          return c == ' ' || c == '\t' || c == '\r' || c == '\n';
      };
      /**
       * @return {string} Next string character.
       * @private
       */
      Lexer.prototype.nextChar_ = function () {
          return this.wkt.charAt(++this.index_);
      };
      /**
       * Fetch and return the next token.
       * @return {!Token} Next string token.
       */
      Lexer.prototype.nextToken = function () {
          var c = this.nextChar_();
          var position = this.index_;
          /** @type {number|string} */
          var value = c;
          var type;
          if (c == '(') {
              type = TokenType.LEFT_PAREN;
          }
          else if (c == ',') {
              type = TokenType.COMMA;
          }
          else if (c == ')') {
              type = TokenType.RIGHT_PAREN;
          }
          else if (this.isNumeric_(c) || c == '-') {
              type = TokenType.NUMBER;
              value = this.readNumber_();
          }
          else if (this.isAlpha_(c)) {
              type = TokenType.TEXT;
              value = this.readText_();
          }
          else if (this.isWhiteSpace_(c)) {
              return this.nextToken();
          }
          else if (c === '') {
              type = TokenType.EOF;
          }
          else {
              throw new Error('Unexpected character: ' + c);
          }
          return { position: position, value: value, type: type };
      };
      /**
       * @return {number} Numeric token value.
       * @private
       */
      Lexer.prototype.readNumber_ = function () {
          var c;
          var index = this.index_;
          var decimal = false;
          var scientificNotation = false;
          do {
              if (c == '.') {
                  decimal = true;
              }
              else if (c == 'e' || c == 'E') {
                  scientificNotation = true;
              }
              c = this.nextChar_();
          } while (this.isNumeric_(c, decimal) ||
              // if we haven't detected a scientific number before, 'e' or 'E'
              // hint that we should continue to read
              (!scientificNotation && (c == 'e' || c == 'E')) ||
              // once we know that we have a scientific number, both '-' and '+'
              // are allowed
              (scientificNotation && (c == '-' || c == '+')));
          return parseFloat(this.wkt.substring(index, this.index_--));
      };
      /**
       * @return {string} String token value.
       * @private
       */
      Lexer.prototype.readText_ = function () {
          var c;
          var index = this.index_;
          do {
              c = this.nextChar_();
          } while (this.isAlpha_(c));
          return this.wkt.substring(index, this.index_--).toUpperCase();
      };
      return Lexer;
  }());
  /**
   * Class to parse the tokens from the WKT string.
   */
  var Parser$1 = /** @class */ (function () {
      /**
       * @param {Lexer} lexer The lexer.
       */
      function Parser(lexer) {
          /**
           * @type {Lexer}
           * @private
           */
          this.lexer_ = lexer;
          /**
           * @type {Token}
           * @private
           */
          this.token_;
          /**
           * @type {import("../geom/GeometryLayout.js").default}
           * @private
           */
          this.layout_ = GeometryLayout.XY;
      }
      /**
       * Fetch the next token form the lexer and replace the active token.
       * @private
       */
      Parser.prototype.consume_ = function () {
          this.token_ = this.lexer_.nextToken();
      };
      /**
       * Tests if the given type matches the type of the current token.
       * @param {TokenType} type Token type.
       * @return {boolean} Whether the token matches the given type.
       */
      Parser.prototype.isTokenType = function (type) {
          var isMatch = this.token_.type == type;
          return isMatch;
      };
      /**
       * If the given type matches the current token, consume it.
       * @param {TokenType} type Token type.
       * @return {boolean} Whether the token matches the given type.
       */
      Parser.prototype.match = function (type) {
          var isMatch = this.isTokenType(type);
          if (isMatch) {
              this.consume_();
          }
          return isMatch;
      };
      /**
       * Try to parse the tokens provided by the lexer.
       * @return {import("../geom/Geometry.js").default} The geometry.
       */
      Parser.prototype.parse = function () {
          this.consume_();
          var geometry = this.parseGeometry_();
          return geometry;
      };
      /**
       * Try to parse the dimensional info.
       * @return {import("../geom/GeometryLayout.js").default} The layout.
       * @private
       */
      Parser.prototype.parseGeometryLayout_ = function () {
          var layout = GeometryLayout.XY;
          var dimToken = this.token_;
          if (this.isTokenType(TokenType.TEXT)) {
              var dimInfo = dimToken.value;
              if (dimInfo === Z$1) {
                  layout = GeometryLayout.XYZ;
              }
              else if (dimInfo === M) {
                  layout = GeometryLayout.XYM;
              }
              else if (dimInfo === ZM) {
                  layout = GeometryLayout.XYZM;
              }
              if (layout !== GeometryLayout.XY) {
                  this.consume_();
              }
          }
          return layout;
      };
      /**
       * @return {!Array<import("../geom/Geometry.js").default>} A collection of geometries.
       * @private
       */
      Parser.prototype.parseGeometryCollectionText_ = function () {
          if (this.match(TokenType.LEFT_PAREN)) {
              var geometries = [];
              do {
                  geometries.push(this.parseGeometry_());
              } while (this.match(TokenType.COMMA));
              if (this.match(TokenType.RIGHT_PAREN)) {
                  return geometries;
              }
          }
          else if (this.isEmptyGeometry_()) {
              return [];
          }
          throw new Error(this.formatErrorMessage_());
      };
      /**
       * @return {Array<number>} All values in a point.
       * @private
       */
      Parser.prototype.parsePointText_ = function () {
          if (this.match(TokenType.LEFT_PAREN)) {
              var coordinates = this.parsePoint_();
              if (this.match(TokenType.RIGHT_PAREN)) {
                  return coordinates;
              }
          }
          else if (this.isEmptyGeometry_()) {
              return null;
          }
          throw new Error(this.formatErrorMessage_());
      };
      /**
       * @return {!Array<!Array<number>>} All points in a linestring.
       * @private
       */
      Parser.prototype.parseLineStringText_ = function () {
          if (this.match(TokenType.LEFT_PAREN)) {
              var coordinates = this.parsePointList_();
              if (this.match(TokenType.RIGHT_PAREN)) {
                  return coordinates;
              }
          }
          else if (this.isEmptyGeometry_()) {
              return [];
          }
          throw new Error(this.formatErrorMessage_());
      };
      /**
       * @return {!Array<!Array<!Array<number>>>} All points in a polygon.
       * @private
       */
      Parser.prototype.parsePolygonText_ = function () {
          if (this.match(TokenType.LEFT_PAREN)) {
              var coordinates = this.parseLineStringTextList_();
              if (this.match(TokenType.RIGHT_PAREN)) {
                  return coordinates;
              }
          }
          else if (this.isEmptyGeometry_()) {
              return [];
          }
          throw new Error(this.formatErrorMessage_());
      };
      /**
       * @return {!Array<!Array<number>>} All points in a multipoint.
       * @private
       */
      Parser.prototype.parseMultiPointText_ = function () {
          if (this.match(TokenType.LEFT_PAREN)) {
              var coordinates = void 0;
              if (this.token_.type == TokenType.LEFT_PAREN) {
                  coordinates = this.parsePointTextList_();
              }
              else {
                  coordinates = this.parsePointList_();
              }
              if (this.match(TokenType.RIGHT_PAREN)) {
                  return coordinates;
              }
          }
          else if (this.isEmptyGeometry_()) {
              return [];
          }
          throw new Error(this.formatErrorMessage_());
      };
      /**
       * @return {!Array<!Array<!Array<number>>>} All linestring points
       *                                          in a multilinestring.
       * @private
       */
      Parser.prototype.parseMultiLineStringText_ = function () {
          if (this.match(TokenType.LEFT_PAREN)) {
              var coordinates = this.parseLineStringTextList_();
              if (this.match(TokenType.RIGHT_PAREN)) {
                  return coordinates;
              }
          }
          else if (this.isEmptyGeometry_()) {
              return [];
          }
          throw new Error(this.formatErrorMessage_());
      };
      /**
       * @return {!Array<!Array<!Array<!Array<number>>>>} All polygon points in a multipolygon.
       * @private
       */
      Parser.prototype.parseMultiPolygonText_ = function () {
          if (this.match(TokenType.LEFT_PAREN)) {
              var coordinates = this.parsePolygonTextList_();
              if (this.match(TokenType.RIGHT_PAREN)) {
                  return coordinates;
              }
          }
          else if (this.isEmptyGeometry_()) {
              return [];
          }
          throw new Error(this.formatErrorMessage_());
      };
      /**
       * @return {!Array<number>} A point.
       * @private
       */
      Parser.prototype.parsePoint_ = function () {
          var coordinates = [];
          var dimensions = this.layout_.length;
          for (var i = 0; i < dimensions; ++i) {
              var token = this.token_;
              if (this.match(TokenType.NUMBER)) {
                  coordinates.push(/** @type {number} */ (token.value));
              }
              else {
                  break;
              }
          }
          if (coordinates.length == dimensions) {
              return coordinates;
          }
          throw new Error(this.formatErrorMessage_());
      };
      /**
       * @return {!Array<!Array<number>>} An array of points.
       * @private
       */
      Parser.prototype.parsePointList_ = function () {
          var coordinates = [this.parsePoint_()];
          while (this.match(TokenType.COMMA)) {
              coordinates.push(this.parsePoint_());
          }
          return coordinates;
      };
      /**
       * @return {!Array<!Array<number>>} An array of points.
       * @private
       */
      Parser.prototype.parsePointTextList_ = function () {
          var coordinates = [this.parsePointText_()];
          while (this.match(TokenType.COMMA)) {
              coordinates.push(this.parsePointText_());
          }
          return coordinates;
      };
      /**
       * @return {!Array<!Array<!Array<number>>>} An array of points.
       * @private
       */
      Parser.prototype.parseLineStringTextList_ = function () {
          var coordinates = [this.parseLineStringText_()];
          while (this.match(TokenType.COMMA)) {
              coordinates.push(this.parseLineStringText_());
          }
          return coordinates;
      };
      /**
       * @return {!Array<!Array<!Array<!Array<number>>>>} An array of points.
       * @private
       */
      Parser.prototype.parsePolygonTextList_ = function () {
          var coordinates = [this.parsePolygonText_()];
          while (this.match(TokenType.COMMA)) {
              coordinates.push(this.parsePolygonText_());
          }
          return coordinates;
      };
      /**
       * @return {boolean} Whether the token implies an empty geometry.
       * @private
       */
      Parser.prototype.isEmptyGeometry_ = function () {
          var isEmpty = this.isTokenType(TokenType.TEXT) && this.token_.value == EMPTY;
          if (isEmpty) {
              this.consume_();
          }
          return isEmpty;
      };
      /**
       * Create an error message for an unexpected token error.
       * @return {string} Error message.
       * @private
       */
      Parser.prototype.formatErrorMessage_ = function () {
          return ('Unexpected `' +
              this.token_.value +
              '` at position ' +
              this.token_.position +
              ' in `' +
              this.lexer_.wkt +
              '`');
      };
      /**
       * @return {!import("../geom/Geometry.js").default} The geometry.
       * @private
       */
      Parser.prototype.parseGeometry_ = function () {
          var token = this.token_;
          if (this.match(TokenType.TEXT)) {
              var geomType = token.value;
              this.layout_ = this.parseGeometryLayout_();
              if (geomType == 'GEOMETRYCOLLECTION') {
                  var geometries = this.parseGeometryCollectionText_();
                  return new GeometryCollection(geometries);
              }
              else {
                  var ctor = GeometryConstructor[geomType];
                  if (!ctor) {
                      throw new Error('Invalid geometry type: ' + geomType);
                  }
                  var coordinates = void 0;
                  switch (geomType) {
                      case 'POINT': {
                          coordinates = this.parsePointText_();
                          break;
                      }
                      case 'LINESTRING': {
                          coordinates = this.parseLineStringText_();
                          break;
                      }
                      case 'POLYGON': {
                          coordinates = this.parsePolygonText_();
                          break;
                      }
                      case 'MULTIPOINT': {
                          coordinates = this.parseMultiPointText_();
                          break;
                      }
                      case 'MULTILINESTRING': {
                          coordinates = this.parseMultiLineStringText_();
                          break;
                      }
                      case 'MULTIPOLYGON': {
                          coordinates = this.parseMultiPolygonText_();
                          break;
                      }
                      default: {
                          throw new Error('Invalid geometry type: ' + geomType);
                      }
                  }
                  if (!coordinates) {
                      if (ctor === GeometryConstructor['POINT']) {
                          coordinates = [NaN, NaN];
                      }
                      else {
                          coordinates = [];
                      }
                  }
                  return new ctor(coordinates, this.layout_);
              }
          }
          throw new Error(this.formatErrorMessage_());
      };
      return Parser;
  }());
  /**
   * @classdesc
   * Geometry format for reading and writing data in the `WellKnownText` (WKT)
   * format.
   *
   * @api
   */
  var WKT = /** @class */ (function (_super) {
      __extends$1s(WKT, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function WKT(opt_options) {
          var _this = _super.call(this) || this;
          var options = opt_options ? opt_options : {};
          /**
           * Split GeometryCollection into multiple features.
           * @type {boolean}
           * @private
           */
          _this.splitCollection_ =
              options.splitCollection !== undefined ? options.splitCollection : false;
          return _this;
      }
      /**
       * Parse a WKT string.
       * @param {string} wkt WKT string.
       * @return {import("../geom/Geometry.js").default|undefined}
       *     The geometry created.
       * @private
       */
      WKT.prototype.parse_ = function (wkt) {
          var lexer = new Lexer(wkt);
          var parser = new Parser$1(lexer);
          return parser.parse();
      };
      /**
       * @protected
       * @param {string} text Text.
       * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
       * @return {import("../Feature.js").default} Feature.
       */
      WKT.prototype.readFeatureFromText = function (text, opt_options) {
          var geom = this.readGeometryFromText(text, opt_options);
          if (geom) {
              var feature = new Feature();
              feature.setGeometry(geom);
              return feature;
          }
          return null;
      };
      /**
       * @param {string} text Text.
       * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
       * @protected
       * @return {Array<Feature>} Features.
       */
      WKT.prototype.readFeaturesFromText = function (text, opt_options) {
          var geometries = [];
          var geometry = this.readGeometryFromText(text, opt_options);
          if (this.splitCollection_ &&
              geometry.getType() == GeometryType.GEOMETRY_COLLECTION) {
              geometries = /** @type {GeometryCollection} */ (geometry).getGeometriesArray();
          }
          else {
              geometries = [geometry];
          }
          var features = [];
          for (var i = 0, ii = geometries.length; i < ii; ++i) {
              var feature = new Feature();
              feature.setGeometry(geometries[i]);
              features.push(feature);
          }
          return features;
      };
      /**
       * @param {string} text Text.
       * @param {import("./Feature.js").ReadOptions=} opt_options Read options.
       * @protected
       * @return {import("../geom/Geometry.js").default} Geometry.
       */
      WKT.prototype.readGeometryFromText = function (text, opt_options) {
          var geometry = this.parse_(text);
          if (geometry) {
              return transformGeometryWithOptions(geometry, false, opt_options);
          }
          else {
              return null;
          }
      };
      /**
       * @param {import("../Feature.js").default} feature Features.
       * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
       * @protected
       * @return {string} Text.
       */
      WKT.prototype.writeFeatureText = function (feature, opt_options) {
          var geometry = feature.getGeometry();
          if (geometry) {
              return this.writeGeometryText(geometry, opt_options);
          }
          return '';
      };
      /**
       * @param {Array<import("../Feature.js").default>} features Features.
       * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
       * @protected
       * @return {string} Text.
       */
      WKT.prototype.writeFeaturesText = function (features, opt_options) {
          if (features.length == 1) {
              return this.writeFeatureText(features[0], opt_options);
          }
          var geometries = [];
          for (var i = 0, ii = features.length; i < ii; ++i) {
              geometries.push(features[i].getGeometry());
          }
          var collection = new GeometryCollection(geometries);
          return this.writeGeometryText(collection, opt_options);
      };
      /**
       * @param {import("../geom/Geometry.js").default} geometry Geometry.
       * @param {import("./Feature.js").WriteOptions=} opt_options Write options.
       * @protected
       * @return {string} Text.
       */
      WKT.prototype.writeGeometryText = function (geometry, opt_options) {
          return encode$1(transformGeometryWithOptions(geometry, true, opt_options));
      };
      return WKT;
  }(TextFeature));
  /**
   * @param {Point} geom Point geometry.
   * @return {string} Coordinates part of Point as WKT.
   */
  function encodePointGeometry(geom) {
      var coordinates = geom.getCoordinates();
      if (coordinates.length === 0) {
          return '';
      }
      return coordinates.join(' ');
  }
  /**
   * @param {MultiPoint} geom MultiPoint geometry.
   * @return {string} Coordinates part of MultiPoint as WKT.
   */
  function encodeMultiPointGeometry(geom) {
      var array = [];
      var components = geom.getPoints();
      for (var i = 0, ii = components.length; i < ii; ++i) {
          array.push('(' + encodePointGeometry(components[i]) + ')');
      }
      return array.join(',');
  }
  /**
   * @param {GeometryCollection} geom GeometryCollection geometry.
   * @return {string} Coordinates part of GeometryCollection as WKT.
   */
  function encodeGeometryCollectionGeometry(geom) {
      var array = [];
      var geoms = geom.getGeometries();
      for (var i = 0, ii = geoms.length; i < ii; ++i) {
          array.push(encode$1(geoms[i]));
      }
      return array.join(',');
  }
  /**
   * @param {LineString|import("../geom/LinearRing.js").default} geom LineString geometry.
   * @return {string} Coordinates part of LineString as WKT.
   */
  function encodeLineStringGeometry(geom) {
      var coordinates = geom.getCoordinates();
      var array = [];
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
          array.push(coordinates[i].join(' '));
      }
      return array.join(',');
  }
  /**
   * @param {MultiLineString} geom MultiLineString geometry.
   * @return {string} Coordinates part of MultiLineString as WKT.
   */
  function encodeMultiLineStringGeometry(geom) {
      var array = [];
      var components = geom.getLineStrings();
      for (var i = 0, ii = components.length; i < ii; ++i) {
          array.push('(' + encodeLineStringGeometry(components[i]) + ')');
      }
      return array.join(',');
  }
  /**
   * @param {Polygon} geom Polygon geometry.
   * @return {string} Coordinates part of Polygon as WKT.
   */
  function encodePolygonGeometry(geom) {
      var array = [];
      var rings = geom.getLinearRings();
      for (var i = 0, ii = rings.length; i < ii; ++i) {
          array.push('(' + encodeLineStringGeometry(rings[i]) + ')');
      }
      return array.join(',');
  }
  /**
   * @param {MultiPolygon} geom MultiPolygon geometry.
   * @return {string} Coordinates part of MultiPolygon as WKT.
   */
  function encodeMultiPolygonGeometry(geom) {
      var array = [];
      var components = geom.getPolygons();
      for (var i = 0, ii = components.length; i < ii; ++i) {
          array.push('(' + encodePolygonGeometry(components[i]) + ')');
      }
      return array.join(',');
  }
  /**
   * @param {import("../geom/SimpleGeometry.js").default} geom SimpleGeometry geometry.
   * @return {string} Potential dimensional information for WKT type.
   */
  function encodeGeometryLayout(geom) {
      var layout = geom.getLayout();
      var dimInfo = '';
      if (layout === GeometryLayout.XYZ || layout === GeometryLayout.XYZM) {
          dimInfo += Z$1;
      }
      if (layout === GeometryLayout.XYM || layout === GeometryLayout.XYZM) {
          dimInfo += M;
      }
      return dimInfo;
  }
  /**
   * @const
   * @type {Object<string, function(import("../geom/Geometry.js").default): string>}
   */
  var GeometryEncoder = {
      'Point': encodePointGeometry,
      'LineString': encodeLineStringGeometry,
      'Polygon': encodePolygonGeometry,
      'MultiPoint': encodeMultiPointGeometry,
      'MultiLineString': encodeMultiLineStringGeometry,
      'MultiPolygon': encodeMultiPolygonGeometry,
      'GeometryCollection': encodeGeometryCollectionGeometry,
  };
  /**
   * Encode a geometry as WKT.
   * @param {!import("../geom/Geometry.js").default} geom The geometry to encode.
   * @return {string} WKT string for the geometry.
   */
  function encode$1(geom) {
      var type = geom.getType();
      var geometryEncoder = GeometryEncoder[type];
      var enc = geometryEncoder(geom);
      type = type.toUpperCase();
      if (typeof ( /** @type {?} */(geom).getFlatCoordinates) === 'function') {
          var dimInfo = encodeGeometryLayout(
          /** @type {import("../geom/SimpleGeometry.js").default} */ (geom));
          if (dimInfo.length > 0) {
              type += ' ' + dimInfo;
          }
      }
      if (enc.length === 0) {
          return type + ' ' + EMPTY;
      }
      return type + '(' + enc + ')';
  }

  var runtime_1 = createCommonjsModule(function (module) {
  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var runtime = (function (exports) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1; // More compressible than void 0.
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }
    try {
      // IE 8 has a broken Object.defineProperty that only works on DOM objects.
      define({}, "");
    } catch (err) {
      define = function(obj, key, value) {
        return obj[key] = value;
      };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);

      // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.
      generator._invoke = makeInvokeMethod(innerFn, self, context);

      return generator;
    }
    exports.wrap = wrap;

    // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.
    function tryCatch(fn, obj, arg) {
      try {
        return { type: "normal", arg: fn.call(obj, arg) };
      } catch (err) {
        return { type: "throw", arg: err };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";

    // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.
    var ContinueSentinel = {};

    // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}

    // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.
    var IteratorPrototype = {};
    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    if (NativeIteratorPrototype &&
        NativeIteratorPrototype !== Op &&
        hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype =
      Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunction.displayName = define(
      GeneratorFunctionPrototype,
      toStringTagSymbol,
      "GeneratorFunction"
    );

    // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method) {
        define(prototype, method, function(arg) {
          return this._invoke(method, arg);
        });
      });
    }

    exports.isGeneratorFunction = function(genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor
        ? ctor === GeneratorFunction ||
          // For the native GeneratorFunction constructor, the best we can
          // do is to check its .name property.
          (ctor.displayName || ctor.name) === "GeneratorFunction"
        : false;
    };

    exports.mark = function(genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };

    // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.
    exports.awrap = function(arg) {
      return { __await: arg };
    };

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value &&
              typeof value === "object" &&
              hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function(value) {
              invoke("next", value, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return PromiseImpl.resolve(value).then(function(unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration.
            result.value = unwrapped;
            resolve(result);
          }, function(error) {
            // If a rejected Promise was yielded, throw the rejection back
            // into the async generator function so it can be handled there.
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise =
          // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(
            callInvokeWithMethodAndArg,
            // Avoid propagating failures to Promises returned by later
            // invocations of the iterator.
            callInvokeWithMethodAndArg
          ) : callInvokeWithMethodAndArg();
      }

      // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).
      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);
    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };
    exports.AsyncIterator = AsyncIterator;

    // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.
    exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;

      var iter = new AsyncIterator(
        wrap(innerFn, outerFn, self, tryLocsList),
        PromiseImpl
      );

      return exports.isGeneratorFunction(outerFn)
        ? iter // If outerFn is a generator, return the full iterator.
        : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
          });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;

      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }

          // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;

          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);

          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;

          var record = tryCatch(innerFn, self, context);
          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done
              ? GenStateCompleted
              : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };

          } else if (record.type === "throw") {
            state = GenStateCompleted;
            // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }

    // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.
    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];
      if (method === undefined$1) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;

        if (context.method === "throw") {
          // Note: ["return"] must be used for ES3 parsing compatibility.
          if (delegate.iterator["return"]) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError(
            "The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (! info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value;

        // Resume execution at the desired location (see delegateYield).
        context.next = delegate.nextLoc;

        // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.
        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }

      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      }

      // The delegate iterator is finished, so forget it and continue with
      // the outer generator.
      context.delegate = null;
      return ContinueSentinel;
    }

    // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.
    defineIteratorMethods(Gp);

    define(Gp, toStringTagSymbol, "Generator");

    // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.
    Gp[iteratorSymbol] = function() {
      return this;
    };

    Gp.toString = function() {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = { tryLoc: locs[0] };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{ tryLoc: "root" }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    exports.keys = function(object) {
      var keys = [];
      for (var key in object) {
        keys.push(key);
      }
      keys.reverse();

      // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.
      return function next() {
        while (keys.length) {
          var key = keys.pop();
          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        }

        // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.
        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1, next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined$1;
            next.done = true;

            return next;
          };

          return next.next = next;
        }
      }

      // Return an iterator with no values.
      return { next: doneResult };
    }
    exports.values = values;

    function doneResult() {
      return { value: undefined$1, done: true };
    }

    Context.prototype = {
      constructor: Context,

      reset: function(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.
        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;

        this.method = "next";
        this.arg = undefined$1;

        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" &&
                hasOwn.call(this, name) &&
                !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },

      stop: function() {
        this.done = true;

        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },

      dispatchException: function(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined$1;
          }

          return !! caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }

            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }

            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }

            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },

      abrupt: function(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev &&
              hasOwn.call(entry, "finallyLoc") &&
              this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry &&
            (type === "break" ||
             type === "continue") &&
            finallyEntry.tryLoc <= arg &&
            arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },

      complete: function(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" ||
            record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },

      finish: function(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },

      "catch": function(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }

        // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.
        throw new Error("illegal catch attempt");
      },

      delegateYield: function(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined$1;
        }

        return ContinueSentinel;
      }
    };

    // Regardless of whether this script is executing as a CommonJS module
    // or not, return the runtime object so that we can declare the variable
    // regeneratorRuntime in the outer scope, which allows this module to be
    // injected easily by `bin/regenerator --include-runtime script.js`.
    return exports;

  }(
    // If this script is executing as a CommonJS module, use module.exports
    // as the regeneratorRuntime namespace. Otherwise create a new empty
    // object. Either way, the resulting object will be used to initialize
    // the regeneratorRuntime variable at the top of this file.
     module.exports 
  ));

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    // This module should not be running in strict mode, so the above
    // assignment should always work unless something is misconfigured. Just
    // in case runtime.js accidentally runs in strict mode, we can escape
    // strict mode using a global Function call. This could conceivably fail
    // if a Content Security Policy forbids using Function, but in that case
    // the proper solution is to fix the accidental strict mode problem. If
    // you've misconfigured your bundler to force strict mode and applied a
    // CSP to forbid Function, and you're not willing to fix either of those
    // problems, please detail your unique predicament in a GitHub issue.
    Function("r", "regeneratorRuntime = r")(runtime);
  }
  });

  function t(){return (t=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var o in n)Object.prototype.hasOwnProperty.call(n,o)&&(t[o]=n[o]);}return t}).apply(this,arguments)}function e(t){if("undefined"!=typeof window&&window.navigator)return !!navigator.userAgent.match(t)}var n=e(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i),o=e(/Edge/i),i=e(/firefox/i),r=e(/safari/i)&&!e(/chrome/i)&&!e(/android/i),a=e(/iP(ad|od|hone)/i),l=e(/chrome/i)&&e(/android/i),s={capture:!1,passive:!1};function c(t,e,o){t.addEventListener(e,o,!n&&s);}function u(t,e,o){t.removeEventListener(e,o,!n&&s);}function d(t,e){if(e){if(">"===e[0]&&(e=e.substring(1)),t)try{if(t.matches)return t.matches(e);if(t.msMatchesSelector)return t.msMatchesSelector(e);if(t.webkitMatchesSelector)return t.webkitMatchesSelector(e)}catch(t){return !1}return !1}}function h(t){return t.host&&t!==document&&t.host.nodeType?t.host:t.parentNode}function f(t,e,n,o){if(t){n=n||document;do{if(null!=e&&(">"===e[0]?t.parentNode===n&&d(t,e):d(t,e))||o&&t===n)return t;if(t===n)break}while(t=h(t))}return null}var p,g=/\s+/g;function v(t,e,n){if(t&&e)if(t.classList)t.classList[n?"add":"remove"](e);else {var o=(" "+t.className+" ").replace(g," ").replace(" "+e+" "," ");t.className=(o+(n?" "+e:"")).replace(g," ");}}function m(t,e,n){var o=t&&t.style;if(o){if(void 0===n)return document.defaultView&&document.defaultView.getComputedStyle?n=document.defaultView.getComputedStyle(t,""):t.currentStyle&&(n=t.currentStyle),void 0===e?n:n[e];e in o||-1!==e.indexOf("webkit")||(e="-webkit-"+e),o[e]=n+("string"==typeof n?"":"px");}}function b(t,e){var n="";if("string"==typeof t)n=t;else do{var o=m(t,"transform");o&&"none"!==o&&(n=o+" "+n);}while(!e&&(t=t.parentNode));var i=window.DOMMatrix||window.WebKitCSSMatrix||window.CSSMatrix||window.MSCSSMatrix;return i&&new i(n)}function w(t,e,n){if(t){var o=t.getElementsByTagName(e),i=0,r=o.length;if(n)for(;i<r;i++)n(o[i],i);return o}return []}function E(){return document.scrollingElement||document.documentElement}function y(t,e,o,i,r){if(t.getBoundingClientRect||t===window){var a,l,s,c,u,d,h;if(t!==window&&t!==E()?(l=(a=t.getBoundingClientRect()).top,s=a.left,c=a.bottom,u=a.right,d=a.height,h=a.width):(l=0,s=0,c=window.innerHeight,u=window.innerWidth,d=window.innerHeight,h=window.innerWidth),(e||o)&&t!==window&&(r=r||t.parentNode,!n))do{if(r&&r.getBoundingClientRect&&("none"!==m(r,"transform")||o&&"static"!==m(r,"position"))){var f=r.getBoundingClientRect();l-=f.top+parseInt(m(r,"border-top-width")),s-=f.left+parseInt(m(r,"border-left-width")),c=l+a.height,u=s+a.width;break}}while(r=r.parentNode);if(i&&t!==window){var p=b(r||t),g=p&&p.a,v=p&&p.d;p&&(c=(l/=v)+(d/=v),u=(s/=g)+(h/=g));}return {top:l,left:s,bottom:c,right:u,width:h,height:d}}}function D(t,e,n){for(var o=x(t,!0),i=y(t)[e];o;){var r=y(o)[n];if(!("top"===n||"left"===n?i>=r:i<=r))return o;if(o===E())break;o=x(o,!1);}return !1}function _(t,e,n){for(var o=0,i=0,r=t.children;i<r.length;){if("none"!==r[i].style.display&&r[i]!==It.ghost&&r[i]!==It.dragged&&f(r[i],n.draggable,t,!1)){if(o===e)return r[i];o++;}i++;}return null}function S(t,e){for(var n=t.lastElementChild;n&&(n===It.ghost||"none"===m(n,"display")||e&&!d(n,e));)n=n.previousElementSibling;return n||null}function C(t,e){var n=0;if(!t||!t.parentNode)return -1;for(;t=t.previousElementSibling;)"TEMPLATE"===t.nodeName.toUpperCase()||t===It.clone||e&&!d(t,e)||n++;return n}function T(t){var e=0,n=0,o=E();if(t)do{var i=b(t);e+=t.scrollLeft*i.a,n+=t.scrollTop*i.d;}while(t!==o&&(t=t.parentNode));return [e,n]}function x(t,e){if(!t||!t.getBoundingClientRect)return E();var n=t,o=!1;do{if(n.clientWidth<n.scrollWidth||n.clientHeight<n.scrollHeight){var i=m(n);if(n.clientWidth<n.scrollWidth&&("auto"==i.overflowX||"scroll"==i.overflowX)||n.clientHeight<n.scrollHeight&&("auto"==i.overflowY||"scroll"==i.overflowY)){if(!n.getBoundingClientRect||n===document.body)return E();if(o||e)return n;o=!0;}}}while(n=n.parentNode);return E()}function M$1(t,e){return Math.round(t.top)===Math.round(e.top)&&Math.round(t.left)===Math.round(e.left)&&Math.round(t.height)===Math.round(e.height)&&Math.round(t.width)===Math.round(e.width)}function N(t,e){return function(){if(!p){var n=arguments,o=this;1===n.length?t.call(o,n[0]):t.apply(o,n),p=setTimeout(function(){p=void 0;},e);}}}function O$1(t,e,n){t.scrollLeft+=e,t.scrollTop+=n;}function A$1(t){var e=window.Polymer,n=window.jQuery||window.Zepto;return e&&e.dom?e.dom(t).cloneNode(!0):n?n(t).clone(!0)[0]:t.cloneNode(!0)}function I$1(t,e){m(t,"position","absolute"),m(t,"top",e.top),m(t,"left",e.left),m(t,"width",e.width),m(t,"height",e.height);}function P(t){m(t,"position",""),m(t,"top",""),m(t,"left",""),m(t,"width",""),m(t,"height","");}var k="Sortable"+(new Date).getTime(),R=[],X={initializeByDefault:!0},Y={mount:function(t){for(var e in X)X.hasOwnProperty(e)&&!(e in t)&&(t[e]=X[e]);R.push(t);},pluginEvent:function(e,n,o){var i=this;this.eventCanceled=!1,o.cancel=function(){i.eventCanceled=!0;};var r=e+"Global";R.forEach(function(i){n[i.pluginName]&&(n[i.pluginName][r]&&n[i.pluginName][r](t({sortable:n},o)),n.options[i.pluginName]&&n[i.pluginName][e]&&n[i.pluginName][e](t({sortable:n},o)));});},initializePlugins:function(t,e,n,o){for(var i in R.forEach(function(o){var i=o.pluginName;if(t.options[i]||o.initializeByDefault){var r=new o(t,e,t.options);r.sortable=t,r.options=t.options,t[i]=r,Object.assign(n,r.defaults);}}),t.options)if(t.options.hasOwnProperty(i)){var r=this.modifyOption(t,i,t.options[i]);void 0!==r&&(t.options[i]=r);}},getEventProperties:function(t,e){var n={};return R.forEach(function(o){"function"==typeof o.eventProperties&&Object.assign(n,o.eventProperties.call(e[o.pluginName],t));}),n},modifyOption:function(t,e,n){var o;return R.forEach(function(i){t[i.pluginName]&&i.optionListeners&&"function"==typeof i.optionListeners[e]&&(o=i.optionListeners[e].call(t[i.pluginName],n));}),o}};function B(e){var i=e.sortable,r=e.rootEl,a=e.name,l=e.targetEl,s=e.cloneEl,c=e.toEl,u=e.fromEl,d=e.oldIndex,h=e.newIndex,f=e.oldDraggableIndex,p=e.newDraggableIndex,g=e.originalEvent,v=e.putSortable,m=e.extraEventProperties;if(i=i||r&&r[k]){var b,w=i.options,E="on"+a.charAt(0).toUpperCase()+a.substr(1);!window.CustomEvent||n||o?(b=document.createEvent("Event")).initEvent(a,!0,!0):b=new CustomEvent(a,{bubbles:!0,cancelable:!0}),b.to=c||r,b.from=u||r,b.item=l||r,b.clone=s,b.oldIndex=d,b.newIndex=h,b.oldDraggableIndex=f,b.newDraggableIndex=p,b.originalEvent=g,b.pullMode=v?v.lastPutMode:void 0;var y=t({},m,Y.getEventProperties(a,i));for(var D in y)b[D]=y[D];r&&r.dispatchEvent(b),w[E]&&w[E].call(i,b);}}var H=function(e,n,o){var i=void 0===o?{}:o,r=i.evt,a=function(t,e){if(null==t)return {};var n,o,i={},r=Object.keys(t);for(o=0;o<r.length;o++)e.indexOf(n=r[o])>=0||(i[n]=t[n]);return i}(i,["evt"]);Y.pluginEvent.bind(It)(e,n,t({dragEl:L,parentEl:K,ghostEl:W,rootEl:j,nextEl:z,lastDownEl:G,cloneEl:U,cloneHidden:q,dragStarted:lt,putSortable:tt,activeSortable:It.active,originalEvent:r,oldIndex:V$1,oldDraggableIndex:Q,newIndex:Z$2,newDraggableIndex:$,hideGhostForTarget:xt,unhideGhostForTarget:Mt,cloneNowHidden:function(){q=!0;},cloneNowShown:function(){q=!1;},dispatchSortableEvent:function(t){F({sortable:n,name:t,originalEvent:r});}},a));};function F(e){B(t({putSortable:tt,cloneEl:U,targetEl:L,rootEl:j,oldIndex:V$1,oldDraggableIndex:Q,newIndex:Z$2,newDraggableIndex:$},e));}var L,K,W,j,z,G,U,q,V$1,Z$2,Q,$,J,tt,et,nt,ot,it,rt,at,lt,st,ct,ut,dt,ht=!1,ft=!1,pt=[],gt=!1,vt=!1,mt=[],bt=!1,wt=[],Et="undefined"!=typeof document,yt=a,Dt=o||n?"cssFloat":"float",_t=Et&&!l&&!a&&"draggable"in document.createElement("div"),St=function(){if(Et){if(n)return !1;var t=document.createElement("x");return t.style.cssText="pointer-events:auto","auto"===t.style.pointerEvents}}(),Ct=function(t,e){var n=m(t),o=parseInt(n.width)-parseInt(n.paddingLeft)-parseInt(n.paddingRight)-parseInt(n.borderLeftWidth)-parseInt(n.borderRightWidth),i=_(t,0,e),r=_(t,1,e),a=i&&m(i),l=r&&m(r),s=a&&parseInt(a.marginLeft)+parseInt(a.marginRight)+y(i).width,c=l&&parseInt(l.marginLeft)+parseInt(l.marginRight)+y(r).width;return "flex"===n.display?"column"===n.flexDirection||"column-reverse"===n.flexDirection?"vertical":"horizontal":"grid"===n.display?n.gridTemplateColumns.split(" ").length<=1?"vertical":"horizontal":i&&a.float&&"none"!==a.float?!r||"both"!==l.clear&&l.clear!==("left"===a.float?"left":"right")?"horizontal":"vertical":i&&("block"===a.display||"flex"===a.display||"table"===a.display||"grid"===a.display||s>=o&&"none"===n[Dt]||r&&"none"===n[Dt]&&s+c>o)?"vertical":"horizontal"},Tt=function(t){function e(t,n){return function(o,i,r,a){if(null==t&&(n||o.options.group.name&&i.options.group.name&&o.options.group.name===i.options.group.name))return !0;if(null==t||!1===t)return !1;if(n&&"clone"===t)return t;if("function"==typeof t)return e(t(o,i,r,a),n)(o,i,r,a);var l=(n?o:i).options.group.name;return !0===t||"string"==typeof t&&t===l||t.join&&t.indexOf(l)>-1}}var n={},o=t.group;o&&"object"==typeof o||(o={name:o}),n.name=o.name,n.checkPull=e(o.pull,!0),n.checkPut=e(o.put),n.revertClone=o.revertClone,t.group=n;},xt=function(){!St&&W&&m(W,"display","none");},Mt=function(){!St&&W&&m(W,"display","");};Et&&document.addEventListener("click",function(t){if(ft)return t.preventDefault(),t.stopPropagation&&t.stopPropagation(),t.stopImmediatePropagation&&t.stopImmediatePropagation(),ft=!1,!1},!0);var Nt,Ot=function(t){if(L){var e=(i=(t=t.touches?t.touches[0]:t).clientX,r=t.clientY,pt.some(function(t){if(!S(t)){var e=y(t),n=t[k].options.emptyInsertThreshold;return n&&i>=e.left-n&&i<=e.right+n&&r>=e.top-n&&r<=e.bottom+n?a=t:void 0}}),a);if(e){var n={};for(var o in t)t.hasOwnProperty(o)&&(n[o]=t[o]);n.target=n.rootEl=e,n.preventDefault=void 0,n.stopPropagation=void 0,e[k]._onDragOver(n);}}var i,r,a;},At=function(t){L&&L.parentNode[k]._isOutsideThisEl(t.target);};function It(e,n){if(!e||!e.nodeType||1!==e.nodeType)throw "Sortable: `el` must be an HTMLElement, not "+{}.toString.call(e);this.el=e,this.options=n=Object.assign({},n),e[k]=this;var o,i,r={group:null,sort:!0,disabled:!1,store:null,handle:null,draggable:/^[uo]l$/i.test(e.nodeName)?">li":">*",swapThreshold:1,invertSwap:!1,invertedSwapThreshold:null,removeCloneOnHide:!0,direction:function(){return Ct(e,this.options)},ghostClass:"sortable-ghost",chosenClass:"sortable-chosen",dragClass:"sortable-drag",ignore:"a, img",filter:null,preventOnFilter:!0,animation:0,easing:null,setData:function(t,e){t.setData("Text",e.textContent);},dropBubble:!1,dragoverBubble:!1,dataIdAttr:"data-id",delay:0,delayOnTouchOnly:!1,touchStartThreshold:(Number.parseInt?Number:window).parseInt(window.devicePixelRatio,10)||1,forceFallback:!1,fallbackClass:"sortable-fallback",fallbackOnBody:!1,fallbackTolerance:0,fallbackOffset:{x:0,y:0},supportPointer:!1!==It.supportPointer&&"PointerEvent"in window,emptyInsertThreshold:5};for(var a in Y.initializePlugins(this,e,r),r)!(a in n)&&(n[a]=r[a]);for(var l in Tt(n),this)"_"===l.charAt(0)&&"function"==typeof this[l]&&(this[l]=this[l].bind(this));this.nativeDraggable=!n.forceFallback&&_t,this.nativeDraggable&&(this.options.touchStartThreshold=1),n.supportPointer?c(e,"pointerdown",this._onTapStart):(c(e,"mousedown",this._onTapStart),c(e,"touchstart",this._onTapStart)),this.nativeDraggable&&(c(e,"dragover",this),c(e,"dragenter",this)),pt.push(this.el),n.store&&n.store.get&&this.sort(n.store.get(this)||[]),Object.assign(this,(i=[],{captureAnimationState:function(){i=[],this.options.animation&&[].slice.call(this.el.children).forEach(function(e){if("none"!==m(e,"display")&&void 0!==e){i.push({target:e,rect:y(e)});var n=t({},i[i.length-1].rect);if(e.thisAnimationDuration){var o=b(e,!0);o&&(n.top-=o.f,n.left-=o.e);}e.fromRect=n;}});},addAnimationState:function(t){i.push(t);},removeAnimationState:function(t){i.splice(function(t,e){for(var n in t)if(t.hasOwnProperty(n))for(var o in e)if(e.hasOwnProperty(o)&&e[o]===t[n][o])return Number(n);return -1}(i,{target:t}),1);},animateAll:function(t){var e=this;if(!this.options.animation)return clearTimeout(o),void("function"==typeof t&&t());var n=!1,r=0;i.forEach(function(t){var o=0,i=t.target,a=i.fromRect,l=y(i),s=i.prevFromRect,c=i.prevToRect,u=t.rect,d=b(i,!0);d&&(l.top-=d.f,l.left-=d.e),i.toRect=l,i.thisAnimationDuration&&M$1(s,l)&&!M$1(a,l)&&(u.top-l.top)/(u.left-l.left)==(a.top-l.top)/(a.left-l.left)&&(o=function(t,e,n,o){return Math.sqrt(Math.pow(e.top-t.top,2)+Math.pow(e.left-t.left,2))/Math.sqrt(Math.pow(e.top-n.top,2)+Math.pow(e.left-n.left,2))*o.animation}(u,s,c,e.options)),M$1(l,a)||(i.prevFromRect=a,i.prevToRect=l,o||(o=e.options.animation),e.animate(i,u,l,o)),o&&(n=!0,r=Math.max(r,o),clearTimeout(i.animationResetTimer),i.animationResetTimer=setTimeout(function(){i.animationTime=0,i.prevFromRect=null,i.fromRect=null,i.prevToRect=null,i.thisAnimationDuration=null;},o),i.thisAnimationDuration=o);}),clearTimeout(o),n?o=setTimeout(function(){"function"==typeof t&&t();},r):"function"==typeof t&&t(),i=[];},animate:function(t,e,n,o){if(o){m(t,"transition",""),m(t,"transform","");var i=b(this.el),r=(e.left-n.left)/(i&&i.a||1),a=(e.top-n.top)/(i&&i.d||1);t.animatingX=!!r,t.animatingY=!!a,m(t,"transform","translate3d("+r+"px,"+a+"px,0)"),this.forRepaintDummy=function(t){return t.offsetWidth}(t),m(t,"transition","transform "+o+"ms"+(this.options.easing?" "+this.options.easing:"")),m(t,"transform","translate3d(0,0,0)"),"number"==typeof t.animated&&clearTimeout(t.animated),t.animated=setTimeout(function(){m(t,"transition",""),m(t,"transform",""),t.animated=!1,t.animatingX=!1,t.animatingY=!1;},o);}}}));}function Pt(t,e,i,r,a,l,s,c){var u,d,h=t[k],f=h.options.onMove;return !window.CustomEvent||n||o?(u=document.createEvent("Event")).initEvent("move",!0,!0):u=new CustomEvent("move",{bubbles:!0,cancelable:!0}),u.to=e,u.from=t,u.dragged=i,u.draggedRect=r,u.related=a||e,u.relatedRect=l||y(e),u.willInsertAfter=c,u.originalEvent=s,t.dispatchEvent(u),f&&(d=f.call(h,u,s)),d}function kt(t){t.draggable=!1;}function Rt(){bt=!1;}function Xt(t){for(var e=t.tagName+t.className+t.src+t.href+t.textContent,n=e.length,o=0;n--;)o+=e.charCodeAt(n);return o.toString(36)}function Yt(t){return setTimeout(t,0)}function Bt(t){return clearTimeout(t)}It.prototype={constructor:It,_isOutsideThisEl:function(t){this.el.contains(t)||t===this.el||(st=null);},_getDirection:function(t,e){return "function"==typeof this.options.direction?this.options.direction.call(this,t,e,L):this.options.direction},_onTapStart:function(t){if(t.cancelable){var e=this,n=this.el,o=this.options,i=o.preventOnFilter,a=t.type,l=t.touches&&t.touches[0]||t.pointerType&&"touch"===t.pointerType&&t,s=(l||t).target,c=t.target.shadowRoot&&(t.path&&t.path[0]||t.composedPath&&t.composedPath()[0])||s,u=o.filter;if(function(t){wt.length=0;for(var e=t.getElementsByTagName("input"),n=e.length;n--;){var o=e[n];o.checked&&wt.push(o);}}(n),!L&&!(/mousedown|pointerdown/.test(a)&&0!==t.button||o.disabled)&&!c.isContentEditable&&(this.nativeDraggable||!r||!s||"SELECT"!==s.tagName.toUpperCase())&&!((s=f(s,o.draggable,n,!1))&&s.animated||G===s)){if(V$1=C(s),Q=C(s,o.draggable),"function"==typeof u){if(u.call(this,t,s,this))return F({sortable:e,rootEl:c,name:"filter",targetEl:s,toEl:n,fromEl:n}),H("filter",e,{evt:t}),void(i&&t.cancelable&&t.preventDefault())}else if(u&&(u=u.split(",").some(function(o){if(o=f(c,o.trim(),n,!1))return F({sortable:e,rootEl:o,name:"filter",targetEl:s,fromEl:n,toEl:n}),H("filter",e,{evt:t}),!0})))return void(i&&t.cancelable&&t.preventDefault());o.handle&&!f(c,o.handle,n,!1)||this._prepareDragStart(t,l,s);}}},_prepareDragStart:function(t,e,r){var a,l=this,s=l.el,u=l.options,d=s.ownerDocument;if(r&&!L&&r.parentNode===s){var h=y(r);if(j=s,K=(L=r).parentNode,z=L.nextSibling,G=r,J=u.group,It.dragged=L,rt=(et={target:L,clientX:(e||t).clientX,clientY:(e||t).clientY}).clientX-h.left,at=et.clientY-h.top,this._lastX=(e||t).clientX,this._lastY=(e||t).clientY,L.style["will-change"]="all",a=function(){H("delayEnded",l,{evt:t}),It.eventCanceled?l._onDrop():(l._disableDelayedDragEvents(),!i&&l.nativeDraggable&&(L.draggable=!0),l._triggerDragStart(t,e),F({sortable:l,name:"choose",originalEvent:t}),v(L,u.chosenClass,!0));},u.ignore.split(",").forEach(function(t){w(L,t.trim(),kt);}),c(d,"dragover",Ot),c(d,"mousemove",Ot),c(d,"touchmove",Ot),c(d,"mouseup",l._onDrop),c(d,"touchend",l._onDrop),c(d,"touchcancel",l._onDrop),i&&this.nativeDraggable&&(this.options.touchStartThreshold=4,L.draggable=!0),H("delayStart",this,{evt:t}),!u.delay||u.delayOnTouchOnly&&!e||this.nativeDraggable&&(o||n))a();else {if(It.eventCanceled)return void this._onDrop();c(d,"mouseup",l._disableDelayedDrag),c(d,"touchend",l._disableDelayedDrag),c(d,"touchcancel",l._disableDelayedDrag),c(d,"mousemove",l._delayedDragTouchMoveHandler),c(d,"touchmove",l._delayedDragTouchMoveHandler),u.supportPointer&&c(d,"pointermove",l._delayedDragTouchMoveHandler),l._dragStartTimer=setTimeout(a,u.delay);}}},_delayedDragTouchMoveHandler:function(t){var e=t.touches?t.touches[0]:t;Math.max(Math.abs(e.clientX-this._lastX),Math.abs(e.clientY-this._lastY))>=Math.floor(this.options.touchStartThreshold/(this.nativeDraggable&&window.devicePixelRatio||1))&&this._disableDelayedDrag();},_disableDelayedDrag:function(){L&&kt(L),clearTimeout(this._dragStartTimer),this._disableDelayedDragEvents();},_disableDelayedDragEvents:function(){var t=this.el.ownerDocument;u(t,"mouseup",this._disableDelayedDrag),u(t,"touchend",this._disableDelayedDrag),u(t,"touchcancel",this._disableDelayedDrag),u(t,"mousemove",this._delayedDragTouchMoveHandler),u(t,"touchmove",this._delayedDragTouchMoveHandler),u(t,"pointermove",this._delayedDragTouchMoveHandler);},_triggerDragStart:function(t,e){e=e||"touch"==t.pointerType&&t,!this.nativeDraggable||e?c(document,this.options.supportPointer?"pointermove":e?"touchmove":"mousemove",this._onTouchMove):(c(L,"dragend",this),c(j,"dragstart",this._onDragStart));try{document.selection?Yt(function(){document.selection.empty();}):window.getSelection().removeAllRanges();}catch(t){}},_dragStarted:function(t,e){if(ht=!1,j&&L){H("dragStarted",this,{evt:e}),this.nativeDraggable&&c(document,"dragover",At);var n=this.options;!t&&v(L,n.dragClass,!1),v(L,n.ghostClass,!0),It.active=this,t&&this._appendGhost(),F({sortable:this,name:"start",originalEvent:e});}else this._nulling();},_emulateDragOver:function(){if(nt){this._lastX=nt.clientX,this._lastY=nt.clientY,xt();for(var t=document.elementFromPoint(nt.clientX,nt.clientY),e=t;t&&t.shadowRoot&&(t=t.shadowRoot.elementFromPoint(nt.clientX,nt.clientY))!==e;)e=t;if(L.parentNode[k]._isOutsideThisEl(t),e)do{if(e[k]&&e[k]._onDragOver({clientX:nt.clientX,clientY:nt.clientY,target:t,rootEl:e})&&!this.options.dragoverBubble)break;t=e;}while(e=e.parentNode);Mt();}},_onTouchMove:function(t){if(et){var e=this.options,n=e.fallbackTolerance,o=e.fallbackOffset,i=t.touches?t.touches[0]:t,r=W&&b(W,!0),a=W&&r&&r.a,l=W&&r&&r.d,s=yt&&dt&&T(dt),c=(i.clientX-et.clientX+o.x)/(a||1)+(s?s[0]-mt[0]:0)/(a||1),u=(i.clientY-et.clientY+o.y)/(l||1)+(s?s[1]-mt[1]:0)/(l||1);if(!It.active&&!ht){if(n&&Math.max(Math.abs(i.clientX-this._lastX),Math.abs(i.clientY-this._lastY))<n)return;this._onDragStart(t,!0);}if(W){r?(r.e+=c-(ot||0),r.f+=u-(it||0)):r={a:1,b:0,c:0,d:1,e:c,f:u};var d="matrix("+r.a+","+r.b+","+r.c+","+r.d+","+r.e+","+r.f+")";m(W,"webkitTransform",d),m(W,"mozTransform",d),m(W,"msTransform",d),m(W,"transform",d),ot=c,it=u,nt=i;}t.cancelable&&t.preventDefault();}},_appendGhost:function(){if(!W){var t=this.options.fallbackOnBody?document.body:j,e=y(L,!0,yt,!0,t),n=this.options;if(yt){for(dt=t;"static"===m(dt,"position")&&"none"===m(dt,"transform")&&dt!==document;)dt=dt.parentNode;dt!==document.body&&dt!==document.documentElement?(dt===document&&(dt=E()),e.top+=dt.scrollTop,e.left+=dt.scrollLeft):dt=E(),mt=T(dt);}v(W=L.cloneNode(!0),n.ghostClass,!1),v(W,n.fallbackClass,!0),v(W,n.dragClass,!0),m(W,"transition",""),m(W,"transform",""),m(W,"box-sizing","border-box"),m(W,"margin",0),m(W,"top",e.top),m(W,"left",e.left),m(W,"width",e.width),m(W,"height",e.height),m(W,"opacity","0.8"),m(W,"position",yt?"absolute":"fixed"),m(W,"zIndex","100000"),m(W,"pointerEvents","none"),It.ghost=W,t.appendChild(W),m(W,"transform-origin",rt/parseInt(W.style.width)*100+"% "+at/parseInt(W.style.height)*100+"%");}},_onDragStart:function(t,e){var n=this,o=t.dataTransfer,i=n.options;H("dragStart",this,{evt:t}),It.eventCanceled?this._onDrop():(H("setupClone",this),It.eventCanceled||((U=A$1(L)).draggable=!1,U.style["will-change"]="",this._hideClone(),v(U,this.options.chosenClass,!1),It.clone=U),n.cloneId=Yt(function(){H("clone",n),It.eventCanceled||(n.options.removeCloneOnHide||j.insertBefore(U,L),n._hideClone(),F({sortable:n,name:"clone"}));}),!e&&v(L,i.dragClass,!0),e?(ft=!0,n._loopId=setInterval(n._emulateDragOver,50)):(u(document,"mouseup",n._onDrop),u(document,"touchend",n._onDrop),u(document,"touchcancel",n._onDrop),o&&(o.effectAllowed="move",i.setData&&i.setData.call(n,o,L)),c(document,"drop",n),m(L,"transform","translateZ(0)")),ht=!0,n._dragStartId=Yt(n._dragStarted.bind(n,e,t)),c(document,"selectstart",n),lt=!0,r&&m(document.body,"user-select","none"));},_onDragOver:function(e){var n,o,i,r,a=this.el,l=e.target,s=this.options,c=s.group,u=It.active,d=J===c,h=s.sort,p=tt||u,g=this,b=!1;if(!bt){if(void 0!==e.preventDefault&&e.cancelable&&e.preventDefault(),l=f(l,s.draggable,a,!0),B("dragOver"),It.eventCanceled)return b;if(L.contains(e.target)||l.animated&&l.animatingX&&l.animatingY||g._ignoreWhileAnimating===l)return U(!1);if(ft=!1,u&&!s.disabled&&(d?h||(i=!j.contains(L)):tt===this||(this.lastPutMode=J.checkPull(this,u,L,e))&&c.checkPut(this,u,L,e))){if(r="vertical"===this._getDirection(e,l),n=y(L),B("dragOverValid"),It.eventCanceled)return b;if(i)return K=j,G(),this._hideClone(),B("revert"),It.eventCanceled||(z?j.insertBefore(L,z):j.appendChild(L)),U(!0);var w=S(a,s.draggable);if(!w||function(t,e,n){var o=y(S(n.el,n.options.draggable));return e?t.clientX>o.right+10||t.clientX<=o.right&&t.clientY>o.bottom&&t.clientX>=o.left:t.clientX>o.right&&t.clientY>o.top||t.clientX<=o.right&&t.clientY>o.bottom+10}(e,r,this)&&!w.animated){if(w===L)return U(!1);if(w&&a===e.target&&(l=w),l&&(o=y(l)),!1!==Pt(j,a,L,n,l,o,e,!!l))return G(),a.appendChild(L),K=a,q(),U(!0)}else if(l.parentNode===a){o=y(l);var E,_,T,x=L.parentNode!==a,M=!function(t,e,n){var o=n?t.left:t.top,i=n?e.left:e.top;return o===i||(n?t.right:t.bottom)===(n?e.right:e.bottom)||o+(n?t.width:t.height)/2===i+(n?e.width:e.height)/2}(L.animated&&L.toRect||n,l.animated&&l.toRect||o,r),N=r?"top":"left",A=D(l,"top","top")||D(L,"top","top"),I=A?A.scrollTop:void 0;if(st!==l&&(_=o[N],gt=!1,vt=!M&&s.invertSwap||x),0!==(E=function(t,e,n,o,i,r,a,l){var s=o?t.clientY:t.clientX,c=o?n.height:n.width,u=o?n.top:n.left,d=o?n.bottom:n.right,h=!1;if(!a)if(l&&ut<c*i){if(!gt&&(1===ct?s>u+c*r/2:s<d-c*r/2)&&(gt=!0),gt)h=!0;else if(1===ct?s<u+ut:s>d-ut)return -ct}else if(s>u+c*(1-i)/2&&s<d-c*(1-i)/2)return function(t){return C(L)<C(t)?1:-1}(e);return (h=h||a)&&(s<u+c*r/2||s>d-c*r/2)?s>u+c/2?1:-1:0}(e,l,o,r,M?1:s.swapThreshold,null==s.invertedSwapThreshold?s.swapThreshold:s.invertedSwapThreshold,vt,st===l))){var P=C(L);do{T=K.children[P-=E];}while(T&&("none"===m(T,"display")||T===W))}if(0===E||T===l)return U(!1);st=l,ct=E;var R=l.nextElementSibling,X=!1,Y=Pt(j,a,L,n,l,o,e,X=1===E);if(!1!==Y)return 1!==Y&&-1!==Y||(X=1===Y),bt=!0,setTimeout(Rt,30),G(),X&&!R?a.appendChild(L):l.parentNode.insertBefore(L,X?R:l),A&&O$1(A,0,I-A.scrollTop),K=L.parentNode,void 0===_||vt||(ut=Math.abs(_-y(l)[N])),q(),U(!0)}if(a.contains(L))return U(!1)}return !1}function B(s,c){H(s,g,t({evt:e,isOwner:d,axis:r?"vertical":"horizontal",revert:i,dragRect:n,targetRect:o,canSort:h,fromSortable:p,target:l,completed:U,onMove:function(t,o){return Pt(j,a,L,n,t,y(t),e,o)},changed:q},c));}function G(){B("dragOverAnimationCapture"),g.captureAnimationState(),g!==p&&p.captureAnimationState();}function U(t){return B("dragOverCompleted",{insertion:t}),t&&(d?u._hideClone():u._showClone(g),g!==p&&(v(L,tt?tt.options.ghostClass:u.options.ghostClass,!1),v(L,s.ghostClass,!0)),tt!==g&&g!==It.active?tt=g:g===It.active&&tt&&(tt=null),p===g&&(g._ignoreWhileAnimating=l),g.animateAll(function(){B("dragOverAnimationComplete"),g._ignoreWhileAnimating=null;}),g!==p&&(p.animateAll(),p._ignoreWhileAnimating=null)),(l===L&&!L.animated||l===a&&!l.animated)&&(st=null),s.dragoverBubble||e.rootEl||l===document||(L.parentNode[k]._isOutsideThisEl(e.target),!t&&Ot(e)),!s.dragoverBubble&&e.stopPropagation&&e.stopPropagation(),b=!0}function q(){Z$2=C(L),$=C(L,s.draggable),F({sortable:g,name:"change",toEl:a,newIndex:Z$2,newDraggableIndex:$,originalEvent:e});}},_ignoreWhileAnimating:null,_offMoveEvents:function(){u(document,"mousemove",this._onTouchMove),u(document,"touchmove",this._onTouchMove),u(document,"pointermove",this._onTouchMove),u(document,"dragover",Ot),u(document,"mousemove",Ot),u(document,"touchmove",Ot);},_offUpEvents:function(){var t=this.el.ownerDocument;u(t,"mouseup",this._onDrop),u(t,"touchend",this._onDrop),u(t,"pointerup",this._onDrop),u(t,"touchcancel",this._onDrop),u(document,"selectstart",this);},_onDrop:function(t){var e=this.el,n=this.options;Z$2=C(L),$=C(L,n.draggable),H("drop",this,{evt:t}),K=L&&L.parentNode,Z$2=C(L),$=C(L,n.draggable),It.eventCanceled||(ht=!1,vt=!1,gt=!1,clearInterval(this._loopId),clearTimeout(this._dragStartTimer),Bt(this.cloneId),Bt(this._dragStartId),this.nativeDraggable&&(u(document,"drop",this),u(e,"dragstart",this._onDragStart)),this._offMoveEvents(),this._offUpEvents(),r&&m(document.body,"user-select",""),m(L,"transform",""),t&&(lt&&(t.cancelable&&t.preventDefault(),!n.dropBubble&&t.stopPropagation()),W&&W.parentNode&&W.parentNode.removeChild(W),(j===K||tt&&"clone"!==tt.lastPutMode)&&U&&U.parentNode&&U.parentNode.removeChild(U),L&&(this.nativeDraggable&&u(L,"dragend",this),kt(L),L.style["will-change"]="",lt&&!ht&&v(L,tt?tt.options.ghostClass:this.options.ghostClass,!1),v(L,this.options.chosenClass,!1),F({sortable:this,name:"unchoose",toEl:K,newIndex:null,newDraggableIndex:null,originalEvent:t}),j!==K?(Z$2>=0&&(F({rootEl:K,name:"add",toEl:K,fromEl:j,originalEvent:t}),F({sortable:this,name:"remove",toEl:K,originalEvent:t}),F({rootEl:K,name:"sort",toEl:K,fromEl:j,originalEvent:t}),F({sortable:this,name:"sort",toEl:K,originalEvent:t})),tt&&tt.save()):Z$2!==V$1&&Z$2>=0&&(F({sortable:this,name:"update",toEl:K,originalEvent:t}),F({sortable:this,name:"sort",toEl:K,originalEvent:t})),It.active&&(null!=Z$2&&-1!==Z$2||(Z$2=V$1,$=Q),F({sortable:this,name:"end",toEl:K,originalEvent:t}),this.save())))),this._nulling();},_nulling:function(){H("nulling",this),j=L=K=W=z=U=G=q=et=nt=lt=Z$2=$=V$1=Q=st=ct=tt=J=It.dragged=It.ghost=It.clone=It.active=null,wt.forEach(function(t){t.checked=!0;}),wt.length=ot=it=0;},handleEvent:function(t){switch(t.type){case"drop":case"dragend":this._onDrop(t);break;case"dragenter":case"dragover":L&&(this._onDragOver(t),function(t){t.dataTransfer&&(t.dataTransfer.dropEffect="move"),t.cancelable&&t.preventDefault();}(t));break;case"selectstart":t.preventDefault();}},toArray:function(){for(var t,e=[],n=this.el.children,o=0,i=n.length,r=this.options;o<i;o++)f(t=n[o],r.draggable,this.el,!1)&&e.push(t.getAttribute(r.dataIdAttr)||Xt(t));return e},sort:function(t){var e={},n=this.el;this.toArray().forEach(function(t,o){var i=n.children[o];f(i,this.options.draggable,n,!1)&&(e[t]=i);},this),t.forEach(function(t){e[t]&&(n.removeChild(e[t]),n.appendChild(e[t]));});},save:function(){var t=this.options.store;t&&t.set&&t.set(this);},closest:function(t,e){return f(t,e||this.options.draggable,this.el,!1)},option:function(t,e){var n=this.options;if(void 0===e)return n[t];var o=Y.modifyOption(this,t,e);n[t]=void 0!==o?o:e,"group"===t&&Tt(n);},destroy:function(){H("destroy",this);var t=this.el;t[k]=null,u(t,"mousedown",this._onTapStart),u(t,"touchstart",this._onTapStart),u(t,"pointerdown",this._onTapStart),this.nativeDraggable&&(u(t,"dragover",this),u(t,"dragenter",this)),Array.prototype.forEach.call(t.querySelectorAll("[draggable]"),function(t){t.removeAttribute("draggable");}),this._onDrop(),this._disableDelayedDragEvents(),pt.splice(pt.indexOf(this.el),1),this.el=t=null;},_hideClone:function(){if(!q){if(H("hideClone",this),It.eventCanceled)return;m(U,"display","none"),this.options.removeCloneOnHide&&U.parentNode&&U.parentNode.removeChild(U),q=!0;}},_showClone:function(t){if("clone"===t.lastPutMode){if(q){if(H("showClone",this),It.eventCanceled)return;L.parentNode!=j||this.options.group.revertClone?z?j.insertBefore(U,z):j.appendChild(U):j.insertBefore(U,L),this.options.group.revertClone&&this.animate(L,U),m(U,"display",""),q=!1;}}else this._hideClone();}},Et&&c(document,"touchmove",function(t){(It.active||ht)&&t.cancelable&&t.preventDefault();}),It.utils={on:c,off:u,css:m,find:w,is:function(t,e){return !!f(t,e,t,!1)},extend:function(t,e){if(t&&e)for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t},throttle:N,closest:f,toggleClass:v,clone:A$1,index:C,nextTick:Yt,cancelNextTick:Bt,detectDirection:Ct,getChild:_},It.get=function(t){return t[k]},It.mount=function(){var e=[].slice.call(arguments);e[0].constructor===Array&&(e=e[0]),e.forEach(function(e){if(!e.prototype||!e.prototype.constructor)throw "Sortable: Mounted plugin must be a constructor function, not "+{}.toString.call(e);e.utils&&(It.utils=t({},It.utils,e.utils)),Y.mount(e);});},It.create=function(t,e){return new It(t,e)},It.version="1.12.0";var Ht,Ft,Lt,Kt,Wt,jt=[],zt=[],Gt=!1,Ut=!1,qt=!1;function Vt(t,e){zt.forEach(function(n,o){var i=e.children[n.sortableIndex+(t?Number(o):0)];i?e.insertBefore(n,i):e.appendChild(n);});}function Zt(){jt.forEach(function(t){t!==Lt&&t.parentNode&&t.parentNode.removeChild(t);});}var Qt=function(t){var e=t.originalEvent,n=t.putSortable,o=t.dragEl,i=t.dispatchSortableEvent,r=t.unhideGhostForTarget;if(e){var a=n||t.activeSortable;(0, t.hideGhostForTarget)();var l=e.changedTouches&&e.changedTouches.length?e.changedTouches[0]:e,s=document.elementFromPoint(l.clientX,l.clientY);r(),a&&!a.el.contains(s)&&(i("spill"),this.onSpill({dragEl:o,putSortable:n}));}};function $t(){}function Jt(){}$t.prototype={startIndex:null,dragStart:function(t){this.startIndex=t.oldDraggableIndex;},onSpill:function(t){var e=t.dragEl,n=t.putSortable;this.sortable.captureAnimationState(),n&&n.captureAnimationState();var o=_(this.sortable.el,this.startIndex,this.options);o?this.sortable.el.insertBefore(e,o):this.sortable.el.appendChild(e),this.sortable.animateAll(),n&&n.animateAll();},drop:Qt},Object.assign($t,{pluginName:"revertOnSpill"}),Jt.prototype={onSpill:function(t){var e=t.dragEl,n=t.putSortable||this.sortable;n.captureAnimationState(),e.parentNode&&e.parentNode.removeChild(e),n.animateAll();},drop:Qt},Object.assign(Jt,{pluginName:"removeOnSpill"});var te,ee,ne,oe,ie,re,ae=[],le=!1;function se(){ae.forEach(function(t){clearInterval(t.pid);}),ae=[];}function ce(){clearInterval(re);}var ue=N(function(t,e,n,o){if(e.scroll){var i,r=(t.touches?t.touches[0]:t).clientX,a=(t.touches?t.touches[0]:t).clientY,l=e.scrollSensitivity,s=e.scrollSpeed,c=E(),u=!1;ee!==n&&(ee=n,se(),i=e.scrollFn,!0===(te=e.scroll)&&(te=x(n,!0)));var d=0,h=te;do{var f=h,p=y(f),g=p.top,v=p.bottom,b=p.left,w=p.right,D=p.width,_=p.height,S=void 0,C=void 0,T=f.scrollWidth,M=f.scrollHeight,N=m(f),A=f.scrollLeft,I=f.scrollTop;f===c?(S=D<T&&("auto"===N.overflowX||"scroll"===N.overflowX||"visible"===N.overflowX),C=_<M&&("auto"===N.overflowY||"scroll"===N.overflowY||"visible"===N.overflowY)):(S=D<T&&("auto"===N.overflowX||"scroll"===N.overflowX),C=_<M&&("auto"===N.overflowY||"scroll"===N.overflowY));var P=S&&(Math.abs(w-r)<=l&&A+D<T)-(Math.abs(b-r)<=l&&!!A),R=C&&(Math.abs(v-a)<=l&&I+_<M)-(Math.abs(g-a)<=l&&!!I);if(!ae[d])for(var X=0;X<=d;X++)ae[X]||(ae[X]={});ae[d].vx==P&&ae[d].vy==R&&ae[d].el===f||(ae[d].el=f,ae[d].vx=P,ae[d].vy=R,clearInterval(ae[d].pid),0==P&&0==R||(u=!0,ae[d].pid=setInterval(function(){o&&0===this.layer&&It.active._onTouchMove(ie);var e=ae[this.layer].vy?ae[this.layer].vy*s:0,n=ae[this.layer].vx?ae[this.layer].vx*s:0;"function"==typeof i&&"continue"!==i.call(It.dragged.parentNode[k],n,e,t,ie,ae[this.layer].el)||O$1(ae[this.layer].el,n,e);}.bind({layer:d}),24))),d++;}while(e.bubbleScroll&&h!==c&&(h=x(h,!1)));le=u;}},30);It.mount(new function(){function t(){for(var t in this.defaults={scroll:!0,scrollSensitivity:30,scrollSpeed:10,bubbleScroll:!0},this)"_"===t.charAt(0)&&"function"==typeof this[t]&&(this[t]=this[t].bind(this));}return t.prototype={dragStarted:function(t){var e=t.originalEvent;this.sortable.nativeDraggable?c(document,"dragover",this._handleAutoScroll):c(document,this.options.supportPointer?"pointermove":e.touches?"touchmove":"mousemove",this._handleFallbackAutoScroll);},dragOverCompleted:function(t){var e=t.originalEvent;this.options.dragOverBubble||e.rootEl||this._handleAutoScroll(e);},drop:function(){this.sortable.nativeDraggable?u(document,"dragover",this._handleAutoScroll):(u(document,"pointermove",this._handleFallbackAutoScroll),u(document,"touchmove",this._handleFallbackAutoScroll),u(document,"mousemove",this._handleFallbackAutoScroll)),ce(),se(),clearTimeout(p),p=void 0;},nulling:function(){ie=ee=te=le=re=ne=oe=null,ae.length=0;},_handleFallbackAutoScroll:function(t){this._handleAutoScroll(t,!0);},_handleAutoScroll:function(t,e){var i=this,a=(t.touches?t.touches[0]:t).clientX,l=(t.touches?t.touches[0]:t).clientY,s=document.elementFromPoint(a,l);if(ie=t,e||o||n||r){ue(t,this.options,s,e);var c=x(s,!0);!le||re&&a===ne&&l===oe||(re&&ce(),re=setInterval(function(){var n=x(document.elementFromPoint(a,l),!0);n!==c&&(c=n,se()),ue(t,i.options,n,e);},10),ne=a,oe=l);}else {if(!this.options.bubbleScroll||x(s,!0)===E())return void se();ue(t,this.options,x(s,!1),!1);}}},Object.assign(t,{pluginName:"scroll",initializeByDefault:!0})}),It.mount(Jt,$t),It.mount(new function(){function t(){this.defaults={swapClass:"sortable-swap-highlight"};}return t.prototype={dragStart:function(t){Nt=t.dragEl;},dragOverValid:function(t){var e=t.completed,n=t.target,o=t.changed,i=t.cancel;if(t.activeSortable.options.swap){var r=this.options;if(n&&n!==this.sortable.el){var a=Nt;!1!==(0, t.onMove)(n)?(v(n,r.swapClass,!0),Nt=n):Nt=null,a&&a!==Nt&&v(a,r.swapClass,!1);}o(),e(!0),i();}},drop:function(t){var e,n,o,i,r,a,l=t.activeSortable,s=t.putSortable,c=t.dragEl,u=s||this.sortable,d=this.options;Nt&&v(Nt,d.swapClass,!1),Nt&&(d.swap||s&&s.options.swap)&&c!==Nt&&(u.captureAnimationState(),u!==l&&l.captureAnimationState(),a=(n=Nt).parentNode,(r=(e=c).parentNode)&&a&&!r.isEqualNode(n)&&!a.isEqualNode(e)&&(o=C(e),i=C(n),r.isEqualNode(a)&&o<i&&i++,r.insertBefore(n,r.children[o]),a.insertBefore(e,a.children[i])),u.animateAll(),u!==l&&l.animateAll());},nulling:function(){Nt=null;}},Object.assign(t,{pluginName:"swap",eventProperties:function(){return {swapItem:Nt}}})}),It.mount(new function(){function t(t){for(var e in this)"_"===e.charAt(0)&&"function"==typeof this[e]&&(this[e]=this[e].bind(this));t.options.supportPointer?c(document,"pointerup",this._deselectMultiDrag):(c(document,"mouseup",this._deselectMultiDrag),c(document,"touchend",this._deselectMultiDrag)),c(document,"keydown",this._checkKeyDown),c(document,"keyup",this._checkKeyUp),this.defaults={selectedClass:"sortable-selected",multiDragKey:null,setData:function(e,n){var o="";jt.length&&Ft===t?jt.forEach(function(t,e){o+=(e?", ":"")+t.textContent;}):o=n.textContent,e.setData("Text",o);}};}return t.prototype={multiDragKeyDown:!1,isMultiDrag:!1,delayStartGlobal:function(t){Lt=t.dragEl;},delayEnded:function(){this.isMultiDrag=~jt.indexOf(Lt);},setupClone:function(t){var e=t.sortable,n=t.cancel;if(this.isMultiDrag){for(var o=0;o<jt.length;o++)zt.push(A$1(jt[o])),zt[o].sortableIndex=jt[o].sortableIndex,zt[o].draggable=!1,zt[o].style["will-change"]="",v(zt[o],this.options.selectedClass,!1),jt[o]===Lt&&v(zt[o],this.options.chosenClass,!1);e._hideClone(),n();}},clone:function(t){var e=t.dispatchSortableEvent,n=t.cancel;this.isMultiDrag&&(this.options.removeCloneOnHide||jt.length&&Ft===t.sortable&&(Vt(!0,t.rootEl),e("clone"),n()));},showClone:function(t){var e=t.cloneNowShown,n=t.cancel;this.isMultiDrag&&(Vt(!1,t.rootEl),zt.forEach(function(t){m(t,"display","");}),e(),Wt=!1,n());},hideClone:function(t){var e=this,n=t.cloneNowHidden,o=t.cancel;this.isMultiDrag&&(zt.forEach(function(t){m(t,"display","none"),e.options.removeCloneOnHide&&t.parentNode&&t.parentNode.removeChild(t);}),n(),Wt=!0,o());},dragStartGlobal:function(t){!this.isMultiDrag&&Ft&&Ft.multiDrag._deselectMultiDrag(),jt.forEach(function(t){t.sortableIndex=C(t);}),jt=jt.sort(function(t,e){return t.sortableIndex-e.sortableIndex}),qt=!0;},dragStarted:function(t){var e=this,n=t.sortable;if(this.isMultiDrag){if(this.options.sort&&(n.captureAnimationState(),this.options.animation)){jt.forEach(function(t){t!==Lt&&m(t,"position","absolute");});var o=y(Lt,!1,!0,!0);jt.forEach(function(t){t!==Lt&&I$1(t,o);}),Ut=!0,Gt=!0;}n.animateAll(function(){Ut=!1,Gt=!1,e.options.animation&&jt.forEach(function(t){P(t);}),e.options.sort&&Zt();});}},dragOver:function(t){var e=t.completed,n=t.cancel;Ut&&~jt.indexOf(t.target)&&(e(!1),n());},revert:function(t){var e=t.fromSortable,n=t.rootEl,o=t.sortable,i=t.dragRect;jt.length>1&&(jt.forEach(function(t){o.addAnimationState({target:t,rect:Ut?y(t):i}),P(t),t.fromRect=i,e.removeAnimationState(t);}),Ut=!1,function(t,e){jt.forEach(function(n,o){var i=e.children[n.sortableIndex+(t?Number(o):0)];i?e.insertBefore(n,i):e.appendChild(n);});}(!this.options.removeCloneOnHide,n));},dragOverCompleted:function(t){var e=t.sortable,n=t.isOwner,o=t.activeSortable,i=t.parentEl,r=t.putSortable,a=this.options;if(t.insertion){if(n&&o._hideClone(),Gt=!1,a.animation&&jt.length>1&&(Ut||!n&&!o.options.sort&&!r)){var l=y(Lt,!1,!0,!0);jt.forEach(function(t){t!==Lt&&(I$1(t,l),i.appendChild(t));}),Ut=!0;}if(!n)if(Ut||Zt(),jt.length>1){var s=Wt;o._showClone(e),o.options.animation&&!Wt&&s&&zt.forEach(function(t){o.addAnimationState({target:t,rect:Kt}),t.fromRect=Kt,t.thisAnimationDuration=null;});}else o._showClone(e);}},dragOverAnimationCapture:function(t){var e=t.dragRect,n=t.isOwner,o=t.activeSortable;if(jt.forEach(function(t){t.thisAnimationDuration=null;}),o.options.animation&&!n&&o.multiDrag.isMultiDrag){Kt=Object.assign({},e);var i=b(Lt,!0);Kt.top-=i.f,Kt.left-=i.e;}},dragOverAnimationComplete:function(){Ut&&(Ut=!1,Zt());},drop:function(t){var e=t.originalEvent,n=t.rootEl,o=t.parentEl,i=t.sortable,r=t.dispatchSortableEvent,a=t.oldIndex,l=t.putSortable,s=l||this.sortable;if(e){var c=this.options,u=o.children;if(!qt)if(c.multiDragKey&&!this.multiDragKeyDown&&this._deselectMultiDrag(),v(Lt,c.selectedClass,!~jt.indexOf(Lt)),~jt.indexOf(Lt))jt.splice(jt.indexOf(Lt),1),Ht=null,B({sortable:i,rootEl:n,name:"deselect",targetEl:Lt,originalEvt:e});else {if(jt.push(Lt),B({sortable:i,rootEl:n,name:"select",targetEl:Lt,originalEvt:e}),e.shiftKey&&Ht&&i.el.contains(Ht)){var d,h,f=C(Ht),p=C(Lt);if(~f&&~p&&f!==p)for(p>f?(h=f,d=p):(h=p,d=f+1);h<d;h++)~jt.indexOf(u[h])||(v(u[h],c.selectedClass,!0),jt.push(u[h]),B({sortable:i,rootEl:n,name:"select",targetEl:u[h],originalEvt:e}));}else Ht=Lt;Ft=s;}if(qt&&this.isMultiDrag){if((o[k].options.sort||o!==n)&&jt.length>1){var g=y(Lt),m=C(Lt,":not(."+this.options.selectedClass+")");if(!Gt&&c.animation&&(Lt.thisAnimationDuration=null),s.captureAnimationState(),!Gt&&(c.animation&&(Lt.fromRect=g,jt.forEach(function(t){if(t.thisAnimationDuration=null,t!==Lt){var e=Ut?y(t):g;t.fromRect=e,s.addAnimationState({target:t,rect:e});}})),Zt(),jt.forEach(function(t){u[m]?o.insertBefore(t,u[m]):o.appendChild(t),m++;}),a===C(Lt))){var b=!1;jt.forEach(function(t){t.sortableIndex===C(t)||(b=!0);}),b&&r("update");}jt.forEach(function(t){P(t);}),s.animateAll();}Ft=s;}(n===o||l&&"clone"!==l.lastPutMode)&&zt.forEach(function(t){t.parentNode&&t.parentNode.removeChild(t);});}},nullingGlobal:function(){this.isMultiDrag=qt=!1,zt.length=0;},destroyGlobal:function(){this._deselectMultiDrag(),u(document,"pointerup",this._deselectMultiDrag),u(document,"mouseup",this._deselectMultiDrag),u(document,"touchend",this._deselectMultiDrag),u(document,"keydown",this._checkKeyDown),u(document,"keyup",this._checkKeyUp);},_deselectMultiDrag:function(t){if(!(void 0!==qt&&qt||Ft!==this.sortable||t&&f(t.target,this.options.draggable,this.sortable.el,!1)||t&&0!==t.button))for(;jt.length;){var e=jt[0];v(e,this.options.selectedClass,!1),jt.shift(),B({sortable:this.sortable,rootEl:this.sortable.el,name:"deselect",targetEl:e,originalEvt:t});}},_checkKeyDown:function(t){t.key===this.options.multiDragKey&&(this.multiDragKeyDown=!0);},_checkKeyUp:function(t){t.key===this.options.multiDragKey&&(this.multiDragKeyDown=!1);}},Object.assign(t,{pluginName:"multiDrag",utils:{select:function(t){var e=t.parentNode[k];e&&e.options.multiDrag&&!~jt.indexOf(t)&&(Ft&&Ft!==e&&(Ft.multiDrag._deselectMultiDrag(),Ft=e),v(t,e.options.selectedClass,!0),jt.push(t));},deselect:function(t){var e=t.parentNode[k],n=jt.indexOf(t);e&&e.options.multiDrag&&~n&&(v(t,e.options.selectedClass,!1),jt.splice(n,1));}},eventProperties:function(){var t=this,e=[],n=[];return jt.forEach(function(o){var i;e.push({multiDragElement:o,index:o.sortableIndex}),i=Ut&&o!==Lt?-1:Ut?C(o,":not(."+t.options.selectedClass+")"):C(o),n.push({multiDragElement:o,index:i});}),{items:[].concat(jt),clones:[].concat(zt),oldIndicies:e,newIndicies:n}},optionListeners:{multiDragKey:function(t){return "ctrl"===(t=t.toLowerCase())?t="Control":t.length>1&&(t=t.charAt(0).toUpperCase()+t.substr(1)),t}}})});

  var arrayMove = require('array-move');

  var sleep = function sleep(ms) {
    return new Promise(function (res) {
      return setTimeout(res, ms);
    });
  };

  var opacityValue = 1;
  proj4.defs('EPSG:27700', '+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 ' + '+x_0=400000 +y_0=-100000 +ellps=airy ' + '+towgs84=446.448,-125.157,542.06,0.15,0.247,0.842,-20.489 ' + '+units=m +no_defs');
  proj4.defs('EPSG:23032', '+proj=utm +zone=32 +ellps=intl ' + '+towgs84=-87,-98,-121,0,0,0,0 +units=m +no_defs');
  proj4.defs('EPSG:5479', '+proj=lcc +lat_1=-76.66666666666667 +lat_2=' + '-79.33333333333333 +lat_0=-78 +lon_0=163 +x_0=7000000 +y_0=5000000 ' + '+ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs');
  proj4.defs('EPSG:21781', '+proj=somerc +lat_0=46.95240555555556 ' + '+lon_0=7.439583333333333 +k_0=1 +x_0=600000 +y_0=200000 +ellps=bessel ' + '+towgs84=674.4,15.1,405.3,0,0,0,0 +units=m +no_defs');
  proj4.defs('EPSG:3413', '+proj=stere +lat_0=90 +lat_ts=70 +lon_0=-45 +k=1 ' + '+x_0=0 +y_0=0 +datum=WGS84 +units=m +no_defs');
  proj4.defs('EPSG:2163', '+proj=laea +lat_0=45 +lon_0=-100 +x_0=0 +y_0=0 ' + '+a=6370997 +b=6370997 +units=m +no_defs');
  proj4.defs('ESRI:54009', '+proj=moll +lon_0=0 +x_0=0 +y_0=0 +datum=WGS84 ' + '+units=m +no_defs');
  register(proj4);
  var proj27700 = get$2('EPSG:27700');
  proj27700.setExtent([0, 0, 700000, 1300000]);
  var proj23032 = get$2('EPSG:23032');
  proj23032.setExtent([-1206118.71, 4021309.92, 1295389.0, 8051813.28]);
  var proj5479 = get$2('EPSG:5479');
  proj5479.setExtent([6825737.53, 4189159.8, 9633741.96, 5782472.71]);
  var proj21781 = get$2('EPSG:21781');
  proj21781.setExtent([485071.54, 75346.36, 828515.78, 299941.84]);
  var proj3413 = get$2('EPSG:3413');
  proj3413.setExtent([-4194304, -4194304, 4194304, 4194304]);
  var proj2163 = get$2('EPSG:2163');
  proj2163.setExtent([-8040784.5135, -2577524.921, 3668901.4484, 4785105.1096]);
  var proj54009 = get$2('ESRI:54009');
  proj54009.setExtent([-18e6, -9e6, 18e6, 9e6]);
  var layers = {};
  layers['osm'] = new TileLayer({
    source: new OSM()
  });
  layers['wms4326'] = new TileLayer({
    source: new TileWMS({
      url: 'https://ahocevar.com/geoserver/wms',
      crossOrigin: '',
      params: {
        'LAYERS': 'ne:NE1_HR_LC_SR_W_DR',
        'TILED': true
      },
      projection: 'EPSG:4326'
    })
  });
  layers['wms21781'] = new TileLayer({
    source: new TileWMS({
      attributions: '© <a href="http://www.geo.admin.ch/internet/geoportal/' + 'en/home.html">Pixelmap 1:1000000 / geo.admin.ch</a>',
      crossOrigin: 'anonymous',
      params: {
        'LAYERS': 'ch.swisstopo.pixelkarte-farbe-pk1000.noscale',
        'FORMAT': 'image/jpeg'
      },
      url: 'https://wms.geo.admin.ch/',
      projection: 'EPSG:21781'
    })
  });
  var parser = new WMTSCapabilities();
  layers['wmts3413'] = new TileLayer();
  var urlA = 'https://map1.vis.earthdata.nasa.gov/wmts-arctic/' + 'wmts.cgi?SERVICE=WMTS&request=GetCapabilities';
  fetch(urlA).then(function (response) {
    return response.text();
  }).then(function (text) {
    var result = parser.read(text);
    var options = optionsFromCapabilities(result, {
      layer: 'OSM_Land_Mask',
      matrixSet: 'EPSG3413_250m'
    });
    options.crossOrigin = '';
    options.projection = 'EPSG:3413';
    options.wrapX = false;
    layers['wmts3413'].setSource(new WMTS(options));
  });
  layers['bng'] = new TileLayer();
  var urlB = 'https://tiles.arcgis.com/tiles/qHLhLQrcvEnxjtPr/arcgis/rest/services/OS_Open_Raster/MapServer/WMTS';
  fetch(urlB).then(function (response) {
    return response.text();
  }).then(function (text) {
    var result = parser.read(text);
    var options = optionsFromCapabilities(result, {
      layer: 'OS_Open_Raster'
    });
    options.attributions = 'Contains OS data © Crown Copyright and database right 2019';
    options.crossOrigin = '';
    options.projection = 'EPSG:27700';
    options.wrapX = false;
    layers['bng'].setSource(new WMTS(options));
  });
  var startResolution = getWidth(get$2('EPSG:27700').getExtent()) / 256;
  var resolutions = new Array(22);

  for (var i$1 = 0, ii = resolutions.length; i$1 < ii; ++i$1) {
    resolutions[i$1] = startResolution / Math.pow(2, i$1);
  }

  layers['states'] = new TileLayer({
    source: new TileWMS({
      url: 'https://ahocevar.com/geoserver/wms',
      crossOrigin: '',
      params: {
        'LAYERS': 'topp:states'
      },
      serverType: 'geoserver',
      tileGrid: new TileGrid({
        extent: [-13884991, 2870341, -7455066, 6338219],
        resolutions: resolutions,
        tileSize: [512, 256]
      }),
      projection: 'EPSG:3857'
    })
  });
  layers['tf'] = new TileLayer({
    source: new TileWMS({
      url: 'http://ec2-3-8-5-157.eu-west-2.compute.amazonaws.com:8080/geoserver/terrafirma/wms?',
      attributions: 'Metadata © <a href="https://www.terrafirmaidc.co.uk/">Terrafirma IDC Ltd.</a> 2020. Polygons subject to Crown and GeoPlace LLP copyright and database rights 2020 Ordnance Survey 100026316',
      params: {
        'FORMAT': 'image/png',
        'VERSION': '1.3.0',
        'LAYERS': 'terrafirma:tf_lr_haz',
        'exceptions': 'application/vnd.ogc.se_inimage',
        tiled: true,
        tilesOrigin: -118397.00155160861 + "," + -15982.135610342928
      },
      serverType: 'geoserver',
      projection: 'EPSG:27700'
    }),
    title: 'LR Haz NGRM ol tile set',
    minZoom: 9.5
  });
  var fillStyle = new Fill({
    color: [255, 0, 0, 0.1]
  });
  var lineStyle = new Stroke({
    color: [0, 0, 0, 1],
    width: 1.5,
    lineDash: [10, 5]
  });
  var pointStyle = new CircleStyle({
    fill: new Fill({
      color: [0, 102, 0, 0.5]
    }),
    stroke: new Stroke({
      color: [155, 0, 0, 1],
      width: 2
    }),
    radius: 5
  });
  layers['eer'] = new VectorLayer({
    source: new VectorSource({
      url: 'https://martinjc.github.io/UK-GeoJSON/json/eng/topo_eer.json',
      format: new TopoJSON() //projection: document.getElementById('view-projection').value

    }),
    title: 'eer',
    style: new Style({
      fill: fillStyle,
      stroke: lineStyle,
      image: pointStyle
    })
  });
  var style = new Style({
    fill: new Fill({
      color: 'rgba(255, 255, 255, 0.6)'
    }),
    stroke: new Stroke({
      color: '#319FD3',
      width: 1
    }),
    text: new Text()
  });
  layers['countries'] = new VectorLayer({
    imageRatio: 2,
    source: new VectorSource({
      format: new GeoJSON(),
      url: 'https://openlayers.org/en/v4.6.5/examples/data/geojson/countries.geojson'
    })
  });
  var wkt$1 = "Polygon ((385219.76934220944531262 275120.31611970614176244, " + "510206.33200901799136773 374468.60952152829850093, " + "611691.14784958900418133 249482.04685471975244582, " + "385219.76934220944531262 275120.31611970614176244))";
  var feature = new WKT().readFeature(wkt$1, {
    dataProjection: 'EPSG:27700',
    featureProjection: 'EPSG:27700'
  });
  layers['wkt_example'] = new VectorLayer({
    source: new VectorSource({
      features: [feature]
    })
  });
  var container = document.getElementById('popup');
  var orientation;

  function viewport_orientation() {
    var l = window.matchMedia("(orientation: landscape)");
    var p = window.matchMedia("(orientation: portrait)");

    if (l.matches) {
      orientation = "landscape";
    } else if (p.matches) {
      orientation = "portrait";
    }
  }

  viewport_orientation();
  var sidebar_visible = false;
  var active_tab = "layer-select-tab";
  var open_sidebar_btn = document.querySelector(".open-sidebar");
  open_sidebar_btn.addEventListener("click", function () {
    if (sidebar_visible) {
      hide_sidebar(orientation); // sidebar_visible = false;
    } else {
      show_sidebar(orientation); // sidebar_visible = true;
    }
  });

  function show_sidebar(orientation) {
    // if (active_tab == "layer-select-tab") {
    //     show_layer_select();
    // };
    if (orientation == "landscape") {
      console.log(activeLayers.length, inactiveLayers.length); //document.querySelector("#tab-list").style.width = '20%';

      document.querySelector("#sidebar").style.width = "25%";
      document.querySelector("#map").style.width = "75%";
      document.querySelector('#map').style.marginLeft = "25%";
    } else if (orientation == "portrait") {
      document.querySelector("#sidebar").style.height = "25vh";
      document.querySelector("#map").style.height = "75vh"; //document.querySelector('#map').style.marginTop = "25vh";
    }

    sidebar_visible = true;
  }

  function hide_sidebar(orientation) {
    // document.querySelector("#active-layers-section").style.display = "none";
    // document.querySelector("#layer-pool-section").style.display = "none";
    //document.querySelector("#tab-list").style.width = '100%';
    if (orientation == "landscape") {
      document.querySelector("#sidebar").style.width = "100px";
      document.querySelector("#map").style.width = "100%";
      document.querySelector('#map').style.marginLeft = "0";
    } else if (orientation == "portrait") {
      document.querySelector("#sidebar").style.height = "100px";
      document.querySelector("#map").style.height = "100vh"; //document.querySelector('#map').style.marginTop = "0vh";
    }

    sidebar_visible = false;
  }

  var layers_btn = document.querySelector("#layer-select-tab");
  layers_btn.addEventListener("click", function () {
    show_layer_select();

    if (sidebar_visible && active_tab == "layer-select-tab") {
      hide_sidebar(orientation);
    } else {
      active_tab = "layer-select-tab";

      if (!sidebar_visible) {
        show_sidebar(orientation);
      }
    }
  });

  function show_layer_select() {
    document.querySelector("#layer-button-list").style.display = "inline-block";

    if (activeLayers.length > 1) {
      document.querySelector("#active-layers-section").style.display = 'block';
    }

    if (inactiveLayers.length > 0) {
      document.querySelector("#layer-pool-section").style.display = 'block';
    }

    document.querySelector("#settings").style.display = "none";
  }
  var settings_btn = document.querySelector("#settings-tab");
  settings_btn.addEventListener("click", function () {
    show_settings();

    if (sidebar_visible && active_tab == "settings-tab") {
      hide_sidebar(orientation);
    } else {
      active_tab = "settings-tab";

      if (!sidebar_visible) {
        show_sidebar(orientation);
      }
    }
  });

  function show_settings() {
    document.querySelector("#layer-button-list").style.display = "none";
    document.querySelector("#settings").style.display = "inline-block";
  }

  var overlay = new Overlay({
    element: container,
    autoPan: true,
    autoPanAnimation: {
      duration: 250
    }
  });
  var overviewMapControl = new OverviewMap({
    layers: [new TileLayer({
      source: new OSM()
    })],
    view: new View({
      projection: 'EPSG:27700',
      center: [0, 0],
      zoom: 1
    })
  });
  var mousePositionControl = new MousePosition({
    coordinateFormat: createStringXY(2),
    projection: document.getElementById('view-projection').value,
    // comment the following two lines to have the mouse position
    // be placed within the map.
    className: 'custom-mouse-position',
    target: document.getElementById('mouse-position'),
    undefinedHTML: '&nbsp;'
  });
  var map = new Map({
    controls: [new Attribution(), mousePositionControl],
    layers: [layers['osm']],
    // Start with just initial OSM basemap
    overlays: [overlay],
    target: 'map',
    view: new View({
      projection: 'EPSG:27700',
      center: [0, 0],
      zoom: 1
    })
  });
  var active_layers_el = document.getElementById("active-layers");
  var layer_pool_el = document.getElementById("layer-pool");
  var activeLayers = ['osm'];
  var inactiveLayers = ['eer', 'bng', 'wkt_example'];
  var regionLayerToggle = document.getElementById('region-layer-button');
  var bngLayerToggle = document.getElementById('bng-layer-button');
  var wktLayerToggle = document.getElementById('wkt-layer-button');
  var layer_toggle_pool = {
    'eer': regionLayerToggle,
    'bng': bngLayerToggle,
    'wkt_example': wktLayerToggle
  };

  function activate_layer(layer_name) {
    var layer_position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : activeLayers.length;
    console.log("Active layers before:", activeLayers);
    layers[layer_name].setOpacity(opacityValue);
    updateRenderEdgesOnLayer(layers[layer_name]);
    layer_toggle_pool[layer_name].firstElementChild.style.backgroundColor = "palegreen";
    layer_toggle_pool[layer_name].firstElementChild.style.fontStyle = "normal";
    var node = document.createElement("div"); // Create a div

    node.setAttribute("id", layer_name + "_slider");
    node.setAttribute("class", "slidecontainer");
    var br = document.createElement("br");
    node.appendChild(br); // <input type="range" min="0" max="100" value="100" class="slider" id="opacitySliderElement">
    // var textnode = document.createTextNode("[opacity slider]");         // Create a filler text node
    // node.appendChild(textnode);

    var slider = document.createElement("input");
    slider.setAttribute("type", "range");
    slider.setAttribute("class", "slider");
    slider.classList.remove('ol-unselectable');
    node.appendChild(slider); // active_layers_el.prepend(node);

    layer_toggle_pool[layer_name].append(node);
    inactiveLayers = inactiveLayers.filter(function (certain_layer_name) {
      return certain_layer_name !== layer_name;
    });
    console.log("Setting layer at:", layer_position);
    map.getLayers().setAt(layer_position, layers[layer_name]);
    activeLayers.push(layer_name);
    active_layers_el.prepend(layer_toggle_pool[layer_name]);
    document.querySelector("#active-layers-section").style.display = 'block';

    if (inactiveLayers.length == 0) {
      document.querySelector("#layer-pool-section").style.display = 'none';
    }

    console.log("Active layers:", activeLayers);
    console.log("Inactive layers:", inactiveLayers);
    console.log("Trying to change list");
    console.log(activeLayers.length);
  }

  function deactivate_layer(layer_name) {
    layer_toggle_pool[layer_name].firstElementChild.style.backgroundColor = "palevioletred";
    layer_toggle_pool[layer_name].firstElementChild.style.fontStyle = "italic";
    console.log("Attempting to deactivate layer..");
    map.getLayers().removeAt(activeLayers.indexOf(layer_name));
    inactiveLayers.push(layer_name);
    activeLayers = activeLayers.filter(function (certain_layer_name) {
      return certain_layer_name !== layer_name;
    });
    console.log("Active layers:", activeLayers);
    console.log("Inactive layers:", inactiveLayers);
    layer_pool_el.append(layer_toggle_pool[layer_name]);
    layer_toggle_pool[layer_name].removeChild(document.getElementById(layer_name + "_slider"));

    if (activeLayers.length == 1) {
      document.querySelector("#active-layers-section").style.display = 'none';
    }

    document.querySelector("#layer-pool-section").style.display = 'block';
  }

  function assign_layer_toggle(layer_name) {
    layer_toggle_pool[layer_name].onclick = function () {
      if (!activeLayers.includes(layer_name)) {
        console.log("Trying to activate", layer_name);
        activate_layer(layer_name);
      } else {
        console.log("Trying to deactivate", layer_name);
        deactivate_layer(layer_name);
      }
    };
  } // Assigns layer toggles to the buttons themselves
  // TODO: Reassign from layer pool


  for (var layer_toggle_name in layer_toggle_pool) {
    layer_toggle_pool[layer_toggle_name].firstElementChild.style.backgroundColor = "palevioletred";
    assign_layer_toggle(layer_toggle_name);
  }

  function layer_target(layer_id) {
    return activeLayers.length - layer_id;
  }

  function swap_active_layers(old_index, new_index) {
    // Move layer at old_index to new_index
    if (old_index > 0 & new_index > 0) {
      var layer_target_old_index = layer_target(old_index);
      var layer_target_new_index = layer_target(new_index);
      var layer_name_old_index = activeLayers[layer_target_old_index]; // Name of layer being moved

      var layer_name_new_index = activeLayers[layer_target_new_index]; // Reassign activeLayers array

      activeLayers = arrayMove(activeLayers, layer_target_old_index, layer_target_new_index);

      if (old_index < new_index) {
        // Corresponds to moving a layer down
        // Remove layers from top to bottom
        map.getLayers().removeAt(layer_target_old_index);
        map.getLayers().removeAt(layer_target_new_index); // Set layers from bottom to top

        map.getLayers().insertAt(layer_target_new_index, layers[layer_name_old_index]);
        map.getLayers().insertAt(layer_target_old_index, layers[layer_name_new_index]);
      } else {
        // Corresponds to moving a layer up
        // Remove layers from top to bottom
        map.getLayers().removeAt(layer_target_new_index);
        map.getLayers().removeAt(layer_target_old_index); // Set layers from bottom to top

        map.getLayers().insertAt(layer_target_old_index, layers[layer_name_new_index]);
        map.getLayers().insertAt(layer_target_new_index, layers[layer_name_old_index]);
      }

      console.log("Active layers after swap:", activeLayers);
    }
  }

  function swap_pool_layers(layer_a_id, layer_b_id) {
    console.log("First layer selected:", inactiveLayers[layer_a_id]);
    console.log("Second layer selected:", inactiveLayers[layer_b_id]);

    if (layer_a_id < layer_b_id) {
      inactiveLayers = [inactiveLayers[layer_b_id], inactiveLayers[layer_a_id]];
    } else {
      inactiveLayers = [inactiveLayers[layer_a_id], inactiveLayers[layer_b_id]];
    }
  }

  var active_layers_sortable = new It(active_layers_el, {
    // variables
    group: "layer-list-group",
    // or { name: "...", pull: [true, false, 'clone', array], put: [true, false, array] }
    // sort: true, // sorting inside list
    // delay: 0, // time in milliseconds to define when the sorting should start
    // delayOnTouchOnly: false, // only delay if user is using touch
    // touchStartThreshold: 0, // px, how many pixels the point should move before cancelling a delayed drag event
    // disabled: false, // Disables the sortable if set to true.
    // store: null, // @see Store
    animation: 150,
    // ms, animation speed moving items when sorting, `0` — without animation
    // easing: "cubic-bezier(1, 0, 0, 1)", // Easing for animation. Defaults to null. See https://easings.net/ for examples.
    // handle: ".my-handle", // Drag handle selector within list items
    // filter: ".ignore-elements", // Selectors that do not lead to dragging (String or Function)
    // filter: ".slider",
    // preventOnFilter: true,
    // preventOnFilter: true, // Call `event.preventDefault()` when triggered `filter`
    // draggable: ".item", // Specifies which items inside the element should be draggable
    draggable: ".layer-button",
    // dataIdAttr: "data-id",
    // ghostClass: "sortable-ghost", // Class name for the drop placeholder
    // chosenClass: "sortable-chosen", // Class name for the chosen item
    // dragClass: "sortable-drag", // Class name for the dragging item
    // swapThreshold: 1, // Threshold of the swap zone
    // invertSwap: false, // Will always use inverted swap zone if set to true
    // invertedSwapThreshold: 1, // Threshold of the inverted swap zone (will be set to swapThreshold value by default)
    // direction: "horizontal", // Direction of Sortable (will be detected automatically if not given)
    // forceFallback: false, // ignore the HTML5 DnD behaviour and force the fallback to kick in
    // fallbackClass: "sortable-fallback", // Class name for the cloned DOM Element when using forceFallback
    // fallbackOnBody: false, // Appends the cloned DOM Element into the Document's Body
    // fallbackTolerance: 0, // Specify in pixels how far the mouse should move before it's considered as a drag.
    // dragoverBubble: false,
    // removeCloneOnHide: true, // Remove the clone element when it is not showing, rather than just hiding it
    // emptyInsertThreshold: 5, // px, distance mouse must be from empty sortable to insert drag element into it
    // // handlers/hooks - listen to sortable events here.
    // setData: function (
    //   /** DataTransfer */ dataTransfer,
    //   /** HTMLElement*/ dragEl
    // ) {
    //   dataTransfer.setData("Text", dragEl.textContent); // `dataTransfer` object of HTML5 DragEvent
    // },
    // // Element is chosen
    onChoose: function onChoose(
    /**Event*/
    evt) {
      console.log("elt chosen"); // deactivate_layer(activeLayers[evt.oldIndex + 1])
    },
    // // Element is unchosen
    // onUnchoose: function (/**Event*/ evt) {
    //   // same properties as onEnd
    // },
    // // Element dragging started
    // onStart: function (/**Event*/ evt) {
    //   evt.oldIndex; // element index within parent
    // },
    // // Element dragging ended
    onEnd: function onEnd(
    /**Event*/
    evt) {
      //   var itemEl = evt.item; // dragged HTMLElement
      //   evt.to; // target list
      //   evt.from; // previous list
      //   evt.oldIndex; // element's old index within old parent
      //   evt.newIndex; // element's new index within new parent
      console.log("Initial list index:", evt.oldIndex, "New list index:", evt.newIndex);

      if (evt.newIndex != evt.oldIndex) {
        swap_active_layers(evt.oldIndex + 1, evt.newIndex + 1);
      }

      console.log(evt.to, evt.from); //   evt.oldDraggableIndex; // element's old index within old parent, only counting draggable elements
      //   evt.newDraggableIndex; // element's new index within new parent, only counting draggable elements
      //   evt.clone; // the clone element
      //   evt.pullMode; // when item is in another sortable: `"clone"` if cloning, `true` if moving
    },
    // // Element is dropped into the list from another list
    // onAdd: function (/**Event*/ evt) {
    //   // same properties as onEnd
    // },
    // // Changed sorting within list
    // onUpdate: function (/**Event*/ evt) {
    //   // same properties as onEnd
    // },
    // // Called by any change to the list (add / update / remove)
    // onSort: function (/**Event*/ evt) {
    //   // same properties as onEnd
    // },
    // // Element is removed from the list into another list
    onRemove: function onRemove(
    /**Event*/
    evt) {
      if (evt.to != evt.from) {
        deactivate_layer(activeLayers[evt.oldIndex + 1]);
      } // same properties as onEnd

    } // // Attempt to drag a filtered element
    // onFilter: function (/**Event*/ evt) {
    //   var itemEl = evt.item; // HTMLElement receiving the `mousedown|tapstart` event.
    // },
    // // Event when you move an item in the list or between lists
    // onMove: function (/**Event*/ evt, /**Event*/ originalEvent) {
    //   // Example: https://jsbin.com/nawahef/edit?js,output
    //   evt.dragged; // dragged HTMLElement
    //   evt.draggedRect; // DOMRect {left, top, right, bottom}
    //   evt.related; // HTMLElement on which have guided
    //   evt.relatedRect; // DOMRect
    //   evt.willInsertAfter; // Boolean that is true if Sortable will insert drag element after target by default
    //   originalEvent.clientY; // mouse position
    //   // return false; — for cancel
    //   // return -1; — insert before target
    //   // return 1; — insert after target
    //   // return true; — keep default insertion point based on the direction
    //   // return void; — keep default insertion point based on the direction
    // },
    // // Called when creating a clone of element
    // onClone: function (/**Event*/ evt) {
    //   var origEl = evt.item;
    //   var cloneEl = evt.clone;
    // },
    // // Called when dragging element changes position
    // onChange: function (/**Event*/ evt) {
    //   evt.newIndex; // most likely why this event is used is to get the dragging element's current index
    //   // same properties as onEnd
    // },

  });
  var layer_pool_sortable = new It(layer_pool_el, {
    group: "layer-list-group",
    // or { name: "...", pull: [true, false, 'clone', array], put: [true, false, array] }
    animation: 150,
    // ms, animation speed moving items when sorting, `0` — without animation
    onEnd: function onEnd(
    /**Event*/
    evt) {
      console.log("Initial list index:", evt.oldIndex, "New list index:", evt.newIndex);
      swap_pool_layers(evt.oldIndex, evt.newIndex);
    },
    // // Element is removed from the list into another list
    onRemove: function onRemove(
    /**Event*/
    evt) {
      console.log(evt.oldIndex);
      console.log(inactiveLayers[evt.oldIndex]);
      activate_layer(inactiveLayers[evt.oldIndex]);
      console.log(evt.from, evt.to); // same properties as onEnd
    } // onChoose: function (/**Event*/ evt) {
    //   console.log("Selected an elt");
    //   console.log(evt.item)
    //   // evt.item.remove()
    //   // layer_pool_el.remove(evt.item.firstChild)
    //   // evt.item.detach().appendTo(active_layers_el)
    // },

  });
  var baseLayerSelect = document.getElementById('base-layer'); // var overlayLayerSelect = document.getElementById('overlay-layer');
  // var renderOverlayCheckbox = document.getElementById('render-overlay');
  // var renderOverlay = false;
  // var opacitySlider = document.getElementById("opacitySliderElement");

  var viewProjSelect = document.getElementById('view-projection');
  var renderEdgesCheckbox = document.getElementById('render-edges');
  var renderEdges = false;

  function updateViewProjection() {
    var newProj = get$2(viewProjSelect.value);
    var newProjExtent = newProj.getExtent();
    var newView = new View({
      projection: newProj,
      center: getCenter(newProjExtent || [0, 0, 0, 0]),
      zoom: 0,
      extent: newProjExtent || undefined
    });
    map.setView(newView); // Example how to prevent double occurrence of map by limiting layer extent

    if (newProj == get$2('EPSG:3857')) {
      layers['bng'].setExtent([-1057216, 6405988, 404315, 8759696]);
    } else {
      layers['bng'].setExtent(undefined);
    }
  }
  /**
   * Handle change event.
   */


  viewProjSelect.onchange = function () {
    updateViewProjection();
    mousePositionControl.setProjection(get$2(viewProjSelect.value));
  };

  updateViewProjection(); // update on startup

  var minZoom = 2.5;
  var maxZoom = 18.5;
  map.getView().setMinZoom(minZoom);
  map.getView().setMaxZoom(maxZoom);
  var currZoom = map.getView().getZoom();
  map.on('moveend', function (e) {
    var newZoom = map.getView().getZoom();

    if (currZoom != newZoom) {
      currZoom = newZoom;
    }
  });

  var updateRenderEdgesOnLayer = function updateRenderEdgesOnLayer(layer) {
    if (layer instanceof TileLayer) {
      var source = layer.getSource();

      if (source instanceof TileImage) {
        source.setRenderReprojectionEdges(renderEdges);
      }
    }
  };
  /**
   * Handle change event.
   */


  baseLayerSelect.onchange = function () {
    var layer = layers[baseLayerSelect.value];

    if (layer) {
      layer.setOpacity(1);
      updateRenderEdgesOnLayer(layer);
      map.getLayers().setAt(0, layer);
    }
  };
  /**
   * Handle change event.
   */
  // overlayLayerSelect.onchange = function () {
  //   var layer = layers[overlayLayerSelect.value];
  //   if (layer && renderOverlay) {
  //     layer.setOpacity(opacityValue);
  //     updateRenderEdgesOnLayer(layer);
  //     map.getLayers().setAt(1, layer);
  //   }
  // };
  // renderOverlayCheckbox.onchange = function () {
  //   renderOverlay = renderOverlayCheckbox.checked;
  //   if (renderOverlay) {
  //     var layer = layers[overlayLayerSelect.value]
  //     map.getLayers().setAt(1, layer)
  //     layer.setOpacity(opacityValue);
  //   } else {
  //     map.getLayers().removeAt(1);
  //   }
  // };
  // opacityDisplay.innerHTML = "Opacity: 1"
  // Update the current slider value (each time you drag the slider handle)
  // opacitySlider.oninput = function() {
  //   opacityValue = this.value / 100;
  //   // opacityDisplay.innerHTML = "Opacity: " + opacityValue;
  //   if (renderOverlay) {
  //     layers[overlayLayerSelect.value].setOpacity(opacityValue);
  //   }
  // }

  /**
   * Handle change event.
   */


  renderEdgesCheckbox.onchange = function () {
    renderEdges = renderEdgesCheckbox.checked;
    map.getLayers().forEach(function (layer) {
      updateRenderEdgesOnLayer(layer);
    });
  };

  var content = document.getElementById('popup-content');
  var closer = document.getElementById('popup-closer');

  closer.onclick = function () {
    overlay.setPosition(undefined);
    closer.blur();
    return false;
  };

  var select = new Select();
  map.addInteraction(select);
  map.on('singleclick', /*#__PURE__*/function () {
    var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(evt) {
      var coordinate, hdms, region, regiontext;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              coordinate = evt.coordinate;
              hdms = toStringHDMS(toLonLat(coordinate));
              _context.next = 4;
              return sleep(1);

            case 4:
              region = select.getFeatures().getArray().map(function (feature) {
                return feature.get('EER13NM');
              });
              regiontext = 'No electoral region selected';

              if (region.length > 0) {
                regiontext = region.join(', ');
              }

              content.innerHTML = '<p>You clicked here:</p><code>' + hdms + '</code><p>Region:</p><code>' + regiontext + '</code>';
              overlay.setPosition(coordinate);

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }());
  document.getElementById('export-png').addEventListener('click', function () {
    map.once('rendercomplete', function () {
      var mapCanvas = document.createElement('canvas');
      var size = map.getSize();
      mapCanvas.width = size[0];
      mapCanvas.height = size[1];
      var mapContext = mapCanvas.getContext('2d');
      Array.prototype.forEach.call(document.querySelectorAll('.ol-layer canvas'), function (canvas) {
        if (canvas.width > 0) {
          var opacity = canvas.parentNode.style.opacity;
          mapContext.globalAlpha = opacity === '' ? 1 : Number(opacity);
          var transform = canvas.style.transform; // Get the transform parameters from the style's transform matrix

          var matrix = transform.match(/^matrix\(([^\(]*)\)$/)[1].split(',').map(Number); // Apply the transform to the export map context

          CanvasRenderingContext2D.prototype.setTransform.apply(mapContext, matrix);
          mapContext.drawImage(canvas, 0, 0);
        }
      });

      if (navigator.msSaveBlob) {
        // link download attribuute does not work on MS browsers
        navigator.msSaveBlob(mapCanvas.msToBlob(), 'map.png');
      } else {
        var link = document.getElementById('image-download');
        link.href = mapCanvas.toDataURL();
        link.click();
      }
    });
    map.renderSync();
  });
  show_layer_select(); // Run at startup as default tab is select-layers

})));
