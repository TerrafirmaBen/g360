(function (factory) {
  typeof define === 'function' && define.amd ? define(factory) :
  factory();
}((function () { 'use strict';

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  /**
   * @module ol/Disposable
   */
  /**
   * @classdesc
   * Objects that need to clean up after themselves.
   */
  var Disposable = /** @class */ (function () {
      function Disposable() {
          /**
           * The object has already been disposed.
           * @type {boolean}
           * @protected
           */
          this.disposed = false;
      }
      /**
       * Clean up.
       */
      Disposable.prototype.dispose = function () {
          if (!this.disposed) {
              this.disposed = true;
              this.disposeInternal();
          }
      };
      /**
       * Extension point for disposable objects.
       * @protected
       */
      Disposable.prototype.disposeInternal = function () { };
      return Disposable;
  }());

  /**
   * @module ol/array
   */
  /**
   * Performs a binary search on the provided sorted list and returns the index of the item if found. If it can't be found it'll return -1.
   * https://github.com/darkskyapp/binary-search
   *
   * @param {Array<*>} haystack Items to search through.
   * @param {*} needle The item to look for.
   * @param {Function=} opt_comparator Comparator function.
   * @return {number} The index of the item if found, -1 if not.
   */
  function binarySearch(haystack, needle, opt_comparator) {
      var mid, cmp;
      var comparator = opt_comparator || numberSafeCompareFunction;
      var low = 0;
      var high = haystack.length;
      var found = false;
      while (low < high) {
          /* Note that "(low + high) >>> 1" may overflow, and results in a typecast
           * to double (which gives the wrong results). */
          mid = low + ((high - low) >> 1);
          cmp = +comparator(haystack[mid], needle);
          if (cmp < 0.0) {
              /* Too low. */
              low = mid + 1;
          }
          else {
              /* Key found or too high */
              high = mid;
              found = !cmp;
          }
      }
      /* Key not found. */
      return found ? low : ~low;
  }
  /**
   * Compare function for array sort that is safe for numbers.
   * @param {*} a The first object to be compared.
   * @param {*} b The second object to be compared.
   * @return {number} A negative number, zero, or a positive number as the first
   *     argument is less than, equal to, or greater than the second.
   */
  function numberSafeCompareFunction(a, b) {
      return a > b ? 1 : a < b ? -1 : 0;
  }
  /**
   * Whether the array contains the given object.
   * @param {Array<*>} arr The array to test for the presence of the element.
   * @param {*} obj The object for which to test.
   * @return {boolean} The object is in the array.
   */
  function includes(arr, obj) {
      return arr.indexOf(obj) >= 0;
  }
  /**
   * @param {Array<number>} arr Array.
   * @param {number} target Target.
   * @param {number} direction 0 means return the nearest, > 0
   *    means return the largest nearest, < 0 means return the
   *    smallest nearest.
   * @return {number} Index.
   */
  function linearFindNearest(arr, target, direction) {
      var n = arr.length;
      if (arr[0] <= target) {
          return 0;
      }
      else if (target <= arr[n - 1]) {
          return n - 1;
      }
      else {
          var i = void 0;
          if (direction > 0) {
              for (i = 1; i < n; ++i) {
                  if (arr[i] < target) {
                      return i - 1;
                  }
              }
          }
          else if (direction < 0) {
              for (i = 1; i < n; ++i) {
                  if (arr[i] <= target) {
                      return i;
                  }
              }
          }
          else {
              for (i = 1; i < n; ++i) {
                  if (arr[i] == target) {
                      return i;
                  }
                  else if (arr[i] < target) {
                      if (arr[i - 1] - target < target - arr[i]) {
                          return i - 1;
                      }
                      else {
                          return i;
                      }
                  }
              }
          }
          return n - 1;
      }
  }
  /**
   * @param {Array<*>} arr Array.
   * @param {number} begin Begin index.
   * @param {number} end End index.
   */
  function reverseSubArray(arr, begin, end) {
      while (begin < end) {
          var tmp = arr[begin];
          arr[begin] = arr[end];
          arr[end] = tmp;
          ++begin;
          --end;
      }
  }
  /**
   * @param {Array<VALUE>} arr The array to modify.
   * @param {!Array<VALUE>|VALUE} data The elements or arrays of elements to add to arr.
   * @template VALUE
   */
  function extend(arr, data) {
      var extension = Array.isArray(data) ? data : [data];
      var length = extension.length;
      for (var i = 0; i < length; i++) {
          arr[arr.length] = extension[i];
      }
  }
  /**
   * @param {Array<VALUE>} arr The array to search in.
   * @param {function(VALUE, number, ?) : boolean} func The function to compare.
   * @template VALUE
   * @return {VALUE|null} The element found or null.
   */
  function find(arr, func) {
      var length = arr.length >>> 0;
      var value;
      for (var i = 0; i < length; i++) {
          value = arr[i];
          if (func(value, i, arr)) {
              return value;
          }
      }
      return null;
  }
  /**
   * @param {Array|Uint8ClampedArray} arr1 The first array to compare.
   * @param {Array|Uint8ClampedArray} arr2 The second array to compare.
   * @return {boolean} Whether the two arrays are equal.
   */
  function equals(arr1, arr2) {
      var len1 = arr1.length;
      if (len1 !== arr2.length) {
          return false;
      }
      for (var i = 0; i < len1; i++) {
          if (arr1[i] !== arr2[i]) {
              return false;
          }
      }
      return true;
  }
  /**
   * @param {Array<*>} arr The array to search in.
   * @param {Function} func Comparison function.
   * @return {number} Return index.
   */
  function findIndex(arr, func) {
      var index;
      var found = !arr.every(function (el, idx) {
          index = idx;
          return !func(el, idx, arr);
      });
      return found ? index : -1;
  }
  /**
   * @param {Array<*>} arr The array to test.
   * @param {Function=} opt_func Comparison function.
   * @param {boolean=} opt_strict Strictly sorted (default false).
   * @return {boolean} Return index.
   */
  function isSorted(arr, opt_func, opt_strict) {
      var compare = opt_func || numberSafeCompareFunction;
      return arr.every(function (currentVal, index) {
          if (index === 0) {
              return true;
          }
          var res = compare(arr[index - 1], currentVal);
          return !(res > 0 || (opt_strict && res === 0));
      });
  }

  /**
   * @module ol/functions
   */
  /**
   * Always returns true.
   * @returns {boolean} true.
   */
  function TRUE() {
      return true;
  }
  /**
   * Always returns false.
   * @returns {boolean} false.
   */
  function FALSE() {
      return false;
  }
  /**
   * A reusable function, used e.g. as a default for callbacks.
   *
   * @return {void} Nothing.
   */
  function VOID() { }
  /**
   * Wrap a function in another function that remembers the last return.  If the
   * returned function is called twice in a row with the same arguments and the same
   * this object, it will return the value from the first call in the second call.
   *
   * @param {function(...any): ReturnType} fn The function to memoize.
   * @return {function(...any): ReturnType} The memoized function.
   * @template ReturnType
   */
  function memoizeOne(fn) {
      var called = false;
      /** @type {ReturnType} */
      var lastResult;
      /** @type {Array<any>} */
      var lastArgs;
      var lastThis;
      return function () {
          var nextArgs = Array.prototype.slice.call(arguments);
          if (!called || this !== lastThis || !equals(nextArgs, lastArgs)) {
              called = true;
              lastThis = this;
              lastArgs = nextArgs;
              lastResult = fn.apply(this, arguments);
          }
          return lastResult;
      };
  }

  /**
   * @module ol/util
   */
  /**
   * @return {?} Any return.
   */
  function abstract() {
      return /** @type {?} */ ((function () {
          throw new Error('Unimplemented abstract method.');
      })());
  }
  /**
   * Counter for getUid.
   * @type {number}
   * @private
   */
  var uidCounter_ = 0;
  /**
   * Gets a unique ID for an object. This mutates the object so that further calls
   * with the same object as a parameter returns the same value. Unique IDs are generated
   * as a strictly increasing sequence. Adapted from goog.getUid.
   *
   * @param {Object} obj The object to get the unique ID for.
   * @return {string} The unique ID for the object.
   * @api
   */
  function getUid(obj) {
      return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
  }
  /**
   * OpenLayers version.
   * @type {string}
   */
  var VERSION = '6.4.3';

  var __extends = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * Error object thrown when an assertion failed. This is an ECMA-262 Error,
   * extended with a `code` property.
   * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error.
   */
  var AssertionError = /** @class */ (function (_super) {
      __extends(AssertionError, _super);
      /**
       * @param {number} code Error code.
       */
      function AssertionError(code) {
          var _this = this;
          var path =  'v' + VERSION.split('-')[0];
          var message = 'Assertion failed. See https://openlayers.org/en/' +
              path +
              '/doc/errors/#' +
              code +
              ' for details.';
          _this = _super.call(this, message) || this;
          /**
           * Error code. The meaning of the code can be found on
           * https://openlayers.org/en/latest/doc/errors/ (replace `latest` with
           * the version found in the OpenLayers script's header comment if a version
           * other than the latest is used).
           * @type {number}
           * @api
           */
          _this.code = code;
          /**
           * @type {string}
           */
          _this.name = 'AssertionError';
          // Re-assign message, see https://github.com/Rich-Harris/buble/issues/40
          _this.message = message;
          return _this;
      }
      return AssertionError;
  }(Error));

  /**
   * @module ol/asserts
   */
  /**
   * @param {*} assertion Assertion we expected to be truthy.
   * @param {number} errorCode Error code.
   */
  function assert(assertion, errorCode) {
      if (!assertion) {
          throw new AssertionError(errorCode);
      }
  }

  /**
   * @module ol/transform
   */
  /**
   * An array representing an affine 2d transformation for use with
   * {@link module:ol/transform} functions. The array has 6 elements.
   * @typedef {!Array<number>} Transform
   * @api
   */
  /**
   * Collection of affine 2d transformation functions. The functions work on an
   * array of 6 elements. The element order is compatible with the [SVGMatrix
   * interface](https://developer.mozilla.org/en-US/docs/Web/API/SVGMatrix) and is
   * a subset (elements a to f) of a 3×3 matrix:
   * ```
   * [ a c e ]
   * [ b d f ]
   * [ 0 0 1 ]
   * ```
   */
  /**
   * @private
   * @type {Transform}
   */
  var tmp_ = new Array(6);
  /**
   * Create an identity transform.
   * @return {!Transform} Identity transform.
   */
  function create() {
      return [1, 0, 0, 1, 0, 0];
  }
  /**
   * Set the transform components a-f on a given transform.
   * @param {!Transform} transform Transform.
   * @param {number} a The a component of the transform.
   * @param {number} b The b component of the transform.
   * @param {number} c The c component of the transform.
   * @param {number} d The d component of the transform.
   * @param {number} e The e component of the transform.
   * @param {number} f The f component of the transform.
   * @return {!Transform} Matrix with transform applied.
   */
  function set(transform, a, b, c, d, e, f) {
      transform[0] = a;
      transform[1] = b;
      transform[2] = c;
      transform[3] = d;
      transform[4] = e;
      transform[5] = f;
      return transform;
  }
  /**
   * Set transform on one matrix from another matrix.
   * @param {!Transform} transform1 Matrix to set transform to.
   * @param {!Transform} transform2 Matrix to set transform from.
   * @return {!Transform} transform1 with transform from transform2 applied.
   */
  function setFromArray(transform1, transform2) {
      transform1[0] = transform2[0];
      transform1[1] = transform2[1];
      transform1[2] = transform2[2];
      transform1[3] = transform2[3];
      transform1[4] = transform2[4];
      transform1[5] = transform2[5];
      return transform1;
  }
  /**
   * Transforms the given coordinate with the given transform returning the
   * resulting, transformed coordinate. The coordinate will be modified in-place.
   *
   * @param {Transform} transform The transformation.
   * @param {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} coordinate The coordinate to transform.
   * @return {import("./coordinate.js").Coordinate|import("./pixel.js").Pixel} return coordinate so that operations can be
   *     chained together.
   */
  function apply(transform, coordinate) {
      var x = coordinate[0];
      var y = coordinate[1];
      coordinate[0] = transform[0] * x + transform[2] * y + transform[4];
      coordinate[1] = transform[1] * x + transform[3] * y + transform[5];
      return coordinate;
  }
  /**
   * Creates a scale transform.
   * @param {!Transform} target Transform to overwrite.
   * @param {number} x Scale factor x.
   * @param {number} y Scale factor y.
   * @return {!Transform} The scale transform.
   */
  function makeScale(target, x, y) {
      return set(target, x, 0, 0, y, 0, 0);
  }
  /**
   * Creates a composite transform given an initial translation, scale, rotation, and
   * final translation (in that order only, not commutative).
   * @param {!Transform} transform The transform (will be modified in place).
   * @param {number} dx1 Initial translation x.
   * @param {number} dy1 Initial translation y.
   * @param {number} sx Scale factor x.
   * @param {number} sy Scale factor y.
   * @param {number} angle Rotation (in counter-clockwise radians).
   * @param {number} dx2 Final translation x.
   * @param {number} dy2 Final translation y.
   * @return {!Transform} The composite transform.
   */
  function compose(transform, dx1, dy1, sx, sy, angle, dx2, dy2) {
      var sin = Math.sin(angle);
      var cos = Math.cos(angle);
      transform[0] = sx * cos;
      transform[1] = sy * sin;
      transform[2] = -sx * sin;
      transform[3] = sy * cos;
      transform[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
      transform[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
      return transform;
  }
  /**
   * Invert the given transform.
   * @param {!Transform} target Transform to be set as the inverse of
   *     the source transform.
   * @param {!Transform} source The source transform to invert.
   * @return {!Transform} The inverted (target) transform.
   */
  function makeInverse(target, source) {
      var det = determinant(source);
      assert(det !== 0, 32); // Transformation matrix cannot be inverted
      var a = source[0];
      var b = source[1];
      var c = source[2];
      var d = source[3];
      var e = source[4];
      var f = source[5];
      target[0] = d / det;
      target[1] = -b / det;
      target[2] = -c / det;
      target[3] = a / det;
      target[4] = (c * f - d * e) / det;
      target[5] = -(a * f - b * e) / det;
      return target;
  }
  /**
   * Returns the determinant of the given matrix.
   * @param {!Transform} mat Matrix.
   * @return {number} Determinant.
   */
  function determinant(mat) {
      return mat[0] * mat[3] - mat[1] * mat[2];
  }
  /**
   * A string version of the transform.  This can be used
   * for CSS transforms.
   * @param {!Transform} mat Matrix.
   * @return {string} The transform as a string.
   */
  function toString(mat) {
      return 'matrix(' + mat.join(', ') + ')';
  }

  /**
   * @module ol/extent/Corner
   */
  /**
   * Extent corner.
   * @enum {string}
   */
  var Corner = {
      BOTTOM_LEFT: 'bottom-left',
      BOTTOM_RIGHT: 'bottom-right',
      TOP_LEFT: 'top-left',
      TOP_RIGHT: 'top-right',
  };

  /**
   * @module ol/extent/Relationship
   */
  /**
   * Relationship to an extent.
   * @enum {number}
   */
  var Relationship = {
      UNKNOWN: 0,
      INTERSECTING: 1,
      ABOVE: 2,
      RIGHT: 4,
      BELOW: 8,
      LEFT: 16,
  };

  /**
   * @module ol/extent
   */
  /**
   * An array of numbers representing an extent: `[minx, miny, maxx, maxy]`.
   * @typedef {Array<number>} Extent
   * @api
   */
  /**
   * Build an extent that includes all given coordinates.
   *
   * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
   * @return {Extent} Bounding extent.
   * @api
   */
  function boundingExtent(coordinates) {
      var extent = createEmpty();
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
          extendCoordinate(extent, coordinates[i]);
      }
      return extent;
  }
  /**
   * @param {Array<number>} xs Xs.
   * @param {Array<number>} ys Ys.
   * @param {Extent=} opt_extent Destination extent.
   * @private
   * @return {Extent} Extent.
   */
  function _boundingExtentXYs(xs, ys, opt_extent) {
      var minX = Math.min.apply(null, xs);
      var minY = Math.min.apply(null, ys);
      var maxX = Math.max.apply(null, xs);
      var maxY = Math.max.apply(null, ys);
      return createOrUpdate(minX, minY, maxX, maxY, opt_extent);
  }
  /**
   * Return extent increased by the provided value.
   * @param {Extent} extent Extent.
   * @param {number} value The amount by which the extent should be buffered.
   * @param {Extent=} opt_extent Extent.
   * @return {Extent} Extent.
   * @api
   */
  function buffer(extent, value, opt_extent) {
      if (opt_extent) {
          opt_extent[0] = extent[0] - value;
          opt_extent[1] = extent[1] - value;
          opt_extent[2] = extent[2] + value;
          opt_extent[3] = extent[3] + value;
          return opt_extent;
      }
      else {
          return [
              extent[0] - value,
              extent[1] - value,
              extent[2] + value,
              extent[3] + value,
          ];
      }
  }
  /**
   * Creates a clone of an extent.
   *
   * @param {Extent} extent Extent to clone.
   * @param {Extent=} opt_extent Extent.
   * @return {Extent} The clone.
   */
  function clone(extent, opt_extent) {
      if (opt_extent) {
          opt_extent[0] = extent[0];
          opt_extent[1] = extent[1];
          opt_extent[2] = extent[2];
          opt_extent[3] = extent[3];
          return opt_extent;
      }
      else {
          return extent.slice();
      }
  }
  /**
   * @param {Extent} extent Extent.
   * @param {number} x X.
   * @param {number} y Y.
   * @return {number} Closest squared distance.
   */
  function closestSquaredDistanceXY(extent, x, y) {
      var dx, dy;
      if (x < extent[0]) {
          dx = extent[0] - x;
      }
      else if (extent[2] < x) {
          dx = x - extent[2];
      }
      else {
          dx = 0;
      }
      if (y < extent[1]) {
          dy = extent[1] - y;
      }
      else if (extent[3] < y) {
          dy = y - extent[3];
      }
      else {
          dy = 0;
      }
      return dx * dx + dy * dy;
  }
  /**
   * Check if the passed coordinate is contained or on the edge of the extent.
   *
   * @param {Extent} extent Extent.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @return {boolean} The coordinate is contained in the extent.
   * @api
   */
  function containsCoordinate(extent, coordinate) {
      return containsXY(extent, coordinate[0], coordinate[1]);
  }
  /**
   * Check if one extent contains another.
   *
   * An extent is deemed contained if it lies completely within the other extent,
   * including if they share one or more edges.
   *
   * @param {Extent} extent1 Extent 1.
   * @param {Extent} extent2 Extent 2.
   * @return {boolean} The second extent is contained by or on the edge of the
   *     first.
   * @api
   */
  function containsExtent(extent1, extent2) {
      return (extent1[0] <= extent2[0] &&
          extent2[2] <= extent1[2] &&
          extent1[1] <= extent2[1] &&
          extent2[3] <= extent1[3]);
  }
  /**
   * Check if the passed coordinate is contained or on the edge of the extent.
   *
   * @param {Extent} extent Extent.
   * @param {number} x X coordinate.
   * @param {number} y Y coordinate.
   * @return {boolean} The x, y values are contained in the extent.
   * @api
   */
  function containsXY(extent, x, y) {
      return extent[0] <= x && x <= extent[2] && extent[1] <= y && y <= extent[3];
  }
  /**
   * Get the relationship between a coordinate and extent.
   * @param {Extent} extent The extent.
   * @param {import("./coordinate.js").Coordinate} coordinate The coordinate.
   * @return {import("./extent/Relationship.js").default} The relationship (bitwise compare with
   *     import("./extent/Relationship.js").Relationship).
   */
  function coordinateRelationship(extent, coordinate) {
      var minX = extent[0];
      var minY = extent[1];
      var maxX = extent[2];
      var maxY = extent[3];
      var x = coordinate[0];
      var y = coordinate[1];
      var relationship = Relationship.UNKNOWN;
      if (x < minX) {
          relationship = relationship | Relationship.LEFT;
      }
      else if (x > maxX) {
          relationship = relationship | Relationship.RIGHT;
      }
      if (y < minY) {
          relationship = relationship | Relationship.BELOW;
      }
      else if (y > maxY) {
          relationship = relationship | Relationship.ABOVE;
      }
      if (relationship === Relationship.UNKNOWN) {
          relationship = Relationship.INTERSECTING;
      }
      return relationship;
  }
  /**
   * Create an empty extent.
   * @return {Extent} Empty extent.
   * @api
   */
  function createEmpty() {
      return [Infinity, Infinity, -Infinity, -Infinity];
  }
  /**
   * Create a new extent or update the provided extent.
   * @param {number} minX Minimum X.
   * @param {number} minY Minimum Y.
   * @param {number} maxX Maximum X.
   * @param {number} maxY Maximum Y.
   * @param {Extent=} opt_extent Destination extent.
   * @return {Extent} Extent.
   */
  function createOrUpdate(minX, minY, maxX, maxY, opt_extent) {
      if (opt_extent) {
          opt_extent[0] = minX;
          opt_extent[1] = minY;
          opt_extent[2] = maxX;
          opt_extent[3] = maxY;
          return opt_extent;
      }
      else {
          return [minX, minY, maxX, maxY];
      }
  }
  /**
   * Create a new empty extent or make the provided one empty.
   * @param {Extent=} opt_extent Extent.
   * @return {Extent} Extent.
   */
  function createOrUpdateEmpty(opt_extent) {
      return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, opt_extent);
  }
  /**
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {Extent=} opt_extent Extent.
   * @return {Extent} Extent.
   */
  function createOrUpdateFromCoordinate(coordinate, opt_extent) {
      var x = coordinate[0];
      var y = coordinate[1];
      return createOrUpdate(x, y, x, y, opt_extent);
  }
  /**
   * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {Extent=} opt_extent Extent.
   * @return {Extent} Extent.
   */
  function createOrUpdateFromCoordinates(coordinates, opt_extent) {
      var extent = createOrUpdateEmpty(opt_extent);
      return extendCoordinates(extent, coordinates);
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {Extent=} opt_extent Extent.
   * @return {Extent} Extent.
   */
  function createOrUpdateFromFlatCoordinates(flatCoordinates, offset, end, stride, opt_extent) {
      var extent = createOrUpdateEmpty(opt_extent);
      return extendFlatCoordinates(extent, flatCoordinates, offset, end, stride);
  }
  /**
   * Determine if two extents are equivalent.
   * @param {Extent} extent1 Extent 1.
   * @param {Extent} extent2 Extent 2.
   * @return {boolean} The two extents are equivalent.
   * @api
   */
  function equals$1(extent1, extent2) {
      return (extent1[0] == extent2[0] &&
          extent1[2] == extent2[2] &&
          extent1[1] == extent2[1] &&
          extent1[3] == extent2[3]);
  }
  /**
   * Modify an extent to include another extent.
   * @param {Extent} extent1 The extent to be modified.
   * @param {Extent} extent2 The extent that will be included in the first.
   * @return {Extent} A reference to the first (extended) extent.
   * @api
   */
  function extend$1(extent1, extent2) {
      if (extent2[0] < extent1[0]) {
          extent1[0] = extent2[0];
      }
      if (extent2[2] > extent1[2]) {
          extent1[2] = extent2[2];
      }
      if (extent2[1] < extent1[1]) {
          extent1[1] = extent2[1];
      }
      if (extent2[3] > extent1[3]) {
          extent1[3] = extent2[3];
      }
      return extent1;
  }
  /**
   * @param {Extent} extent Extent.
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   */
  function extendCoordinate(extent, coordinate) {
      if (coordinate[0] < extent[0]) {
          extent[0] = coordinate[0];
      }
      if (coordinate[0] > extent[2]) {
          extent[2] = coordinate[0];
      }
      if (coordinate[1] < extent[1]) {
          extent[1] = coordinate[1];
      }
      if (coordinate[1] > extent[3]) {
          extent[3] = coordinate[1];
      }
  }
  /**
   * @param {Extent} extent Extent.
   * @param {Array<import("./coordinate.js").Coordinate>} coordinates Coordinates.
   * @return {Extent} Extent.
   */
  function extendCoordinates(extent, coordinates) {
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
          extendCoordinate(extent, coordinates[i]);
      }
      return extent;
  }
  /**
   * @param {Extent} extent Extent.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @return {Extent} Extent.
   */
  function extendFlatCoordinates(extent, flatCoordinates, offset, end, stride) {
      for (; offset < end; offset += stride) {
          extendXY(extent, flatCoordinates[offset], flatCoordinates[offset + 1]);
      }
      return extent;
  }
  /**
   * @param {Extent} extent Extent.
   * @param {number} x X.
   * @param {number} y Y.
   */
  function extendXY(extent, x, y) {
      extent[0] = Math.min(extent[0], x);
      extent[1] = Math.min(extent[1], y);
      extent[2] = Math.max(extent[2], x);
      extent[3] = Math.max(extent[3], y);
  }
  /**
   * This function calls `callback` for each corner of the extent. If the
   * callback returns a truthy value the function returns that value
   * immediately. Otherwise the function returns `false`.
   * @param {Extent} extent Extent.
   * @param {function(import("./coordinate.js").Coordinate): S} callback Callback.
   * @return {S|boolean} Value.
   * @template S
   */
  function forEachCorner(extent, callback) {
      var val;
      val = callback(getBottomLeft(extent));
      if (val) {
          return val;
      }
      val = callback(getBottomRight(extent));
      if (val) {
          return val;
      }
      val = callback(getTopRight(extent));
      if (val) {
          return val;
      }
      val = callback(getTopLeft(extent));
      if (val) {
          return val;
      }
      return false;
  }
  /**
   * Get the size of an extent.
   * @param {Extent} extent Extent.
   * @return {number} Area.
   * @api
   */
  function getArea(extent) {
      var area = 0;
      if (!isEmpty(extent)) {
          area = getWidth(extent) * getHeight(extent);
      }
      return area;
  }
  /**
   * Get the bottom left coordinate of an extent.
   * @param {Extent} extent Extent.
   * @return {import("./coordinate.js").Coordinate} Bottom left coordinate.
   * @api
   */
  function getBottomLeft(extent) {
      return [extent[0], extent[1]];
  }
  /**
   * Get the bottom right coordinate of an extent.
   * @param {Extent} extent Extent.
   * @return {import("./coordinate.js").Coordinate} Bottom right coordinate.
   * @api
   */
  function getBottomRight(extent) {
      return [extent[2], extent[1]];
  }
  /**
   * Get the center coordinate of an extent.
   * @param {Extent} extent Extent.
   * @return {import("./coordinate.js").Coordinate} Center.
   * @api
   */
  function getCenter(extent) {
      return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
  }
  /**
   * Get a corner coordinate of an extent.
   * @param {Extent} extent Extent.
   * @param {import("./extent/Corner.js").default} corner Corner.
   * @return {import("./coordinate.js").Coordinate} Corner coordinate.
   */
  function getCorner(extent, corner) {
      var coordinate;
      if (corner === Corner.BOTTOM_LEFT) {
          coordinate = getBottomLeft(extent);
      }
      else if (corner === Corner.BOTTOM_RIGHT) {
          coordinate = getBottomRight(extent);
      }
      else if (corner === Corner.TOP_LEFT) {
          coordinate = getTopLeft(extent);
      }
      else if (corner === Corner.TOP_RIGHT) {
          coordinate = getTopRight(extent);
      }
      else {
          assert(false, 13); // Invalid corner
      }
      return coordinate;
  }
  /**
   * @param {import("./coordinate.js").Coordinate} center Center.
   * @param {number} resolution Resolution.
   * @param {number} rotation Rotation.
   * @param {import("./size.js").Size} size Size.
   * @param {Extent=} opt_extent Destination extent.
   * @return {Extent} Extent.
   */
  function getForViewAndSize(center, resolution, rotation, size, opt_extent) {
      var dx = (resolution * size[0]) / 2;
      var dy = (resolution * size[1]) / 2;
      var cosRotation = Math.cos(rotation);
      var sinRotation = Math.sin(rotation);
      var xCos = dx * cosRotation;
      var xSin = dx * sinRotation;
      var yCos = dy * cosRotation;
      var ySin = dy * sinRotation;
      var x = center[0];
      var y = center[1];
      var x0 = x - xCos + ySin;
      var x1 = x - xCos - ySin;
      var x2 = x + xCos - ySin;
      var x3 = x + xCos + ySin;
      var y0 = y - xSin - yCos;
      var y1 = y - xSin + yCos;
      var y2 = y + xSin + yCos;
      var y3 = y + xSin - yCos;
      return createOrUpdate(Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), opt_extent);
  }
  /**
   * Get the height of an extent.
   * @param {Extent} extent Extent.
   * @return {number} Height.
   * @api
   */
  function getHeight(extent) {
      return extent[3] - extent[1];
  }
  /**
   * Get the intersection of two extents.
   * @param {Extent} extent1 Extent 1.
   * @param {Extent} extent2 Extent 2.
   * @param {Extent=} opt_extent Optional extent to populate with intersection.
   * @return {Extent} Intersecting extent.
   * @api
   */
  function getIntersection(extent1, extent2, opt_extent) {
      var intersection = opt_extent ? opt_extent : createEmpty();
      if (intersects(extent1, extent2)) {
          if (extent1[0] > extent2[0]) {
              intersection[0] = extent1[0];
          }
          else {
              intersection[0] = extent2[0];
          }
          if (extent1[1] > extent2[1]) {
              intersection[1] = extent1[1];
          }
          else {
              intersection[1] = extent2[1];
          }
          if (extent1[2] < extent2[2]) {
              intersection[2] = extent1[2];
          }
          else {
              intersection[2] = extent2[2];
          }
          if (extent1[3] < extent2[3]) {
              intersection[3] = extent1[3];
          }
          else {
              intersection[3] = extent2[3];
          }
      }
      else {
          createOrUpdateEmpty(intersection);
      }
      return intersection;
  }
  /**
   * Get the top left coordinate of an extent.
   * @param {Extent} extent Extent.
   * @return {import("./coordinate.js").Coordinate} Top left coordinate.
   * @api
   */
  function getTopLeft(extent) {
      return [extent[0], extent[3]];
  }
  /**
   * Get the top right coordinate of an extent.
   * @param {Extent} extent Extent.
   * @return {import("./coordinate.js").Coordinate} Top right coordinate.
   * @api
   */
  function getTopRight(extent) {
      return [extent[2], extent[3]];
  }
  /**
   * Get the width of an extent.
   * @param {Extent} extent Extent.
   * @return {number} Width.
   * @api
   */
  function getWidth(extent) {
      return extent[2] - extent[0];
  }
  /**
   * Determine if one extent intersects another.
   * @param {Extent} extent1 Extent 1.
   * @param {Extent} extent2 Extent.
   * @return {boolean} The two extents intersect.
   * @api
   */
  function intersects(extent1, extent2) {
      return (extent1[0] <= extent2[2] &&
          extent1[2] >= extent2[0] &&
          extent1[1] <= extent2[3] &&
          extent1[3] >= extent2[1]);
  }
  /**
   * Determine if an extent is empty.
   * @param {Extent} extent Extent.
   * @return {boolean} Is empty.
   * @api
   */
  function isEmpty(extent) {
      return extent[2] < extent[0] || extent[3] < extent[1];
  }
  /**
   * @param {Extent} extent Extent.
   * @param {Extent=} opt_extent Extent.
   * @return {Extent} Extent.
   */
  function returnOrUpdate(extent, opt_extent) {
      if (opt_extent) {
          opt_extent[0] = extent[0];
          opt_extent[1] = extent[1];
          opt_extent[2] = extent[2];
          opt_extent[3] = extent[3];
          return opt_extent;
      }
      else {
          return extent;
      }
  }
  /**
   * @param {Extent} extent Extent.
   * @param {number} value Value.
   */
  function scaleFromCenter(extent, value) {
      var deltaX = ((extent[2] - extent[0]) / 2) * (value - 1);
      var deltaY = ((extent[3] - extent[1]) / 2) * (value - 1);
      extent[0] -= deltaX;
      extent[2] += deltaX;
      extent[1] -= deltaY;
      extent[3] += deltaY;
  }
  /**
   * Determine if the segment between two coordinates intersects (crosses,
   * touches, or is contained by) the provided extent.
   * @param {Extent} extent The extent.
   * @param {import("./coordinate.js").Coordinate} start Segment start coordinate.
   * @param {import("./coordinate.js").Coordinate} end Segment end coordinate.
   * @return {boolean} The segment intersects the extent.
   */
  function intersectsSegment(extent, start, end) {
      var intersects = false;
      var startRel = coordinateRelationship(extent, start);
      var endRel = coordinateRelationship(extent, end);
      if (startRel === Relationship.INTERSECTING ||
          endRel === Relationship.INTERSECTING) {
          intersects = true;
      }
      else {
          var minX = extent[0];
          var minY = extent[1];
          var maxX = extent[2];
          var maxY = extent[3];
          var startX = start[0];
          var startY = start[1];
          var endX = end[0];
          var endY = end[1];
          var slope = (endY - startY) / (endX - startX);
          var x = void 0, y = void 0;
          if (!!(endRel & Relationship.ABOVE) && !(startRel & Relationship.ABOVE)) {
              // potentially intersects top
              x = endX - (endY - maxY) / slope;
              intersects = x >= minX && x <= maxX;
          }
          if (!intersects &&
              !!(endRel & Relationship.RIGHT) &&
              !(startRel & Relationship.RIGHT)) {
              // potentially intersects right
              y = endY - (endX - maxX) * slope;
              intersects = y >= minY && y <= maxY;
          }
          if (!intersects &&
              !!(endRel & Relationship.BELOW) &&
              !(startRel & Relationship.BELOW)) {
              // potentially intersects bottom
              x = endX - (endY - minY) / slope;
              intersects = x >= minX && x <= maxX;
          }
          if (!intersects &&
              !!(endRel & Relationship.LEFT) &&
              !(startRel & Relationship.LEFT)) {
              // potentially intersects left
              y = endY - (endX - minX) * slope;
              intersects = y >= minY && y <= maxY;
          }
      }
      return intersects;
  }
  /**
   * Apply a transform function to the extent.
   * @param {Extent} extent Extent.
   * @param {import("./proj.js").TransformFunction} transformFn Transform function.
   * Called with `[minX, minY, maxX, maxY]` extent coordinates.
   * @param {Extent=} opt_extent Destination extent.
   * @param {number=} opt_stops Number of stops per side used for the transform.
   * By default only the corners are used.
   * @return {Extent} Extent.
   * @api
   */
  function applyTransform(extent, transformFn, opt_extent, opt_stops) {
      var coordinates = [];
      if (opt_stops > 1) {
          var width = extent[2] - extent[0];
          var height = extent[3] - extent[1];
          for (var i = 0; i < opt_stops; ++i) {
              coordinates.push(extent[0] + (width * i) / opt_stops, extent[1], extent[2], extent[1] + (height * i) / opt_stops, extent[2] - (width * i) / opt_stops, extent[3], extent[0], extent[3] - (height * i) / opt_stops);
          }
      }
      else {
          coordinates = [
              extent[0],
              extent[1],
              extent[2],
              extent[1],
              extent[2],
              extent[3],
              extent[0],
              extent[3],
          ];
      }
      transformFn(coordinates, coordinates, 2);
      var xs = [];
      var ys = [];
      for (var i = 0, l = coordinates.length; i < l; i += 2) {
          xs.push(coordinates[i]);
          ys.push(coordinates[i + 1]);
      }
      return _boundingExtentXYs(xs, ys, opt_extent);
  }
  /**
   * Modifies the provided extent in-place to be within the real world
   * extent.
   *
   * @param {Extent} extent Extent.
   * @param {import("./proj/Projection.js").default} projection Projection
   * @return {Extent} The extent within the real world extent.
   */
  function wrapX(extent, projection) {
      var projectionExtent = projection.getExtent();
      var center = getCenter(extent);
      if (projection.canWrapX() &&
          (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
          var worldWidth = getWidth(projectionExtent);
          var worldsAway = Math.floor((center[0] - projectionExtent[0]) / worldWidth);
          var offset = worldsAway * worldWidth;
          extent[0] -= offset;
          extent[2] -= offset;
      }
      return extent;
  }

  /**
   * @module ol/math
   */
  /**
   * Takes a number and clamps it to within the provided bounds.
   * @param {number} value The input number.
   * @param {number} min The minimum value to return.
   * @param {number} max The maximum value to return.
   * @return {number} The input number if it is within bounds, or the nearest
   *     number within the bounds.
   */
  function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
  }
  /**
   * Return the hyperbolic cosine of a given number. The method will use the
   * native `Math.cosh` function if it is available, otherwise the hyperbolic
   * cosine will be calculated via the reference implementation of the Mozilla
   * developer network.
   *
   * @param {number} x X.
   * @return {number} Hyperbolic cosine of x.
   */
  var cosh = (function () {
      // Wrapped in a iife, to save the overhead of checking for the native
      // implementation on every invocation.
      var cosh;
      if ('cosh' in Math) {
          // The environment supports the native Math.cosh function, use it…
          cosh = Math.cosh;
      }
      else {
          // … else, use the reference implementation of MDN:
          cosh = function (x) {
              var y = /** @type {Math} */ (Math).exp(x);
              return (y + 1 / y) / 2;
          };
      }
      return cosh;
  })();
  /**
   * Return the base 2 logarithm of a given number. The method will use the
   * native `Math.log2` function if it is available, otherwise the base 2
   * logarithm will be calculated via the reference implementation of the
   * Mozilla developer network.
   *
   * @param {number} x X.
   * @return {number} Base 2 logarithm of x.
   */
  var log2 = (function () {
      // Wrapped in a iife, to save the overhead of checking for the native
      // implementation on every invocation.
      var log2;
      if ('log2' in Math) {
          // The environment supports the native Math.log2 function, use it…
          log2 = Math.log2;
      }
      else {
          // … else, use the reference implementation of MDN:
          log2 = function (x) {
              return Math.log(x) * Math.LOG2E;
          };
      }
      return log2;
  })();
  /**
   * Returns the square of the closest distance between the point (x, y) and the
   * line segment (x1, y1) to (x2, y2).
   * @param {number} x X.
   * @param {number} y Y.
   * @param {number} x1 X1.
   * @param {number} y1 Y1.
   * @param {number} x2 X2.
   * @param {number} y2 Y2.
   * @return {number} Squared distance.
   */
  function squaredSegmentDistance(x, y, x1, y1, x2, y2) {
      var dx = x2 - x1;
      var dy = y2 - y1;
      if (dx !== 0 || dy !== 0) {
          var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
          if (t > 1) {
              x1 = x2;
              y1 = y2;
          }
          else if (t > 0) {
              x1 += dx * t;
              y1 += dy * t;
          }
      }
      return squaredDistance(x, y, x1, y1);
  }
  /**
   * Returns the square of the distance between the points (x1, y1) and (x2, y2).
   * @param {number} x1 X1.
   * @param {number} y1 Y1.
   * @param {number} x2 X2.
   * @param {number} y2 Y2.
   * @return {number} Squared distance.
   */
  function squaredDistance(x1, y1, x2, y2) {
      var dx = x2 - x1;
      var dy = y2 - y1;
      return dx * dx + dy * dy;
  }
  /**
   * Solves system of linear equations using Gaussian elimination method.
   *
   * @param {Array<Array<number>>} mat Augmented matrix (n x n + 1 column)
   *                                     in row-major order.
   * @return {Array<number>} The resulting vector.
   */
  function solveLinearSystem(mat) {
      var n = mat.length;
      for (var i = 0; i < n; i++) {
          // Find max in the i-th column (ignoring i - 1 first rows)
          var maxRow = i;
          var maxEl = Math.abs(mat[i][i]);
          for (var r = i + 1; r < n; r++) {
              var absValue = Math.abs(mat[r][i]);
              if (absValue > maxEl) {
                  maxEl = absValue;
                  maxRow = r;
              }
          }
          if (maxEl === 0) {
              return null; // matrix is singular
          }
          // Swap max row with i-th (current) row
          var tmp = mat[maxRow];
          mat[maxRow] = mat[i];
          mat[i] = tmp;
          // Subtract the i-th row to make all the remaining rows 0 in the i-th column
          for (var j = i + 1; j < n; j++) {
              var coef = -mat[j][i] / mat[i][i];
              for (var k = i; k < n + 1; k++) {
                  if (i == k) {
                      mat[j][k] = 0;
                  }
                  else {
                      mat[j][k] += coef * mat[i][k];
                  }
              }
          }
      }
      // Solve Ax=b for upper triangular matrix A (mat)
      var x = new Array(n);
      for (var l = n - 1; l >= 0; l--) {
          x[l] = mat[l][n] / mat[l][l];
          for (var m = l - 1; m >= 0; m--) {
              mat[m][n] -= mat[m][l] * x[l];
          }
      }
      return x;
  }
  /**
   * Converts degrees to radians.
   *
   * @param {number} angleInDegrees Angle in degrees.
   * @return {number} Angle in radians.
   */
  function toRadians(angleInDegrees) {
      return (angleInDegrees * Math.PI) / 180;
  }
  /**
   * Returns the modulo of a / b, depending on the sign of b.
   *
   * @param {number} a Dividend.
   * @param {number} b Divisor.
   * @return {number} Modulo.
   */
  function modulo(a, b) {
      var r = a % b;
      return r * b < 0 ? r + b : r;
  }
  /**
   * Calculates the linearly interpolated value of x between a and b.
   *
   * @param {number} a Number
   * @param {number} b Number
   * @param {number} x Value to be interpolated.
   * @return {number} Interpolated value.
   */
  function lerp(a, b, x) {
      return a + x * (b - a);
  }

  /**
   * @module ol/color
   */
  /**
   * A color represented as a short array [red, green, blue, alpha].
   * red, green, and blue should be integers in the range 0..255 inclusive.
   * alpha should be a float in the range 0..1 inclusive. If no alpha value is
   * given then `1` will be used.
   * @typedef {Array<number>} Color
   * @api
   */
  /**
   * This RegExp matches # followed by 3, 4, 6, or 8 hex digits.
   * @const
   * @type {RegExp}
   * @private
   */
  var HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;
  /**
   * Regular expression for matching potential named color style strings.
   * @const
   * @type {RegExp}
   * @private
   */
  var NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\(.*\)$/i;
  /**
   * Return the color as an rgba string.
   * @param {Color|string} color Color.
   * @return {string} Rgba string.
   * @api
   */
  function asString(color) {
      if (typeof color === 'string') {
          return color;
      }
      else {
          return toString$1(color);
      }
  }
  /**
   * Return named color as an rgba string.
   * @param {string} color Named color.
   * @return {string} Rgb string.
   */
  function fromNamed(color) {
      var el = document.createElement('div');
      el.style.color = color;
      if (el.style.color !== '') {
          document.body.appendChild(el);
          var rgb = getComputedStyle(el).color;
          document.body.removeChild(el);
          return rgb;
      }
      else {
          return '';
      }
  }
  /**
   * @param {string} s String.
   * @return {Color} Color.
   */
  var fromString = (function () {
      // We maintain a small cache of parsed strings.  To provide cheap LRU-like
      // semantics, whenever the cache grows too large we simply delete an
      // arbitrary 25% of the entries.
      /**
       * @const
       * @type {number}
       */
      var MAX_CACHE_SIZE = 1024;
      /**
       * @type {Object<string, Color>}
       */
      var cache = {};
      /**
       * @type {number}
       */
      var cacheSize = 0;
      return (
      /**
       * @param {string} s String.
       * @return {Color} Color.
       */
      function (s) {
          var color;
          if (cache.hasOwnProperty(s)) {
              color = cache[s];
          }
          else {
              if (cacheSize >= MAX_CACHE_SIZE) {
                  var i = 0;
                  for (var key in cache) {
                      if ((i++ & 3) === 0) {
                          delete cache[key];
                          --cacheSize;
                      }
                  }
              }
              color = fromStringInternal_(s);
              cache[s] = color;
              ++cacheSize;
          }
          return color;
      });
  })();
  /**
   * Return the color as an array. This function maintains a cache of calculated
   * arrays which means the result should not be modified.
   * @param {Color|string} color Color.
   * @return {Color} Color.
   * @api
   */
  function asArray(color) {
      if (Array.isArray(color)) {
          return color;
      }
      else {
          return fromString(color);
      }
  }
  /**
   * @param {string} s String.
   * @private
   * @return {Color} Color.
   */
  function fromStringInternal_(s) {
      var r, g, b, a, color;
      if (NAMED_COLOR_RE_.exec(s)) {
          s = fromNamed(s);
      }
      if (HEX_COLOR_RE_.exec(s)) {
          // hex
          var n = s.length - 1; // number of hex digits
          var d = // number of digits per channel
           void 0; // number of digits per channel
          if (n <= 4) {
              d = 1;
          }
          else {
              d = 2;
          }
          var hasAlpha = n === 4 || n === 8;
          r = parseInt(s.substr(1 + 0 * d, d), 16);
          g = parseInt(s.substr(1 + 1 * d, d), 16);
          b = parseInt(s.substr(1 + 2 * d, d), 16);
          if (hasAlpha) {
              a = parseInt(s.substr(1 + 3 * d, d), 16);
          }
          else {
              a = 255;
          }
          if (d == 1) {
              r = (r << 4) + r;
              g = (g << 4) + g;
              b = (b << 4) + b;
              if (hasAlpha) {
                  a = (a << 4) + a;
              }
          }
          color = [r, g, b, a / 255];
      }
      else if (s.indexOf('rgba(') == 0) {
          // rgba()
          color = s.slice(5, -1).split(',').map(Number);
          normalize(color);
      }
      else if (s.indexOf('rgb(') == 0) {
          // rgb()
          color = s.slice(4, -1).split(',').map(Number);
          color.push(1);
          normalize(color);
      }
      else {
          assert(false, 14); // Invalid color
      }
      return color;
  }
  /**
   * TODO this function is only used in the test, we probably shouldn't export it
   * @param {Color} color Color.
   * @return {Color} Clamped color.
   */
  function normalize(color) {
      color[0] = clamp((color[0] + 0.5) | 0, 0, 255);
      color[1] = clamp((color[1] + 0.5) | 0, 0, 255);
      color[2] = clamp((color[2] + 0.5) | 0, 0, 255);
      color[3] = clamp(color[3], 0, 1);
      return color;
  }
  /**
   * @param {Color} color Color.
   * @return {string} String.
   */
  function toString$1(color) {
      var r = color[0];
      if (r != (r | 0)) {
          r = (r + 0.5) | 0;
      }
      var g = color[1];
      if (g != (g | 0)) {
          g = (g + 0.5) | 0;
      }
      var b = color[2];
      if (b != (b | 0)) {
          b = (b + 0.5) | 0;
      }
      var a = color[3] === undefined ? 1 : color[3];
      return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')';
  }

  /**
   * @module ol/style/IconImageCache
   */
  /**
   * @classdesc
   * Singleton class. Available through {@link module:ol/style/IconImageCache~shared}.
   */
  var IconImageCache = /** @class */ (function () {
      function IconImageCache() {
          /**
           * @type {!Object<string, import("./IconImage.js").default>}
           * @private
           */
          this.cache_ = {};
          /**
           * @type {number}
           * @private
           */
          this.cacheSize_ = 0;
          /**
           * @type {number}
           * @private
           */
          this.maxCacheSize_ = 32;
      }
      /**
       * FIXME empty description for jsdoc
       */
      IconImageCache.prototype.clear = function () {
          this.cache_ = {};
          this.cacheSize_ = 0;
      };
      /**
       * @return {boolean} Can expire cache.
       */
      IconImageCache.prototype.canExpireCache = function () {
          return this.cacheSize_ > this.maxCacheSize_;
      };
      /**
       * FIXME empty description for jsdoc
       */
      IconImageCache.prototype.expire = function () {
          if (this.canExpireCache()) {
              var i = 0;
              for (var key in this.cache_) {
                  var iconImage = this.cache_[key];
                  if ((i++ & 3) === 0 && !iconImage.hasListener()) {
                      delete this.cache_[key];
                      --this.cacheSize_;
                  }
              }
          }
      };
      /**
       * @param {string} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../color.js").Color} color Color.
       * @return {import("./IconImage.js").default} Icon image.
       */
      IconImageCache.prototype.get = function (src, crossOrigin, color) {
          var key = getKey(src, crossOrigin, color);
          return key in this.cache_ ? this.cache_[key] : null;
      };
      /**
       * @param {string} src Src.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../color.js").Color} color Color.
       * @param {import("./IconImage.js").default} iconImage Icon image.
       */
      IconImageCache.prototype.set = function (src, crossOrigin, color, iconImage) {
          var key = getKey(src, crossOrigin, color);
          this.cache_[key] = iconImage;
          ++this.cacheSize_;
      };
      /**
       * Set the cache size of the icon cache. Default is `32`. Change this value when
       * your map uses more than 32 different icon images and you are not caching icon
       * styles on the application level.
       * @param {number} maxCacheSize Cache max size.
       * @api
       */
      IconImageCache.prototype.setSize = function (maxCacheSize) {
          this.maxCacheSize_ = maxCacheSize;
          this.expire();
      };
      return IconImageCache;
  }());
  /**
   * @param {string} src Src.
   * @param {?string} crossOrigin Cross origin.
   * @param {import("../color.js").Color} color Color.
   * @return {string} Cache key.
   */
  function getKey(src, crossOrigin, color) {
      var colorString = color ? asString(color) : 'null';
      return crossOrigin + ':' + src + ':' + colorString;
  }
  /**
   * The {@link module:ol/style/IconImageCache~IconImageCache} for
   * {@link module:ol/style/Icon~Icon} images.
   * @api
   */
  var shared = new IconImageCache();

  /**
   * @module ol/events/Event
   */
  /**
   * @classdesc
   * Stripped down implementation of the W3C DOM Level 2 Event interface.
   * See https://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-interface.
   *
   * This implementation only provides `type` and `target` properties, and
   * `stopPropagation` and `preventDefault` methods. It is meant as base class
   * for higher level events defined in the library, and works with
   * {@link module:ol/events/Target~Target}.
   */
  var BaseEvent = /** @class */ (function () {
      /**
       * @param {string} type Type.
       */
      function BaseEvent(type) {
          /**
           * @type {boolean}
           */
          this.propagationStopped;
          /**
           * The event type.
           * @type {string}
           * @api
           */
          this.type = type;
          /**
           * The event target.
           * @type {Object}
           * @api
           */
          this.target = null;
      }
      /**
       * Stop event propagation.
       * @api
       */
      BaseEvent.prototype.preventDefault = function () {
          this.propagationStopped = true;
      };
      /**
       * Stop event propagation.
       * @api
       */
      BaseEvent.prototype.stopPropagation = function () {
          this.propagationStopped = true;
      };
      return BaseEvent;
  }());

  /**
   * @module ol/ObjectEventType
   */
  /**
   * @enum {string}
   */
  var ObjectEventType = {
      /**
       * Triggered when a property is changed.
       * @event module:ol/Object.ObjectEvent#propertychange
       * @api
       */
      PROPERTYCHANGE: 'propertychange',
  };

  /**
   * @module ol/obj
   */
  /**
   * Polyfill for Object.assign().  Assigns enumerable and own properties from
   * one or more source objects to a target object.
   * See https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign.
   *
   * @param {!Object} target The target object.
   * @param {...Object} var_sources The source object(s).
   * @return {!Object} The modified target object.
   */
  var assign = typeof Object.assign === 'function'
      ? Object.assign
      : function (target, var_sources) {
          if (target === undefined || target === null) {
              throw new TypeError('Cannot convert undefined or null to object');
          }
          var output = Object(target);
          for (var i = 1, ii = arguments.length; i < ii; ++i) {
              var source = arguments[i];
              if (source !== undefined && source !== null) {
                  for (var key in source) {
                      if (source.hasOwnProperty(key)) {
                          output[key] = source[key];
                      }
                  }
              }
          }
          return output;
      };
  /**
   * Removes all properties from an object.
   * @param {Object} object The object to clear.
   */
  function clear(object) {
      for (var property in object) {
          delete object[property];
      }
  }
  /**
   * Polyfill for Object.values().  Get an array of property values from an object.
   * See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/values
   *
   * @param {!Object<K,V>} object The object from which to get the values.
   * @return {!Array<V>} The property values.
   * @template K,V
   */
  var getValues = typeof Object.values === 'function'
      ? Object.values
      : function (object) {
          var values = [];
          for (var property in object) {
              values.push(object[property]);
          }
          return values;
      };
  /**
   * Determine if an object has any properties.
   * @param {Object} object The object to check.
   * @return {boolean} The object is empty.
   */
  function isEmpty$1(object) {
      var property;
      for (property in object) {
          return false;
      }
      return !property;
  }

  var __extends$1 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {EventTarget|Target} EventTargetLike
   */
  /**
   * @classdesc
   * A simplified implementation of the W3C DOM Level 2 EventTarget interface.
   * See https://www.w3.org/TR/2000/REC-DOM-Level-2-Events-20001113/events.html#Events-EventTarget.
   *
   * There are two important simplifications compared to the specification:
   *
   * 1. The handling of `useCapture` in `addEventListener` and
   *    `removeEventListener`. There is no real capture model.
   * 2. The handling of `stopPropagation` and `preventDefault` on `dispatchEvent`.
   *    There is no event target hierarchy. When a listener calls
   *    `stopPropagation` or `preventDefault` on an event object, it means that no
   *    more listeners after this one will be called. Same as when the listener
   *    returns false.
   */
  var Target = /** @class */ (function (_super) {
      __extends$1(Target, _super);
      /**
       * @param {*=} opt_target Default event target for dispatched events.
       */
      function Target(opt_target) {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {*}
           */
          _this.eventTarget_ = opt_target;
          /**
           * @private
           * @type {Object<string, number>}
           */
          _this.pendingRemovals_ = null;
          /**
           * @private
           * @type {Object<string, number>}
           */
          _this.dispatching_ = null;
          /**
           * @private
           * @type {Object<string, Array<import("../events.js").Listener>>}
           */
          _this.listeners_ = null;
          return _this;
      }
      /**
       * @param {string} type Type.
       * @param {import("../events.js").Listener} listener Listener.
       */
      Target.prototype.addEventListener = function (type, listener) {
          if (!type || !listener) {
              return;
          }
          var listeners = this.listeners_ || (this.listeners_ = {});
          var listenersForType = listeners[type] || (listeners[type] = []);
          if (listenersForType.indexOf(listener) === -1) {
              listenersForType.push(listener);
          }
      };
      /**
       * Dispatches an event and calls all listeners listening for events
       * of this type. The event parameter can either be a string or an
       * Object with a `type` property.
       *
       * @param {import("./Event.js").default|string} event Event object.
       * @return {boolean|undefined} `false` if anyone called preventDefault on the
       *     event object or if any of the listeners returned false.
       * @api
       */
      Target.prototype.dispatchEvent = function (event) {
          /** @type {import("./Event.js").default|Event} */
          var evt = typeof event === 'string' ? new BaseEvent(event) : event;
          var type = evt.type;
          if (!evt.target) {
              evt.target = this.eventTarget_ || this;
          }
          var listeners = this.listeners_ && this.listeners_[type];
          var propagate;
          if (listeners) {
              var dispatching = this.dispatching_ || (this.dispatching_ = {});
              var pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
              if (!(type in dispatching)) {
                  dispatching[type] = 0;
                  pendingRemovals[type] = 0;
              }
              ++dispatching[type];
              for (var i = 0, ii = listeners.length; i < ii; ++i) {
                  if ('handleEvent' in listeners[i]) {
                      propagate = /** @type {import("../events.js").ListenerObject} */ (listeners[i]).handleEvent(evt);
                  }
                  else {
                      propagate = /** @type {import("../events.js").ListenerFunction} */ (listeners[i]).call(this, evt);
                  }
                  if (propagate === false || evt.propagationStopped) {
                      propagate = false;
                      break;
                  }
              }
              --dispatching[type];
              if (dispatching[type] === 0) {
                  var pr = pendingRemovals[type];
                  delete pendingRemovals[type];
                  while (pr--) {
                      this.removeEventListener(type, VOID);
                  }
                  delete dispatching[type];
              }
              return propagate;
          }
      };
      /**
       * Clean up.
       */
      Target.prototype.disposeInternal = function () {
          this.listeners_ && clear(this.listeners_);
      };
      /**
       * Get the listeners for a specified event type. Listeners are returned in the
       * order that they will be called in.
       *
       * @param {string} type Type.
       * @return {Array<import("../events.js").Listener>|undefined} Listeners.
       */
      Target.prototype.getListeners = function (type) {
          return (this.listeners_ && this.listeners_[type]) || undefined;
      };
      /**
       * @param {string=} opt_type Type. If not provided,
       *     `true` will be returned if this event target has any listeners.
       * @return {boolean} Has listeners.
       */
      Target.prototype.hasListener = function (opt_type) {
          if (!this.listeners_) {
              return false;
          }
          return opt_type
              ? opt_type in this.listeners_
              : Object.keys(this.listeners_).length > 0;
      };
      /**
       * @param {string} type Type.
       * @param {import("../events.js").Listener} listener Listener.
       */
      Target.prototype.removeEventListener = function (type, listener) {
          var listeners = this.listeners_ && this.listeners_[type];
          if (listeners) {
              var index = listeners.indexOf(listener);
              if (index !== -1) {
                  if (this.pendingRemovals_ && type in this.pendingRemovals_) {
                      // make listener a no-op, and remove later in #dispatchEvent()
                      listeners[index] = VOID;
                      ++this.pendingRemovals_[type];
                  }
                  else {
                      listeners.splice(index, 1);
                      if (listeners.length === 0) {
                          delete this.listeners_[type];
                      }
                  }
              }
          }
      };
      return Target;
  }(Disposable));

  /**
   * @module ol/events/EventType
   */
  /**
   * @enum {string}
   * @const
   */
  var EventType = {
      /**
       * Generic change event. Triggered when the revision counter is increased.
       * @event module:ol/events/Event~BaseEvent#change
       * @api
       */
      CHANGE: 'change',
      /**
       * Generic error event. Triggered when an error occurs.
       * @event module:ol/events/Event~BaseEvent#error
       * @api
       */
      ERROR: 'error',
      BLUR: 'blur',
      CLEAR: 'clear',
      CONTEXTMENU: 'contextmenu',
      CLICK: 'click',
      DBLCLICK: 'dblclick',
      DRAGENTER: 'dragenter',
      DRAGOVER: 'dragover',
      DROP: 'drop',
      FOCUS: 'focus',
      KEYDOWN: 'keydown',
      KEYPRESS: 'keypress',
      LOAD: 'load',
      RESIZE: 'resize',
      TOUCHMOVE: 'touchmove',
      WHEEL: 'wheel',
  };

  /**
   * @module ol/events
   */
  /**
   * Key to use with {@link module:ol/Observable~Observable#unByKey}.
   * @typedef {Object} EventsKey
   * @property {ListenerFunction} listener
   * @property {import("./events/Target.js").EventTargetLike} target
   * @property {string} type
   * @api
   */
  /**
   * Listener function. This function is called with an event object as argument.
   * When the function returns `false`, event propagation will stop.
   *
   * @typedef {function((Event|import("./events/Event.js").default)): (void|boolean)} ListenerFunction
   * @api
   */
  /**
   * @typedef {Object} ListenerObject
   * @property {ListenerFunction} handleEvent
   */
  /**
   * @typedef {ListenerFunction|ListenerObject} Listener
   */
  /**
   * Registers an event listener on an event target. Inspired by
   * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
   *
   * This function efficiently binds a `listener` to a `this` object, and returns
   * a key for use with {@link module:ol/events~unlistenByKey}.
   *
   * @param {import("./events/Target.js").EventTargetLike} target Event target.
   * @param {string} type Event type.
   * @param {ListenerFunction} listener Listener.
   * @param {Object=} opt_this Object referenced by the `this` keyword in the
   *     listener. Default is the `target`.
   * @param {boolean=} opt_once If true, add the listener as one-off listener.
   * @return {EventsKey} Unique key for the listener.
   */
  function listen(target, type, listener, opt_this, opt_once) {
      if (opt_this && opt_this !== target) {
          listener = listener.bind(opt_this);
      }
      if (opt_once) {
          var originalListener_1 = listener;
          listener = function () {
              target.removeEventListener(type, listener);
              originalListener_1.apply(this, arguments);
          };
      }
      var eventsKey = {
          target: target,
          type: type,
          listener: listener,
      };
      target.addEventListener(type, listener);
      return eventsKey;
  }
  /**
   * Registers a one-off event listener on an event target. Inspired by
   * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
   *
   * This function efficiently binds a `listener` as self-unregistering listener
   * to a `this` object, and returns a key for use with
   * {@link module:ol/events~unlistenByKey} in case the listener needs to be
   * unregistered before it is called.
   *
   * When {@link module:ol/events~listen} is called with the same arguments after this
   * function, the self-unregistering listener will be turned into a permanent
   * listener.
   *
   * @param {import("./events/Target.js").EventTargetLike} target Event target.
   * @param {string} type Event type.
   * @param {ListenerFunction} listener Listener.
   * @param {Object=} opt_this Object referenced by the `this` keyword in the
   *     listener. Default is the `target`.
   * @return {EventsKey} Key for unlistenByKey.
   */
  function listenOnce(target, type, listener, opt_this) {
      return listen(target, type, listener, opt_this, true);
  }
  /**
   * Unregisters event listeners on an event target. Inspired by
   * https://google.github.io/closure-library/api/source/closure/goog/events/events.js.src.html
   *
   * The argument passed to this function is the key returned from
   * {@link module:ol/events~listen} or {@link module:ol/events~listenOnce}.
   *
   * @param {EventsKey} key The key.
   */
  function unlistenByKey(key) {
      if (key && key.target) {
          key.target.removeEventListener(key.type, key.listener);
          clear(key);
      }
  }

  var __extends$2 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * An event target providing convenient methods for listener registration
   * and unregistration. A generic `change` event is always available through
   * {@link module:ol/Observable~Observable#changed}.
   *
   * @fires import("./events/Event.js").default
   * @api
   */
  var Observable = /** @class */ (function (_super) {
      __extends$2(Observable, _super);
      function Observable() {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {number}
           */
          _this.revision_ = 0;
          return _this;
      }
      /**
       * Increases the revision counter and dispatches a 'change' event.
       * @api
       */
      Observable.prototype.changed = function () {
          ++this.revision_;
          this.dispatchEvent(EventType.CHANGE);
      };
      /**
       * Get the version number for this object.  Each time the object is modified,
       * its version number will be incremented.
       * @return {number} Revision.
       * @api
       */
      Observable.prototype.getRevision = function () {
          return this.revision_;
      };
      /**
       * Listen for a certain type of event.
       * @param {string|Array<string>} type The event type or array of event types.
       * @param {function(?): ?} listener The listener function.
       * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
       *     called with an array of event types as the first argument, the return
       *     will be an array of keys.
       * @api
       */
      Observable.prototype.on = function (type, listener) {
          if (Array.isArray(type)) {
              var len = type.length;
              var keys = new Array(len);
              for (var i = 0; i < len; ++i) {
                  keys[i] = listen(this, type[i], listener);
              }
              return keys;
          }
          else {
              return listen(this, /** @type {string} */ (type), listener);
          }
      };
      /**
       * Listen once for a certain type of event.
       * @param {string|Array<string>} type The event type or array of event types.
       * @param {function(?): ?} listener The listener function.
       * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Unique key for the listener. If
       *     called with an array of event types as the first argument, the return
       *     will be an array of keys.
       * @api
       */
      Observable.prototype.once = function (type, listener) {
          var key;
          if (Array.isArray(type)) {
              var len = type.length;
              key = new Array(len);
              for (var i = 0; i < len; ++i) {
                  key[i] = listenOnce(this, type[i], listener);
              }
          }
          else {
              key = listenOnce(this, /** @type {string} */ (type), listener);
          }
          /** @type {Object} */ (listener).ol_key = key;
          return key;
      };
      /**
       * Unlisten for a certain type of event.
       * @param {string|Array<string>} type The event type or array of event types.
       * @param {function(?): ?} listener The listener function.
       * @api
       */
      Observable.prototype.un = function (type, listener) {
          var key = /** @type {Object} */ (listener).ol_key;
          if (key) {
              unByKey(key);
          }
          else if (Array.isArray(type)) {
              for (var i = 0, ii = type.length; i < ii; ++i) {
                  this.removeEventListener(type[i], listener);
              }
          }
          else {
              this.removeEventListener(type, listener);
          }
      };
      return Observable;
  }(Target));
  /**
   * Removes an event listener using the key returned by `on()` or `once()`.
   * @param {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} key The key returned by `on()`
   *     or `once()` (or an array of keys).
   * @api
   */
  function unByKey(key) {
      if (Array.isArray(key)) {
          for (var i = 0, ii = key.length; i < ii; ++i) {
              unlistenByKey(key[i]);
          }
      }
      else {
          unlistenByKey(/** @type {import("./events.js").EventsKey} */ (key));
      }
  }

  var __extends$3 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Events emitted by {@link module:ol/Object~BaseObject} instances are instances of this type.
   */
  var ObjectEvent = /** @class */ (function (_super) {
      __extends$3(ObjectEvent, _super);
      /**
       * @param {string} type The event type.
       * @param {string} key The property name.
       * @param {*} oldValue The old value for `key`.
       */
      function ObjectEvent(type, key, oldValue) {
          var _this = _super.call(this, type) || this;
          /**
           * The name of the property whose value is changing.
           * @type {string}
           * @api
           */
          _this.key = key;
          /**
           * The old value. To get the new value use `e.target.get(e.key)` where
           * `e` is the event object.
           * @type {*}
           * @api
           */
          _this.oldValue = oldValue;
          return _this;
      }
      return ObjectEvent;
  }(BaseEvent));
  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * Most non-trivial classes inherit from this.
   *
   * This extends {@link module:ol/Observable} with observable
   * properties, where each property is observable as well as the object as a
   * whole.
   *
   * Classes that inherit from this have pre-defined properties, to which you can
   * add your owns. The pre-defined properties are listed in this documentation as
   * 'Observable Properties', and have their own accessors; for example,
   * {@link module:ol/Map~Map} has a `target` property, accessed with
   * `getTarget()` and changed with `setTarget()`. Not all properties are however
   * settable. There are also general-purpose accessors `get()` and `set()`. For
   * example, `get('target')` is equivalent to `getTarget()`.
   *
   * The `set` accessors trigger a change event, and you can monitor this by
   * registering a listener. For example, {@link module:ol/View~View} has a
   * `center` property, so `view.on('change:center', function(evt) {...});` would
   * call the function whenever the value of the center property changes. Within
   * the function, `evt.target` would be the view, so `evt.target.getCenter()`
   * would return the new center.
   *
   * You can add your own observable properties with
   * `object.set('prop', 'value')`, and retrieve that with `object.get('prop')`.
   * You can listen for changes on that property value with
   * `object.on('change:prop', listener)`. You can get a list of all
   * properties with {@link module:ol/Object~BaseObject#getProperties}.
   *
   * Note that the observable properties are separate from standard JS properties.
   * You can, for example, give your map object a title with
   * `map.title='New title'` and with `map.set('title', 'Another title')`. The
   * first will be a `hasOwnProperty`; the second will appear in
   * `getProperties()`. Only the second is observable.
   *
   * Properties can be deleted by using the unset method. E.g.
   * object.unset('foo').
   *
   * @fires ObjectEvent
   * @api
   */
  var BaseObject = /** @class */ (function (_super) {
      __extends$3(BaseObject, _super);
      /**
       * @param {Object<string, *>=} opt_values An object with key-value pairs.
       */
      function BaseObject(opt_values) {
          var _this = _super.call(this) || this;
          // Call {@link module:ol/util~getUid} to ensure that the order of objects' ids is
          // the same as the order in which they were created.  This also helps to
          // ensure that object properties are always added in the same order, which
          // helps many JavaScript engines generate faster code.
          getUid(_this);
          /**
           * @private
           * @type {Object<string, *>}
           */
          _this.values_ = null;
          if (opt_values !== undefined) {
              _this.setProperties(opt_values);
          }
          return _this;
      }
      /**
       * Gets a value.
       * @param {string} key Key name.
       * @return {*} Value.
       * @api
       */
      BaseObject.prototype.get = function (key) {
          var value;
          if (this.values_ && this.values_.hasOwnProperty(key)) {
              value = this.values_[key];
          }
          return value;
      };
      /**
       * Get a list of object property names.
       * @return {Array<string>} List of property names.
       * @api
       */
      BaseObject.prototype.getKeys = function () {
          return (this.values_ && Object.keys(this.values_)) || [];
      };
      /**
       * Get an object of all property names and values.
       * @return {Object<string, *>} Object.
       * @api
       */
      BaseObject.prototype.getProperties = function () {
          return (this.values_ && assign({}, this.values_)) || {};
      };
      /**
       * @return {boolean} The object has properties.
       */
      BaseObject.prototype.hasProperties = function () {
          return !!this.values_;
      };
      /**
       * @param {string} key Key name.
       * @param {*} oldValue Old value.
       */
      BaseObject.prototype.notify = function (key, oldValue) {
          var eventType;
          eventType = getChangeEventType(key);
          this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
          eventType = ObjectEventType.PROPERTYCHANGE;
          this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
      };
      /**
       * Sets a value.
       * @param {string} key Key name.
       * @param {*} value Value.
       * @param {boolean=} opt_silent Update without triggering an event.
       * @api
       */
      BaseObject.prototype.set = function (key, value, opt_silent) {
          var values = this.values_ || (this.values_ = {});
          if (opt_silent) {
              values[key] = value;
          }
          else {
              var oldValue = values[key];
              values[key] = value;
              if (oldValue !== value) {
                  this.notify(key, oldValue);
              }
          }
      };
      /**
       * Sets a collection of key-value pairs.  Note that this changes any existing
       * properties and adds new ones (it does not remove any existing properties).
       * @param {Object<string, *>} values Values.
       * @param {boolean=} opt_silent Update without triggering an event.
       * @api
       */
      BaseObject.prototype.setProperties = function (values, opt_silent) {
          for (var key in values) {
              this.set(key, values[key], opt_silent);
          }
      };
      /**
       * Unsets a property.
       * @param {string} key Key name.
       * @param {boolean=} opt_silent Unset without triggering an event.
       * @api
       */
      BaseObject.prototype.unset = function (key, opt_silent) {
          if (this.values_ && key in this.values_) {
              var oldValue = this.values_[key];
              delete this.values_[key];
              if (isEmpty$1(this.values_)) {
                  this.values_ = null;
              }
              if (!opt_silent) {
                  this.notify(key, oldValue);
              }
          }
      };
      return BaseObject;
  }(Observable));
  /**
   * @type {Object<string, string>}
   */
  var changeEventTypeCache = {};
  /**
   * @param {string} key Key name.
   * @return {string} Change name.
   */
  function getChangeEventType(key) {
      return changeEventTypeCache.hasOwnProperty(key)
          ? changeEventTypeCache[key]
          : (changeEventTypeCache[key] = 'change:' + key);
  }

  /**
   * @module ol/layer/Property
   */
  /**
   * @enum {string}
   */
  var LayerProperty = {
      OPACITY: 'opacity',
      VISIBLE: 'visible',
      EXTENT: 'extent',
      Z_INDEX: 'zIndex',
      MAX_RESOLUTION: 'maxResolution',
      MIN_RESOLUTION: 'minResolution',
      MAX_ZOOM: 'maxZoom',
      MIN_ZOOM: 'minZoom',
      SOURCE: 'source',
  };

  var __extends$4 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
   * @property {number} [opacity=1] Opacity (0, 1).
   * @property {boolean} [visible=true] Visibility.
   * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
   * rendered outside of this extent.
   * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
   * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
   * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
   * method was used.
   * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
   * visible.
   * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
   * be visible.
   * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
   * visible.
   * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
   * be visible.
   */
  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * Note that with {@link module:ol/layer/Base} and all its subclasses, any property set in
   * the options is set as a {@link module:ol/Object} property on the layer object, so
   * is observable, and has get/set accessors.
   *
   * @api
   */
  var BaseLayer = /** @class */ (function (_super) {
      __extends$4(BaseLayer, _super);
      /**
       * @param {Options} options Layer options.
       */
      function BaseLayer(options) {
          var _this = _super.call(this) || this;
          /**
           * @type {Object<string, *>}
           */
          var properties = assign({}, options);
          properties[LayerProperty.OPACITY] =
              options.opacity !== undefined ? options.opacity : 1;
          assert(typeof properties[LayerProperty.OPACITY] === 'number', 64); // Layer opacity must be a number
          properties[LayerProperty.VISIBLE] =
              options.visible !== undefined ? options.visible : true;
          properties[LayerProperty.Z_INDEX] = options.zIndex;
          properties[LayerProperty.MAX_RESOLUTION] =
              options.maxResolution !== undefined ? options.maxResolution : Infinity;
          properties[LayerProperty.MIN_RESOLUTION] =
              options.minResolution !== undefined ? options.minResolution : 0;
          properties[LayerProperty.MIN_ZOOM] =
              options.minZoom !== undefined ? options.minZoom : -Infinity;
          properties[LayerProperty.MAX_ZOOM] =
              options.maxZoom !== undefined ? options.maxZoom : Infinity;
          /**
           * @type {string}
           * @private
           */
          _this.className_ =
              properties.className !== undefined ? options.className : 'ol-layer';
          delete properties.className;
          _this.setProperties(properties);
          /**
           * @type {import("./Layer.js").State}
           * @private
           */
          _this.state_ = null;
          return _this;
      }
      /**
       * @return {string} CSS class name.
       */
      BaseLayer.prototype.getClassName = function () {
          return this.className_;
      };
      /**
       * This method is not meant to be called by layers or layer renderers because the state
       * is incorrect if the layer is included in a layer group.
       *
       * @param {boolean=} opt_managed Layer is managed.
       * @return {import("./Layer.js").State} Layer state.
       */
      BaseLayer.prototype.getLayerState = function (opt_managed) {
          /** @type {import("./Layer.js").State} */
          var state = this.state_ ||
              /** @type {?} */ ({
                  layer: this,
                  managed: opt_managed === undefined ? true : opt_managed,
              });
          var zIndex = this.getZIndex();
          state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);
          state.sourceState = this.getSourceState();
          state.visible = this.getVisible();
          state.extent = this.getExtent();
          state.zIndex =
              zIndex !== undefined ? zIndex : state.managed === false ? Infinity : 0;
          state.maxResolution = this.getMaxResolution();
          state.minResolution = Math.max(this.getMinResolution(), 0);
          state.minZoom = this.getMinZoom();
          state.maxZoom = this.getMaxZoom();
          this.state_ = state;
          return state;
      };
      /**
       * @abstract
       * @param {Array<import("./Layer.js").default>=} opt_array Array of layers (to be
       *     modified in place).
       * @return {Array<import("./Layer.js").default>} Array of layers.
       */
      BaseLayer.prototype.getLayersArray = function (opt_array) {
          return abstract();
      };
      /**
       * @abstract
       * @param {Array<import("./Layer.js").State>=} opt_states Optional list of layer
       *     states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       */
      BaseLayer.prototype.getLayerStatesArray = function (opt_states) {
          return abstract();
      };
      /**
       * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
       * will be visible regardless of extent.
       * @return {import("../extent.js").Extent|undefined} The layer extent.
       * @observable
       * @api
       */
      BaseLayer.prototype.getExtent = function () {
          return /** @type {import("../extent.js").Extent|undefined} */ (this.get(LayerProperty.EXTENT));
      };
      /**
       * Return the maximum resolution of the layer.
       * @return {number} The maximum resolution of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.getMaxResolution = function () {
          return /** @type {number} */ (this.get(LayerProperty.MAX_RESOLUTION));
      };
      /**
       * Return the minimum resolution of the layer.
       * @return {number} The minimum resolution of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.getMinResolution = function () {
          return /** @type {number} */ (this.get(LayerProperty.MIN_RESOLUTION));
      };
      /**
       * Return the minimum zoom level of the layer.
       * @return {number} The minimum zoom level of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.getMinZoom = function () {
          return /** @type {number} */ (this.get(LayerProperty.MIN_ZOOM));
      };
      /**
       * Return the maximum zoom level of the layer.
       * @return {number} The maximum zoom level of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.getMaxZoom = function () {
          return /** @type {number} */ (this.get(LayerProperty.MAX_ZOOM));
      };
      /**
       * Return the opacity of the layer (between 0 and 1).
       * @return {number} The opacity of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.getOpacity = function () {
          return /** @type {number} */ (this.get(LayerProperty.OPACITY));
      };
      /**
       * @abstract
       * @return {import("../source/State.js").default} Source state.
       */
      BaseLayer.prototype.getSourceState = function () {
          return abstract();
      };
      /**
       * Return the visibility of the layer (`true` or `false`).
       * @return {boolean} The visibility of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.getVisible = function () {
          return /** @type {boolean} */ (this.get(LayerProperty.VISIBLE));
      };
      /**
       * Return the Z-index of the layer, which is used to order layers before
       * rendering. The default Z-index is 0.
       * @return {number} The Z-index of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.getZIndex = function () {
          return /** @type {number} */ (this.get(LayerProperty.Z_INDEX));
      };
      /**
       * Set the extent at which the layer is visible.  If `undefined`, the layer
       * will be visible at all extents.
       * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.setExtent = function (extent) {
          this.set(LayerProperty.EXTENT, extent);
      };
      /**
       * Set the maximum resolution at which the layer is visible.
       * @param {number} maxResolution The maximum resolution of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.setMaxResolution = function (maxResolution) {
          this.set(LayerProperty.MAX_RESOLUTION, maxResolution);
      };
      /**
       * Set the minimum resolution at which the layer is visible.
       * @param {number} minResolution The minimum resolution of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.setMinResolution = function (minResolution) {
          this.set(LayerProperty.MIN_RESOLUTION, minResolution);
      };
      /**
       * Set the maximum zoom (exclusive) at which the layer is visible.
       * Note that the zoom levels for layer visibility are based on the
       * view zoom level, which may be different from a tile source zoom level.
       * @param {number} maxZoom The maximum zoom of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.setMaxZoom = function (maxZoom) {
          this.set(LayerProperty.MAX_ZOOM, maxZoom);
      };
      /**
       * Set the minimum zoom (inclusive) at which the layer is visible.
       * Note that the zoom levels for layer visibility are based on the
       * view zoom level, which may be different from a tile source zoom level.
       * @param {number} minZoom The minimum zoom of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.setMinZoom = function (minZoom) {
          this.set(LayerProperty.MIN_ZOOM, minZoom);
      };
      /**
       * Set the opacity of the layer, allowed values range from 0 to 1.
       * @param {number} opacity The opacity of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.setOpacity = function (opacity) {
          assert(typeof opacity === 'number', 64); // Layer opacity must be a number
          this.set(LayerProperty.OPACITY, opacity);
      };
      /**
       * Set the visibility of the layer (`true` or `false`).
       * @param {boolean} visible The visibility of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.setVisible = function (visible) {
          this.set(LayerProperty.VISIBLE, visible);
      };
      /**
       * Set Z-index of the layer, which is used to order layers before rendering.
       * The default Z-index is 0.
       * @param {number} zindex The z-index of the layer.
       * @observable
       * @api
       */
      BaseLayer.prototype.setZIndex = function (zindex) {
          this.set(LayerProperty.Z_INDEX, zindex);
      };
      /**
       * Clean up.
       */
      BaseLayer.prototype.disposeInternal = function () {
          if (this.state_) {
              this.state_.layer = null;
              this.state_ = null;
          }
          _super.prototype.disposeInternal.call(this);
      };
      return BaseLayer;
  }(BaseObject));

  /**
   * @module ol/render/EventType
   */
  /**
   * @enum {string}
   */
  var EventType$1 = {
      /**
       * Triggered before a layer is rendered.
       * @event module:ol/render/Event~RenderEvent#prerender
       * @api
       */
      PRERENDER: 'prerender',
      /**
       * Triggered after a layer is rendered.
       * @event module:ol/render/Event~RenderEvent#postrender
       * @api
       */
      POSTRENDER: 'postrender',
      /**
       * Triggered before layers are rendered.
       * The event object will not have a `context` set.
       * @event module:ol/render/Event~RenderEvent#precompose
       * @api
       */
      PRECOMPOSE: 'precompose',
      /**
       * Triggered after all layers are rendered.
       * The event object will not have a `context` set.
       * @event module:ol/render/Event~RenderEvent#postcompose
       * @api
       */
      POSTCOMPOSE: 'postcompose',
      /**
       * Triggered when rendering is complete, i.e. all sources and tiles have
       * finished loading for the current viewport, and all tiles are faded in.
       * The event object will not have a `context` set.
       * @event module:ol/render/Event~RenderEvent#rendercomplete
       * @api
       */
      RENDERCOMPLETE: 'rendercomplete',
  };

  /**
   * @module ol/source/State
   */
  /**
   * @enum {string}
   * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
   */
  var SourceState = {
      UNDEFINED: 'undefined',
      LOADING: 'loading',
      READY: 'ready',
      ERROR: 'error',
  };

  var __extends$5 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {function(import("../PluggableMap.js").FrameState):HTMLElement} RenderFunction
   */
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
   * @property {number} [opacity=1] Opacity (0, 1).
   * @property {boolean} [visible=true] Visibility.
   * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
   * rendered outside of this extent.
   * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
   * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
   * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
   * method was used.
   * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
   * visible.
   * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
   * be visible.
   * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
   * visible.
   * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
   * be visible.
   * @property {import("../source/Source.js").default} [source] Source for this layer.  If not provided to the constructor,
   * the source can be set by calling {@link module:ol/layer/Layer#setSource layer.setSource(source)} after
   * construction.
   * @property {import("../PluggableMap.js").default} [map] Map.
   * @property {RenderFunction} [render] Render function. Takes the frame state as input and is expected to return an
   * HTML element. Will overwrite the default rendering for the layer.
   */
  /**
   * @typedef {Object} State
   * @property {import("./Layer.js").default} layer
   * @property {number} opacity Opacity, the value is rounded to two digits to appear after the decimal point.
   * @property {import("../source/State.js").default} sourceState
   * @property {boolean} visible
   * @property {boolean} managed
   * @property {import("../extent.js").Extent} [extent]
   * @property {number} zIndex
   * @property {number} maxResolution
   * @property {number} minResolution
   * @property {number} minZoom
   * @property {number} maxZoom
   */
  /**
   * @classdesc
   * Base class from which all layer types are derived. This should only be instantiated
   * in the case where a custom layer is be added to the map with a custom `render` function.
   * Such a function can be specified in the `options` object, and is expected to return an HTML element.
   *
   * A visual representation of raster or vector map data.
   * Layers group together those properties that pertain to how the data is to be
   * displayed, irrespective of the source of that data.
   *
   * Layers are usually added to a map with {@link module:ol/Map#addLayer}. Components
   * like {@link module:ol/interaction/Select~Select} use unmanaged layers
   * internally. These unmanaged layers are associated with the map using
   * {@link module:ol/layer/Layer~Layer#setMap} instead.
   *
   * A generic `change` event is fired when the state of the source changes.
   *
   * Please note that for performance reasons several layers might get rendered to
   * the same HTML element, which will cause {@link module:ol/Map~Map#forEachLayerAtPixel} to
   * give false positives. To avoid this, apply different `className` properties to the
   * layers at creation time.
   *
   * @fires import("../render/Event.js").RenderEvent#prerender
   * @fires import("../render/Event.js").RenderEvent#postrender
   *
   * @template {import("../source/Source.js").default} SourceType
   * @api
   */
  var Layer = /** @class */ (function (_super) {
      __extends$5(Layer, _super);
      /**
       * @param {Options} options Layer options.
       */
      function Layer(options) {
          var _this = this;
          var baseOptions = assign({}, options);
          delete baseOptions.source;
          _this = _super.call(this, baseOptions) || this;
          /**
           * @private
           * @type {?import("../events.js").EventsKey}
           */
          _this.mapPrecomposeKey_ = null;
          /**
           * @private
           * @type {?import("../events.js").EventsKey}
           */
          _this.mapRenderKey_ = null;
          /**
           * @private
           * @type {?import("../events.js").EventsKey}
           */
          _this.sourceChangeKey_ = null;
          /**
           * @private
           * @type {import("../renderer/Layer.js").default}
           */
          _this.renderer_ = null;
          // Overwrite default render method with a custom one
          if (options.render) {
              _this.render = options.render;
          }
          if (options.map) {
              _this.setMap(options.map);
          }
          _this.addEventListener(getChangeEventType(LayerProperty.SOURCE), _this.handleSourcePropertyChange_);
          var source = options.source
              ? /** @type {SourceType} */ (options.source)
              : null;
          _this.setSource(source);
          return _this;
      }
      /**
       * @param {Array<import("./Layer.js").default>=} opt_array Array of layers (to be modified in place).
       * @return {Array<import("./Layer.js").default>} Array of layers.
       */
      Layer.prototype.getLayersArray = function (opt_array) {
          var array = opt_array ? opt_array : [];
          array.push(this);
          return array;
      };
      /**
       * @param {Array<import("./Layer.js").State>=} opt_states Optional list of layer states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       */
      Layer.prototype.getLayerStatesArray = function (opt_states) {
          var states = opt_states ? opt_states : [];
          states.push(this.getLayerState());
          return states;
      };
      /**
       * Get the layer source.
       * @return {SourceType} The layer source (or `null` if not yet set).
       * @observable
       * @api
       */
      Layer.prototype.getSource = function () {
          return /** @type {SourceType} */ (this.get(LayerProperty.SOURCE)) || null;
      };
      /**
       * @return {import("../source/State.js").default} Source state.
       */
      Layer.prototype.getSourceState = function () {
          var source = this.getSource();
          return !source ? SourceState.UNDEFINED : source.getState();
      };
      /**
       * @private
       */
      Layer.prototype.handleSourceChange_ = function () {
          this.changed();
      };
      /**
       * @private
       */
      Layer.prototype.handleSourcePropertyChange_ = function () {
          if (this.sourceChangeKey_) {
              unlistenByKey(this.sourceChangeKey_);
              this.sourceChangeKey_ = null;
          }
          var source = this.getSource();
          if (source) {
              this.sourceChangeKey_ = listen(source, EventType.CHANGE, this.handleSourceChange_, this);
          }
          this.changed();
      };
      /**
       * @param {import("../pixel").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
       * an array of features.
       */
      Layer.prototype.getFeatures = function (pixel) {
          return this.renderer_.getFeatures(pixel);
      };
      /**
       * In charge to manage the rendering of the layer. One layer type is
       * bounded with one layer renderer.
       * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target which the renderer may (but need not) use
       * for rendering its content.
       * @return {HTMLElement} The rendered element.
       */
      Layer.prototype.render = function (frameState, target) {
          var layerRenderer = this.getRenderer();
          if (layerRenderer.prepareFrame(frameState)) {
              return layerRenderer.renderFrame(frameState, target);
          }
      };
      /**
       * Sets the layer to be rendered on top of other layers on a map. The map will
       * not manage this layer in its layers collection, and the callback in
       * {@link module:ol/Map#forEachLayerAtPixel} will receive `null` as layer. This
       * is useful for temporary layers. To remove an unmanaged layer from the map,
       * use `#setMap(null)`.
       *
       * To add the layer to a map and have it managed by the map, use
       * {@link module:ol/Map#addLayer} instead.
       * @param {import("../PluggableMap.js").default} map Map.
       * @api
       */
      Layer.prototype.setMap = function (map) {
          if (this.mapPrecomposeKey_) {
              unlistenByKey(this.mapPrecomposeKey_);
              this.mapPrecomposeKey_ = null;
          }
          if (!map) {
              this.changed();
          }
          if (this.mapRenderKey_) {
              unlistenByKey(this.mapRenderKey_);
              this.mapRenderKey_ = null;
          }
          if (map) {
              this.mapPrecomposeKey_ = listen(map, EventType$1.PRECOMPOSE, function (evt) {
                  var renderEvent = /** @type {import("../render/Event.js").default} */ (evt);
                  var layerStatesArray = renderEvent.frameState.layerStatesArray;
                  var layerState = this.getLayerState(false);
                  // A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both.
                  assert(!layerStatesArray.some(function (arrayLayerState) {
                      return arrayLayerState.layer === layerState.layer;
                  }), 67);
                  layerStatesArray.push(layerState);
              }, this);
              this.mapRenderKey_ = listen(this, EventType.CHANGE, map.render, map);
              this.changed();
          }
      };
      /**
       * Set the layer source.
       * @param {SourceType} source The layer source.
       * @observable
       * @api
       */
      Layer.prototype.setSource = function (source) {
          this.set(LayerProperty.SOURCE, source);
      };
      /**
       * Get the renderer for this layer.
       * @return {import("../renderer/Layer.js").default} The layer renderer.
       */
      Layer.prototype.getRenderer = function () {
          if (!this.renderer_) {
              this.renderer_ = this.createRenderer();
          }
          return this.renderer_;
      };
      /**
       * @return {boolean} The layer has a renderer.
       */
      Layer.prototype.hasRenderer = function () {
          return !!this.renderer_;
      };
      /**
       * Create a renderer for this layer.
       * @return {import("../renderer/Layer.js").default} A layer renderer.
       * @protected
       */
      Layer.prototype.createRenderer = function () {
          return null;
      };
      /**
       * Clean up.
       */
      Layer.prototype.disposeInternal = function () {
          this.setSource(null);
          _super.prototype.disposeInternal.call(this);
      };
      return Layer;
  }(BaseLayer));
  /**
   * Return `true` if the layer is visible and if the provided view state
   * has resolution and zoom levels that are in range of the layer's min/max.
   * @param {State} layerState Layer state.
   * @param {import("../View.js").State} viewState View state.
   * @return {boolean} The layer is visible at the given view state.
   */
  function inView(layerState, viewState) {
      if (!layerState.visible) {
          return false;
      }
      var resolution = viewState.resolution;
      if (resolution < layerState.minResolution ||
          resolution >= layerState.maxResolution) {
          return false;
      }
      var zoom = viewState.zoom;
      return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
  }

  /**
   * @module ol/geom/GeometryType
   */
  /**
   * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,
   * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
   * `'GeometryCollection'`, `'Circle'`.
   * @enum {string}
   */
  var GeometryType = {
      POINT: 'Point',
      LINE_STRING: 'LineString',
      LINEAR_RING: 'LinearRing',
      POLYGON: 'Polygon',
      MULTI_POINT: 'MultiPoint',
      MULTI_LINE_STRING: 'MultiLineString',
      MULTI_POLYGON: 'MultiPolygon',
      GEOMETRY_COLLECTION: 'GeometryCollection',
      CIRCLE: 'Circle',
  };

  /**
   * @module ol/render/VectorContext
   */
  /**
   * @classdesc
   * Context for drawing geometries.  A vector context is available on render
   * events and does not need to be constructed directly.
   * @api
   */
  var VectorContext = /** @class */ (function () {
      function VectorContext() {
      }
      /**
       * Render a geometry with a custom renderer.
       *
       * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       * @param {Function} renderer Renderer.
       */
      VectorContext.prototype.drawCustom = function (geometry, feature, renderer) { };
      /**
       * Render a geometry.
       *
       * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
       */
      VectorContext.prototype.drawGeometry = function (geometry) { };
      /**
       * Set the rendering style.
       *
       * @param {import("../style/Style.js").default} style The rendering style.
       */
      VectorContext.prototype.setStyle = function (style) { };
      /**
       * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
       * @param {import("../Feature.js").default} feature Feature.
       */
      VectorContext.prototype.drawCircle = function (circleGeometry, feature) { };
      /**
       * @param {import("../Feature.js").default} feature Feature.
       * @param {import("../style/Style.js").default} style Style.
       */
      VectorContext.prototype.drawFeature = function (feature, style) { };
      /**
       * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
       * @param {import("../Feature.js").default} feature Feature.
       */
      VectorContext.prototype.drawGeometryCollection = function (geometryCollectionGeometry, feature) { };
      /**
       * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      VectorContext.prototype.drawLineString = function (lineStringGeometry, feature) { };
      /**
       * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      VectorContext.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) { };
      /**
       * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      VectorContext.prototype.drawMultiPoint = function (multiPointGeometry, feature) { };
      /**
       * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      VectorContext.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) { };
      /**
       * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      VectorContext.prototype.drawPoint = function (pointGeometry, feature) { };
      /**
       * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      VectorContext.prototype.drawPolygon = function (polygonGeometry, feature) { };
      /**
       * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
       * @param {import("../Feature.js").FeatureLike} feature Feature.
       */
      VectorContext.prototype.drawText = function (geometry, feature) { };
      /**
       * @param {import("../style/Fill.js").default} fillStyle Fill style.
       * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
       */
      VectorContext.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) { };
      /**
       * @param {import("../style/Image.js").default} imageStyle Image style.
       * @param {import("./canvas.js").DeclutterGroup=} opt_declutterGroup Declutter.
       */
      VectorContext.prototype.setImageStyle = function (imageStyle, opt_declutterGroup) { };
      /**
       * @param {import("../style/Text.js").default} textStyle Text style.
       * @param {import("./canvas.js").DeclutterGroups=} opt_declutterGroups Declutter.
       */
      VectorContext.prototype.setTextStyle = function (textStyle, opt_declutterGroups) { };
      return VectorContext;
  }());

  /**
   * @module ol/colorlike
   */
  /**
   * A type accepted by CanvasRenderingContext2D.fillStyle
   * or CanvasRenderingContext2D.strokeStyle.
   * Represents a color, pattern, or gradient. The origin for patterns and
   * gradients as fill style is an increment of 512 css pixels from map coordinate
   * `[0, 0]`. For seamless repeat patterns, width and height of the pattern image
   * must be a factor of two (2, 4, 8, ..., 512).
   *
   * @typedef {string|CanvasPattern|CanvasGradient} ColorLike
   * @api
   */
  /**
   * @param {import("./color.js").Color|ColorLike} color Color.
   * @return {ColorLike} The color as an {@link ol/colorlike~ColorLike}.
   * @api
   */
  function asColorLike(color) {
      if (Array.isArray(color)) {
          return toString$1(color);
      }
      else {
          return color;
      }
  }

  /**
   * @module ol/has
   */
  var ua = typeof navigator !== 'undefined' && typeof navigator.userAgent !== 'undefined'
      ? navigator.userAgent.toLowerCase()
      : '';
  /**
   * User agent string says we are dealing with Firefox as browser.
   * @type {boolean}
   */
  var FIREFOX = ua.indexOf('firefox') !== -1;
  /**
   * User agent string says we are dealing with Safari as browser.
   * @type {boolean}
   */
  var SAFARI = ua.indexOf('safari') !== -1 && ua.indexOf('chrom') == -1;
  /**
   * User agent string says we are dealing with a WebKit engine.
   * @type {boolean}
   */
  var WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1;
  /**
   * User agent string says we are dealing with a Mac as platform.
   * @type {boolean}
   */
  var MAC = ua.indexOf('macintosh') !== -1;
  /**
   * The ratio between physical pixels and device-independent pixels
   * (dips) on the device (`window.devicePixelRatio`).
   * @const
   * @type {number}
   * @api
   */
  var DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== 'undefined' ? devicePixelRatio : 1;
  /**
   * The execution context is a worker with OffscreenCanvas available.
   * @const
   * @type {boolean}
   */
  var WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== 'undefined' &&
      typeof OffscreenCanvas !== 'undefined' &&
      self instanceof WorkerGlobalScope; //eslint-disable-line
  /**
   * Image.prototype.decode() is supported.
   * @type {boolean}
   */
  var IMAGE_DECODE = typeof Image !== 'undefined' && Image.prototype.decode;
  /**
   * @type {boolean}
   */
  var PASSIVE_EVENT_LISTENERS = (function () {
      var passive = false;
      try {
          var options = Object.defineProperty({}, 'passive', {
              get: function () {
                  passive = true;
              },
          });
          window.addEventListener('_', null, options);
          window.removeEventListener('_', null, options);
      }
      catch (error) {
          // passive not supported
      }
      return passive;
  })();

  /**
   * @module ol/dom
   */
  //FIXME Move this function to the canvas module
  /**
   * Create an html canvas element and returns its 2d context.
   * @param {number=} opt_width Canvas width.
   * @param {number=} opt_height Canvas height.
   * @param {Array<HTMLCanvasElement>=} opt_canvasPool Canvas pool to take existing canvas from.
   * @return {CanvasRenderingContext2D} The context.
   */
  function createCanvasContext2D(opt_width, opt_height, opt_canvasPool) {
      var canvas = opt_canvasPool && opt_canvasPool.length
          ? opt_canvasPool.shift()
          : WORKER_OFFSCREEN_CANVAS
              ? new OffscreenCanvas(opt_width || 300, opt_height || 300)
              : document.createElement('canvas');
      if (opt_width) {
          canvas.width = opt_width;
      }
      if (opt_height) {
          canvas.height = opt_height;
      }
      //FIXME Allow OffscreenCanvasRenderingContext2D as return type
      return /** @type {CanvasRenderingContext2D} */ (canvas.getContext('2d'));
  }
  /**
   * Get the current computed width for the given element including margin,
   * padding and border.
   * Equivalent to jQuery's `$(el).outerWidth(true)`.
   * @param {!HTMLElement} element Element.
   * @return {number} The width.
   */
  function outerWidth(element) {
      var width = element.offsetWidth;
      var style = getComputedStyle(element);
      width += parseInt(style.marginLeft, 10) + parseInt(style.marginRight, 10);
      return width;
  }
  /**
   * Get the current computed height for the given element including margin,
   * padding and border.
   * Equivalent to jQuery's `$(el).outerHeight(true)`.
   * @param {!HTMLElement} element Element.
   * @return {number} The height.
   */
  function outerHeight(element) {
      var height = element.offsetHeight;
      var style = getComputedStyle(element);
      height += parseInt(style.marginTop, 10) + parseInt(style.marginBottom, 10);
      return height;
  }
  /**
   * @param {Node} newNode Node to replace old node
   * @param {Node} oldNode The node to be replaced
   */
  function replaceNode(newNode, oldNode) {
      var parent = oldNode.parentNode;
      if (parent) {
          parent.replaceChild(newNode, oldNode);
      }
  }
  /**
   * @param {Node} node The node to remove.
   * @returns {Node} The node that was removed or null.
   */
  function removeNode(node) {
      return node && node.parentNode ? node.parentNode.removeChild(node) : null;
  }
  /**
   * @param {Node} node The node to remove the children from.
   */
  function removeChildren(node) {
      while (node.lastChild) {
          node.removeChild(node.lastChild);
      }
  }
  /**
   * Transform the children of a parent node so they match the
   * provided list of children.  This function aims to efficiently
   * remove, add, and reorder child nodes while maintaining a simple
   * implementation (it is not guaranteed to minimize DOM operations).
   * @param {Node} node The parent node whose children need reworking.
   * @param {Array<Node>} children The desired children.
   */
  function replaceChildren(node, children) {
      var oldChildren = node.childNodes;
      for (var i = 0; true; ++i) {
          var oldChild = oldChildren[i];
          var newChild = children[i];
          // check if our work is done
          if (!oldChild && !newChild) {
              break;
          }
          // check if children match
          if (oldChild === newChild) {
              continue;
          }
          // check if a new child needs to be added
          if (!oldChild) {
              node.appendChild(newChild);
              continue;
          }
          // check if an old child needs to be removed
          if (!newChild) {
              node.removeChild(oldChild);
              --i;
              continue;
          }
          // reorder
          node.insertBefore(newChild, oldChild);
      }
  }

  /**
   * @module ol/css
   */
  /**
   * @typedef {Object} FontParameters
   * @property {string} style
   * @property {string} variant
   * @property {string} weight
   * @property {string} size
   * @property {string} lineHeight
   * @property {string} family
   * @property {Array<string>} families
   */
  /**
   * The CSS class for hidden feature.
   *
   * @const
   * @type {string}
   */
  var CLASS_HIDDEN = 'ol-hidden';
  /**
   * The CSS class that we'll give the DOM elements to have them selectable.
   *
   * @const
   * @type {string}
   */
  var CLASS_SELECTABLE = 'ol-selectable';
  /**
   * The CSS class that we'll give the DOM elements to have them unselectable.
   *
   * @const
   * @type {string}
   */
  var CLASS_UNSELECTABLE = 'ol-unselectable';
  /**
   * The CSS class for controls.
   *
   * @const
   * @type {string}
   */
  var CLASS_CONTROL = 'ol-control';
  /**
   * The CSS class that we'll give the DOM elements that are collapsed, i.e.
   * to those elements which usually can be expanded.
   *
   * @const
   * @type {string}
   */
  var CLASS_COLLAPSED = 'ol-collapsed';
  /**
   * From http://stackoverflow.com/questions/10135697/regex-to-parse-any-css-font
   * @type {RegExp}
   */
  var fontRegEx = new RegExp([
      '^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)',
      '(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)',
      '(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)',
      '(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?',
      '(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))',
      '(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))',
      '?\\s*([-,\\"\\\'\\sa-z]+?)\\s*$',
  ].join(''), 'i');
  var fontRegExMatchIndex = [
      'style',
      'variant',
      'weight',
      'size',
      'lineHeight',
      'family',
  ];
  /**
   * Get the list of font families from a font spec.  Note that this doesn't work
   * for font families that have commas in them.
   * @param {string} fontSpec The CSS font property.
   * @return {FontParameters} The font parameters (or null if the input spec is invalid).
   */
  var getFontParameters = function (fontSpec) {
      var match = fontSpec.match(fontRegEx);
      if (!match) {
          return null;
      }
      var style = /** @type {FontParameters} */ ({
          lineHeight: 'normal',
          size: '1.2em',
          style: 'normal',
          weight: 'normal',
          variant: 'normal',
      });
      for (var i = 0, ii = fontRegExMatchIndex.length; i < ii; ++i) {
          var value = match[i + 1];
          if (value !== undefined) {
              style[fontRegExMatchIndex[i]] = value;
          }
      }
      style.families = style.family.split(/,\s?/);
      return style;
  };

  /**
   * @module ol/render/canvas
   */
  /**
   * @typedef {Object} FillState
   * @property {import("../colorlike.js").ColorLike} fillStyle
   */
  /**
   * @typedef Label
   * @property {number} width
   * @property {number} height
   * @property {Array<string|number>} contextInstructions
   */
  /**
   * @typedef {Object} FillStrokeState
   * @property {import("../colorlike.js").ColorLike} [currentFillStyle]
   * @property {import("../colorlike.js").ColorLike} [currentStrokeStyle]
   * @property {CanvasLineCap} [currentLineCap]
   * @property {Array<number>} currentLineDash
   * @property {number} [currentLineDashOffset]
   * @property {CanvasLineJoin} [currentLineJoin]
   * @property {number} [currentLineWidth]
   * @property {number} [currentMiterLimit]
   * @property {number} [lastStroke]
   * @property {import("../colorlike.js").ColorLike} [fillStyle]
   * @property {import("../colorlike.js").ColorLike} [strokeStyle]
   * @property {CanvasLineCap} [lineCap]
   * @property {Array<number>} lineDash
   * @property {number} [lineDashOffset]
   * @property {CanvasLineJoin} [lineJoin]
   * @property {number} [lineWidth]
   * @property {number} [miterLimit]
   */
  /**
   * @typedef {Object} StrokeState
   * @property {CanvasLineCap} lineCap
   * @property {Array<number>} lineDash
   * @property {number} lineDashOffset
   * @property {CanvasLineJoin} lineJoin
   * @property {number} lineWidth
   * @property {number} miterLimit
   * @property {import("../colorlike.js").ColorLike} strokeStyle
   */
  /**
   * @typedef {Object} TextState
   * @property {string} font
   * @property {string} [textAlign]
   * @property {string} textBaseline
   * @property {string} [placement]
   * @property {number} [maxAngle]
   * @property {boolean} [overflow]
   * @property {import("../style/Fill.js").default} [backgroundFill]
   * @property {import("../style/Stroke.js").default} [backgroundStroke]
   * @property {import("../size.js").Size} [scale]
   * @property {Array<number>} [padding]
   */
  /**
   * Container for decluttered replay instructions that need to be rendered or
   * omitted together, i.e. when styles render both an image and text, or for the
   * characters that form text along lines. The basic elements of this array are
   * `[minX, minY, maxX, maxY, count]`, where the first four entries are the
   * rendered extent of the group in pixel space. `count` is the number of styles
   * in the group, i.e. 2 when an image and a text are grouped, or 1 otherwise.
   * In addition to these four elements, declutter instruction arrays (i.e. the
   * arguments to {@link module:ol/render/canvas~drawImage} are appended to the array.
   * @typedef {Array<*>} DeclutterGroup
   */
  /**
   * Declutter groups for support of multi geometries.
   * @typedef {Array<DeclutterGroup>} DeclutterGroups
   */
  /**
   * @const
   * @type {string}
   */
  var defaultFont = '10px sans-serif';
  /**
   * @const
   * @type {import("../colorlike.js").ColorLike}
   */
  var defaultFillStyle = '#000';
  /**
   * @const
   * @type {CanvasLineCap}
   */
  var defaultLineCap = 'round';
  /**
   * @const
   * @type {Array<number>}
   */
  var defaultLineDash = [];
  /**
   * @const
   * @type {number}
   */
  var defaultLineDashOffset = 0;
  /**
   * @const
   * @type {CanvasLineJoin}
   */
  var defaultLineJoin = 'round';
  /**
   * @const
   * @type {number}
   */
  var defaultMiterLimit = 10;
  /**
   * @const
   * @type {import("../colorlike.js").ColorLike}
   */
  var defaultStrokeStyle = '#000';
  /**
   * @const
   * @type {string}
   */
  var defaultTextAlign = 'center';
  /**
   * @const
   * @type {string}
   */
  var defaultTextBaseline = 'middle';
  /**
   * @const
   * @type {Array<number>}
   */
  var defaultPadding = [0, 0, 0, 0];
  /**
   * @const
   * @type {number}
   */
  var defaultLineWidth = 1;
  /**
   * @type {BaseObject}
   */
  var checkedFonts = new BaseObject();
  /**
   * The label cache for text rendering. To change the default cache size of 2048
   * entries, use {@link module:ol/structs/LRUCache#setSize}.
   * Deprecated - there is no label cache any more.
   * @type {?}
   * @api
   * @deprecated
   */
  var labelCache = new Target();
  labelCache.setSize = function () {
      console.warn('labelCache is deprecated.'); //eslint-disable-line
  };
  /**
   * @type {CanvasRenderingContext2D}
   */
  var measureContext = null;
  /**
   * @type {string}
   */
  var measureFont;
  /**
   * @type {!Object<string, number>}
   */
  var textHeights = {};
  /**
   * Clears the label cache when a font becomes available.
   * @param {string} fontSpec CSS font spec.
   */
  var registerFont = (function () {
      var retries = 100;
      var size = '32px ';
      var referenceFonts = ['monospace', 'serif'];
      var len = referenceFonts.length;
      var text = 'wmytzilWMYTZIL@#/&?$%10\uF013';
      var interval, referenceWidth;
      /**
       * @param {string} fontStyle Css font-style
       * @param {string} fontWeight Css font-weight
       * @param {*} fontFamily Css font-family
       * @return {boolean} Font with style and weight is available
       */
      function isAvailable(fontStyle, fontWeight, fontFamily) {
          var available = true;
          for (var i = 0; i < len; ++i) {
              var referenceFont = referenceFonts[i];
              referenceWidth = measureTextWidth(fontStyle + ' ' + fontWeight + ' ' + size + referenceFont, text);
              if (fontFamily != referenceFont) {
                  var width = measureTextWidth(fontStyle +
                      ' ' +
                      fontWeight +
                      ' ' +
                      size +
                      fontFamily +
                      ',' +
                      referenceFont, text);
                  // If width and referenceWidth are the same, then the fallback was used
                  // instead of the font we wanted, so the font is not available.
                  available = available && width != referenceWidth;
              }
          }
          if (available) {
              return true;
          }
          return false;
      }
      function check() {
          var done = true;
          var fonts = checkedFonts.getKeys();
          for (var i = 0, ii = fonts.length; i < ii; ++i) {
              var font = fonts[i];
              if (checkedFonts.get(font) < retries) {
                  if (isAvailable.apply(this, font.split('\n'))) {
                      clear(textHeights);
                      // Make sure that loaded fonts are picked up by Safari
                      measureContext = null;
                      measureFont = undefined;
                      checkedFonts.set(font, retries);
                  }
                  else {
                      checkedFonts.set(font, checkedFonts.get(font) + 1, true);
                      done = false;
                  }
              }
          }
          if (done) {
              clearInterval(interval);
              interval = undefined;
          }
      }
      return function (fontSpec) {
          var font = getFontParameters(fontSpec);
          if (!font) {
              return;
          }
          var families = font.families;
          for (var i = 0, ii = families.length; i < ii; ++i) {
              var family = families[i];
              var key = font.style + '\n' + font.weight + '\n' + family;
              if (checkedFonts.get(key) === undefined) {
                  checkedFonts.set(key, retries, true);
                  if (!isAvailable(font.style, font.weight, family)) {
                      checkedFonts.set(key, 0, true);
                      if (interval === undefined) {
                          interval = setInterval(check, 32);
                      }
                  }
              }
          }
      };
  })();
  /**
   * @param {string} font Font to use for measuring.
   * @return {import("../size.js").Size} Measurement.
   */
  var measureTextHeight = (function () {
      /**
       * @type {HTMLDivElement}
       */
      var div;
      var heights = textHeights;
      return function (fontSpec) {
          var height = heights[fontSpec];
          if (height == undefined) {
              if (WORKER_OFFSCREEN_CANVAS) {
                  var font = getFontParameters(fontSpec);
                  var metrics = measureText(fontSpec, 'Žg');
                  var lineHeight = isNaN(Number(font.lineHeight))
                      ? 1.2
                      : Number(font.lineHeight);
                  textHeights[fontSpec] =
                      lineHeight *
                          (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
              }
              else {
                  if (!div) {
                      div = document.createElement('div');
                      div.innerHTML = 'M';
                      div.style.margin = '0 !important';
                      div.style.padding = '0 !important';
                      div.style.position = 'absolute !important';
                      div.style.left = '-99999px !important';
                  }
                  div.style.font = fontSpec;
                  document.body.appendChild(div);
                  height = div.offsetHeight;
                  heights[fontSpec] = height;
                  document.body.removeChild(div);
              }
          }
          return height;
      };
  })();
  /**
   * @param {string} font Font.
   * @param {string} text Text.
   * @return {TextMetrics} Text metrics.
   */
  function measureText(font, text) {
      if (!measureContext) {
          measureContext = createCanvasContext2D(1, 1);
      }
      if (font != measureFont) {
          measureContext.font = font;
          measureFont = measureContext.font;
      }
      return measureContext.measureText(text);
  }
  /**
   * @param {string} font Font.
   * @param {string} text Text.
   * @return {number} Width.
   */
  function measureTextWidth(font, text) {
      return measureText(font, text).width;
  }
  /**
   * Measure text width using a cache.
   * @param {string} font The font.
   * @param {string} text The text to measure.
   * @param {Object<string, number>} cache A lookup of cached widths by text.
   * @returns {number} The text width.
   */
  function measureAndCacheTextWidth(font, text, cache) {
      if (text in cache) {
          return cache[text];
      }
      var width = measureTextWidth(font, text);
      cache[text] = width;
      return width;
  }
  /**
   * @param {string} font Font to use for measuring.
   * @param {Array<string>} lines Lines to measure.
   * @param {Array<number>} widths Array will be populated with the widths of
   * each line.
   * @return {number} Width of the whole text.
   */
  function measureTextWidths(font, lines, widths) {
      var numLines = lines.length;
      var width = 0;
      for (var i = 0; i < numLines; ++i) {
          var currentWidth = measureTextWidth(font, lines[i]);
          width = Math.max(width, currentWidth);
          widths.push(currentWidth);
      }
      return width;
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} rotation Rotation.
   * @param {number} offsetX X offset.
   * @param {number} offsetY Y offset.
   */
  function rotateAtOffset(context, rotation, offsetX, offsetY) {
      if (rotation !== 0) {
          context.translate(offsetX, offsetY);
          context.rotate(rotation);
          context.translate(-offsetX, -offsetY);
      }
  }
  /**
   * @param {CanvasRenderingContext2D} context Context.
   * @param {import("../transform.js").Transform|null} transform Transform.
   * @param {number} opacity Opacity.
   * @param {Label|HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} labelOrImage Label.
   * @param {number} originX Origin X.
   * @param {number} originY Origin Y.
   * @param {number} w Width.
   * @param {number} h Height.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {import("../size.js").Size} scale Scale.
   */
  function drawImageOrLabel(context, transform, opacity, labelOrImage, originX, originY, w, h, x, y, scale) {
      context.save();
      if (opacity !== 1) {
          context.globalAlpha *= opacity;
      }
      if (transform) {
          context.setTransform.apply(context, transform);
      }
      if ( /** @type {*} */(labelOrImage).contextInstructions) {
          // label
          context.translate(x, y);
          context.scale(scale[0], scale[1]);
          executeLabelInstructions(/** @type {Label} */ (labelOrImage), context);
      }
      else if (scale[0] < 0 || scale[1] < 0) {
          // flipped image
          context.translate(x, y);
          context.scale(scale[0], scale[1]);
          context.drawImage(
          /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */ (labelOrImage), originX, originY, w, h, 0, 0, w, h);
      }
      else {
          // if image not flipped translate and scale can be avoided
          context.drawImage(
          /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */ (labelOrImage), originX, originY, w, h, x, y, w * scale[0], h * scale[1]);
      }
      context.restore();
  }
  /**
   * @param {Label} label Label.
   * @param {CanvasRenderingContext2D} context Context.
   */
  function executeLabelInstructions(label, context) {
      var contextInstructions = label.contextInstructions;
      for (var i = 0, ii = contextInstructions.length; i < ii; i += 2) {
          if (Array.isArray(contextInstructions[i + 1])) {
              context[contextInstructions[i]].apply(context, contextInstructions[i + 1]);
          }
          else {
              context[contextInstructions[i]] = contextInstructions[i + 1];
          }
      }
  }
  /**
   * @type {HTMLCanvasElement}
   * @private
   */
  var createTransformStringCanvas = null;
  /**
   * @param {import("../transform.js").Transform} transform Transform.
   * @return {string} CSS transform.
   */
  function createTransformString(transform) {
      if (WORKER_OFFSCREEN_CANVAS) {
          return toString(transform);
      }
      else {
          if (!createTransformStringCanvas) {
              createTransformStringCanvas = createCanvasContext2D(1, 1).canvas;
          }
          createTransformStringCanvas.style.transform = toString(transform);
          return createTransformStringCanvas.style.transform;
      }
  }

  /**
   * @module ol/geom/flat/transform
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {import("../../transform.js").Transform} transform Transform.
   * @param {Array<number>=} opt_dest Destination.
   * @return {Array<number>} Transformed coordinates.
   */
  function transform2D(flatCoordinates, offset, end, stride, transform, opt_dest) {
      var dest = opt_dest ? opt_dest : [];
      var i = 0;
      for (var j = offset; j < end; j += stride) {
          var x = flatCoordinates[j];
          var y = flatCoordinates[j + 1];
          dest[i++] = transform[0] * x + transform[2] * y + transform[4];
          dest[i++] = transform[1] * x + transform[3] * y + transform[5];
      }
      if (opt_dest && dest.length != i) {
          dest.length = i;
      }
      return dest;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} angle Angle.
   * @param {Array<number>} anchor Rotation anchor point.
   * @param {Array<number>=} opt_dest Destination.
   * @return {Array<number>} Transformed coordinates.
   */
  function rotate(flatCoordinates, offset, end, stride, angle, anchor, opt_dest) {
      var dest = opt_dest ? opt_dest : [];
      var cos = Math.cos(angle);
      var sin = Math.sin(angle);
      var anchorX = anchor[0];
      var anchorY = anchor[1];
      var i = 0;
      for (var j = offset; j < end; j += stride) {
          var deltaX = flatCoordinates[j] - anchorX;
          var deltaY = flatCoordinates[j + 1] - anchorY;
          dest[i++] = anchorX + deltaX * cos - deltaY * sin;
          dest[i++] = anchorY + deltaX * sin + deltaY * cos;
          for (var k = j + 2; k < j + stride; ++k) {
              dest[i++] = flatCoordinates[k];
          }
      }
      if (opt_dest && dest.length != i) {
          dest.length = i;
      }
      return dest;
  }
  /**
   * Scale the coordinates.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} sx Scale factor in the x-direction.
   * @param {number} sy Scale factor in the y-direction.
   * @param {Array<number>} anchor Scale anchor point.
   * @param {Array<number>=} opt_dest Destination.
   * @return {Array<number>} Transformed coordinates.
   */
  function scale(flatCoordinates, offset, end, stride, sx, sy, anchor, opt_dest) {
      var dest = opt_dest ? opt_dest : [];
      var anchorX = anchor[0];
      var anchorY = anchor[1];
      var i = 0;
      for (var j = offset; j < end; j += stride) {
          var deltaX = flatCoordinates[j] - anchorX;
          var deltaY = flatCoordinates[j + 1] - anchorY;
          dest[i++] = anchorX + sx * deltaX;
          dest[i++] = anchorY + sy * deltaY;
          for (var k = j + 2; k < j + stride; ++k) {
              dest[i++] = flatCoordinates[k];
          }
      }
      if (opt_dest && dest.length != i) {
          dest.length = i;
      }
      return dest;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} deltaX Delta X.
   * @param {number} deltaY Delta Y.
   * @param {Array<number>=} opt_dest Destination.
   * @return {Array<number>} Transformed coordinates.
   */
  function translate(flatCoordinates, offset, end, stride, deltaX, deltaY, opt_dest) {
      var dest = opt_dest ? opt_dest : [];
      var i = 0;
      for (var j = offset; j < end; j += stride) {
          dest[i++] = flatCoordinates[j] + deltaX;
          dest[i++] = flatCoordinates[j + 1] + deltaY;
          for (var k = j + 2; k < j + stride; ++k) {
              dest[i++] = flatCoordinates[k];
          }
      }
      if (opt_dest && dest.length != i) {
          dest.length = i;
      }
      return dest;
  }

  /**
   * @module ol/proj/Units
   */
  /**
   * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or
   * `'us-ft'`.
   * @enum {string}
   */
  var Units = {
      DEGREES: 'degrees',
      FEET: 'ft',
      METERS: 'm',
      PIXELS: 'pixels',
      TILE_PIXELS: 'tile-pixels',
      USFEET: 'us-ft',
  };
  /**
   * Meters per unit lookup table.
   * @const
   * @type {Object<Units, number>}
   * @api
   */
  var METERS_PER_UNIT = {};
  // use the radius of the Normal sphere
  METERS_PER_UNIT[Units.DEGREES] = (2 * Math.PI * 6370997) / 360;
  METERS_PER_UNIT[Units.FEET] = 0.3048;
  METERS_PER_UNIT[Units.METERS] = 1;
  METERS_PER_UNIT[Units.USFEET] = 1200 / 3937;

  /**
   * @module ol/proj/Projection
   */
  /**
   * @typedef {Object} Options
   * @property {string} code The SRS identifier code, e.g. `EPSG:4326`.
   * @property {import("./Units.js").default|string} [units] Units. Required unless a
   * proj4 projection is defined for `code`.
   * @property {import("../extent.js").Extent} [extent] The validity extent for the SRS.
   * @property {string} [axisOrientation='enu'] The axis orientation as specified in Proj4.
   * @property {boolean} [global=false] Whether the projection is valid for the whole globe.
   * @property {number} [metersPerUnit] The meters per unit for the SRS.
   * If not provided, the `units` are used to get the meters per unit from the {@link module:ol/proj/Units~METERS_PER_UNIT}
   * lookup table.
   * @property {import("../extent.js").Extent} [worldExtent] The world extent for the SRS.
   * @property {function(number, import("../coordinate.js").Coordinate):number} [getPointResolution]
   * Function to determine resolution at a point. The function is called with a
   * `{number}` view resolution and an `{import("../coordinate.js").Coordinate}` as arguments, and returns
   * the `{number}` resolution in projection units at the passed coordinate. If this is `undefined`,
   * the default {@link module:ol/proj#getPointResolution} function will be used.
   */
  /**
   * @classdesc
   * Projection definition class. One of these is created for each projection
   * supported in the application and stored in the {@link module:ol/proj} namespace.
   * You can use these in applications, but this is not required, as API params
   * and options use {@link module:ol/proj~ProjectionLike} which means the simple string
   * code will suffice.
   *
   * You can use {@link module:ol/proj~get} to retrieve the object for a particular
   * projection.
   *
   * The library includes definitions for `EPSG:4326` and `EPSG:3857`, together
   * with the following aliases:
   * * `EPSG:4326`: CRS:84, urn:ogc:def:crs:EPSG:6.6:4326,
   *     urn:ogc:def:crs:OGC:1.3:CRS84, urn:ogc:def:crs:OGC:2:84,
   *     http://www.opengis.net/gml/srs/epsg.xml#4326,
   *     urn:x-ogc:def:crs:EPSG:4326
   * * `EPSG:3857`: EPSG:102100, EPSG:102113, EPSG:900913,
   *     urn:ogc:def:crs:EPSG:6.18:3:3857,
   *     http://www.opengis.net/gml/srs/epsg.xml#3857
   *
   * If you use [proj4js](https://github.com/proj4js/proj4js), aliases can
   * be added using `proj4.defs()`. After all required projection definitions are
   * added, call the {@link module:ol/proj/proj4~register} function.
   *
   * @api
   */
  var Projection = /** @class */ (function () {
      /**
       * @param {Options} options Projection options.
       */
      function Projection(options) {
          /**
           * @private
           * @type {string}
           */
          this.code_ = options.code;
          /**
           * Units of projected coordinates. When set to `TILE_PIXELS`, a
           * `this.extent_` and `this.worldExtent_` must be configured properly for each
           * tile.
           * @private
           * @type {import("./Units.js").default}
           */
          this.units_ = /** @type {import("./Units.js").default} */ (options.units);
          /**
           * Validity extent of the projection in projected coordinates. For projections
           * with `TILE_PIXELS` units, this is the extent of the tile in
           * tile pixel space.
           * @private
           * @type {import("../extent.js").Extent}
           */
          this.extent_ = options.extent !== undefined ? options.extent : null;
          /**
           * Extent of the world in EPSG:4326. For projections with
           * `TILE_PIXELS` units, this is the extent of the tile in
           * projected coordinate space.
           * @private
           * @type {import("../extent.js").Extent}
           */
          this.worldExtent_ =
              options.worldExtent !== undefined ? options.worldExtent : null;
          /**
           * @private
           * @type {string}
           */
          this.axisOrientation_ =
              options.axisOrientation !== undefined ? options.axisOrientation : 'enu';
          /**
           * @private
           * @type {boolean}
           */
          this.global_ = options.global !== undefined ? options.global : false;
          /**
           * @private
           * @type {boolean}
           */
          this.canWrapX_ = !!(this.global_ && this.extent_);
          /**
           * @private
           * @type {function(number, import("../coordinate.js").Coordinate):number|undefined}
           */
          this.getPointResolutionFunc_ = options.getPointResolution;
          /**
           * @private
           * @type {import("../tilegrid/TileGrid.js").default}
           */
          this.defaultTileGrid_ = null;
          /**
           * @private
           * @type {number|undefined}
           */
          this.metersPerUnit_ = options.metersPerUnit;
      }
      /**
       * @return {boolean} The projection is suitable for wrapping the x-axis
       */
      Projection.prototype.canWrapX = function () {
          return this.canWrapX_;
      };
      /**
       * Get the code for this projection, e.g. 'EPSG:4326'.
       * @return {string} Code.
       * @api
       */
      Projection.prototype.getCode = function () {
          return this.code_;
      };
      /**
       * Get the validity extent for this projection.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      Projection.prototype.getExtent = function () {
          return this.extent_;
      };
      /**
       * Get the units of this projection.
       * @return {import("./Units.js").default} Units.
       * @api
       */
      Projection.prototype.getUnits = function () {
          return this.units_;
      };
      /**
       * Get the amount of meters per unit of this projection.  If the projection is
       * not configured with `metersPerUnit` or a units identifier, the return is
       * `undefined`.
       * @return {number|undefined} Meters.
       * @api
       */
      Projection.prototype.getMetersPerUnit = function () {
          return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];
      };
      /**
       * Get the world extent for this projection.
       * @return {import("../extent.js").Extent} Extent.
       * @api
       */
      Projection.prototype.getWorldExtent = function () {
          return this.worldExtent_;
      };
      /**
       * Get the axis orientation of this projection.
       * Example values are:
       * enu - the default easting, northing, elevation.
       * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
       *     or south orientated transverse mercator.
       * wnu - westing, northing, up - some planetary coordinate systems have
       *     "west positive" coordinate systems
       * @return {string} Axis orientation.
       * @api
       */
      Projection.prototype.getAxisOrientation = function () {
          return this.axisOrientation_;
      };
      /**
       * Is this projection a global projection which spans the whole world?
       * @return {boolean} Whether the projection is global.
       * @api
       */
      Projection.prototype.isGlobal = function () {
          return this.global_;
      };
      /**
       * Set if the projection is a global projection which spans the whole world
       * @param {boolean} global Whether the projection is global.
       * @api
       */
      Projection.prototype.setGlobal = function (global) {
          this.global_ = global;
          this.canWrapX_ = !!(global && this.extent_);
      };
      /**
       * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
       */
      Projection.prototype.getDefaultTileGrid = function () {
          return this.defaultTileGrid_;
      };
      /**
       * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
       */
      Projection.prototype.setDefaultTileGrid = function (tileGrid) {
          this.defaultTileGrid_ = tileGrid;
      };
      /**
       * Set the validity extent for this projection.
       * @param {import("../extent.js").Extent} extent Extent.
       * @api
       */
      Projection.prototype.setExtent = function (extent) {
          this.extent_ = extent;
          this.canWrapX_ = !!(this.global_ && extent);
      };
      /**
       * Set the world extent for this projection.
       * @param {import("../extent.js").Extent} worldExtent World extent
       *     [minlon, minlat, maxlon, maxlat].
       * @api
       */
      Projection.prototype.setWorldExtent = function (worldExtent) {
          this.worldExtent_ = worldExtent;
      };
      /**
       * Set the getPointResolution function (see {@link module:ol/proj~getPointResolution}
       * for this projection.
       * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
       * @api
       */
      Projection.prototype.setGetPointResolution = function (func) {
          this.getPointResolutionFunc_ = func;
      };
      /**
       * Get the custom point resolution function for this projection (if set).
       * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
       * resolution function (if set).
       */
      Projection.prototype.getPointResolutionFunc = function () {
          return this.getPointResolutionFunc_;
      };
      return Projection;
  }());

  var __extends$6 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * Radius of WGS84 sphere
   *
   * @const
   * @type {number}
   */
  var RADIUS = 6378137;
  /**
   * @const
   * @type {number}
   */
  var HALF_SIZE = Math.PI * RADIUS;
  /**
   * @const
   * @type {import("../extent.js").Extent}
   */
  var EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
  /**
   * @const
   * @type {import("../extent.js").Extent}
   */
  var WORLD_EXTENT = [-180, -85, 180, 85];
  /**
   * @classdesc
   * Projection object for web/spherical Mercator (EPSG:3857).
   */
  var EPSG3857Projection = /** @class */ (function (_super) {
      __extends$6(EPSG3857Projection, _super);
      /**
       * @param {string} code Code.
       */
      function EPSG3857Projection(code) {
          return _super.call(this, {
              code: code,
              units: Units.METERS,
              extent: EXTENT,
              global: true,
              worldExtent: WORLD_EXTENT,
              getPointResolution: function (resolution, point) {
                  return resolution / cosh(point[1] / RADIUS);
              },
          }) || this;
      }
      return EPSG3857Projection;
  }(Projection));
  /**
   * Projections equal to EPSG:3857.
   *
   * @const
   * @type {Array<import("./Projection.js").default>}
   */
  var PROJECTIONS = [
      new EPSG3857Projection('EPSG:3857'),
      new EPSG3857Projection('EPSG:102100'),
      new EPSG3857Projection('EPSG:102113'),
      new EPSG3857Projection('EPSG:900913'),
      new EPSG3857Projection('urn:ogc:def:crs:EPSG:6.18:3:3857'),
      new EPSG3857Projection('urn:ogc:def:crs:EPSG::3857'),
      new EPSG3857Projection('http://www.opengis.net/gml/srs/epsg.xml#3857'),
  ];
  /**
   * Transformation from EPSG:4326 to EPSG:3857.
   *
   * @param {Array<number>} input Input array of coordinate values.
   * @param {Array<number>=} opt_output Output array of coordinate values.
   * @param {number=} opt_dimension Dimension (default is `2`).
   * @return {Array<number>} Output array of coordinate values.
   */
  function fromEPSG4326(input, opt_output, opt_dimension) {
      var length = input.length;
      var dimension = opt_dimension > 1 ? opt_dimension : 2;
      var output = opt_output;
      if (output === undefined) {
          if (dimension > 2) {
              // preserve values beyond second dimension
              output = input.slice();
          }
          else {
              output = new Array(length);
          }
      }
      var halfSize = HALF_SIZE;
      for (var i = 0; i < length; i += dimension) {
          output[i] = (halfSize * input[i]) / 180;
          var y = RADIUS * Math.log(Math.tan((Math.PI * (+input[i + 1] + 90)) / 360));
          if (y > halfSize) {
              y = halfSize;
          }
          else if (y < -halfSize) {
              y = -halfSize;
          }
          output[i + 1] = y;
      }
      return output;
  }
  /**
   * Transformation from EPSG:3857 to EPSG:4326.
   *
   * @param {Array<number>} input Input array of coordinate values.
   * @param {Array<number>=} opt_output Output array of coordinate values.
   * @param {number=} opt_dimension Dimension (default is `2`).
   * @return {Array<number>} Output array of coordinate values.
   */
  function toEPSG4326(input, opt_output, opt_dimension) {
      var length = input.length;
      var dimension = opt_dimension > 1 ? opt_dimension : 2;
      var output = opt_output;
      if (output === undefined) {
          if (dimension > 2) {
              // preserve values beyond second dimension
              output = input.slice();
          }
          else {
              output = new Array(length);
          }
      }
      for (var i = 0; i < length; i += dimension) {
          output[i] = (180 * input[i]) / HALF_SIZE;
          output[i + 1] =
              (360 * Math.atan(Math.exp(input[i + 1] / RADIUS))) / Math.PI - 90;
      }
      return output;
  }

  var __extends$7 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * Semi-major radius of the WGS84 ellipsoid.
   *
   * @const
   * @type {number}
   */
  var RADIUS$1 = 6378137;
  /**
   * Extent of the EPSG:4326 projection which is the whole world.
   *
   * @const
   * @type {import("../extent.js").Extent}
   */
  var EXTENT$1 = [-180, -90, 180, 90];
  /**
   * @const
   * @type {number}
   */
  var METERS_PER_UNIT$1 = (Math.PI * RADIUS$1) / 180;
  /**
   * @classdesc
   * Projection object for WGS84 geographic coordinates (EPSG:4326).
   *
   * Note that OpenLayers does not strictly comply with the EPSG definition.
   * The EPSG registry defines 4326 as a CRS for Latitude,Longitude (y,x).
   * OpenLayers treats EPSG:4326 as a pseudo-projection, with x,y coordinates.
   */
  var EPSG4326Projection = /** @class */ (function (_super) {
      __extends$7(EPSG4326Projection, _super);
      /**
       * @param {string} code Code.
       * @param {string=} opt_axisOrientation Axis orientation.
       */
      function EPSG4326Projection(code, opt_axisOrientation) {
          return _super.call(this, {
              code: code,
              units: Units.DEGREES,
              extent: EXTENT$1,
              axisOrientation: opt_axisOrientation,
              global: true,
              metersPerUnit: METERS_PER_UNIT$1,
              worldExtent: EXTENT$1,
          }) || this;
      }
      return EPSG4326Projection;
  }(Projection));
  /**
   * Projections equal to EPSG:4326.
   *
   * @const
   * @type {Array<import("./Projection.js").default>}
   */
  var PROJECTIONS$1 = [
      new EPSG4326Projection('CRS:84'),
      new EPSG4326Projection('EPSG:4326', 'neu'),
      new EPSG4326Projection('urn:ogc:def:crs:EPSG::4326', 'neu'),
      new EPSG4326Projection('urn:ogc:def:crs:EPSG:6.6:4326', 'neu'),
      new EPSG4326Projection('urn:ogc:def:crs:OGC:1.3:CRS84'),
      new EPSG4326Projection('urn:ogc:def:crs:OGC:2:84'),
      new EPSG4326Projection('http://www.opengis.net/gml/srs/epsg.xml#4326', 'neu'),
      new EPSG4326Projection('urn:x-ogc:def:crs:EPSG:4326', 'neu'),
  ];

  /**
   * @module ol/proj/projections
   */
  /**
   * @type {Object<string, import("./Projection.js").default>}
   */
  var cache = {};
  /**
   * Get a cached projection by code.
   * @param {string} code The code for the projection.
   * @return {import("./Projection.js").default} The projection (if cached).
   */
  function get(code) {
      return cache[code] || null;
  }
  /**
   * Add a projection to the cache.
   * @param {string} code The projection code.
   * @param {import("./Projection.js").default} projection The projection to cache.
   */
  function add(code, projection) {
      cache[code] = projection;
  }

  /**
   * @module ol/proj/transforms
   */
  /**
   * @private
   * @type {!Object<string, Object<string, import("../proj.js").TransformFunction>>}
   */
  var transforms = {};
  /**
   * Registers a conversion function to convert coordinates from the source
   * projection to the destination projection.
   *
   * @param {import("./Projection.js").default} source Source.
   * @param {import("./Projection.js").default} destination Destination.
   * @param {import("../proj.js").TransformFunction} transformFn Transform.
   */
  function add$1(source, destination, transformFn) {
      var sourceCode = source.getCode();
      var destinationCode = destination.getCode();
      if (!(sourceCode in transforms)) {
          transforms[sourceCode] = {};
      }
      transforms[sourceCode][destinationCode] = transformFn;
  }
  /**
   * Get a transform given a source code and a destination code.
   * @param {string} sourceCode The code for the source projection.
   * @param {string} destinationCode The code for the destination projection.
   * @return {import("../proj.js").TransformFunction|undefined} The transform function (if found).
   */
  function get$1(sourceCode, destinationCode) {
      var transform;
      if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
          transform = transforms[sourceCode][destinationCode];
      }
      return transform;
  }

  /**
   * @module ol/sphere
   */
  /**
   * Object literal with options for the {@link getLength} or {@link getArea}
   * functions.
   * @typedef {Object} SphereMetricOptions
   * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857']
   * Projection of the  geometry.  By default, the geometry is assumed to be in
   * Web Mercator.
   * @property {number} [radius=6371008.8] Sphere radius.  By default, the
   * [mean Earth radius](https://en.wikipedia.org/wiki/Earth_radius#Mean_radius)
   * for the WGS84 ellipsoid is used.
   */
  /**
   * The mean Earth radius (1/3 * (2a + b)) for the WGS84 ellipsoid.
   * https://en.wikipedia.org/wiki/Earth_radius#Mean_radius
   * @type {number}
   */
  var DEFAULT_RADIUS = 6371008.8;
  /**
   * Get the great circle distance (in meters) between two geographic coordinates.
   * @param {Array} c1 Starting coordinate.
   * @param {Array} c2 Ending coordinate.
   * @param {number=} opt_radius The sphere radius to use.  Defaults to the Earth's
   *     mean radius using the WGS84 ellipsoid.
   * @return {number} The great circle distance between the points (in meters).
   * @api
   */
  function getDistance(c1, c2, opt_radius) {
      var radius = opt_radius || DEFAULT_RADIUS;
      var lat1 = toRadians(c1[1]);
      var lat2 = toRadians(c2[1]);
      var deltaLatBy2 = (lat2 - lat1) / 2;
      var deltaLonBy2 = toRadians(c2[0] - c1[0]) / 2;
      var a = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) +
          Math.sin(deltaLonBy2) *
              Math.sin(deltaLonBy2) *
              Math.cos(lat1) *
              Math.cos(lat2);
      return 2 * radius * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  }

  /**
   * @module ol/string
   */
  /**
   * @param {number} number Number to be formatted
   * @param {number} width The desired width
   * @param {number=} opt_precision Precision of the output string (i.e. number of decimal places)
   * @returns {string} Formatted string
   */
  function padNumber(number, width, opt_precision) {
      var numberString = opt_precision !== undefined ? number.toFixed(opt_precision) : '' + number;
      var decimal = numberString.indexOf('.');
      decimal = decimal === -1 ? numberString.length : decimal;
      return decimal > width
          ? numberString
          : new Array(1 + width - decimal).join('0') + numberString;
  }
  /**
   * Adapted from https://github.com/omichelsen/compare-versions/blob/master/index.js
   * @param {string|number} v1 First version
   * @param {string|number} v2 Second version
   * @returns {number} Value
   */
  function compareVersions(v1, v2) {
      var s1 = ('' + v1).split('.');
      var s2 = ('' + v2).split('.');
      for (var i = 0; i < Math.max(s1.length, s2.length); i++) {
          var n1 = parseInt(s1[i] || '0', 10);
          var n2 = parseInt(s2[i] || '0', 10);
          if (n1 > n2) {
              return 1;
          }
          if (n2 > n1) {
              return -1;
          }
      }
      return 0;
  }

  /**
   * @module ol/coordinate
   */
  /**
   * An array of numbers representing an xy coordinate. Example: `[16, 48]`.
   * @typedef {Array<number>} Coordinate
   * @api
   */
  /**
   * A function that takes a {@link module:ol/coordinate~Coordinate} and
   * transforms it into a `{string}`.
   *
   * @typedef {function((Coordinate|undefined)): string} CoordinateFormat
   * @api
   */
  /**
   * Add `delta` to `coordinate`. `coordinate` is modified in place and returned
   * by the function.
   *
   * Example:
   *
   *     import {add} from 'ol/coordinate';
   *
   *     var coord = [7.85, 47.983333];
   *     add(coord, [-2, 4]);
   *     // coord is now [5.85, 51.983333]
   *
   * @param {Coordinate} coordinate Coordinate.
   * @param {Coordinate} delta Delta.
   * @return {Coordinate} The input coordinate adjusted by
   * the given delta.
   * @api
   */
  function add$2(coordinate, delta) {
      coordinate[0] += +delta[0];
      coordinate[1] += +delta[1];
      return coordinate;
  }
  /**
   * Returns a {@link module:ol/coordinate~CoordinateFormat} function that can be
   * used to format
   * a {Coordinate} to a string.
   *
   * Example without specifying the fractional digits:
   *
   *     import {createStringXY} from 'ol/coordinate';
   *
   *     var coord = [7.85, 47.983333];
   *     var stringifyFunc = createStringXY();
   *     var out = stringifyFunc(coord);
   *     // out is now '8, 48'
   *
   * Example with explicitly specifying 2 fractional digits:
   *
   *     import {createStringXY} from 'ol/coordinate';
   *
   *     var coord = [7.85, 47.983333];
   *     var stringifyFunc = createStringXY(2);
   *     var out = stringifyFunc(coord);
   *     // out is now '7.85, 47.98'
   *
   * @param {number=} opt_fractionDigits The number of digits to include
   *    after the decimal point. Default is `0`.
   * @return {CoordinateFormat} Coordinate format.
   * @api
   */
  function createStringXY(opt_fractionDigits) {
      return (
      /**
       * @param {Coordinate} coordinate Coordinate.
       * @return {string} String XY.
       */
      function (coordinate) {
          return toStringXY(coordinate, opt_fractionDigits);
      });
  }
  /**
   * @param {string} hemispheres Hemispheres.
   * @param {number} degrees Degrees.
   * @param {number=} opt_fractionDigits The number of digits to include
   *    after the decimal point. Default is `0`.
   * @return {string} String.
   */
  function degreesToStringHDMS(hemispheres, degrees, opt_fractionDigits) {
      var normalizedDegrees = modulo(degrees + 180, 360) - 180;
      var x = Math.abs(3600 * normalizedDegrees);
      var dflPrecision = opt_fractionDigits || 0;
      var precision = Math.pow(10, dflPrecision);
      var deg = Math.floor(x / 3600);
      var min = Math.floor((x - deg * 3600) / 60);
      var sec = x - deg * 3600 - min * 60;
      sec = Math.ceil(sec * precision) / precision;
      if (sec >= 60) {
          sec = 0;
          min += 1;
      }
      if (min >= 60) {
          min = 0;
          deg += 1;
      }
      return (deg +
          '\u00b0 ' +
          padNumber(min, 2) +
          '\u2032 ' +
          padNumber(sec, 2, dflPrecision) +
          '\u2033' +
          (normalizedDegrees == 0
              ? ''
              : ' ' + hemispheres.charAt(normalizedDegrees < 0 ? 1 : 0)));
  }
  /**
   * Transforms the given {@link module:ol/coordinate~Coordinate} to a string
   * using the given string template. The strings `{x}` and `{y}` in the template
   * will be replaced with the first and second coordinate values respectively.
   *
   * Example without specifying the fractional digits:
   *
   *     import {format} from 'ol/coordinate';
   *
   *     var coord = [7.85, 47.983333];
   *     var template = 'Coordinate is ({x}|{y}).';
   *     var out = format(coord, template);
   *     // out is now 'Coordinate is (8|48).'
   *
   * Example explicitly specifying the fractional digits:
   *
   *     import {format} from 'ol/coordinate';
   *
   *     var coord = [7.85, 47.983333];
   *     var template = 'Coordinate is ({x}|{y}).';
   *     var out = format(coord, template, 2);
   *     // out is now 'Coordinate is (7.85|47.98).'
   *
   * @param {Coordinate} coordinate Coordinate.
   * @param {string} template A template string with `{x}` and `{y}` placeholders
   *     that will be replaced by first and second coordinate values.
   * @param {number=} opt_fractionDigits The number of digits to include
   *    after the decimal point. Default is `0`.
   * @return {string} Formatted coordinate.
   * @api
   */
  function format(coordinate, template, opt_fractionDigits) {
      if (coordinate) {
          return template
              .replace('{x}', coordinate[0].toFixed(opt_fractionDigits))
              .replace('{y}', coordinate[1].toFixed(opt_fractionDigits));
      }
      else {
          return '';
      }
  }
  /**
   * @param {Coordinate} coordinate1 First coordinate.
   * @param {Coordinate} coordinate2 Second coordinate.
   * @return {boolean} The two coordinates are equal.
   */
  function equals$2(coordinate1, coordinate2) {
      var equals = true;
      for (var i = coordinate1.length - 1; i >= 0; --i) {
          if (coordinate1[i] != coordinate2[i]) {
              equals = false;
              break;
          }
      }
      return equals;
  }
  /**
   * Rotate `coordinate` by `angle`. `coordinate` is modified in place and
   * returned by the function.
   *
   * Example:
   *
   *     import {rotate} from 'ol/coordinate';
   *
   *     var coord = [7.85, 47.983333];
   *     var rotateRadians = Math.PI / 2; // 90 degrees
   *     rotate(coord, rotateRadians);
   *     // coord is now [-47.983333, 7.85]
   *
   * @param {Coordinate} coordinate Coordinate.
   * @param {number} angle Angle in radian.
   * @return {Coordinate} Coordinate.
   * @api
   */
  function rotate$1(coordinate, angle) {
      var cosAngle = Math.cos(angle);
      var sinAngle = Math.sin(angle);
      var x = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
      var y = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
      coordinate[0] = x;
      coordinate[1] = y;
      return coordinate;
  }
  /**
   * Scale `coordinate` by `scale`. `coordinate` is modified in place and returned
   * by the function.
   *
   * Example:
   *
   *     import {scale as scaleCoordinate} from 'ol/coordinate';
   *
   *     var coord = [7.85, 47.983333];
   *     var scale = 1.2;
   *     scaleCoordinate(coord, scale);
   *     // coord is now [9.42, 57.5799996]
   *
   * @param {Coordinate} coordinate Coordinate.
   * @param {number} scale Scale factor.
   * @return {Coordinate} Coordinate.
   */
  function scale$1(coordinate, scale) {
      coordinate[0] *= scale;
      coordinate[1] *= scale;
      return coordinate;
  }
  /**
   * Format a geographic coordinate with the hemisphere, degrees, minutes, and
   * seconds.
   *
   * Example without specifying fractional digits:
   *
   *     import {toStringHDMS} from 'ol/coordinate';
   *
   *     var coord = [7.85, 47.983333];
   *     var out = toStringHDMS(coord);
   *     // out is now '47° 58′ 60″ N 7° 50′ 60″ E'
   *
   * Example explicitly specifying 1 fractional digit:
   *
   *     import {toStringHDMS} from 'ol/coordinate';
   *
   *     var coord = [7.85, 47.983333];
   *     var out = toStringHDMS(coord, 1);
   *     // out is now '47° 58′ 60.0″ N 7° 50′ 60.0″ E'
   *
   * @param {Coordinate} coordinate Coordinate.
   * @param {number=} opt_fractionDigits The number of digits to include
   *    after the decimal point. Default is `0`.
   * @return {string} Hemisphere, degrees, minutes and seconds.
   * @api
   */
  function toStringHDMS(coordinate, opt_fractionDigits) {
      if (coordinate) {
          return (degreesToStringHDMS('NS', coordinate[1], opt_fractionDigits) +
              ' ' +
              degreesToStringHDMS('EW', coordinate[0], opt_fractionDigits));
      }
      else {
          return '';
      }
  }
  /**
   * Format a coordinate as a comma delimited string.
   *
   * Example without specifying fractional digits:
   *
   *     import {toStringXY} from 'ol/coordinate';
   *
   *     var coord = [7.85, 47.983333];
   *     var out = toStringXY(coord);
   *     // out is now '8, 48'
   *
   * Example explicitly specifying 1 fractional digit:
   *
   *     import {toStringXY} from 'ol/coordinate';
   *
   *     var coord = [7.85, 47.983333];
   *     var out = toStringXY(coord, 1);
   *     // out is now '7.8, 48.0'
   *
   * @param {Coordinate} coordinate Coordinate.
   * @param {number=} opt_fractionDigits The number of digits to include
   *    after the decimal point. Default is `0`.
   * @return {string} XY.
   * @api
   */
  function toStringXY(coordinate, opt_fractionDigits) {
      return format(coordinate, '{x}, {y}', opt_fractionDigits);
  }
  /**
   * Modifies the provided coordinate in-place to be within the real world
   * extent. The lower projection extent boundary is inclusive, the upper one
   * exclusive.
   *
   * @param {Coordinate} coordinate Coordinate.
   * @param {import("./proj/Projection.js").default} projection Projection.
   * @return {Coordinate} The coordinate within the real world extent.
   */
  function wrapX$1(coordinate, projection) {
      if (projection.canWrapX()) {
          var worldWidth = getWidth(projection.getExtent());
          var worldsAway = getWorldsAway(coordinate, projection, worldWidth);
          if (worldsAway) {
              coordinate[0] -= worldsAway * worldWidth;
          }
      }
      return coordinate;
  }
  /**
   * @param {Coordinate} coordinate Coordinate.
   * @param {import("./proj/Projection.js").default} projection Projection.
   * @param {number=} opt_sourceExtentWidth Width of the source extent.
   * @return {number} Offset in world widths.
   */
  function getWorldsAway(coordinate, projection, opt_sourceExtentWidth) {
      var projectionExtent = projection.getExtent();
      var worldsAway = 0;
      if (projection.canWrapX() &&
          (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
          var sourceExtentWidth = opt_sourceExtentWidth || getWidth(projectionExtent);
          worldsAway = Math.floor((coordinate[0] - projectionExtent[0]) / sourceExtentWidth);
      }
      return worldsAway;
  }

  /**
   * @module ol/proj
   */
  /**
   * @param {Array<number>} input Input coordinate array.
   * @param {Array<number>=} opt_output Output array of coordinate values.
   * @param {number=} opt_dimension Dimension.
   * @return {Array<number>} Output coordinate array (new array, same coordinate
   *     values).
   */
  function cloneTransform(input, opt_output, opt_dimension) {
      var output;
      if (opt_output !== undefined) {
          for (var i = 0, ii = input.length; i < ii; ++i) {
              opt_output[i] = input[i];
          }
          output = opt_output;
      }
      else {
          output = input.slice();
      }
      return output;
  }
  /**
   * @param {Array<number>} input Input coordinate array.
   * @param {Array<number>=} opt_output Output array of coordinate values.
   * @param {number=} opt_dimension Dimension.
   * @return {Array<number>} Input coordinate array (same array as input).
   */
  function identityTransform(input, opt_output, opt_dimension) {
      if (opt_output !== undefined && input !== opt_output) {
          for (var i = 0, ii = input.length; i < ii; ++i) {
              opt_output[i] = input[i];
          }
          input = opt_output;
      }
      return input;
  }
  /**
   * Add a Projection object to the list of supported projections that can be
   * looked up by their code.
   *
   * @param {Projection} projection Projection instance.
   * @api
   */
  function addProjection(projection) {
      add(projection.getCode(), projection);
      add$1(projection, projection, cloneTransform);
  }
  /**
   * @param {Array<Projection>} projections Projections.
   */
  function addProjections(projections) {
      projections.forEach(addProjection);
  }
  /**
   * Fetches a Projection object for the code specified.
   *
   * @param {ProjectionLike} projectionLike Either a code string which is
   *     a combination of authority and identifier such as "EPSG:4326", or an
   *     existing projection object, or undefined.
   * @return {Projection} Projection object, or null if not in list.
   * @api
   */
  function get$2(projectionLike) {
      return typeof projectionLike === 'string'
          ? get(/** @type {string} */ (projectionLike))
          : /** @type {Projection} */ (projectionLike) || null;
  }
  /**
   * Get the resolution of the point in degrees or distance units.
   * For projections with degrees as the unit this will simply return the
   * provided resolution. For other projections the point resolution is
   * by default estimated by transforming the 'point' pixel to EPSG:4326,
   * measuring its width and height on the normal sphere,
   * and taking the average of the width and height.
   * A custom function can be provided for a specific projection, either
   * by setting the `getPointResolution` option in the
   * {@link module:ol/proj/Projection~Projection} constructor or by using
   * {@link module:ol/proj/Projection~Projection#setGetPointResolution} to change an existing
   * projection object.
   * @param {ProjectionLike} projection The projection.
   * @param {number} resolution Nominal resolution in projection units.
   * @param {import("./coordinate.js").Coordinate} point Point to find adjusted resolution at.
   * @param {import("./proj/Units.js").default=} opt_units Units to get the point resolution in.
   * Default is the projection's units.
   * @return {number} Point resolution.
   * @api
   */
  function getPointResolution(projection, resolution, point, opt_units) {
      projection = get$2(projection);
      var pointResolution;
      var getter = projection.getPointResolutionFunc();
      if (getter) {
          pointResolution = getter(resolution, point);
          if (opt_units && opt_units !== projection.getUnits()) {
              var metersPerUnit = projection.getMetersPerUnit();
              if (metersPerUnit) {
                  pointResolution =
                      (pointResolution * metersPerUnit) / METERS_PER_UNIT[opt_units];
              }
          }
      }
      else {
          var units = projection.getUnits();
          if ((units == Units.DEGREES && !opt_units) || opt_units == Units.DEGREES) {
              pointResolution = resolution;
          }
          else {
              // Estimate point resolution by transforming the center pixel to EPSG:4326,
              // measuring its width and height on the normal sphere, and taking the
              // average of the width and height.
              var toEPSG4326_1 = getTransformFromProjections(projection, get$2('EPSG:4326'));
              var vertices = [
                  point[0] - resolution / 2,
                  point[1],
                  point[0] + resolution / 2,
                  point[1],
                  point[0],
                  point[1] - resolution / 2,
                  point[0],
                  point[1] + resolution / 2,
              ];
              vertices = toEPSG4326_1(vertices, vertices, 2);
              var width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));
              var height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));
              pointResolution = (width + height) / 2;
              var metersPerUnit = opt_units
                  ? METERS_PER_UNIT[opt_units]
                  : projection.getMetersPerUnit();
              if (metersPerUnit !== undefined) {
                  pointResolution /= metersPerUnit;
              }
          }
      }
      return pointResolution;
  }
  /**
   * Registers transformation functions that don't alter coordinates. Those allow
   * to transform between projections with equal meaning.
   *
   * @param {Array<Projection>} projections Projections.
   * @api
   */
  function addEquivalentProjections(projections) {
      addProjections(projections);
      projections.forEach(function (source) {
          projections.forEach(function (destination) {
              if (source !== destination) {
                  add$1(source, destination, cloneTransform);
              }
          });
      });
  }
  /**
   * Registers transformation functions to convert coordinates in any projection
   * in projection1 to any projection in projection2.
   *
   * @param {Array<Projection>} projections1 Projections with equal
   *     meaning.
   * @param {Array<Projection>} projections2 Projections with equal
   *     meaning.
   * @param {TransformFunction} forwardTransform Transformation from any
   *   projection in projection1 to any projection in projection2.
   * @param {TransformFunction} inverseTransform Transform from any projection
   *   in projection2 to any projection in projection1..
   */
  function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
      projections1.forEach(function (projection1) {
          projections2.forEach(function (projection2) {
              add$1(projection1, projection2, forwardTransform);
              add$1(projection2, projection1, inverseTransform);
          });
      });
  }
  /**
   * @param {Projection|string|undefined} projection Projection.
   * @param {string} defaultCode Default code.
   * @return {Projection} Projection.
   */
  function createProjection(projection, defaultCode) {
      if (!projection) {
          return get$2(defaultCode);
      }
      else if (typeof projection === 'string') {
          return get$2(projection);
      }
      else {
          return /** @type {Projection} */ (projection);
      }
  }
  /**
   * Creates a {@link module:ol/proj~TransformFunction} from a simple 2D coordinate transform
   * function.
   * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} coordTransform Coordinate
   *     transform.
   * @return {TransformFunction} Transform function.
   */
  function createTransformFromCoordinateTransform(coordTransform) {
      return (
      /**
       * @param {Array<number>} input Input.
       * @param {Array<number>=} opt_output Output.
       * @param {number=} opt_dimension Dimension.
       * @return {Array<number>} Output.
       */
      function (input, opt_output, opt_dimension) {
          var length = input.length;
          var dimension = opt_dimension !== undefined ? opt_dimension : 2;
          var output = opt_output !== undefined ? opt_output : new Array(length);
          for (var i = 0; i < length; i += dimension) {
              var point = coordTransform([input[i], input[i + 1]]);
              output[i] = point[0];
              output[i + 1] = point[1];
              for (var j = dimension - 1; j >= 2; --j) {
                  output[i + j] = input[i + j];
              }
          }
          return output;
      });
  }
  /**
   * Registers coordinate transform functions to convert coordinates between the
   * source projection and the destination projection.
   * The forward and inverse functions convert coordinate pairs; this function
   * converts these into the functions used internally which also handle
   * extents and coordinate arrays.
   *
   * @param {ProjectionLike} source Source projection.
   * @param {ProjectionLike} destination Destination projection.
   * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} forward The forward transform
   *     function (that is, from the source projection to the destination
   *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
   *     the transformed {@link module:ol/coordinate~Coordinate}.
   * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} inverse The inverse transform
   *     function (that is, from the destination projection to the source
   *     projection) that takes a {@link module:ol/coordinate~Coordinate} as argument and returns
   *     the transformed {@link module:ol/coordinate~Coordinate}.
   * @api
   */
  function addCoordinateTransforms(source, destination, forward, inverse) {
      var sourceProj = get$2(source);
      var destProj = get$2(destination);
      add$1(sourceProj, destProj, createTransformFromCoordinateTransform(forward));
      add$1(destProj, sourceProj, createTransformFromCoordinateTransform(inverse));
  }
  /**
   * Transforms a coordinate to longitude/latitude.
   * @param {import("./coordinate.js").Coordinate} coordinate Projected coordinate.
   * @param {ProjectionLike=} opt_projection Projection of the coordinate.
   *     The default is Web Mercator, i.e. 'EPSG:3857'.
   * @return {import("./coordinate.js").Coordinate} Coordinate as longitude and latitude, i.e. an array
   *     with longitude as 1st and latitude as 2nd element.
   * @api
   */
  function toLonLat(coordinate, opt_projection) {
      var lonLat = transform(coordinate, opt_projection !== undefined ? opt_projection : 'EPSG:3857', 'EPSG:4326');
      var lon = lonLat[0];
      if (lon < -180 || lon > 180) {
          lonLat[0] = modulo(lon + 180, 360) - 180;
      }
      return lonLat;
  }
  /**
   * Checks if two projections are the same, that is every coordinate in one
   * projection does represent the same geographic point as the same coordinate in
   * the other projection.
   *
   * @param {Projection} projection1 Projection 1.
   * @param {Projection} projection2 Projection 2.
   * @return {boolean} Equivalent.
   * @api
   */
  function equivalent(projection1, projection2) {
      if (projection1 === projection2) {
          return true;
      }
      var equalUnits = projection1.getUnits() === projection2.getUnits();
      if (projection1.getCode() === projection2.getCode()) {
          return equalUnits;
      }
      else {
          var transformFunc = getTransformFromProjections(projection1, projection2);
          return transformFunc === cloneTransform && equalUnits;
      }
  }
  /**
   * Searches in the list of transform functions for the function for converting
   * coordinates from the source projection to the destination projection.
   *
   * @param {Projection} sourceProjection Source Projection object.
   * @param {Projection} destinationProjection Destination Projection
   *     object.
   * @return {TransformFunction} Transform function.
   */
  function getTransformFromProjections(sourceProjection, destinationProjection) {
      var sourceCode = sourceProjection.getCode();
      var destinationCode = destinationProjection.getCode();
      var transformFunc = get$1(sourceCode, destinationCode);
      if (!transformFunc) {
          transformFunc = identityTransform;
      }
      return transformFunc;
  }
  /**
   * Given the projection-like objects, searches for a transformation
   * function to convert a coordinates array from the source projection to the
   * destination projection.
   *
   * @param {ProjectionLike} source Source.
   * @param {ProjectionLike} destination Destination.
   * @return {TransformFunction} Transform function.
   * @api
   */
  function getTransform(source, destination) {
      var sourceProjection = get$2(source);
      var destinationProjection = get$2(destination);
      return getTransformFromProjections(sourceProjection, destinationProjection);
  }
  /**
   * Transforms a coordinate from source projection to destination projection.
   * This returns a new coordinate (and does not modify the original).
   *
   * See {@link module:ol/proj~transformExtent} for extent transformation.
   * See the transform method of {@link module:ol/geom/Geometry~Geometry} and its
   * subclasses for geometry transforms.
   *
   * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
   * @param {ProjectionLike} source Source projection-like.
   * @param {ProjectionLike} destination Destination projection-like.
   * @return {import("./coordinate.js").Coordinate} Coordinate.
   * @api
   */
  function transform(coordinate, source, destination) {
      var transformFunc = getTransform(source, destination);
      return transformFunc(coordinate, undefined, coordinate.length);
  }
  /**
   * Transforms an extent from source projection to destination projection.  This
   * returns a new extent (and does not modify the original).
   *
   * @param {import("./extent.js").Extent} extent The extent to transform.
   * @param {ProjectionLike} source Source projection-like.
   * @param {ProjectionLike} destination Destination projection-like.
   * @param {number=} opt_stops Number of stops per side used for the transform.
   * By default only the corners are used.
   * @return {import("./extent.js").Extent} The transformed extent.
   * @api
   */
  function transformExtent(extent, source, destination, opt_stops) {
      var transformFunc = getTransform(source, destination);
      return applyTransform(extent, transformFunc, undefined, opt_stops);
  }
  /**
   * @type {?Projection}
   */
  var userProjection = null;
  /**
   * Get the projection for coordinates supplied from and returned by API methods.
   * Note that this method is not yet a part of the stable API.  Support for user
   * projections is not yet complete and should be considered experimental.
   * @returns {?Projection} The user projection (or null if not set).
   */
  function getUserProjection() {
      return userProjection;
  }
  /**
   * Return a coordinate transformed into the user projection.  If no user projection
   * is set, the original coordinate is returned.
   * @param {Array<number>} coordinate Input coordinate.
   * @param {ProjectionLike} sourceProjection The input coordinate projection.
   * @returns {Array<number>} The input coordinate in the user projection.
   */
  function toUserCoordinate(coordinate, sourceProjection) {
      {
          return coordinate;
      }
  }
  /**
   * Return a coordinate transformed from the user projection.  If no user projection
   * is set, the original coordinate is returned.
   * @param {Array<number>} coordinate Input coordinate.
   * @param {ProjectionLike} destProjection The destination projection.
   * @returns {Array<number>} The input coordinate transformed.
   */
  function fromUserCoordinate(coordinate, destProjection) {
      {
          return coordinate;
      }
  }
  /**
   * Return an extent transformed into the user projection.  If no user projection
   * is set, the original extent is returned.
   * @param {import("./extent.js").Extent} extent Input extent.
   * @param {ProjectionLike} sourceProjection The input extent projection.
   * @returns {import("./extent.js").Extent} The input extent in the user projection.
   */
  function toUserExtent(extent, sourceProjection) {
      {
          return extent;
      }
  }
  /**
   * Return an extent transformed from the user projection.  If no user projection
   * is set, the original extent is returned.
   * @param {import("./extent.js").Extent} extent Input extent.
   * @param {ProjectionLike} destProjection The destination projection.
   * @returns {import("./extent.js").Extent} The input extent transformed.
   */
  function fromUserExtent(extent, destProjection) {
      {
          return extent;
      }
  }
  /**
   * Creates a safe coordinate transform function from a coordinate transform function.
   * "Safe" means that it can handle wrapping of x-coordinates for global projections,
   * and that coordinates exceeding the source projection validity extent's range will be
   * clamped to the validity range.
   * @param {Projection} sourceProj Source projection.
   * @param {Projection} destProj Destination projection.
   * @param {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} transform Transform function (source to destiation).
   * @return {function(import("./coordinate.js").Coordinate): import("./coordinate.js").Coordinate} Safe transform function (source to destiation).
   */
  function createSafeCoordinateTransform(sourceProj, destProj, transform) {
      return function (coord) {
          var sourceX = coord[0];
          var sourceY = coord[1];
          var transformed, worldsAway;
          if (sourceProj.canWrapX()) {
              var sourceExtent = sourceProj.getExtent();
              var sourceExtentWidth = getWidth(sourceExtent);
              worldsAway = getWorldsAway(coord, sourceProj, sourceExtentWidth);
              if (worldsAway) {
                  // Move x to the real world
                  sourceX = sourceX - worldsAway * sourceExtentWidth;
              }
              sourceX = clamp(sourceX, sourceExtent[0], sourceExtent[2]);
              sourceY = clamp(sourceY, sourceExtent[1], sourceExtent[3]);
              transformed = transform([sourceX, sourceY]);
          }
          else {
              transformed = transform(coord);
          }
          if (worldsAway && destProj.canWrapX()) {
              // Move transformed coordinate back to the offset world
              transformed[0] += worldsAway * getWidth(destProj.getExtent());
          }
          return transformed;
      };
  }
  /**
   * Add transforms to and from EPSG:4326 and EPSG:3857.  This function is called
   * by when this module is executed and should only need to be called again after
   * `clearAllProjections()` is called (e.g. in tests).
   */
  function addCommon() {
      // Add transformations that don't alter coordinates to convert within set of
      // projections with equal meaning.
      addEquivalentProjections(PROJECTIONS);
      addEquivalentProjections(PROJECTIONS$1);
      // Add transformations to convert EPSG:4326 like coordinates to EPSG:3857 like
      // coordinates and back.
      addEquivalentTransforms(PROJECTIONS$1, PROJECTIONS, fromEPSG4326, toEPSG4326);
  }
  addCommon();

  var __extends$8 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @type {import("../transform.js").Transform}
   */
  var tmpTransform = create();
  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * Base class for vector geometries.
   *
   * To get notified of changes to the geometry, register a listener for the
   * generic `change` event on your geometry instance.
   *
   * @abstract
   * @api
   */
  var Geometry = /** @class */ (function (_super) {
      __extends$8(Geometry, _super);
      function Geometry() {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {import("../extent.js").Extent}
           */
          _this.extent_ = createEmpty();
          /**
           * @private
           * @type {number}
           */
          _this.extentRevision_ = -1;
          /**
           * @protected
           * @type {number}
           */
          _this.simplifiedGeometryMaxMinSquaredTolerance = 0;
          /**
           * @protected
           * @type {number}
           */
          _this.simplifiedGeometryRevision = 0;
          /**
           * Get a transformed and simplified version of the geometry.
           * @abstract
           * @param {number} revision The geometry revision.
           * @param {number} squaredTolerance Squared tolerance.
           * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
           * @return {Geometry} Simplified geometry.
           */
          _this.simplifyTransformedInternal = memoizeOne(function (revision, squaredTolerance, opt_transform) {
              if (!opt_transform) {
                  return this.getSimplifiedGeometry(squaredTolerance);
              }
              var clone = this.clone();
              clone.applyTransform(opt_transform);
              return clone.getSimplifiedGeometry(squaredTolerance);
          });
          return _this;
      }
      /**
       * Get a transformed and simplified version of the geometry.
       * @abstract
       * @param {number} squaredTolerance Squared tolerance.
       * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
       * @return {Geometry} Simplified geometry.
       */
      Geometry.prototype.simplifyTransformed = function (squaredTolerance, opt_transform) {
          return this.simplifyTransformedInternal(this.getRevision(), squaredTolerance, opt_transform);
      };
      /**
       * Make a complete copy of the geometry.
       * @abstract
       * @return {!Geometry} Clone.
       */
      Geometry.prototype.clone = function () {
          return abstract();
      };
      /**
       * @abstract
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      Geometry.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
          return abstract();
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */
      Geometry.prototype.containsXY = function (x, y) {
          var coord = this.getClosestPoint([x, y]);
          return coord[0] === x && coord[1] === y;
      };
      /**
       * Return the closest point of the geometry to the passed point as
       * {@link module:ol/coordinate~Coordinate coordinate}.
       * @param {import("../coordinate.js").Coordinate} point Point.
       * @param {import("../coordinate.js").Coordinate=} opt_closestPoint Closest point.
       * @return {import("../coordinate.js").Coordinate} Closest point.
       * @api
       */
      Geometry.prototype.getClosestPoint = function (point, opt_closestPoint) {
          var closestPoint = opt_closestPoint ? opt_closestPoint : [NaN, NaN];
          this.closestPointXY(point[0], point[1], closestPoint, Infinity);
          return closestPoint;
      };
      /**
       * Returns true if this geometry includes the specified coordinate. If the
       * coordinate is on the boundary of the geometry, returns false.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @return {boolean} Contains coordinate.
       * @api
       */
      Geometry.prototype.intersectsCoordinate = function (coordinate) {
          return this.containsXY(coordinate[0], coordinate[1]);
      };
      /**
       * @abstract
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */
      Geometry.prototype.computeExtent = function (extent) {
          return abstract();
      };
      /**
       * Get the extent of the geometry.
       * @param {import("../extent.js").Extent=} opt_extent Extent.
       * @return {import("../extent.js").Extent} extent Extent.
       * @api
       */
      Geometry.prototype.getExtent = function (opt_extent) {
          if (this.extentRevision_ != this.getRevision()) {
              var extent = this.computeExtent(this.extent_);
              if (isNaN(extent[0]) || isNaN(extent[1])) {
                  createOrUpdateEmpty(extent);
              }
              this.extentRevision_ = this.getRevision();
          }
          return returnOrUpdate(this.extent_, opt_extent);
      };
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} angle Rotation angle in radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       */
      Geometry.prototype.rotate = function (angle, anchor) {
          abstract();
      };
      /**
       * Scale the geometry (with an optional origin).  This modifies the geometry
       * coordinates in place.
       * @abstract
       * @param {number} sx The scaling factor in the x-direction.
       * @param {number=} opt_sy The scaling factor in the y-direction (defaults to sx).
       * @param {import("../coordinate.js").Coordinate=} opt_anchor The scale origin (defaults to the center
       *     of the geometry extent).
       * @api
       */
      Geometry.prototype.scale = function (sx, opt_sy, opt_anchor) {
          abstract();
      };
      /**
       * Create a simplified version of this geometry.  For linestrings, this uses
       * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
       * algorithm.  For polygons, a quantization-based
       * simplification is used to preserve topology.
       * @param {number} tolerance The tolerance distance for simplification.
       * @return {Geometry} A new, simplified version of the original geometry.
       * @api
       */
      Geometry.prototype.simplify = function (tolerance) {
          return this.getSimplifiedGeometry(tolerance * tolerance);
      };
      /**
       * Create a simplified version of this geometry using the Douglas Peucker
       * algorithm.
       * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
       * @abstract
       * @param {number} squaredTolerance Squared tolerance.
       * @return {Geometry} Simplified geometry.
       */
      Geometry.prototype.getSimplifiedGeometry = function (squaredTolerance) {
          return abstract();
      };
      /**
       * Get the type of this geometry.
       * @abstract
       * @return {import("./GeometryType.js").default} Geometry type.
       */
      Geometry.prototype.getType = function () {
          return abstract();
      };
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @abstract
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       * Called with a flat array of geometry coordinates.
       */
      Geometry.prototype.applyTransform = function (transformFn) {
          abstract();
      };
      /**
       * Test if the geometry and the passed extent intersect.
       * @abstract
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       */
      Geometry.prototype.intersectsExtent = function (extent) {
          return abstract();
      };
      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @abstract
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       */
      Geometry.prototype.translate = function (deltaX, deltaY) {
          abstract();
      };
      /**
       * Transform each coordinate of the geometry from one coordinate reference
       * system to another. The geometry is modified in place.
       * For example, a line will be transformed to a line and a circle to a circle.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       *
       * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
       *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
       * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
       *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
       * @return {Geometry} This geometry.  Note that original geometry is
       *     modified in place.
       * @api
       */
      Geometry.prototype.transform = function (source, destination) {
          /** @type {import("../proj/Projection.js").default} */
          var sourceProj = get$2(source);
          var transformFn = sourceProj.getUnits() == Units.TILE_PIXELS
              ? function (inCoordinates, outCoordinates, stride) {
                  var pixelExtent = sourceProj.getExtent();
                  var projectedExtent = sourceProj.getWorldExtent();
                  var scale = getHeight(projectedExtent) / getHeight(pixelExtent);
                  compose(tmpTransform, projectedExtent[0], projectedExtent[3], scale, -scale, 0, 0, 0);
                  transform2D(inCoordinates, 0, inCoordinates.length, stride, tmpTransform, outCoordinates);
                  return getTransform(sourceProj, destination)(inCoordinates, outCoordinates, stride);
              }
              : getTransform(sourceProj, destination);
          this.applyTransform(transformFn);
          return this;
      };
      return Geometry;
  }(BaseObject));

  /**
   * @module ol/geom/GeometryLayout
   */
  /**
   * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
   * or measure ('M') coordinate is available. Supported values are `'XY'`,
   * `'XYZ'`, `'XYM'`, `'XYZM'`.
   * @enum {string}
   */
  var GeometryLayout = {
      XY: 'XY',
      XYZ: 'XYZ',
      XYM: 'XYM',
      XYZM: 'XYZM',
  };

  var __extends$9 = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Abstract base class; only used for creating subclasses; do not instantiate
   * in apps, as cannot be rendered.
   *
   * @abstract
   * @api
   */
  var SimpleGeometry = /** @class */ (function (_super) {
      __extends$9(SimpleGeometry, _super);
      function SimpleGeometry() {
          var _this = _super.call(this) || this;
          /**
           * @protected
           * @type {import("./GeometryLayout.js").default}
           */
          _this.layout = GeometryLayout.XY;
          /**
           * @protected
           * @type {number}
           */
          _this.stride = 2;
          /**
           * @protected
           * @type {Array<number>}
           */
          _this.flatCoordinates = null;
          return _this;
      }
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */
      SimpleGeometry.prototype.computeExtent = function (extent) {
          return createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
      };
      /**
       * @abstract
       * @return {Array<*>} Coordinates.
       */
      SimpleGeometry.prototype.getCoordinates = function () {
          return abstract();
      };
      /**
       * Return the first coordinate of the geometry.
       * @return {import("../coordinate.js").Coordinate} First coordinate.
       * @api
       */
      SimpleGeometry.prototype.getFirstCoordinate = function () {
          return this.flatCoordinates.slice(0, this.stride);
      };
      /**
       * @return {Array<number>} Flat coordinates.
       */
      SimpleGeometry.prototype.getFlatCoordinates = function () {
          return this.flatCoordinates;
      };
      /**
       * Return the last coordinate of the geometry.
       * @return {import("../coordinate.js").Coordinate} Last point.
       * @api
       */
      SimpleGeometry.prototype.getLastCoordinate = function () {
          return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride);
      };
      /**
       * Return the {@link module:ol/geom/GeometryLayout layout} of the geometry.
       * @return {import("./GeometryLayout.js").default} Layout.
       * @api
       */
      SimpleGeometry.prototype.getLayout = function () {
          return this.layout;
      };
      /**
       * Create a simplified version of this geometry using the Douglas Peucker algorithm.
       * @param {number} squaredTolerance Squared tolerance.
       * @return {SimpleGeometry} Simplified geometry.
       */
      SimpleGeometry.prototype.getSimplifiedGeometry = function (squaredTolerance) {
          if (this.simplifiedGeometryRevision !== this.getRevision()) {
              this.simplifiedGeometryMaxMinSquaredTolerance = 0;
              this.simplifiedGeometryRevision = this.getRevision();
          }
          // If squaredTolerance is negative or if we know that simplification will not
          // have any effect then just return this.
          if (squaredTolerance < 0 ||
              (this.simplifiedGeometryMaxMinSquaredTolerance !== 0 &&
                  squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance)) {
              return this;
          }
          var simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
          var simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
          if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
              return simplifiedGeometry;
          }
          else {
              // Simplification did not actually remove any coordinates.  We now know
              // that any calls to getSimplifiedGeometry with a squaredTolerance less
              // than or equal to the current squaredTolerance will also not have any
              // effect.  This allows us to short circuit simplification (saving CPU
              // cycles) and prevents the cache of simplified geometries from filling
              // up with useless identical copies of this geometry (saving memory).
              this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
              return this;
          }
      };
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {SimpleGeometry} Simplified geometry.
       * @protected
       */
      SimpleGeometry.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
          return this;
      };
      /**
       * @return {number} Stride.
       */
      SimpleGeometry.prototype.getStride = function () {
          return this.stride;
      };
      /**
       * @param {import("./GeometryLayout.js").default} layout Layout.
       * @param {Array<number>} flatCoordinates Flat coordinates.
       */
      SimpleGeometry.prototype.setFlatCoordinates = function (layout, flatCoordinates) {
          this.stride = getStrideForLayout(layout);
          this.layout = layout;
          this.flatCoordinates = flatCoordinates;
      };
      /**
       * @abstract
       * @param {!Array<*>} coordinates Coordinates.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       */
      SimpleGeometry.prototype.setCoordinates = function (coordinates, opt_layout) {
          abstract();
      };
      /**
       * @param {import("./GeometryLayout.js").default|undefined} layout Layout.
       * @param {Array<*>} coordinates Coordinates.
       * @param {number} nesting Nesting.
       * @protected
       */
      SimpleGeometry.prototype.setLayout = function (layout, coordinates, nesting) {
          /** @type {number} */
          var stride;
          if (layout) {
              stride = getStrideForLayout(layout);
          }
          else {
              for (var i = 0; i < nesting; ++i) {
                  if (coordinates.length === 0) {
                      this.layout = GeometryLayout.XY;
                      this.stride = 2;
                      return;
                  }
                  else {
                      coordinates = /** @type {Array} */ (coordinates[0]);
                  }
              }
              stride = coordinates.length;
              layout = getLayoutForStride(stride);
          }
          this.layout = layout;
          this.stride = stride;
      };
      /**
       * Apply a transform function to the coordinates of the geometry.
       * The geometry is modified in place.
       * If you do not want the geometry modified in place, first `clone()` it and
       * then use this function on the clone.
       * @param {import("../proj.js").TransformFunction} transformFn Transform function.
       * Called with a flat array of geometry coordinates.
       * @api
       */
      SimpleGeometry.prototype.applyTransform = function (transformFn) {
          if (this.flatCoordinates) {
              transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
              this.changed();
          }
      };
      /**
       * Rotate the geometry around a given coordinate. This modifies the geometry
       * coordinates in place.
       * @param {number} angle Rotation angle in radians.
       * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
       * @api
       */
      SimpleGeometry.prototype.rotate = function (angle, anchor) {
          var flatCoordinates = this.getFlatCoordinates();
          if (flatCoordinates) {
              var stride = this.getStride();
              rotate(flatCoordinates, 0, flatCoordinates.length, stride, angle, anchor, flatCoordinates);
              this.changed();
          }
      };
      /**
       * Scale the geometry (with an optional origin).  This modifies the geometry
       * coordinates in place.
       * @param {number} sx The scaling factor in the x-direction.
       * @param {number=} opt_sy The scaling factor in the y-direction (defaults to sx).
       * @param {import("../coordinate.js").Coordinate=} opt_anchor The scale origin (defaults to the center
       *     of the geometry extent).
       * @api
       */
      SimpleGeometry.prototype.scale = function (sx, opt_sy, opt_anchor) {
          var sy = opt_sy;
          if (sy === undefined) {
              sy = sx;
          }
          var anchor = opt_anchor;
          if (!anchor) {
              anchor = getCenter(this.getExtent());
          }
          var flatCoordinates = this.getFlatCoordinates();
          if (flatCoordinates) {
              var stride = this.getStride();
              scale(flatCoordinates, 0, flatCoordinates.length, stride, sx, sy, anchor, flatCoordinates);
              this.changed();
          }
      };
      /**
       * Translate the geometry.  This modifies the geometry coordinates in place.  If
       * instead you want a new geometry, first `clone()` this geometry.
       * @param {number} deltaX Delta X.
       * @param {number} deltaY Delta Y.
       * @api
       */
      SimpleGeometry.prototype.translate = function (deltaX, deltaY) {
          var flatCoordinates = this.getFlatCoordinates();
          if (flatCoordinates) {
              var stride = this.getStride();
              translate(flatCoordinates, 0, flatCoordinates.length, stride, deltaX, deltaY, flatCoordinates);
              this.changed();
          }
      };
      return SimpleGeometry;
  }(Geometry));
  /**
   * @param {number} stride Stride.
   * @return {import("./GeometryLayout.js").default} layout Layout.
   */
  function getLayoutForStride(stride) {
      var layout;
      if (stride == 2) {
          layout = GeometryLayout.XY;
      }
      else if (stride == 3) {
          layout = GeometryLayout.XYZ;
      }
      else if (stride == 4) {
          layout = GeometryLayout.XYZM;
      }
      return /** @type {import("./GeometryLayout.js").default} */ (layout);
  }
  /**
   * @param {import("./GeometryLayout.js").default} layout Layout.
   * @return {number} Stride.
   */
  function getStrideForLayout(layout) {
      var stride;
      if (layout == GeometryLayout.XY) {
          stride = 2;
      }
      else if (layout == GeometryLayout.XYZ || layout == GeometryLayout.XYM) {
          stride = 3;
      }
      else if (layout == GeometryLayout.XYZM) {
          stride = 4;
      }
      return /** @type {number} */ (stride);
  }
  /**
   * @param {SimpleGeometry} simpleGeometry Simple geometry.
   * @param {import("../transform.js").Transform} transform Transform.
   * @param {Array<number>=} opt_dest Destination.
   * @return {Array<number>} Transformed flat coordinates.
   */
  function transformGeom2D(simpleGeometry, transform, opt_dest) {
      var flatCoordinates = simpleGeometry.getFlatCoordinates();
      if (!flatCoordinates) {
          return null;
      }
      else {
          var stride = simpleGeometry.getStride();
          return transform2D(flatCoordinates, 0, flatCoordinates.length, stride, transform, opt_dest);
      }
  }

  /**
   * @module ol/render/canvas/Immediate
   */
  // FIXME test, especially polygons with holes and multipolygons
  // FIXME need to handle large thick features (where pixel size matters)
  // FIXME add offset and end to ol/geom/flat/transform~transform2D?
  var __extends$a = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * A concrete subclass of {@link module:ol/render/VectorContext} that implements
   * direct rendering of features and geometries to an HTML5 Canvas context.
   * Instances of this class are created internally by the library and
   * provided to application code as vectorContext member of the
   * {@link module:ol/render/Event~RenderEvent} object associated with postcompose, precompose and
   * render events emitted by layers and maps.
   */
  var CanvasImmediateRenderer = /** @class */ (function (_super) {
      __extends$a(CanvasImmediateRenderer, _super);
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("../../extent.js").Extent} extent Extent.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {number=} opt_squaredTolerance Optional squared tolerance for simplification.
       * @param {import("../../proj.js").TransformFunction=} opt_userTransform Transform from user to view projection.
       */
      function CanvasImmediateRenderer(context, pixelRatio, extent, transform, viewRotation, opt_squaredTolerance, opt_userTransform) {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {CanvasRenderingContext2D}
           */
          _this.context_ = context;
          /**
           * @private
           * @type {number}
           */
          _this.pixelRatio_ = pixelRatio;
          /**
           * @private
           * @type {import("../../extent.js").Extent}
           */
          _this.extent_ = extent;
          /**
           * @private
           * @type {import("../../transform.js").Transform}
           */
          _this.transform_ = transform;
          /**
           * @private
           * @type {number}
           */
          _this.viewRotation_ = viewRotation;
          /**
           * @private
           * @type {number}
           */
          _this.squaredTolerance_ = opt_squaredTolerance;
          /**
           * @private
           * @type {import("../../proj.js").TransformFunction}
           */
          _this.userTransform_ = opt_userTransform;
          /**
           * @private
           * @type {?import("../canvas.js").FillState}
           */
          _this.contextFillState_ = null;
          /**
           * @private
           * @type {?import("../canvas.js").StrokeState}
           */
          _this.contextStrokeState_ = null;
          /**
           * @private
           * @type {?import("../canvas.js").TextState}
           */
          _this.contextTextState_ = null;
          /**
           * @private
           * @type {?import("../canvas.js").FillState}
           */
          _this.fillState_ = null;
          /**
           * @private
           * @type {?import("../canvas.js").StrokeState}
           */
          _this.strokeState_ = null;
          /**
           * @private
           * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
           */
          _this.image_ = null;
          /**
           * @private
           * @type {number}
           */
          _this.imageAnchorX_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.imageAnchorY_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.imageHeight_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.imageOpacity_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.imageOriginX_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.imageOriginY_ = 0;
          /**
           * @private
           * @type {boolean}
           */
          _this.imageRotateWithView_ = false;
          /**
           * @private
           * @type {number}
           */
          _this.imageRotation_ = 0;
          /**
           * @private
           * @type {import("../../size.js").Size}
           */
          _this.imageScale_ = [0, 0];
          /**
           * @private
           * @type {number}
           */
          _this.imageWidth_ = 0;
          /**
           * @private
           * @type {string}
           */
          _this.text_ = '';
          /**
           * @private
           * @type {number}
           */
          _this.textOffsetX_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.textOffsetY_ = 0;
          /**
           * @private
           * @type {boolean}
           */
          _this.textRotateWithView_ = false;
          /**
           * @private
           * @type {number}
           */
          _this.textRotation_ = 0;
          /**
           * @private
           * @type {import("../../size.js").Size}
           */
          _this.textScale_ = [0, 0];
          /**
           * @private
           * @type {?import("../canvas.js").FillState}
           */
          _this.textFillState_ = null;
          /**
           * @private
           * @type {?import("../canvas.js").StrokeState}
           */
          _this.textStrokeState_ = null;
          /**
           * @private
           * @type {?import("../canvas.js").TextState}
           */
          _this.textState_ = null;
          /**
           * @private
           * @type {Array<number>}
           */
          _this.pixelCoordinates_ = [];
          /**
           * @private
           * @type {import("../../transform.js").Transform}
           */
          _this.tmpLocalTransform_ = create();
          return _this;
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       */
      CanvasImmediateRenderer.prototype.drawImages_ = function (flatCoordinates, offset, end, stride) {
          if (!this.image_) {
              return;
          }
          var pixelCoordinates = transform2D(flatCoordinates, offset, end, 2, this.transform_, this.pixelCoordinates_);
          var context = this.context_;
          var localTransform = this.tmpLocalTransform_;
          var alpha = context.globalAlpha;
          if (this.imageOpacity_ != 1) {
              context.globalAlpha = alpha * this.imageOpacity_;
          }
          var rotation = this.imageRotation_;
          if (this.imageRotateWithView_) {
              rotation += this.viewRotation_;
          }
          for (var i = 0, ii = pixelCoordinates.length; i < ii; i += 2) {
              var x = pixelCoordinates[i] - this.imageAnchorX_;
              var y = pixelCoordinates[i + 1] - this.imageAnchorY_;
              if (rotation !== 0 ||
                  this.imageScale_[0] != 1 ||
                  this.imageScale_[1] != 1) {
                  var centerX = x + this.imageAnchorX_;
                  var centerY = y + this.imageAnchorY_;
                  compose(localTransform, centerX, centerY, 1, 1, rotation, -centerX, -centerY);
                  context.setTransform.apply(context, localTransform);
                  context.translate(centerX, centerY);
                  context.scale(this.imageScale_[0], this.imageScale_[1]);
                  context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_);
                  context.setTransform(1, 0, 0, 1, 0, 0);
              }
              else {
                  context.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, x, y, this.imageWidth_, this.imageHeight_);
              }
          }
          if (this.imageOpacity_ != 1) {
              context.globalAlpha = alpha;
          }
      };
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       */
      CanvasImmediateRenderer.prototype.drawText_ = function (flatCoordinates, offset, end, stride) {
          if (!this.textState_ || this.text_ === '') {
              return;
          }
          if (this.textFillState_) {
              this.setContextFillState_(this.textFillState_);
          }
          if (this.textStrokeState_) {
              this.setContextStrokeState_(this.textStrokeState_);
          }
          this.setContextTextState_(this.textState_);
          var pixelCoordinates = transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
          var context = this.context_;
          var rotation = this.textRotation_;
          if (this.textRotateWithView_) {
              rotation += this.viewRotation_;
          }
          for (; offset < end; offset += stride) {
              var x = pixelCoordinates[offset] + this.textOffsetX_;
              var y = pixelCoordinates[offset + 1] + this.textOffsetY_;
              if (rotation !== 0 ||
                  this.textScale_[0] != 1 ||
                  this.textScale_[1] != 1) {
                  var localTransform = compose(this.tmpLocalTransform_, x, y, 1, 1, rotation, -x, -y);
                  context.setTransform.apply(context, localTransform);
                  context.translate(x, y);
                  context.scale(this.textScale_[0], this.textScale_[1]);
                  if (this.textStrokeState_) {
                      context.strokeText(this.text_, 0, 0);
                  }
                  if (this.textFillState_) {
                      context.fillText(this.text_, 0, 0);
                  }
                  context.setTransform(1, 0, 0, 1, 0, 0);
              }
              else {
                  if (this.textStrokeState_) {
                      context.strokeText(this.text_, x, y);
                  }
                  if (this.textFillState_) {
                      context.fillText(this.text_, x, y);
                  }
              }
          }
      };
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @param {boolean} close Close.
       * @private
       * @return {number} end End.
       */
      CanvasImmediateRenderer.prototype.moveToLineTo_ = function (flatCoordinates, offset, end, stride, close) {
          var context = this.context_;
          var pixelCoordinates = transform2D(flatCoordinates, offset, end, stride, this.transform_, this.pixelCoordinates_);
          context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
          var length = pixelCoordinates.length;
          if (close) {
              length -= 2;
          }
          for (var i = 2; i < length; i += 2) {
              context.lineTo(pixelCoordinates[i], pixelCoordinates[i + 1]);
          }
          if (close) {
              context.closePath();
          }
          return end;
      };
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @private
       * @return {number} End.
       */
      CanvasImmediateRenderer.prototype.drawRings_ = function (flatCoordinates, offset, ends, stride) {
          for (var i = 0, ii = ends.length; i < ii; ++i) {
              offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, true);
          }
          return offset;
      };
      /**
       * Render a circle geometry into the canvas.  Rendering is immediate and uses
       * the current fill and stroke styles.
       *
       * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
       * @api
       */
      CanvasImmediateRenderer.prototype.drawCircle = function (geometry) {
          if (!intersects(this.extent_, geometry.getExtent())) {
              return;
          }
          if (this.fillState_ || this.strokeState_) {
              if (this.fillState_) {
                  this.setContextFillState_(this.fillState_);
              }
              if (this.strokeState_) {
                  this.setContextStrokeState_(this.strokeState_);
              }
              var pixelCoordinates = transformGeom2D(geometry, this.transform_, this.pixelCoordinates_);
              var dx = pixelCoordinates[2] - pixelCoordinates[0];
              var dy = pixelCoordinates[3] - pixelCoordinates[1];
              var radius = Math.sqrt(dx * dx + dy * dy);
              var context = this.context_;
              context.beginPath();
              context.arc(pixelCoordinates[0], pixelCoordinates[1], radius, 0, 2 * Math.PI);
              if (this.fillState_) {
                  context.fill();
              }
              if (this.strokeState_) {
                  context.stroke();
              }
          }
          if (this.text_ !== '') {
              this.drawText_(geometry.getCenter(), 0, 2, 2);
          }
      };
      /**
       * Set the rendering style.  Note that since this is an immediate rendering API,
       * any `zIndex` on the provided style will be ignored.
       *
       * @param {import("../../style/Style.js").default} style The rendering style.
       * @api
       */
      CanvasImmediateRenderer.prototype.setStyle = function (style) {
          this.setFillStrokeStyle(style.getFill(), style.getStroke());
          this.setImageStyle(style.getImage());
          this.setTextStyle(style.getText());
      };
      /**
       * @param {import("../../transform.js").Transform} transform Transform.
       */
      CanvasImmediateRenderer.prototype.setTransform = function (transform) {
          this.transform_ = transform;
      };
      /**
       * Render a geometry into the canvas.  Call
       * {@link module:ol/render/canvas/Immediate#setStyle} first to set the rendering style.
       *
       * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
       * @api
       */
      CanvasImmediateRenderer.prototype.drawGeometry = function (geometry) {
          var type = geometry.getType();
          switch (type) {
              case GeometryType.POINT:
                  this.drawPoint(
                  /** @type {import("../../geom/Point.js").default} */ (geometry));
                  break;
              case GeometryType.LINE_STRING:
                  this.drawLineString(
                  /** @type {import("../../geom/LineString.js").default} */ (geometry));
                  break;
              case GeometryType.POLYGON:
                  this.drawPolygon(
                  /** @type {import("../../geom/Polygon.js").default} */ (geometry));
                  break;
              case GeometryType.MULTI_POINT:
                  this.drawMultiPoint(
                  /** @type {import("../../geom/MultiPoint.js").default} */ (geometry));
                  break;
              case GeometryType.MULTI_LINE_STRING:
                  this.drawMultiLineString(
                  /** @type {import("../../geom/MultiLineString.js").default} */ (geometry));
                  break;
              case GeometryType.MULTI_POLYGON:
                  this.drawMultiPolygon(
                  /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry));
                  break;
              case GeometryType.GEOMETRY_COLLECTION:
                  this.drawGeometryCollection(
                  /** @type {import("../../geom/GeometryCollection.js").default} */ (geometry));
                  break;
              case GeometryType.CIRCLE:
                  this.drawCircle(
                  /** @type {import("../../geom/Circle.js").default} */ (geometry));
                  break;
          }
      };
      /**
       * Render a feature into the canvas.  Note that any `zIndex` on the provided
       * style will be ignored - features are rendered immediately in the order that
       * this method is called.  If you need `zIndex` support, you should be using an
       * {@link module:ol/layer/Vector~VectorLayer} instead.
       *
       * @param {import("../../Feature.js").default} feature Feature.
       * @param {import("../../style/Style.js").default} style Style.
       * @api
       */
      CanvasImmediateRenderer.prototype.drawFeature = function (feature, style) {
          var geometry = style.getGeometryFunction()(feature);
          if (!geometry || !intersects(this.extent_, geometry.getExtent())) {
              return;
          }
          this.setStyle(style);
          this.drawGeometry(geometry);
      };
      /**
       * Render a GeometryCollection to the canvas.  Rendering is immediate and
       * uses the current styles appropriate for each geometry in the collection.
       *
       * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
       */
      CanvasImmediateRenderer.prototype.drawGeometryCollection = function (geometry) {
          var geometries = geometry.getGeometriesArray();
          for (var i = 0, ii = geometries.length; i < ii; ++i) {
              this.drawGeometry(geometries[i]);
          }
      };
      /**
       * Render a Point geometry into the canvas.  Rendering is immediate and uses
       * the current style.
       *
       * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
       */
      CanvasImmediateRenderer.prototype.drawPoint = function (geometry) {
          if (this.squaredTolerance_) {
              geometry = /** @type {import("../../geom/Point.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          }
          var flatCoordinates = geometry.getFlatCoordinates();
          var stride = geometry.getStride();
          if (this.image_) {
              this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
          }
          if (this.text_ !== '') {
              this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
          }
      };
      /**
       * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
       * uses the current style.
       *
       * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
       */
      CanvasImmediateRenderer.prototype.drawMultiPoint = function (geometry) {
          if (this.squaredTolerance_) {
              geometry = /** @type {import("../../geom/MultiPoint.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          }
          var flatCoordinates = geometry.getFlatCoordinates();
          var stride = geometry.getStride();
          if (this.image_) {
              this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
          }
          if (this.text_ !== '') {
              this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
          }
      };
      /**
       * Render a LineString into the canvas.  Rendering is immediate and uses
       * the current style.
       *
       * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
       */
      CanvasImmediateRenderer.prototype.drawLineString = function (geometry) {
          if (this.squaredTolerance_) {
              geometry = /** @type {import("../../geom/LineString.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          }
          if (!intersects(this.extent_, geometry.getExtent())) {
              return;
          }
          if (this.strokeState_) {
              this.setContextStrokeState_(this.strokeState_);
              var context = this.context_;
              var flatCoordinates = geometry.getFlatCoordinates();
              context.beginPath();
              this.moveToLineTo_(flatCoordinates, 0, flatCoordinates.length, geometry.getStride(), false);
              context.stroke();
          }
          if (this.text_ !== '') {
              var flatMidpoint = geometry.getFlatMidpoint();
              this.drawText_(flatMidpoint, 0, 2, 2);
          }
      };
      /**
       * Render a MultiLineString geometry into the canvas.  Rendering is immediate
       * and uses the current style.
       *
       * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
       */
      CanvasImmediateRenderer.prototype.drawMultiLineString = function (geometry) {
          if (this.squaredTolerance_) {
              geometry = /** @type {import("../../geom/MultiLineString.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          }
          var geometryExtent = geometry.getExtent();
          if (!intersects(this.extent_, geometryExtent)) {
              return;
          }
          if (this.strokeState_) {
              this.setContextStrokeState_(this.strokeState_);
              var context = this.context_;
              var flatCoordinates = geometry.getFlatCoordinates();
              var offset = 0;
              var ends = /** @type {Array<number>} */ (geometry.getEnds());
              var stride = geometry.getStride();
              context.beginPath();
              for (var i = 0, ii = ends.length; i < ii; ++i) {
                  offset = this.moveToLineTo_(flatCoordinates, offset, ends[i], stride, false);
              }
              context.stroke();
          }
          if (this.text_ !== '') {
              var flatMidpoints = geometry.getFlatMidpoints();
              this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
          }
      };
      /**
       * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
       * the current style.
       *
       * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
       */
      CanvasImmediateRenderer.prototype.drawPolygon = function (geometry) {
          if (this.squaredTolerance_) {
              geometry = /** @type {import("../../geom/Polygon.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          }
          if (!intersects(this.extent_, geometry.getExtent())) {
              return;
          }
          if (this.strokeState_ || this.fillState_) {
              if (this.fillState_) {
                  this.setContextFillState_(this.fillState_);
              }
              if (this.strokeState_) {
                  this.setContextStrokeState_(this.strokeState_);
              }
              var context = this.context_;
              context.beginPath();
              this.drawRings_(geometry.getOrientedFlatCoordinates(), 0, 
              /** @type {Array<number>} */ (geometry.getEnds()), geometry.getStride());
              if (this.fillState_) {
                  context.fill();
              }
              if (this.strokeState_) {
                  context.stroke();
              }
          }
          if (this.text_ !== '') {
              var flatInteriorPoint = geometry.getFlatInteriorPoint();
              this.drawText_(flatInteriorPoint, 0, 2, 2);
          }
      };
      /**
       * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
       * uses the current style.
       * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
       */
      CanvasImmediateRenderer.prototype.drawMultiPolygon = function (geometry) {
          if (this.squaredTolerance_) {
              geometry = /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
          }
          if (!intersects(this.extent_, geometry.getExtent())) {
              return;
          }
          if (this.strokeState_ || this.fillState_) {
              if (this.fillState_) {
                  this.setContextFillState_(this.fillState_);
              }
              if (this.strokeState_) {
                  this.setContextStrokeState_(this.strokeState_);
              }
              var context = this.context_;
              var flatCoordinates = geometry.getOrientedFlatCoordinates();
              var offset = 0;
              var endss = geometry.getEndss();
              var stride = geometry.getStride();
              context.beginPath();
              for (var i = 0, ii = endss.length; i < ii; ++i) {
                  var ends = endss[i];
                  offset = this.drawRings_(flatCoordinates, offset, ends, stride);
              }
              if (this.fillState_) {
                  context.fill();
              }
              if (this.strokeState_) {
                  context.stroke();
              }
          }
          if (this.text_ !== '') {
              var flatInteriorPoints = geometry.getFlatInteriorPoints();
              this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
          }
      };
      /**
       * @param {import("../canvas.js").FillState} fillState Fill state.
       * @private
       */
      CanvasImmediateRenderer.prototype.setContextFillState_ = function (fillState) {
          var context = this.context_;
          var contextFillState = this.contextFillState_;
          if (!contextFillState) {
              context.fillStyle = fillState.fillStyle;
              this.contextFillState_ = {
                  fillStyle: fillState.fillStyle,
              };
          }
          else {
              if (contextFillState.fillStyle != fillState.fillStyle) {
                  contextFillState.fillStyle = fillState.fillStyle;
                  context.fillStyle = fillState.fillStyle;
              }
          }
      };
      /**
       * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
       * @private
       */
      CanvasImmediateRenderer.prototype.setContextStrokeState_ = function (strokeState) {
          var context = this.context_;
          var contextStrokeState = this.contextStrokeState_;
          if (!contextStrokeState) {
              context.lineCap = strokeState.lineCap;
              if (context.setLineDash) {
                  context.setLineDash(strokeState.lineDash);
                  context.lineDashOffset = strokeState.lineDashOffset;
              }
              context.lineJoin = strokeState.lineJoin;
              context.lineWidth = strokeState.lineWidth;
              context.miterLimit = strokeState.miterLimit;
              context.strokeStyle = strokeState.strokeStyle;
              this.contextStrokeState_ = {
                  lineCap: strokeState.lineCap,
                  lineDash: strokeState.lineDash,
                  lineDashOffset: strokeState.lineDashOffset,
                  lineJoin: strokeState.lineJoin,
                  lineWidth: strokeState.lineWidth,
                  miterLimit: strokeState.miterLimit,
                  strokeStyle: strokeState.strokeStyle,
              };
          }
          else {
              if (contextStrokeState.lineCap != strokeState.lineCap) {
                  contextStrokeState.lineCap = strokeState.lineCap;
                  context.lineCap = strokeState.lineCap;
              }
              if (context.setLineDash) {
                  if (!equals(contextStrokeState.lineDash, strokeState.lineDash)) {
                      context.setLineDash((contextStrokeState.lineDash = strokeState.lineDash));
                  }
                  if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
                      contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
                      context.lineDashOffset = strokeState.lineDashOffset;
                  }
              }
              if (contextStrokeState.lineJoin != strokeState.lineJoin) {
                  contextStrokeState.lineJoin = strokeState.lineJoin;
                  context.lineJoin = strokeState.lineJoin;
              }
              if (contextStrokeState.lineWidth != strokeState.lineWidth) {
                  contextStrokeState.lineWidth = strokeState.lineWidth;
                  context.lineWidth = strokeState.lineWidth;
              }
              if (contextStrokeState.miterLimit != strokeState.miterLimit) {
                  contextStrokeState.miterLimit = strokeState.miterLimit;
                  context.miterLimit = strokeState.miterLimit;
              }
              if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
                  contextStrokeState.strokeStyle = strokeState.strokeStyle;
                  context.strokeStyle = strokeState.strokeStyle;
              }
          }
      };
      /**
       * @param {import("../canvas.js").TextState} textState Text state.
       * @private
       */
      CanvasImmediateRenderer.prototype.setContextTextState_ = function (textState) {
          var context = this.context_;
          var contextTextState = this.contextTextState_;
          var textAlign = textState.textAlign
              ? textState.textAlign
              : defaultTextAlign;
          if (!contextTextState) {
              context.font = textState.font;
              context.textAlign = /** @type {CanvasTextAlign} */ (textAlign);
              context.textBaseline = /** @type {CanvasTextBaseline} */ (textState.textBaseline);
              this.contextTextState_ = {
                  font: textState.font,
                  textAlign: textAlign,
                  textBaseline: textState.textBaseline,
              };
          }
          else {
              if (contextTextState.font != textState.font) {
                  contextTextState.font = textState.font;
                  context.font = textState.font;
              }
              if (contextTextState.textAlign != textAlign) {
                  contextTextState.textAlign = /** @type {CanvasTextAlign} */ (textAlign);
                  context.textAlign = /** @type {CanvasTextAlign} */ (textAlign);
              }
              if (contextTextState.textBaseline != textState.textBaseline) {
                  contextTextState.textBaseline = /** @type {CanvasTextBaseline} */ (textState.textBaseline);
                  context.textBaseline = /** @type {CanvasTextBaseline} */ (textState.textBaseline);
              }
          }
      };
      /**
       * Set the fill and stroke style for subsequent draw operations.  To clear
       * either fill or stroke styles, pass null for the appropriate parameter.
       *
       * @param {import("../../style/Fill.js").default} fillStyle Fill style.
       * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
       */
      CanvasImmediateRenderer.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
          if (!fillStyle) {
              this.fillState_ = null;
          }
          else {
              var fillStyleColor = fillStyle.getColor();
              this.fillState_ = {
                  fillStyle: asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle),
              };
          }
          if (!strokeStyle) {
              this.strokeState_ = null;
          }
          else {
              var strokeStyleColor = strokeStyle.getColor();
              var strokeStyleLineCap = strokeStyle.getLineCap();
              var strokeStyleLineDash = strokeStyle.getLineDash();
              var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
              var strokeStyleLineJoin = strokeStyle.getLineJoin();
              var strokeStyleWidth = strokeStyle.getWidth();
              var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
              this.strokeState_ = {
                  lineCap: strokeStyleLineCap !== undefined
                      ? strokeStyleLineCap
                      : defaultLineCap,
                  lineDash: strokeStyleLineDash ? strokeStyleLineDash : defaultLineDash,
                  lineDashOffset: strokeStyleLineDashOffset
                      ? strokeStyleLineDashOffset
                      : defaultLineDashOffset,
                  lineJoin: strokeStyleLineJoin !== undefined
                      ? strokeStyleLineJoin
                      : defaultLineJoin,
                  lineWidth: this.pixelRatio_ *
                      (strokeStyleWidth !== undefined
                          ? strokeStyleWidth
                          : defaultLineWidth),
                  miterLimit: strokeStyleMiterLimit !== undefined
                      ? strokeStyleMiterLimit
                      : defaultMiterLimit,
                  strokeStyle: asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle),
              };
          }
      };
      /**
       * Set the image style for subsequent draw operations.  Pass null to remove
       * the image style.
       *
       * @param {import("../../style/Image.js").default} imageStyle Image style.
       */
      CanvasImmediateRenderer.prototype.setImageStyle = function (imageStyle) {
          if (!imageStyle) {
              this.image_ = null;
          }
          else {
              var imageSize = imageStyle.getSize();
              if (!imageSize) {
                  this.image_ = null;
              }
              else {
                  var imageAnchor = imageStyle.getAnchor();
                  // FIXME pixel ratio
                  var imageImage = imageStyle.getImage(1);
                  var imageOrigin = imageStyle.getOrigin();
                  var imageScale = imageStyle.getScaleArray();
                  this.imageAnchorX_ = imageAnchor[0];
                  this.imageAnchorY_ = imageAnchor[1];
                  this.imageHeight_ = imageSize[1];
                  this.image_ = imageImage;
                  this.imageOpacity_ = imageStyle.getOpacity();
                  this.imageOriginX_ = imageOrigin[0];
                  this.imageOriginY_ = imageOrigin[1];
                  this.imageRotateWithView_ = imageStyle.getRotateWithView();
                  this.imageRotation_ = imageStyle.getRotation();
                  this.imageScale_ = [
                      this.pixelRatio_ * imageScale[0],
                      this.pixelRatio_ * imageScale[1],
                  ];
                  this.imageWidth_ = imageSize[0];
              }
          }
      };
      /**
       * Set the text style for subsequent draw operations.  Pass null to
       * remove the text style.
       *
       * @param {import("../../style/Text.js").default} textStyle Text style.
       */
      CanvasImmediateRenderer.prototype.setTextStyle = function (textStyle) {
          if (!textStyle) {
              this.text_ = '';
          }
          else {
              var textFillStyle = textStyle.getFill();
              if (!textFillStyle) {
                  this.textFillState_ = null;
              }
              else {
                  var textFillStyleColor = textFillStyle.getColor();
                  this.textFillState_ = {
                      fillStyle: asColorLike(textFillStyleColor ? textFillStyleColor : defaultFillStyle),
                  };
              }
              var textStrokeStyle = textStyle.getStroke();
              if (!textStrokeStyle) {
                  this.textStrokeState_ = null;
              }
              else {
                  var textStrokeStyleColor = textStrokeStyle.getColor();
                  var textStrokeStyleLineCap = textStrokeStyle.getLineCap();
                  var textStrokeStyleLineDash = textStrokeStyle.getLineDash();
                  var textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
                  var textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
                  var textStrokeStyleWidth = textStrokeStyle.getWidth();
                  var textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
                  this.textStrokeState_ = {
                      lineCap: textStrokeStyleLineCap !== undefined
                          ? textStrokeStyleLineCap
                          : defaultLineCap,
                      lineDash: textStrokeStyleLineDash
                          ? textStrokeStyleLineDash
                          : defaultLineDash,
                      lineDashOffset: textStrokeStyleLineDashOffset
                          ? textStrokeStyleLineDashOffset
                          : defaultLineDashOffset,
                      lineJoin: textStrokeStyleLineJoin !== undefined
                          ? textStrokeStyleLineJoin
                          : defaultLineJoin,
                      lineWidth: textStrokeStyleWidth !== undefined
                          ? textStrokeStyleWidth
                          : defaultLineWidth,
                      miterLimit: textStrokeStyleMiterLimit !== undefined
                          ? textStrokeStyleMiterLimit
                          : defaultMiterLimit,
                      strokeStyle: asColorLike(textStrokeStyleColor ? textStrokeStyleColor : defaultStrokeStyle),
                  };
              }
              var textFont = textStyle.getFont();
              var textOffsetX = textStyle.getOffsetX();
              var textOffsetY = textStyle.getOffsetY();
              var textRotateWithView = textStyle.getRotateWithView();
              var textRotation = textStyle.getRotation();
              var textScale = textStyle.getScaleArray();
              var textText = textStyle.getText();
              var textTextAlign = textStyle.getTextAlign();
              var textTextBaseline = textStyle.getTextBaseline();
              this.textState_ = {
                  font: textFont !== undefined ? textFont : defaultFont,
                  textAlign: textTextAlign !== undefined ? textTextAlign : defaultTextAlign,
                  textBaseline: textTextBaseline !== undefined
                      ? textTextBaseline
                      : defaultTextBaseline,
              };
              this.text_ = textText !== undefined ? textText : '';
              this.textOffsetX_ =
                  textOffsetX !== undefined ? this.pixelRatio_ * textOffsetX : 0;
              this.textOffsetY_ =
                  textOffsetY !== undefined ? this.pixelRatio_ * textOffsetY : 0;
              this.textRotateWithView_ =
                  textRotateWithView !== undefined ? textRotateWithView : false;
              this.textRotation_ = textRotation !== undefined ? textRotation : 0;
              this.textScale_ = [
                  this.pixelRatio_ * textScale[0],
                  this.pixelRatio_ * textScale[1],
              ];
          }
      };
      return CanvasImmediateRenderer;
  }(VectorContext));

  /**
   * @module ol/render/canvas/BuilderType
   */
  /**
   * @enum {string}
   */
  var ReplayType = {
      CIRCLE: 'Circle',
      DEFAULT: 'Default',
      IMAGE: 'Image',
      LINE_STRING: 'LineString',
      POLYGON: 'Polygon',
      TEXT: 'Text',
  };

  /**
   * @module ol/ImageState
   */
  /**
   * @enum {number}
   */
  var ImageState = {
      IDLE: 0,
      LOADING: 1,
      LOADED: 2,
      ERROR: 3,
      EMPTY: 4,
  };

  /**
   * @module ol/renderer/vector
   */
  /**
   * Tolerance for geometry simplification in device pixels.
   * @type {number}
   */
  var SIMPLIFY_TOLERANCE = 0.5;
  /**
   * @const
   * @type {Object<import("../geom/GeometryType.js").default,
   *                function(import("../render/canvas/BuilderGroup.js").default, import("../geom/Geometry.js").default,
   *                         import("../style/Style.js").default, Object): void>}
   */
  var GEOMETRY_RENDERERS = {
      'Point': renderPointGeometry,
      'LineString': renderLineStringGeometry,
      'Polygon': renderPolygonGeometry,
      'MultiPoint': renderMultiPointGeometry,
      'MultiLineString': renderMultiLineStringGeometry,
      'MultiPolygon': renderMultiPolygonGeometry,
      'GeometryCollection': renderGeometryCollectionGeometry,
      'Circle': renderCircleGeometry,
  };
  /**
   * @param {import("../Feature.js").FeatureLike} feature1 Feature 1.
   * @param {import("../Feature.js").FeatureLike} feature2 Feature 2.
   * @return {number} Order.
   */
  function defaultOrder(feature1, feature2) {
      return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);
  }
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Squared pixel tolerance.
   */
  function getSquaredTolerance(resolution, pixelRatio) {
      var tolerance = getTolerance(resolution, pixelRatio);
      return tolerance * tolerance;
  }
  /**
   * @param {number} resolution Resolution.
   * @param {number} pixelRatio Pixel ratio.
   * @return {number} Pixel tolerance.
   */
  function getTolerance(resolution, pixelRatio) {
      return (SIMPLIFY_TOLERANCE * resolution) / pixelRatio;
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
   * @param {import("../geom/Circle.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").default} feature Feature.
   */
  function renderCircleGeometry(builderGroup, geometry, style, feature) {
      var fillStyle = style.getFill();
      var strokeStyle = style.getStroke();
      if (fillStyle || strokeStyle) {
          var circleReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.CIRCLE);
          circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
          circleReplay.drawCircle(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
          var textReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.TEXT);
          textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(false));
          textReplay.drawText(geometry, feature);
      }
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {function(import("../events/Event.js").default): void} listener Listener function.
   * @param {import("../proj.js").TransformFunction} [opt_transform] Transform from user to view projection.
   * @return {boolean} `true` if style is loading.
   * @template T
   */
  function renderFeature(replayGroup, feature, style, squaredTolerance, listener, opt_transform) {
      var loading = false;
      var imageStyle = style.getImage();
      if (imageStyle) {
          var imageState = imageStyle.getImageState();
          if (imageState == ImageState.LOADED || imageState == ImageState.ERROR) {
              imageStyle.unlistenImageChange(listener);
          }
          else {
              if (imageState == ImageState.IDLE) {
                  imageStyle.load();
              }
              imageState = imageStyle.getImageState();
              imageStyle.listenImageChange(listener);
              loading = true;
          }
      }
      renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform);
      return loading;
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {import("../style/Style.js").default} style Style.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {import("../proj.js").TransformFunction} [opt_transform] Optional transform function.
   */
  function renderFeatureInternal(replayGroup, feature, style, squaredTolerance, opt_transform) {
      var geometry = style.getGeometryFunction()(feature);
      if (!geometry) {
          return;
      }
      var simplifiedGeometry = geometry.simplifyTransformed(squaredTolerance, opt_transform);
      var renderer = style.getRenderer();
      if (renderer) {
          renderGeometry(replayGroup, simplifiedGeometry, style, feature);
      }
      else {
          var geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
          geometryRenderer(replayGroup, simplifiedGeometry, style, feature);
      }
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
   * @param {import("../geom/Geometry.js").default|import("../render/Feature.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  function renderGeometry(replayGroup, geometry, style, feature) {
      if (geometry.getType() == GeometryType.GEOMETRY_COLLECTION) {
          var geometries = /** @type {import("../geom/GeometryCollection.js").default} */ (geometry).getGeometries();
          for (var i = 0, ii = geometries.length; i < ii; ++i) {
              renderGeometry(replayGroup, geometries[i], style, feature);
          }
          return;
      }
      var replay = replayGroup.getBuilder(style.getZIndex(), ReplayType.DEFAULT);
      replay.drawCustom(
      /** @type {import("../geom/SimpleGeometry.js").default} */ (geometry), feature, style.getRenderer());
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} replayGroup Replay group.
   * @param {import("../geom/GeometryCollection.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").default} feature Feature.
   */
  function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature) {
      var geometries = geometry.getGeometriesArray();
      var i, ii;
      for (i = 0, ii = geometries.length; i < ii; ++i) {
          var geometryRenderer = GEOMETRY_RENDERERS[geometries[i].getType()];
          geometryRenderer(replayGroup, geometries[i], style, feature);
      }
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {import("../geom/LineString.js").default|import("../render/Feature.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  function renderLineStringGeometry(builderGroup, geometry, style, feature) {
      var strokeStyle = style.getStroke();
      if (strokeStyle) {
          var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.LINE_STRING);
          lineStringReplay.setFillStrokeStyle(null, strokeStyle);
          lineStringReplay.drawLineString(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
          var textReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.TEXT);
          textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(false));
          textReplay.drawText(geometry, feature);
      }
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {import("../geom/MultiLineString.js").default|import("../render/Feature.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  function renderMultiLineStringGeometry(builderGroup, geometry, style, feature) {
      var strokeStyle = style.getStroke();
      if (strokeStyle) {
          var lineStringReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.LINE_STRING);
          lineStringReplay.setFillStrokeStyle(null, strokeStyle);
          lineStringReplay.drawMultiLineString(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
          var textReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.TEXT);
          textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(false));
          textReplay.drawText(geometry, feature);
      }
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {import("../geom/MultiPolygon.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").default} feature Feature.
   */
  function renderMultiPolygonGeometry(builderGroup, geometry, style, feature) {
      var fillStyle = style.getFill();
      var strokeStyle = style.getStroke();
      if (strokeStyle || fillStyle) {
          var polygonReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.POLYGON);
          polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
          polygonReplay.drawMultiPolygon(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
          var textReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.TEXT);
          textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(false));
          textReplay.drawText(geometry, feature);
      }
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {import("../geom/Point.js").default|import("../render/Feature.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  function renderPointGeometry(builderGroup, geometry, style, feature) {
      var imageStyle = style.getImage();
      if (imageStyle) {
          if (imageStyle.getImageState() != ImageState.LOADED) {
              return;
          }
          var imageReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.IMAGE);
          imageReplay.setImageStyle(imageStyle, builderGroup.addDeclutter(false));
          imageReplay.drawPoint(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
          var textReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.TEXT);
          textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(!!imageStyle));
          textReplay.drawText(geometry, feature);
      }
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {import("../geom/MultiPoint.js").default|import("../render/Feature.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  function renderMultiPointGeometry(builderGroup, geometry, style, feature) {
      var imageStyle = style.getImage();
      if (imageStyle) {
          if (imageStyle.getImageState() != ImageState.LOADED) {
              return;
          }
          var imageReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.IMAGE);
          imageReplay.setImageStyle(imageStyle, builderGroup.addDeclutter(false));
          imageReplay.drawMultiPoint(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
          var textReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.TEXT);
          textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(!!imageStyle));
          textReplay.drawText(geometry, feature);
      }
  }
  /**
   * @param {import("../render/canvas/BuilderGroup.js").default} builderGroup Replay group.
   * @param {import("../geom/Polygon.js").default|import("../render/Feature.js").default} geometry Geometry.
   * @param {import("../style/Style.js").default} style Style.
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   */
  function renderPolygonGeometry(builderGroup, geometry, style, feature) {
      var fillStyle = style.getFill();
      var strokeStyle = style.getStroke();
      if (fillStyle || strokeStyle) {
          var polygonReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.POLYGON);
          polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
          polygonReplay.drawPolygon(geometry, feature);
      }
      var textStyle = style.getText();
      if (textStyle) {
          var textReplay = builderGroup.getBuilder(style.getZIndex(), ReplayType.TEXT);
          textReplay.setTextStyle(textStyle, builderGroup.addDeclutter(false));
          textReplay.drawText(geometry, feature);
      }
  }

  /**
   * @module ol/render
   */
  /**
   * @param {import("./PluggableMap.js").FrameState} frameState Frame state.
   * @param {?} declutterTree Declutter tree.
   * @returns {?} Declutter tree.
   */
  function renderDeclutterItems(frameState, declutterTree) {
      if (declutterTree) {
          declutterTree.clear();
      }
      var items = frameState.declutterItems;
      for (var z = items.length - 1; z >= 0; --z) {
          var item = items[z];
          var zIndexItems = item.items;
          for (var i = 0, ii = zIndexItems.length; i < ii; i += 3) {
              declutterTree = zIndexItems[i].renderDeclutter(zIndexItems[i + 1], zIndexItems[i + 2], item.opacity, declutterTree);
          }
      }
      items.length = 0;
      return declutterTree;
  }

  var __extends$b = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @abstract
   */
  var MapRenderer = /** @class */ (function (_super) {
      __extends$b(MapRenderer, _super);
      /**
       * @param {import("../PluggableMap.js").default} map Map.
       */
      function MapRenderer(map) {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {import("../PluggableMap.js").default}
           */
          _this.map_ = map;
          /**
           * @private
           */
          _this.declutterTree_ = null;
          return _this;
      }
      /**
       * @abstract
       * @param {import("../render/EventType.js").default} type Event type.
       * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
       */
      MapRenderer.prototype.dispatchRenderEvent = function (type, frameState) {
          abstract();
      };
      /**
       * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
       * @protected
       */
      MapRenderer.prototype.calculateMatrices2D = function (frameState) {
          var viewState = frameState.viewState;
          var coordinateToPixelTransform = frameState.coordinateToPixelTransform;
          var pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
          compose(coordinateToPixelTransform, frameState.size[0] / 2, frameState.size[1] / 2, 1 / viewState.resolution, -1 / viewState.resolution, -viewState.rotation, -viewState.center[0], -viewState.center[1]);
          makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);
      };
      /**
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {boolean} checkWrapped Check for wrapped geometries.
       * @param {function(this: S, import("../Feature.js").FeatureLike,
       *     import("../layer/Layer.js").default): T} callback Feature callback.
       * @param {S} thisArg Value to use as `this` when executing `callback`.
       * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
       *     function, only layers which are visible and for which this function
       *     returns `true` will be tested for features.  By default, all visible
       *     layers will be tested.
       * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
       * @return {T|undefined} Callback result.
       * @template S,T,U
       */
      MapRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
          var result;
          var viewState = frameState.viewState;
          /**
           * @param {boolean} managed Managed layer.
           * @param {import("../Feature.js").FeatureLike} feature Feature.
           * @param {import("../layer/Layer.js").default} layer Layer.
           * @return {?} Callback result.
           */
          function forEachFeatureAtCoordinate(managed, feature, layer) {
              return callback.call(thisArg, feature, managed ? layer : null);
          }
          var projection = viewState.projection;
          var translatedCoordinate = wrapX$1(coordinate.slice(), projection);
          var offsets = [[0, 0]];
          if (projection.canWrapX() && checkWrapped) {
              var projectionExtent = projection.getExtent();
              var worldWidth = getWidth(projectionExtent);
              offsets.push([-worldWidth, 0], [worldWidth, 0]);
          }
          var layerStates = frameState.layerStatesArray;
          var numLayers = layerStates.length;
          var declutteredFeatures;
          if (this.declutterTree_) {
              declutteredFeatures = this.declutterTree_.all().map(function (entry) {
                  return entry.value;
              });
          }
          var tmpCoord = [];
          for (var i = 0; i < offsets.length; i++) {
              for (var j = numLayers - 1; j >= 0; --j) {
                  var layerState = layerStates[j];
                  var layer = /** @type {import("../layer/Layer.js").default} */ (layerState.layer);
                  if (layer.hasRenderer() &&
                      inView(layerState, viewState) &&
                      layerFilter.call(thisArg2, layer)) {
                      var layerRenderer = layer.getRenderer();
                      var source = layer.getSource();
                      if (layerRenderer && source) {
                          var coordinates = source.getWrapX()
                              ? translatedCoordinate
                              : coordinate;
                          var callback_1 = forEachFeatureAtCoordinate.bind(null, layerState.managed);
                          tmpCoord[0] = coordinates[0] + offsets[i][0];
                          tmpCoord[1] = coordinates[1] + offsets[i][1];
                          result = layerRenderer.forEachFeatureAtCoordinate(tmpCoord, frameState, hitTolerance, callback_1, declutteredFeatures);
                      }
                      if (result) {
                          return result;
                      }
                  }
              }
          }
          return undefined;
      };
      /**
       * @abstract
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {function(import("../layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback Layer
       *     callback.
       * @param {function(import("../layer/Layer.js").default): boolean} layerFilter Layer filter
       *     function, only layers which are visible and for which this function
       *     returns `true` will be tested for features.  By default, all visible
       *     layers will be tested.
       * @return {T|undefined} Callback result.
       * @template T
       */
      MapRenderer.prototype.forEachLayerAtPixel = function (pixel, frameState, hitTolerance, callback, layerFilter) {
          return abstract();
      };
      /**
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {boolean} checkWrapped Check for wrapped geometries.
       * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
       *     function, only layers which are visible and for which this function
       *     returns `true` will be tested for features.  By default, all visible
       *     layers will be tested.
       * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
       * @return {boolean} Is there a feature at the given coordinate?
       * @template U
       */
      MapRenderer.prototype.hasFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
          var hasFeature = this.forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, TRUE, this, layerFilter, thisArg);
          return hasFeature !== undefined;
      };
      /**
       * @return {import("../PluggableMap.js").default} Map.
       */
      MapRenderer.prototype.getMap = function () {
          return this.map_;
      };
      /**
       * Render.
       * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
       */
      MapRenderer.prototype.renderFrame = function (frameState) {
          this.declutterTree_ = renderDeclutterItems(frameState, this.declutterTree_);
      };
      /**
       * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
       * @protected
       */
      MapRenderer.prototype.scheduleExpireIconCache = function (frameState) {
          if (shared.canExpireCache()) {
              frameState.postRenderFunctions.push(expireIconCache);
          }
      };
      return MapRenderer;
  }(Disposable));
  /**
   * @param {import("../PluggableMap.js").default} map Map.
   * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
   */
  function expireIconCache(map, frameState) {
      shared.expire();
  }

  /**
   * @module ol/render/Event
   */
  var __extends$c = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var RenderEvent = /** @class */ (function (_super) {
      __extends$c(RenderEvent, _super);
      /**
       * @param {import("./EventType.js").default} type Type.
       * @param {import("../transform.js").Transform=} opt_inversePixelTransform Transform for
       *     CSS pixels to rendered pixels.
       * @param {import("../PluggableMap.js").FrameState=} opt_frameState Frame state.
       * @param {?CanvasRenderingContext2D=} opt_context Context.
       */
      function RenderEvent(type, opt_inversePixelTransform, opt_frameState, opt_context) {
          var _this = _super.call(this, type) || this;
          /**
           * Transform from CSS pixels (relative to the top-left corner of the map viewport)
           * to rendered pixels on this event's `context`.
           * @type {import("../transform.js").Transform|undefined}
           * @api
           */
          _this.inversePixelTransform = opt_inversePixelTransform;
          /**
           * An object representing the current render frame state.
           * @type {import("../PluggableMap.js").FrameState|undefined}
           * @api
           */
          _this.frameState = opt_frameState;
          /**
           * Canvas context. Not available when the event is dispatched by the map. Only available
           * when a Canvas renderer is used, null otherwise.
           * @type {CanvasRenderingContext2D|null|undefined}
           * @api
           */
          _this.context = opt_context;
          return _this;
      }
      return RenderEvent;
  }(BaseEvent));

  var __extends$d = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Canvas map renderer.
   * @api
   */
  var CompositeMapRenderer = /** @class */ (function (_super) {
      __extends$d(CompositeMapRenderer, _super);
      /**
       * @param {import("../PluggableMap.js").default} map Map.
       */
      function CompositeMapRenderer(map) {
          var _this = _super.call(this, map) || this;
          /**
           * @type {import("../events.js").EventsKey}
           */
          _this.fontChangeListenerKey_ = listen(checkedFonts, ObjectEventType.PROPERTYCHANGE, map.redrawText.bind(map));
          /**
           * @private
           * @type {HTMLDivElement}
           */
          _this.element_ = document.createElement('div');
          var style = _this.element_.style;
          style.position = 'absolute';
          style.width = '100%';
          style.height = '100%';
          style.zIndex = '0';
          _this.element_.className = CLASS_UNSELECTABLE + ' ol-layers';
          var container = map.getViewport();
          container.insertBefore(_this.element_, container.firstChild || null);
          /**
           * @private
           * @type {Array<HTMLElement>}
           */
          _this.children_ = [];
          /**
           * @private
           * @type {boolean}
           */
          _this.renderedVisible_ = true;
          return _this;
      }
      /**
       * @param {import("../render/EventType.js").default} type Event type.
       * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
       */
      CompositeMapRenderer.prototype.dispatchRenderEvent = function (type, frameState) {
          var map = this.getMap();
          if (map.hasListener(type)) {
              var event_1 = new RenderEvent(type, undefined, frameState);
              map.dispatchEvent(event_1);
          }
      };
      CompositeMapRenderer.prototype.disposeInternal = function () {
          unlistenByKey(this.fontChangeListenerKey_);
          this.element_.parentNode.removeChild(this.element_);
          _super.prototype.disposeInternal.call(this);
      };
      /**
       * Render.
       * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
       */
      CompositeMapRenderer.prototype.renderFrame = function (frameState) {
          if (!frameState) {
              if (this.renderedVisible_) {
                  this.element_.style.display = 'none';
                  this.renderedVisible_ = false;
              }
              return;
          }
          this.calculateMatrices2D(frameState);
          this.dispatchRenderEvent(EventType$1.PRECOMPOSE, frameState);
          var layerStatesArray = frameState.layerStatesArray.sort(function (a, b) {
              return a.zIndex - b.zIndex;
          });
          var viewState = frameState.viewState;
          this.children_.length = 0;
          var previousElement = null;
          for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
              var layerState = layerStatesArray[i];
              frameState.layerIndex = i;
              if (!inView(layerState, viewState) ||
                  (layerState.sourceState != SourceState.READY &&
                      layerState.sourceState != SourceState.UNDEFINED)) {
                  continue;
              }
              var layer = layerState.layer;
              var element = layer.render(frameState, previousElement);
              if (!element) {
                  continue;
              }
              if (element !== previousElement) {
                  this.children_.push(element);
                  previousElement = element;
              }
          }
          _super.prototype.renderFrame.call(this, frameState);
          replaceChildren(this.element_, this.children_);
          this.dispatchRenderEvent(EventType$1.POSTCOMPOSE, frameState);
          if (!this.renderedVisible_) {
              this.element_.style.display = '';
              this.renderedVisible_ = true;
          }
          this.scheduleExpireIconCache(frameState);
      };
      /**
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {function(import("../layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback Layer
       *     callback.
       * @param {function(import("../layer/Layer.js").default): boolean} layerFilter Layer filter
       *     function, only layers which are visible and for which this function
       *     returns `true` will be tested for features.  By default, all visible
       *     layers will be tested.
       * @return {T|undefined} Callback result.
       * @template T
       */
      CompositeMapRenderer.prototype.forEachLayerAtPixel = function (pixel, frameState, hitTolerance, callback, layerFilter) {
          var viewState = frameState.viewState;
          var layerStates = frameState.layerStatesArray;
          var numLayers = layerStates.length;
          for (var i = numLayers - 1; i >= 0; --i) {
              var layerState = layerStates[i];
              var layer = layerState.layer;
              if (layer.hasRenderer() &&
                  inView(layerState, viewState) &&
                  layerFilter(layer)) {
                  var layerRenderer = layer.getRenderer();
                  var data = layerRenderer.getDataAtPixel(pixel, frameState, hitTolerance);
                  if (data) {
                      var result = callback(layer, data);
                      if (result) {
                          return result;
                      }
                  }
              }
          }
          return undefined;
      };
      return CompositeMapRenderer;
  }(MapRenderer));

  /**
   * @module ol/CollectionEventType
   */
  /**
   * @enum {string}
   */
  var CollectionEventType = {
      /**
       * Triggered when an item is added to the collection.
       * @event module:ol/Collection.CollectionEvent#add
       * @api
       */
      ADD: 'add',
      /**
       * Triggered when an item is removed from the collection.
       * @event module:ol/Collection.CollectionEvent#remove
       * @api
       */
      REMOVE: 'remove',
  };

  var __extends$e = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @enum {string}
   * @private
   */
  var Property = {
      LENGTH: 'length',
  };
  /**
   * @classdesc
   * Events emitted by {@link module:ol/Collection~Collection} instances are instances of this
   * type.
   */
  var CollectionEvent = /** @class */ (function (_super) {
      __extends$e(CollectionEvent, _super);
      /**
       * @param {import("./CollectionEventType.js").default} type Type.
       * @param {*=} opt_element Element.
       * @param {number=} opt_index The index of the added or removed element.
       */
      function CollectionEvent(type, opt_element, opt_index) {
          var _this = _super.call(this, type) || this;
          /**
           * The element that is added to or removed from the collection.
           * @type {*}
           * @api
           */
          _this.element = opt_element;
          /**
           * The index of the added or removed element.
           * @type {number}
           * @api
           */
          _this.index = opt_index;
          return _this;
      }
      return CollectionEvent;
  }(BaseEvent));
  /**
   * @typedef {Object} Options
   * @property {boolean} [unique=false] Disallow the same item from being added to
   * the collection twice.
   */
  /**
   * @classdesc
   * An expanded version of standard JS Array, adding convenience methods for
   * manipulation. Add and remove changes to the Collection trigger a Collection
   * event. Note that this does not cover changes to the objects _within_ the
   * Collection; they trigger events on the appropriate object, not on the
   * Collection as a whole.
   *
   * @fires CollectionEvent
   *
   * @template T
   * @api
   */
  var Collection = /** @class */ (function (_super) {
      __extends$e(Collection, _super);
      /**
       * @param {Array<T>=} opt_array Array.
       * @param {Options=} opt_options Collection options.
       */
      function Collection(opt_array, opt_options) {
          var _this = _super.call(this) || this;
          var options = opt_options || {};
          /**
           * @private
           * @type {boolean}
           */
          _this.unique_ = !!options.unique;
          /**
           * @private
           * @type {!Array<T>}
           */
          _this.array_ = opt_array ? opt_array : [];
          if (_this.unique_) {
              for (var i = 0, ii = _this.array_.length; i < ii; ++i) {
                  _this.assertUnique_(_this.array_[i], i);
              }
          }
          _this.updateLength_();
          return _this;
      }
      /**
       * Remove all elements from the collection.
       * @api
       */
      Collection.prototype.clear = function () {
          while (this.getLength() > 0) {
              this.pop();
          }
      };
      /**
       * Add elements to the collection.  This pushes each item in the provided array
       * to the end of the collection.
       * @param {!Array<T>} arr Array.
       * @return {Collection<T>} This collection.
       * @api
       */
      Collection.prototype.extend = function (arr) {
          for (var i = 0, ii = arr.length; i < ii; ++i) {
              this.push(arr[i]);
          }
          return this;
      };
      /**
       * Iterate over each element, calling the provided callback.
       * @param {function(T, number, Array<T>): *} f The function to call
       *     for every element. This function takes 3 arguments (the element, the
       *     index and the array). The return value is ignored.
       * @api
       */
      Collection.prototype.forEach = function (f) {
          var array = this.array_;
          for (var i = 0, ii = array.length; i < ii; ++i) {
              f(array[i], i, array);
          }
      };
      /**
       * Get a reference to the underlying Array object. Warning: if the array
       * is mutated, no events will be dispatched by the collection, and the
       * collection's "length" property won't be in sync with the actual length
       * of the array.
       * @return {!Array<T>} Array.
       * @api
       */
      Collection.prototype.getArray = function () {
          return this.array_;
      };
      /**
       * Get the element at the provided index.
       * @param {number} index Index.
       * @return {T} Element.
       * @api
       */
      Collection.prototype.item = function (index) {
          return this.array_[index];
      };
      /**
       * Get the length of this collection.
       * @return {number} The length of the array.
       * @observable
       * @api
       */
      Collection.prototype.getLength = function () {
          return this.get(Property.LENGTH);
      };
      /**
       * Insert an element at the provided index.
       * @param {number} index Index.
       * @param {T} elem Element.
       * @api
       */
      Collection.prototype.insertAt = function (index, elem) {
          if (this.unique_) {
              this.assertUnique_(elem);
          }
          this.array_.splice(index, 0, elem);
          this.updateLength_();
          this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem, index));
      };
      /**
       * Remove the last element of the collection and return it.
       * Return `undefined` if the collection is empty.
       * @return {T|undefined} Element.
       * @api
       */
      Collection.prototype.pop = function () {
          return this.removeAt(this.getLength() - 1);
      };
      /**
       * Insert the provided element at the end of the collection.
       * @param {T} elem Element.
       * @return {number} New length of the collection.
       * @api
       */
      Collection.prototype.push = function (elem) {
          if (this.unique_) {
              this.assertUnique_(elem);
          }
          var n = this.getLength();
          this.insertAt(n, elem);
          return this.getLength();
      };
      /**
       * Remove the first occurrence of an element from the collection.
       * @param {T} elem Element.
       * @return {T|undefined} The removed element or undefined if none found.
       * @api
       */
      Collection.prototype.remove = function (elem) {
          var arr = this.array_;
          for (var i = 0, ii = arr.length; i < ii; ++i) {
              if (arr[i] === elem) {
                  return this.removeAt(i);
              }
          }
          return undefined;
      };
      /**
       * Remove the element at the provided index and return it.
       * Return `undefined` if the collection does not contain this index.
       * @param {number} index Index.
       * @return {T|undefined} Value.
       * @api
       */
      Collection.prototype.removeAt = function (index) {
          var prev = this.array_[index];
          this.array_.splice(index, 1);
          this.updateLength_();
          this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev, index));
          return prev;
      };
      /**
       * Set the element at the provided index.
       * @param {number} index Index.
       * @param {T} elem Element.
       * @api
       */
      Collection.prototype.setAt = function (index, elem) {
          var n = this.getLength();
          if (index < n) {
              if (this.unique_) {
                  this.assertUnique_(elem, index);
              }
              var prev = this.array_[index];
              this.array_[index] = elem;
              this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE, prev, index));
              this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD, elem, index));
          }
          else {
              for (var j = n; j < index; ++j) {
                  this.insertAt(j, undefined);
              }
              this.insertAt(index, elem);
          }
      };
      /**
       * @private
       */
      Collection.prototype.updateLength_ = function () {
          this.set(Property.LENGTH, this.array_.length);
      };
      /**
       * @private
       * @param {T} elem Element.
       * @param {number=} opt_except Optional index to ignore.
       */
      Collection.prototype.assertUnique_ = function (elem, opt_except) {
          for (var i = 0, ii = this.array_.length; i < ii; ++i) {
              if (this.array_[i] === elem && i !== opt_except) {
                  throw new AssertionError(58);
              }
          }
      };
      return Collection;
  }(BaseObject));

  var __extends$f = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {number} [opacity=1] Opacity (0, 1).
   * @property {boolean} [visible=true] Visibility.
   * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
   * rendered outside of this extent.
   * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
   * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
   * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
   * method was used.
   * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
   * visible.
   * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
   * be visible.
   * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
   * visible.
   * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
   * be visible.
   * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
   * visible.
   * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
   * be visible.
   * @property {Array<import("./Base.js").default>|import("../Collection.js").default<import("./Base.js").default>} [layers] Child layers.
   */
  /**
   * @enum {string}
   * @private
   */
  var Property$1 = {
      LAYERS: 'layers',
  };
  /**
   * @classdesc
   * A {@link module:ol/Collection~Collection} of layers that are handled together.
   *
   * A generic `change` event is triggered when the group/Collection changes.
   *
   * @api
   */
  var LayerGroup = /** @class */ (function (_super) {
      __extends$f(LayerGroup, _super);
      /**
       * @param {Options=} opt_options Layer options.
       */
      function LayerGroup(opt_options) {
          var _this = this;
          var options = opt_options || {};
          var baseOptions = /** @type {Options} */ (assign({}, options));
          delete baseOptions.layers;
          var layers = options.layers;
          _this = _super.call(this, baseOptions) || this;
          /**
           * @private
           * @type {Array<import("../events.js").EventsKey>}
           */
          _this.layersListenerKeys_ = [];
          /**
           * @private
           * @type {Object<string, Array<import("../events.js").EventsKey>>}
           */
          _this.listenerKeys_ = {};
          _this.addEventListener(getChangeEventType(Property$1.LAYERS), _this.handleLayersChanged_);
          if (layers) {
              if (Array.isArray(layers)) {
                  layers = new Collection(layers.slice(), { unique: true });
              }
              else {
                  assert(typeof ( /** @type {?} */(layers).getArray) === 'function', 43); // Expected `layers` to be an array or a `Collection`
              }
          }
          else {
              layers = new Collection(undefined, { unique: true });
          }
          _this.setLayers(layers);
          return _this;
      }
      /**
       * @private
       */
      LayerGroup.prototype.handleLayerChange_ = function () {
          this.changed();
      };
      /**
       * @private
       */
      LayerGroup.prototype.handleLayersChanged_ = function () {
          this.layersListenerKeys_.forEach(unlistenByKey);
          this.layersListenerKeys_.length = 0;
          var layers = this.getLayers();
          this.layersListenerKeys_.push(listen(layers, CollectionEventType.ADD, this.handleLayersAdd_, this), listen(layers, CollectionEventType.REMOVE, this.handleLayersRemove_, this));
          for (var id in this.listenerKeys_) {
              this.listenerKeys_[id].forEach(unlistenByKey);
          }
          clear(this.listenerKeys_);
          var layersArray = layers.getArray();
          for (var i = 0, ii = layersArray.length; i < ii; i++) {
              var layer = layersArray[i];
              this.listenerKeys_[getUid(layer)] = [
                  listen(layer, ObjectEventType.PROPERTYCHANGE, this.handleLayerChange_, this),
                  listen(layer, EventType.CHANGE, this.handleLayerChange_, this),
              ];
          }
          this.changed();
      };
      /**
       * @param {import("../Collection.js").CollectionEvent} collectionEvent CollectionEvent.
       * @private
       */
      LayerGroup.prototype.handleLayersAdd_ = function (collectionEvent) {
          var layer = /** @type {import("./Base.js").default} */ (collectionEvent.element);
          this.listenerKeys_[getUid(layer)] = [
              listen(layer, ObjectEventType.PROPERTYCHANGE, this.handleLayerChange_, this),
              listen(layer, EventType.CHANGE, this.handleLayerChange_, this),
          ];
          this.changed();
      };
      /**
       * @param {import("../Collection.js").CollectionEvent} collectionEvent CollectionEvent.
       * @private
       */
      LayerGroup.prototype.handleLayersRemove_ = function (collectionEvent) {
          var layer = /** @type {import("./Base.js").default} */ (collectionEvent.element);
          var key = getUid(layer);
          this.listenerKeys_[key].forEach(unlistenByKey);
          delete this.listenerKeys_[key];
          this.changed();
      };
      /**
       * Returns the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}
       * in this group.
       * @return {!import("../Collection.js").default<import("./Base.js").default>} Collection of
       *   {@link module:ol/layer/Base layers} that are part of this group.
       * @observable
       * @api
       */
      LayerGroup.prototype.getLayers = function () {
          return /** @type {!import("../Collection.js").default<import("./Base.js").default>} */ (this.get(Property$1.LAYERS));
      };
      /**
       * Set the {@link module:ol/Collection collection} of {@link module:ol/layer/Layer~Layer layers}
       * in this group.
       * @param {!import("../Collection.js").default<import("./Base.js").default>} layers Collection of
       *   {@link module:ol/layer/Base layers} that are part of this group.
       * @observable
       * @api
       */
      LayerGroup.prototype.setLayers = function (layers) {
          this.set(Property$1.LAYERS, layers);
      };
      /**
       * @param {Array<import("./Layer.js").default>=} opt_array Array of layers (to be modified in place).
       * @return {Array<import("./Layer.js").default>} Array of layers.
       */
      LayerGroup.prototype.getLayersArray = function (opt_array) {
          var array = opt_array !== undefined ? opt_array : [];
          this.getLayers().forEach(function (layer) {
              layer.getLayersArray(array);
          });
          return array;
      };
      /**
       * @param {Array<import("./Layer.js").State>=} opt_states Optional list of layer states (to be modified in place).
       * @return {Array<import("./Layer.js").State>} List of layer states.
       */
      LayerGroup.prototype.getLayerStatesArray = function (opt_states) {
          var states = opt_states !== undefined ? opt_states : [];
          var pos = states.length;
          this.getLayers().forEach(function (layer) {
              layer.getLayerStatesArray(states);
          });
          var ownLayerState = this.getLayerState();
          for (var i = pos, ii = states.length; i < ii; i++) {
              var layerState = states[i];
              layerState.opacity *= ownLayerState.opacity;
              layerState.visible = layerState.visible && ownLayerState.visible;
              layerState.maxResolution = Math.min(layerState.maxResolution, ownLayerState.maxResolution);
              layerState.minResolution = Math.max(layerState.minResolution, ownLayerState.minResolution);
              layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
              layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);
              if (ownLayerState.extent !== undefined) {
                  if (layerState.extent !== undefined) {
                      layerState.extent = getIntersection(layerState.extent, ownLayerState.extent);
                  }
                  else {
                      layerState.extent = ownLayerState.extent;
                  }
              }
          }
          return states;
      };
      /**
       * @return {import("../source/State.js").default} Source state.
       */
      LayerGroup.prototype.getSourceState = function () {
          return SourceState.READY;
      };
      return LayerGroup;
  }(BaseLayer));

  var __extends$g = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Events emitted as map events are instances of this type.
   * See {@link module:ol/PluggableMap~PluggableMap} for which events trigger a map event.
   */
  var MapEvent = /** @class */ (function (_super) {
      __extends$g(MapEvent, _super);
      /**
       * @param {string} type Event type.
       * @param {import("./PluggableMap.js").default} map Map.
       * @param {?import("./PluggableMap.js").FrameState=} opt_frameState Frame state.
       */
      function MapEvent(type, map, opt_frameState) {
          var _this = _super.call(this, type) || this;
          /**
           * The map where the event occurred.
           * @type {import("./PluggableMap.js").default}
           * @api
           */
          _this.map = map;
          /**
           * The frame state at the time of the event.
           * @type {?import("./PluggableMap.js").FrameState}
           * @api
           */
          _this.frameState = opt_frameState !== undefined ? opt_frameState : null;
          return _this;
      }
      return MapEvent;
  }(BaseEvent));

  var __extends$h = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Events emitted as map browser events are instances of this type.
   * See {@link module:ol/PluggableMap~PluggableMap} for which events trigger a map browser event.
   * @template {UIEvent} EVENT
   */
  var MapBrowserEvent = /** @class */ (function (_super) {
      __extends$h(MapBrowserEvent, _super);
      /**
       * @param {string} type Event type.
       * @param {import("./PluggableMap.js").default} map Map.
       * @param {EVENT} originalEvent Original event.
       * @param {boolean=} opt_dragging Is the map currently being dragged?
       * @param {?import("./PluggableMap.js").FrameState=} opt_frameState Frame state.
       */
      function MapBrowserEvent(type, map, originalEvent, opt_dragging, opt_frameState) {
          var _this = _super.call(this, type, map, opt_frameState) || this;
          /**
           * The original browser event.
           * @const
           * @type {EVENT}
           * @api
           */
          _this.originalEvent = originalEvent;
          /**
           * The map pixel relative to the viewport corresponding to the original browser event.
           * @type {?import("./pixel.js").Pixel}
           */
          _this.pixel_ = null;
          /**
           * The coordinate in the user projection corresponding to the original browser event.
           * @type {?import("./coordinate.js").Coordinate}
           */
          _this.coordinate_ = null;
          /**
           * Indicates if the map is currently being dragged. Only set for
           * `POINTERDRAG` and `POINTERMOVE` events. Default is `false`.
           *
           * @type {boolean}
           * @api
           */
          _this.dragging = opt_dragging !== undefined ? opt_dragging : false;
          return _this;
      }
      Object.defineProperty(MapBrowserEvent.prototype, "pixel", {
          /**
           * The map pixel relative to the viewport corresponding to the original event.
           * @type {import("./pixel.js").Pixel}
           * @api
           */
          get: function () {
              if (!this.pixel_) {
                  this.pixel_ = this.map.getEventPixel(this.originalEvent);
              }
              return this.pixel_;
          },
          set: function (pixel) {
              this.pixel_ = pixel;
          },
          enumerable: false,
          configurable: true
      });
      Object.defineProperty(MapBrowserEvent.prototype, "coordinate", {
          /**
           * The coordinate corresponding to the original browser event.  This will be in the user
           * projection if one is set.  Otherwise it will be in the view projection.
           * @type {import("./coordinate.js").Coordinate}
           * @api
           */
          get: function () {
              if (!this.coordinate_) {
                  this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
              }
              return this.coordinate_;
          },
          set: function (coordinate) {
              this.coordinate_ = coordinate;
          },
          enumerable: false,
          configurable: true
      });
      /**
       * Prevents the default browser action.
       * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
       * @api
       */
      MapBrowserEvent.prototype.preventDefault = function () {
          _super.prototype.preventDefault.call(this);
          this.originalEvent.preventDefault();
      };
      /**
       * Prevents further propagation of the current event.
       * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
       * @api
       */
      MapBrowserEvent.prototype.stopPropagation = function () {
          _super.prototype.stopPropagation.call(this);
          this.originalEvent.stopPropagation();
      };
      return MapBrowserEvent;
  }(MapEvent));

  /**
   * @module ol/MapBrowserEventType
   */
  /**
   * Constants for event names.
   * @enum {string}
   */
  var MapBrowserEventType = {
      /**
       * A true single click with no dragging and no double click. Note that this
       * event is delayed by 250 ms to ensure that it is not a double click.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
       * @api
       */
      SINGLECLICK: 'singleclick',
      /**
       * A click with no dragging. A double click will fire two of this.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
       * @api
       */
      CLICK: EventType.CLICK,
      /**
       * A true double click, with no dragging.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
       * @api
       */
      DBLCLICK: EventType.DBLCLICK,
      /**
       * Triggered when a pointer is dragged.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
       * @api
       */
      POINTERDRAG: 'pointerdrag',
      /**
       * Triggered when a pointer is moved. Note that on touch devices this is
       * triggered when the map is panned, so is not the same as mousemove.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
       * @api
       */
      POINTERMOVE: 'pointermove',
      POINTERDOWN: 'pointerdown',
      POINTERUP: 'pointerup',
      POINTEROVER: 'pointerover',
      POINTEROUT: 'pointerout',
      POINTERENTER: 'pointerenter',
      POINTERLEAVE: 'pointerleave',
      POINTERCANCEL: 'pointercancel',
  };

  /**
   * @module ol/pointer/EventType
   */
  /**
   * Constants for event names.
   * @enum {string}
   */
  var PointerEventType = {
      POINTERMOVE: 'pointermove',
      POINTERDOWN: 'pointerdown',
      POINTERUP: 'pointerup',
      POINTEROVER: 'pointerover',
      POINTEROUT: 'pointerout',
      POINTERENTER: 'pointerenter',
      POINTERLEAVE: 'pointerleave',
      POINTERCANCEL: 'pointercancel',
  };

  /**
   * @module ol/MapBrowserEventHandler
   */
  var __extends$i = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var MapBrowserEventHandler = /** @class */ (function (_super) {
      __extends$i(MapBrowserEventHandler, _super);
      /**
       * @param {import("./PluggableMap.js").default} map The map with the viewport to listen to events on.
       * @param {number=} moveTolerance The minimal distance the pointer must travel to trigger a move.
       */
      function MapBrowserEventHandler(map, moveTolerance) {
          var _this = _super.call(this, map) || this;
          /**
           * This is the element that we will listen to the real events on.
           * @type {import("./PluggableMap.js").default}
           * @private
           */
          _this.map_ = map;
          /**
           * @type {any}
           * @private
           */
          _this.clickTimeoutId_;
          /**
           * @type {boolean}
           * @private
           */
          _this.dragging_ = false;
          /**
           * @type {!Array<import("./events.js").EventsKey>}
           * @private
           */
          _this.dragListenerKeys_ = [];
          /**
           * @type {number}
           * @private
           */
          _this.moveTolerance_ = moveTolerance
              ? moveTolerance * DEVICE_PIXEL_RATIO
              : DEVICE_PIXEL_RATIO;
          /**
           * The most recent "down" type event (or null if none have occurred).
           * Set on pointerdown.
           * @type {PointerEvent}
           * @private
           */
          _this.down_ = null;
          var element = _this.map_.getViewport();
          /**
           * @type {number}
           * @private
           */
          _this.activePointers_ = 0;
          /**
           * @type {!Object<number, boolean>}
           * @private
           */
          _this.trackedTouches_ = {};
          _this.element_ = element;
          /**
           * @type {?import("./events.js").EventsKey}
           * @private
           */
          _this.pointerdownListenerKey_ = listen(element, PointerEventType.POINTERDOWN, _this.handlePointerDown_, _this);
          /**
           * @type {PointerEvent}
           * @private
           */
          _this.originalPointerMoveEvent_;
          /**
           * @type {?import("./events.js").EventsKey}
           * @private
           */
          _this.relayedListenerKey_ = listen(element, PointerEventType.POINTERMOVE, _this.relayEvent_, _this);
          /**
           * @private
           */
          _this.boundHandleTouchMove_ = _this.handleTouchMove_.bind(_this);
          _this.element_.addEventListener(EventType.TOUCHMOVE, _this.boundHandleTouchMove_, PASSIVE_EVENT_LISTENERS ? { passive: false } : false);
          return _this;
      }
      /**
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */
      MapBrowserEventHandler.prototype.emulateClick_ = function (pointerEvent) {
          var newEvent = new MapBrowserEvent(MapBrowserEventType.CLICK, this.map_, pointerEvent);
          this.dispatchEvent(newEvent);
          if (this.clickTimeoutId_ !== undefined) {
              // double-click
              clearTimeout(this.clickTimeoutId_);
              this.clickTimeoutId_ = undefined;
              newEvent = new MapBrowserEvent(MapBrowserEventType.DBLCLICK, this.map_, pointerEvent);
              this.dispatchEvent(newEvent);
          }
          else {
              // click
              this.clickTimeoutId_ = setTimeout(function () {
                  this.clickTimeoutId_ = undefined;
                  var newEvent = new MapBrowserEvent(MapBrowserEventType.SINGLECLICK, this.map_, pointerEvent);
                  this.dispatchEvent(newEvent);
              }.bind(this), 250);
          }
      };
      /**
       * Keeps track on how many pointers are currently active.
       *
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */
      MapBrowserEventHandler.prototype.updateActivePointers_ = function (pointerEvent) {
          var event = pointerEvent;
          if (event.type == MapBrowserEventType.POINTERUP ||
              event.type == MapBrowserEventType.POINTERCANCEL) {
              delete this.trackedTouches_[event.pointerId];
          }
          else if (event.type == MapBrowserEventType.POINTERDOWN) {
              this.trackedTouches_[event.pointerId] = true;
          }
          this.activePointers_ = Object.keys(this.trackedTouches_).length;
      };
      /**
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */
      MapBrowserEventHandler.prototype.handlePointerUp_ = function (pointerEvent) {
          this.updateActivePointers_(pointerEvent);
          var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERUP, this.map_, pointerEvent);
          this.dispatchEvent(newEvent);
          // We emulate click events on left mouse button click, touch contact, and pen
          // contact. isMouseActionButton returns true in these cases (evt.button is set
          // to 0).
          // See http://www.w3.org/TR/pointerevents/#button-states
          // We only fire click, singleclick, and doubleclick if nobody has called
          // event.stopPropagation() or event.preventDefault().
          if (!newEvent.propagationStopped &&
              !this.dragging_ &&
              this.isMouseActionButton_(pointerEvent)) {
              this.emulateClick_(this.down_);
          }
          if (this.activePointers_ === 0) {
              this.dragListenerKeys_.forEach(unlistenByKey);
              this.dragListenerKeys_.length = 0;
              this.dragging_ = false;
              this.down_ = null;
          }
      };
      /**
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @return {boolean} If the left mouse button was pressed.
       * @private
       */
      MapBrowserEventHandler.prototype.isMouseActionButton_ = function (pointerEvent) {
          return pointerEvent.button === 0;
      };
      /**
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */
      MapBrowserEventHandler.prototype.handlePointerDown_ = function (pointerEvent) {
          this.updateActivePointers_(pointerEvent);
          var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDOWN, this.map_, pointerEvent);
          this.dispatchEvent(newEvent);
          this.down_ = pointerEvent;
          if (this.dragListenerKeys_.length === 0) {
              this.dragListenerKeys_.push(listen(document, MapBrowserEventType.POINTERMOVE, this.handlePointerMove_, this), listen(document, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this), 
              /* Note that the listener for `pointercancel is set up on
               * `pointerEventHandler_` and not `documentPointerEventHandler_` like
               * the `pointerup` and `pointermove` listeners.
               *
               * The reason for this is the following: `TouchSource.vacuumTouches_()`
               * issues `pointercancel` events, when there was no `touchend` for a
               * `touchstart`. Now, let's say a first `touchstart` is registered on
               * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
               * But `documentPointerEventHandler_` doesn't know about the first
               * `touchstart`. If there is no `touchend` for the `touchstart`, we can
               * only receive a `touchcancel` from `pointerEventHandler_`, because it is
               * only registered there.
               */
              listen(this.element_, MapBrowserEventType.POINTERCANCEL, this.handlePointerUp_, this));
              if (this.element_.getRootNode &&
                  this.element_.getRootNode() !== document) {
                  this.dragListenerKeys_.push(listen(this.element_.getRootNode(), MapBrowserEventType.POINTERUP, this.handlePointerUp_, this));
              }
          }
      };
      /**
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */
      MapBrowserEventHandler.prototype.handlePointerMove_ = function (pointerEvent) {
          // Between pointerdown and pointerup, pointermove events are triggered.
          // To avoid a 'false' touchmove event to be dispatched, we test if the pointer
          // moved a significant distance.
          if (this.isMoving_(pointerEvent)) {
              this.dragging_ = true;
              var newEvent = new MapBrowserEvent(MapBrowserEventType.POINTERDRAG, this.map_, pointerEvent, this.dragging_);
              this.dispatchEvent(newEvent);
          }
      };
      /**
       * Wrap and relay a pointer event.  Note that this requires that the type
       * string for the MapBrowserEvent matches the PointerEvent type.
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @private
       */
      MapBrowserEventHandler.prototype.relayEvent_ = function (pointerEvent) {
          this.originalPointerMoveEvent_ = pointerEvent;
          var dragging = !!(this.down_ && this.isMoving_(pointerEvent));
          this.dispatchEvent(new MapBrowserEvent(pointerEvent.type, this.map_, pointerEvent, dragging));
      };
      /**
       * Flexible handling of a `touch-action: none` css equivalent: because calling
       * `preventDefault()` on a `pointermove` event does not stop native page scrolling
       * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
       * when an interaction (currently `DragPan` handles the event.
       * @param {TouchEvent} event Event.
       * @private
       */
      MapBrowserEventHandler.prototype.handleTouchMove_ = function (event) {
          // Due to https://github.com/mpizenberg/elm-pep/issues/2, `this.originalPointerMoveEvent_`
          // may not be initialized yet when we get here on a platform without native pointer events.
          if (!this.originalPointerMoveEvent_ ||
              this.originalPointerMoveEvent_.defaultPrevented) {
              event.preventDefault();
          }
      };
      /**
       * @param {PointerEvent} pointerEvent Pointer
       * event.
       * @return {boolean} Is moving.
       * @private
       */
      MapBrowserEventHandler.prototype.isMoving_ = function (pointerEvent) {
          return (this.dragging_ ||
              Math.abs(pointerEvent.clientX - this.down_.clientX) >
                  this.moveTolerance_ ||
              Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_);
      };
      /**
       * Clean up.
       */
      MapBrowserEventHandler.prototype.disposeInternal = function () {
          if (this.relayedListenerKey_) {
              unlistenByKey(this.relayedListenerKey_);
              this.relayedListenerKey_ = null;
          }
          this.element_.removeEventListener(EventType.TOUCHMOVE, this.boundHandleTouchMove_);
          if (this.pointerdownListenerKey_) {
              unlistenByKey(this.pointerdownListenerKey_);
              this.pointerdownListenerKey_ = null;
          }
          this.dragListenerKeys_.forEach(unlistenByKey);
          this.dragListenerKeys_.length = 0;
          this.element_ = null;
          _super.prototype.disposeInternal.call(this);
      };
      return MapBrowserEventHandler;
  }(Target));

  /**
   * @module ol/MapEventType
   */
  /**
   * @enum {string}
   */
  var MapEventType = {
      /**
       * Triggered after a map frame is rendered.
       * @event module:ol/MapEvent~MapEvent#postrender
       * @api
       */
      POSTRENDER: 'postrender',
      /**
       * Triggered when the map starts moving.
       * @event module:ol/MapEvent~MapEvent#movestart
       * @api
       */
      MOVESTART: 'movestart',
      /**
       * Triggered after the map is moved.
       * @event module:ol/MapEvent~MapEvent#moveend
       * @api
       */
      MOVEEND: 'moveend',
  };

  /**
   * @module ol/MapProperty
   */
  /**
   * @enum {string}
   */
  var MapProperty = {
      LAYERGROUP: 'layergroup',
      SIZE: 'size',
      TARGET: 'target',
      VIEW: 'view',
  };

  /**
   * @module ol/structs/PriorityQueue
   */
  /**
   * @type {number}
   */
  var DROP = Infinity;
  /**
   * @classdesc
   * Priority queue.
   *
   * The implementation is inspired from the Closure Library's Heap class and
   * Python's heapq module.
   *
   * See http://closure-library.googlecode.com/svn/docs/closure_goog_structs_heap.js.source.html
   * and http://hg.python.org/cpython/file/2.7/Lib/heapq.py.
   *
   * @template T
   */
  var PriorityQueue = /** @class */ (function () {
      /**
       * @param {function(T): number} priorityFunction Priority function.
       * @param {function(T): string} keyFunction Key function.
       */
      function PriorityQueue(priorityFunction, keyFunction) {
          /**
           * @type {function(T): number}
           * @private
           */
          this.priorityFunction_ = priorityFunction;
          /**
           * @type {function(T): string}
           * @private
           */
          this.keyFunction_ = keyFunction;
          /**
           * @type {Array<T>}
           * @private
           */
          this.elements_ = [];
          /**
           * @type {Array<number>}
           * @private
           */
          this.priorities_ = [];
          /**
           * @type {!Object<string, boolean>}
           * @private
           */
          this.queuedElements_ = {};
      }
      /**
       * FIXME empty description for jsdoc
       */
      PriorityQueue.prototype.clear = function () {
          this.elements_.length = 0;
          this.priorities_.length = 0;
          clear(this.queuedElements_);
      };
      /**
       * Remove and return the highest-priority element. O(log N).
       * @return {T} Element.
       */
      PriorityQueue.prototype.dequeue = function () {
          var elements = this.elements_;
          var priorities = this.priorities_;
          var element = elements[0];
          if (elements.length == 1) {
              elements.length = 0;
              priorities.length = 0;
          }
          else {
              elements[0] = elements.pop();
              priorities[0] = priorities.pop();
              this.siftUp_(0);
          }
          var elementKey = this.keyFunction_(element);
          delete this.queuedElements_[elementKey];
          return element;
      };
      /**
       * Enqueue an element. O(log N).
       * @param {T} element Element.
       * @return {boolean} The element was added to the queue.
       */
      PriorityQueue.prototype.enqueue = function (element) {
          assert(!(this.keyFunction_(element) in this.queuedElements_), 31); // Tried to enqueue an `element` that was already added to the queue
          var priority = this.priorityFunction_(element);
          if (priority != DROP) {
              this.elements_.push(element);
              this.priorities_.push(priority);
              this.queuedElements_[this.keyFunction_(element)] = true;
              this.siftDown_(0, this.elements_.length - 1);
              return true;
          }
          return false;
      };
      /**
       * @return {number} Count.
       */
      PriorityQueue.prototype.getCount = function () {
          return this.elements_.length;
      };
      /**
       * Gets the index of the left child of the node at the given index.
       * @param {number} index The index of the node to get the left child for.
       * @return {number} The index of the left child.
       * @private
       */
      PriorityQueue.prototype.getLeftChildIndex_ = function (index) {
          return index * 2 + 1;
      };
      /**
       * Gets the index of the right child of the node at the given index.
       * @param {number} index The index of the node to get the right child for.
       * @return {number} The index of the right child.
       * @private
       */
      PriorityQueue.prototype.getRightChildIndex_ = function (index) {
          return index * 2 + 2;
      };
      /**
       * Gets the index of the parent of the node at the given index.
       * @param {number} index The index of the node to get the parent for.
       * @return {number} The index of the parent.
       * @private
       */
      PriorityQueue.prototype.getParentIndex_ = function (index) {
          return (index - 1) >> 1;
      };
      /**
       * Make this a heap. O(N).
       * @private
       */
      PriorityQueue.prototype.heapify_ = function () {
          var i;
          for (i = (this.elements_.length >> 1) - 1; i >= 0; i--) {
              this.siftUp_(i);
          }
      };
      /**
       * @return {boolean} Is empty.
       */
      PriorityQueue.prototype.isEmpty = function () {
          return this.elements_.length === 0;
      };
      /**
       * @param {string} key Key.
       * @return {boolean} Is key queued.
       */
      PriorityQueue.prototype.isKeyQueued = function (key) {
          return key in this.queuedElements_;
      };
      /**
       * @param {T} element Element.
       * @return {boolean} Is queued.
       */
      PriorityQueue.prototype.isQueued = function (element) {
          return this.isKeyQueued(this.keyFunction_(element));
      };
      /**
       * @param {number} index The index of the node to move down.
       * @private
       */
      PriorityQueue.prototype.siftUp_ = function (index) {
          var elements = this.elements_;
          var priorities = this.priorities_;
          var count = elements.length;
          var element = elements[index];
          var priority = priorities[index];
          var startIndex = index;
          while (index < count >> 1) {
              var lIndex = this.getLeftChildIndex_(index);
              var rIndex = this.getRightChildIndex_(index);
              var smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex]
                  ? rIndex
                  : lIndex;
              elements[index] = elements[smallerChildIndex];
              priorities[index] = priorities[smallerChildIndex];
              index = smallerChildIndex;
          }
          elements[index] = element;
          priorities[index] = priority;
          this.siftDown_(startIndex, index);
      };
      /**
       * @param {number} startIndex The index of the root.
       * @param {number} index The index of the node to move up.
       * @private
       */
      PriorityQueue.prototype.siftDown_ = function (startIndex, index) {
          var elements = this.elements_;
          var priorities = this.priorities_;
          var element = elements[index];
          var priority = priorities[index];
          while (index > startIndex) {
              var parentIndex = this.getParentIndex_(index);
              if (priorities[parentIndex] > priority) {
                  elements[index] = elements[parentIndex];
                  priorities[index] = priorities[parentIndex];
                  index = parentIndex;
              }
              else {
                  break;
              }
          }
          elements[index] = element;
          priorities[index] = priority;
      };
      /**
       * FIXME empty description for jsdoc
       */
      PriorityQueue.prototype.reprioritize = function () {
          var priorityFunction = this.priorityFunction_;
          var elements = this.elements_;
          var priorities = this.priorities_;
          var index = 0;
          var n = elements.length;
          var element, i, priority;
          for (i = 0; i < n; ++i) {
              element = elements[i];
              priority = priorityFunction(element);
              if (priority == DROP) {
                  delete this.queuedElements_[this.keyFunction_(element)];
              }
              else {
                  priorities[index] = priority;
                  elements[index++] = element;
              }
          }
          elements.length = index;
          priorities.length = index;
          this.heapify_();
      };
      return PriorityQueue;
  }());

  /**
   * @module ol/TileState
   */
  /**
   * @enum {number}
   */
  var TileState = {
      IDLE: 0,
      LOADING: 1,
      LOADED: 2,
      /**
       * Indicates that tile loading failed
       * @type {number}
       */
      ERROR: 3,
      EMPTY: 4,
  };

  var __extends$j = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {function(import("./Tile.js").default, string, import("./coordinate.js").Coordinate, number): number} PriorityFunction
   */
  var TileQueue = /** @class */ (function (_super) {
      __extends$j(TileQueue, _super);
      /**
       * @param {PriorityFunction} tilePriorityFunction Tile priority function.
       * @param {function(): ?} tileChangeCallback Function called on each tile change event.
       */
      function TileQueue(tilePriorityFunction, tileChangeCallback) {
          var _this = _super.call(this, 
          /**
           * @param {Array} element Element.
           * @return {number} Priority.
           */
          function (element) {
              return tilePriorityFunction.apply(null, element);
          }, 
          /**
           * @param {Array} element Element.
           * @return {string} Key.
           */
          function (element) {
              return /** @type {import("./Tile.js").default} */ (element[0]).getKey();
          }) || this;
          /** @private */
          _this.boundHandleTileChange_ = _this.handleTileChange.bind(_this);
          /**
           * @private
           * @type {function(): ?}
           */
          _this.tileChangeCallback_ = tileChangeCallback;
          /**
           * @private
           * @type {number}
           */
          _this.tilesLoading_ = 0;
          /**
           * @private
           * @type {!Object<string,boolean>}
           */
          _this.tilesLoadingKeys_ = {};
          return _this;
      }
      /**
       * @param {Array} element Element.
       * @return {boolean} The element was added to the queue.
       */
      TileQueue.prototype.enqueue = function (element) {
          var added = _super.prototype.enqueue.call(this, element);
          if (added) {
              var tile = element[0];
              tile.addEventListener(EventType.CHANGE, this.boundHandleTileChange_);
          }
          return added;
      };
      /**
       * @return {number} Number of tiles loading.
       */
      TileQueue.prototype.getTilesLoading = function () {
          return this.tilesLoading_;
      };
      /**
       * @param {import("./events/Event.js").default} event Event.
       * @protected
       */
      TileQueue.prototype.handleTileChange = function (event) {
          var tile = /** @type {import("./Tile.js").default} */ (event.target);
          var state = tile.getState();
          if ((tile.hifi && state === TileState.LOADED) ||
              state === TileState.ERROR ||
              state === TileState.EMPTY) {
              tile.removeEventListener(EventType.CHANGE, this.boundHandleTileChange_);
              var tileKey = tile.getKey();
              if (tileKey in this.tilesLoadingKeys_) {
                  delete this.tilesLoadingKeys_[tileKey];
                  --this.tilesLoading_;
              }
              this.tileChangeCallback_();
          }
      };
      /**
       * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
       * @param {number} maxNewLoads Maximum number of new tiles to load.
       */
      TileQueue.prototype.loadMoreTiles = function (maxTotalLoading, maxNewLoads) {
          var newLoads = 0;
          var state, tile, tileKey;
          while (this.tilesLoading_ < maxTotalLoading &&
              newLoads < maxNewLoads &&
              this.getCount() > 0) {
              tile = /** @type {import("./Tile.js").default} */ (this.dequeue()[0]);
              tileKey = tile.getKey();
              state = tile.getState();
              if (state === TileState.IDLE && !(tileKey in this.tilesLoadingKeys_)) {
                  this.tilesLoadingKeys_[tileKey] = true;
                  ++this.tilesLoading_;
                  ++newLoads;
                  tile.load();
              }
          }
      };
      return TileQueue;
  }(PriorityQueue));
  /**
   * @param {import('./PluggableMap.js').FrameState} frameState Frame state.
   * @param {import("./Tile.js").default} tile Tile.
   * @param {string} tileSourceKey Tile source key.
   * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
   * @param {number} tileResolution Tile resolution.
   * @return {number} Tile priority.
   */
  function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {
      // Filter out tiles at higher zoom levels than the current zoom level, or that
      // are outside the visible extent.
      if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
          return DROP;
      }
      if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
          return DROP;
      }
      // Prioritize the highest zoom level tiles closest to the focus.
      // Tiles at higher zoom levels are prioritized using Math.log(tileResolution).
      // Within a zoom level, tiles are prioritized by the distance in pixels between
      // the center of the tile and the center of the viewport.  The factor of 65536
      // means that the prioritization should behave as desired for tiles up to
      // 65536 * Math.log(2) = 45426 pixels from the focus.
      var center = frameState.viewState.center;
      var deltaX = tileCenter[0] - center[0];
      var deltaY = tileCenter[1] - center[1];
      return (65536 * Math.log(tileResolution) +
          Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution);
  }

  /**
   * @module ol/ViewHint
   */
  /**
   * @enum {number}
   */
  var ViewHint = {
      ANIMATING: 0,
      INTERACTING: 1,
  };

  /**
   * @module ol/ViewProperty
   */
  /**
   * @enum {string}
   */
  var ViewProperty = {
      CENTER: 'center',
      RESOLUTION: 'resolution',
      ROTATION: 'rotation',
  };

  /**
   * @module ol/tilegrid/common
   */
  /**
   * Default maximum zoom for default tile grids.
   * @type {number}
   */
  var DEFAULT_MAX_ZOOM = 42;
  /**
   * Default tile size.
   * @type {number}
   */
  var DEFAULT_TILE_SIZE = 256;

  /**
   * @module ol/centerconstraint
   */
  /**
   * @typedef {function((import("./coordinate.js").Coordinate|undefined), number, import("./size.js").Size, boolean=): (import("./coordinate.js").Coordinate|undefined)} Type
   */
  /**
   * @param {import("./extent.js").Extent} extent Extent.
   * @param {boolean} onlyCenter If true, the constraint will only apply to the view center.
   * @param {boolean} smooth If true, the view will be able to go slightly out of the given extent
   * (only during interaction and animation).
   * @return {Type} The constraint.
   */
  function createExtent(extent, onlyCenter, smooth) {
      return (
      /**
       * @param {import("./coordinate.js").Coordinate|undefined} center Center.
       * @param {number} resolution Resolution.
       * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
       * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
       * @return {import("./coordinate.js").Coordinate|undefined} Center.
       */
      function (center, resolution, size, opt_isMoving) {
          if (center) {
              var viewWidth = onlyCenter ? 0 : size[0] * resolution;
              var viewHeight = onlyCenter ? 0 : size[1] * resolution;
              var minX = extent[0] + viewWidth / 2;
              var maxX = extent[2] - viewWidth / 2;
              var minY = extent[1] + viewHeight / 2;
              var maxY = extent[3] - viewHeight / 2;
              // note: when zooming out of bounds, min and max values for x and y may
              // end up inverted (min > max); this has to be accounted for
              if (minX > maxX) {
                  minX = (maxX + minX) / 2;
                  maxX = minX;
              }
              if (minY > maxY) {
                  minY = (maxY + minY) / 2;
                  maxY = minY;
              }
              var x = clamp(center[0], minX, maxX);
              var y = clamp(center[1], minY, maxY);
              var ratio = 30 * resolution;
              // during an interaction, allow some overscroll
              if (opt_isMoving && smooth) {
                  x +=
                      -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) +
                          ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
                  y +=
                      -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) +
                          ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
              }
              return [x, y];
          }
          else {
              return undefined;
          }
      });
  }
  /**
   * @param {import("./coordinate.js").Coordinate=} center Center.
   * @return {import("./coordinate.js").Coordinate|undefined} Center.
   */
  function none(center) {
      return center;
  }

  /**
   * @module ol/resolutionconstraint
   */
  /**
   * @typedef {function((number|undefined), number, import("./size.js").Size, boolean=): (number|undefined)} Type
   */
  /**
   * Returns a modified resolution taking into account the viewport size and maximum
   * allowed extent.
   * @param {number} resolution Resolution
   * @param {import("./extent.js").Extent=} maxExtent Maximum allowed extent.
   * @param {import("./size.js").Size} viewportSize Viewport size.
   * @param {boolean} showFullExtent Whether to show the full extent.
   * @return {number} Capped resolution.
   */
  function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
      var xResolution = getWidth(maxExtent) / viewportSize[0];
      var yResolution = getHeight(maxExtent) / viewportSize[1];
      if (showFullExtent) {
          return Math.min(resolution, Math.max(xResolution, yResolution));
      }
      return Math.min(resolution, Math.min(xResolution, yResolution));
  }
  /**
   * Returns a modified resolution to be between maxResolution and minResolution while
   * still allowing the value to be slightly out of bounds.
   * Note: the computation is based on the logarithm function (ln):
   *  - at 1, ln(x) is 0
   *  - above 1, ln(x) keeps increasing but at a much slower pace than x
   * The final result is clamped to prevent getting too far away from bounds.
   * @param {number} resolution Resolution.
   * @param {number} maxResolution Max resolution.
   * @param {number} minResolution Min resolution.
   * @return {number} Smoothed resolution.
   */
  function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
      var result = Math.min(resolution, maxResolution);
      var ratio = 50;
      result *=
          Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio +
              1;
      if (minResolution) {
          result = Math.max(result, minResolution);
          result /=
              Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) /
                  ratio +
                  1;
      }
      return clamp(result, minResolution / 2, maxResolution * 2);
  }
  /**
   * @param {Array<number>} resolutions Resolutions.
   * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.
   * @param {import("./extent.js").Extent=} opt_maxExtent Maximum allowed extent.
   * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.
   * @return {Type} Zoom function.
   */
  function createSnapToResolutions(resolutions, opt_smooth, opt_maxExtent, opt_showFullExtent) {
      return (
      /**
       * @param {number|undefined} resolution Resolution.
       * @param {number} direction Direction.
       * @param {import("./size.js").Size} size Viewport size.
       * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
       * @return {number|undefined} Resolution.
       */
      function (resolution, direction, size, opt_isMoving) {
          if (resolution !== undefined) {
              var maxResolution = resolutions[0];
              var minResolution = resolutions[resolutions.length - 1];
              var cappedMaxRes = opt_maxExtent
                  ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)
                  : maxResolution;
              // during interacting or animating, allow intermediary values
              if (opt_isMoving) {
                  var smooth = opt_smooth !== undefined ? opt_smooth : true;
                  if (!smooth) {
                      return clamp(resolution, minResolution, cappedMaxRes);
                  }
                  return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
              }
              var capped = Math.min(cappedMaxRes, resolution);
              var z = Math.floor(linearFindNearest(resolutions, capped, direction));
              if (resolutions[z] > cappedMaxRes && z < resolutions.length - 1) {
                  return resolutions[z + 1];
              }
              return resolutions[z];
          }
          else {
              return undefined;
          }
      });
  }
  /**
   * @param {number} power Power.
   * @param {number} maxResolution Maximum resolution.
   * @param {number=} opt_minResolution Minimum resolution.
   * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.
   * @param {import("./extent.js").Extent=} opt_maxExtent Maximum allowed extent.
   * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.
   * @return {Type} Zoom function.
   */
  function createSnapToPower(power, maxResolution, opt_minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
      return (
      /**
       * @param {number|undefined} resolution Resolution.
       * @param {number} direction Direction.
       * @param {import("./size.js").Size} size Viewport size.
       * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
       * @return {number|undefined} Resolution.
       */
      function (resolution, direction, size, opt_isMoving) {
          if (resolution !== undefined) {
              var cappedMaxRes = opt_maxExtent
                  ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)
                  : maxResolution;
              var minResolution = opt_minResolution !== undefined ? opt_minResolution : 0;
              // during interacting or animating, allow intermediary values
              if (opt_isMoving) {
                  var smooth = opt_smooth !== undefined ? opt_smooth : true;
                  if (!smooth) {
                      return clamp(resolution, minResolution, cappedMaxRes);
                  }
                  return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
              }
              var tolerance = 1e-9;
              var minZoomLevel = Math.ceil(Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance);
              var offset = -direction * (0.5 - tolerance) + 0.5;
              var capped = Math.min(cappedMaxRes, resolution);
              var cappedZoomLevel = Math.floor(Math.log(maxResolution / capped) / Math.log(power) + offset);
              var zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
              var newResolution = maxResolution / Math.pow(power, zoomLevel);
              return clamp(newResolution, minResolution, cappedMaxRes);
          }
          else {
              return undefined;
          }
      });
  }
  /**
   * @param {number} maxResolution Max resolution.
   * @param {number} minResolution Min resolution.
   * @param {boolean=} opt_smooth If true, the view will be able to slightly exceed resolution limits. Default: true.
   * @param {import("./extent.js").Extent=} opt_maxExtent Maximum allowed extent.
   * @param {boolean=} opt_showFullExtent If true, allows us to show the full extent. Default: false.
   * @return {Type} Zoom function.
   */
  function createMinMaxResolution(maxResolution, minResolution, opt_smooth, opt_maxExtent, opt_showFullExtent) {
      return (
      /**
       * @param {number|undefined} resolution Resolution.
       * @param {number} direction Direction.
       * @param {import("./size.js").Size} size Viewport size.
       * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
       * @return {number|undefined} Resolution.
       */
      function (resolution, direction, size, opt_isMoving) {
          if (resolution !== undefined) {
              var cappedMaxRes = opt_maxExtent
                  ? getViewportClampedResolution(maxResolution, opt_maxExtent, size, opt_showFullExtent)
                  : maxResolution;
              var smooth = opt_smooth !== undefined ? opt_smooth : true;
              if (!smooth || !opt_isMoving) {
                  return clamp(resolution, minResolution, cappedMaxRes);
              }
              return getSmoothClampedResolution(resolution, cappedMaxRes, minResolution);
          }
          else {
              return undefined;
          }
      });
  }

  /**
   * @module ol/rotationconstraint
   */
  /**
   * @typedef {function((number|undefined), boolean=): (number|undefined)} Type
   */
  /**
   * @param {number|undefined} rotation Rotation.
   * @return {number|undefined} Rotation.
   */
  function disable(rotation) {
      if (rotation !== undefined) {
          return 0;
      }
      else {
          return undefined;
      }
  }
  /**
   * @param {number|undefined} rotation Rotation.
   * @return {number|undefined} Rotation.
   */
  function none$1(rotation) {
      if (rotation !== undefined) {
          return rotation;
      }
      else {
          return undefined;
      }
  }
  /**
   * @param {number} n N.
   * @return {Type} Rotation constraint.
   */
  function createSnapToN(n) {
      var theta = (2 * Math.PI) / n;
      return (
      /**
       * @param {number|undefined} rotation Rotation.
       * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
       * @return {number|undefined} Rotation.
       */
      function (rotation, opt_isMoving) {
          if (opt_isMoving) {
              return rotation;
          }
          if (rotation !== undefined) {
              rotation = Math.floor(rotation / theta + 0.5) * theta;
              return rotation;
          }
          else {
              return undefined;
          }
      });
  }
  /**
   * @param {number=} opt_tolerance Tolerance.
   * @return {Type} Rotation constraint.
   */
  function createSnapToZero(opt_tolerance) {
      var tolerance = opt_tolerance || toRadians(5);
      return (
      /**
       * @param {number|undefined} rotation Rotation.
       * @param {boolean=} opt_isMoving True if an interaction or animation is in progress.
       * @return {number|undefined} Rotation.
       */
      function (rotation, opt_isMoving) {
          if (opt_isMoving) {
              return rotation;
          }
          if (rotation !== undefined) {
              if (Math.abs(rotation) <= tolerance) {
                  return 0;
              }
              else {
                  return rotation;
              }
          }
          else {
              return undefined;
          }
      });
  }

  /**
   * @module ol/easing
   */
  /**
   * Start slow and speed up.
   * @param {number} t Input between 0 and 1.
   * @return {number} Output between 0 and 1.
   * @api
   */
  function easeIn(t) {
      return Math.pow(t, 3);
  }
  /**
   * Start fast and slow down.
   * @param {number} t Input between 0 and 1.
   * @return {number} Output between 0 and 1.
   * @api
   */
  function easeOut(t) {
      return 1 - easeIn(1 - t);
  }
  /**
   * Start slow, speed up, and then slow down again.
   * @param {number} t Input between 0 and 1.
   * @return {number} Output between 0 and 1.
   * @api
   */
  function inAndOut(t) {
      return 3 * t * t - 2 * t * t * t;
  }
  /**
   * Maintain a constant speed over time.
   * @param {number} t Input between 0 and 1.
   * @return {number} Output between 0 and 1.
   * @api
   */
  function linear(t) {
      return t;
  }

  /**
   * @module ol/geom/flat/closest
   */
  /**
   * Returns the point on the 2D line segment flatCoordinates[offset1] to
   * flatCoordinates[offset2] that is closest to the point (x, y).  Extra
   * dimensions are linearly interpolated.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset1 Offset 1.
   * @param {number} offset2 Offset 2.
   * @param {number} stride Stride.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {Array<number>} closestPoint Closest point.
   */
  function assignClosest(flatCoordinates, offset1, offset2, stride, x, y, closestPoint) {
      var x1 = flatCoordinates[offset1];
      var y1 = flatCoordinates[offset1 + 1];
      var dx = flatCoordinates[offset2] - x1;
      var dy = flatCoordinates[offset2 + 1] - y1;
      var offset;
      if (dx === 0 && dy === 0) {
          offset = offset1;
      }
      else {
          var t = ((x - x1) * dx + (y - y1) * dy) / (dx * dx + dy * dy);
          if (t > 1) {
              offset = offset2;
          }
          else if (t > 0) {
              for (var i = 0; i < stride; ++i) {
                  closestPoint[i] = lerp(flatCoordinates[offset1 + i], flatCoordinates[offset2 + i], t);
              }
              closestPoint.length = stride;
              return;
          }
          else {
              offset = offset1;
          }
      }
      for (var i = 0; i < stride; ++i) {
          closestPoint[i] = flatCoordinates[offset + i];
      }
      closestPoint.length = stride;
  }
  /**
   * Return the squared of the largest distance between any pair of consecutive
   * coordinates.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} max Max squared delta.
   * @return {number} Max squared delta.
   */
  function maxSquaredDelta(flatCoordinates, offset, end, stride, max) {
      var x1 = flatCoordinates[offset];
      var y1 = flatCoordinates[offset + 1];
      for (offset += stride; offset < end; offset += stride) {
          var x2 = flatCoordinates[offset];
          var y2 = flatCoordinates[offset + 1];
          var squaredDelta = squaredDistance(x1, y1, x2, y2);
          if (squaredDelta > max) {
              max = squaredDelta;
          }
          x1 = x2;
          y1 = y2;
      }
      return max;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {number} max Max squared delta.
   * @return {number} Max squared delta.
   */
  function arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          max = maxSquaredDelta(flatCoordinates, offset, end, stride, max);
          offset = end;
      }
      return max;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {number} max Max squared delta.
   * @return {number} Max squared delta.
   */
  function multiArrayMaxSquaredDelta(flatCoordinates, offset, endss, stride, max) {
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          max = arrayMaxSquaredDelta(flatCoordinates, offset, ends, stride, max);
          offset = ends[ends.length - 1];
      }
      return max;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} maxDelta Max delta.
   * @param {boolean} isRing Is ring.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {Array<number>} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @param {Array<number>=} opt_tmpPoint Temporary point object.
   * @return {number} Minimum squared distance.
   */
  function assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
      if (offset == end) {
          return minSquaredDistance;
      }
      var i, squaredDistance$1;
      if (maxDelta === 0) {
          // All points are identical, so just test the first point.
          squaredDistance$1 = squaredDistance(x, y, flatCoordinates[offset], flatCoordinates[offset + 1]);
          if (squaredDistance$1 < minSquaredDistance) {
              for (i = 0; i < stride; ++i) {
                  closestPoint[i] = flatCoordinates[offset + i];
              }
              closestPoint.length = stride;
              return squaredDistance$1;
          }
          else {
              return minSquaredDistance;
          }
      }
      var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
      var index = offset + stride;
      while (index < end) {
          assignClosest(flatCoordinates, index - stride, index, stride, x, y, tmpPoint);
          squaredDistance$1 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
          if (squaredDistance$1 < minSquaredDistance) {
              minSquaredDistance = squaredDistance$1;
              for (i = 0; i < stride; ++i) {
                  closestPoint[i] = tmpPoint[i];
              }
              closestPoint.length = stride;
              index += stride;
          }
          else {
              // Skip ahead multiple points, because we know that all the skipped
              // points cannot be any closer than the closest point we have found so
              // far.  We know this because we know how close the current point is, how
              // close the closest point we have found so far is, and the maximum
              // distance between consecutive points.  For example, if we're currently
              // at distance 10, the best we've found so far is 3, and that the maximum
              // distance between consecutive points is 2, then we'll need to skip at
              // least (10 - 3) / 2 == 3 (rounded down) points to have any chance of
              // finding a closer point.  We use Math.max(..., 1) to ensure that we
              // always advance at least one point, to avoid an infinite loop.
              index +=
                  stride *
                      Math.max(((Math.sqrt(squaredDistance$1) - Math.sqrt(minSquaredDistance)) /
                          maxDelta) |
                          0, 1);
          }
      }
      if (isRing) {
          // Check the closing segment.
          assignClosest(flatCoordinates, end - stride, offset, stride, x, y, tmpPoint);
          squaredDistance$1 = squaredDistance(x, y, tmpPoint[0], tmpPoint[1]);
          if (squaredDistance$1 < minSquaredDistance) {
              minSquaredDistance = squaredDistance$1;
              for (i = 0; i < stride; ++i) {
                  closestPoint[i] = tmpPoint[i];
              }
              closestPoint.length = stride;
          }
      }
      return minSquaredDistance;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {number} maxDelta Max delta.
   * @param {boolean} isRing Is ring.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {Array<number>} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @param {Array<number>=} opt_tmpPoint Temporary point object.
   * @return {number} Minimum squared distance.
   */
  function assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
      var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          minSquaredDistance = assignClosestPoint(flatCoordinates, offset, end, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
          offset = end;
      }
      return minSquaredDistance;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {number} maxDelta Max delta.
   * @param {boolean} isRing Is ring.
   * @param {number} x X.
   * @param {number} y Y.
   * @param {Array<number>} closestPoint Closest point.
   * @param {number} minSquaredDistance Minimum squared distance.
   * @param {Array<number>=} opt_tmpPoint Temporary point object.
   * @return {number} Minimum squared distance.
   */
  function assignClosestMultiArrayPoint(flatCoordinates, offset, endss, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, opt_tmpPoint) {
      var tmpPoint = opt_tmpPoint ? opt_tmpPoint : [NaN, NaN];
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          minSquaredDistance = assignClosestArrayPoint(flatCoordinates, offset, ends, stride, maxDelta, isRing, x, y, closestPoint, minSquaredDistance, tmpPoint);
          offset = ends[ends.length - 1];
      }
      return minSquaredDistance;
  }

  /**
   * @module ol/geom/flat/deflate
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
   * @param {number} stride Stride.
   * @return {number} offset Offset.
   */
  function deflateCoordinate(flatCoordinates, offset, coordinate, stride) {
      for (var i = 0, ii = coordinate.length; i < ii; ++i) {
          flatCoordinates[offset++] = coordinate[i];
      }
      return offset;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<import("../../coordinate.js").Coordinate>} coordinates Coordinates.
   * @param {number} stride Stride.
   * @return {number} offset Offset.
   */
  function deflateCoordinates(flatCoordinates, offset, coordinates, stride) {
      for (var i = 0, ii = coordinates.length; i < ii; ++i) {
          var coordinate = coordinates[i];
          for (var j = 0; j < stride; ++j) {
              flatCoordinates[offset++] = coordinate[j];
          }
      }
      return offset;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<import("../../coordinate.js").Coordinate>>} coordinatess Coordinatess.
   * @param {number} stride Stride.
   * @param {Array<number>=} opt_ends Ends.
   * @return {Array<number>} Ends.
   */
  function deflateCoordinatesArray(flatCoordinates, offset, coordinatess, stride, opt_ends) {
      var ends = opt_ends ? opt_ends : [];
      var i = 0;
      for (var j = 0, jj = coordinatess.length; j < jj; ++j) {
          var end = deflateCoordinates(flatCoordinates, offset, coordinatess[j], stride);
          ends[i++] = end;
          offset = end;
      }
      ends.length = i;
      return ends;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} coordinatesss Coordinatesss.
   * @param {number} stride Stride.
   * @param {Array<Array<number>>=} opt_endss Endss.
   * @return {Array<Array<number>>} Endss.
   */
  function deflateMultiCoordinatesArray(flatCoordinates, offset, coordinatesss, stride, opt_endss) {
      var endss = opt_endss ? opt_endss : [];
      var i = 0;
      for (var j = 0, jj = coordinatesss.length; j < jj; ++j) {
          var ends = deflateCoordinatesArray(flatCoordinates, offset, coordinatesss[j], stride, endss[i]);
          endss[i++] = ends;
          offset = ends[ends.length - 1];
      }
      endss.length = i;
      return endss;
  }

  /**
   * @module ol/geom/flat/simplify
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
   *     coordinates.
   * @param {number} simplifiedOffset Simplified offset.
   * @return {number} Simplified offset.
   */
  function douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
      var n = (end - offset) / stride;
      if (n < 3) {
          for (; offset < end; offset += stride) {
              simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset];
              simplifiedFlatCoordinates[simplifiedOffset++] =
                  flatCoordinates[offset + 1];
          }
          return simplifiedOffset;
      }
      /** @type {Array<number>} */
      var markers = new Array(n);
      markers[0] = 1;
      markers[n - 1] = 1;
      /** @type {Array<number>} */
      var stack = [offset, end - stride];
      var index = 0;
      while (stack.length > 0) {
          var last = stack.pop();
          var first = stack.pop();
          var maxSquaredDistance = 0;
          var x1 = flatCoordinates[first];
          var y1 = flatCoordinates[first + 1];
          var x2 = flatCoordinates[last];
          var y2 = flatCoordinates[last + 1];
          for (var i = first + stride; i < last; i += stride) {
              var x = flatCoordinates[i];
              var y = flatCoordinates[i + 1];
              var squaredDistance_1 = squaredSegmentDistance(x, y, x1, y1, x2, y2);
              if (squaredDistance_1 > maxSquaredDistance) {
                  index = i;
                  maxSquaredDistance = squaredDistance_1;
              }
          }
          if (maxSquaredDistance > squaredTolerance) {
              markers[(index - offset) / stride] = 1;
              if (first + stride < index) {
                  stack.push(first, index);
              }
              if (index + stride < last) {
                  stack.push(index, last);
              }
          }
      }
      for (var i = 0; i < n; ++i) {
          if (markers[i]) {
              simplifiedFlatCoordinates[simplifiedOffset++] =
                  flatCoordinates[offset + i * stride];
              simplifiedFlatCoordinates[simplifiedOffset++] =
                  flatCoordinates[offset + i * stride + 1];
          }
      }
      return simplifiedOffset;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {number} squaredTolerance Squared tolerance.
   * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
   *     coordinates.
   * @param {number} simplifiedOffset Simplified offset.
   * @param {Array<number>} simplifiedEnds Simplified ends.
   * @return {number} Simplified offset.
   */
  function douglasPeuckerArray(flatCoordinates, offset, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          simplifiedOffset = douglasPeucker(flatCoordinates, offset, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset);
          simplifiedEnds.push(simplifiedOffset);
          offset = end;
      }
      return simplifiedOffset;
  }
  /**
   * @param {number} value Value.
   * @param {number} tolerance Tolerance.
   * @return {number} Rounded value.
   */
  function snap(value, tolerance) {
      return tolerance * Math.round(value / tolerance);
  }
  /**
   * Simplifies a line string using an algorithm designed by Tim Schaub.
   * Coordinates are snapped to the nearest value in a virtual grid and
   * consecutive duplicate coordinates are discarded.  This effectively preserves
   * topology as the simplification of any subsection of a line string is
   * independent of the rest of the line string.  This means that, for examples,
   * the common edge between two polygons will be simplified to the same line
   * string independently in both polygons.  This implementation uses a single
   * pass over the coordinates and eliminates intermediate collinear points.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} tolerance Tolerance.
   * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
   *     coordinates.
   * @param {number} simplifiedOffset Simplified offset.
   * @return {number} Simplified offset.
   */
  function quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
      // do nothing if the line is empty
      if (offset == end) {
          return simplifiedOffset;
      }
      // snap the first coordinate (P1)
      var x1 = snap(flatCoordinates[offset], tolerance);
      var y1 = snap(flatCoordinates[offset + 1], tolerance);
      offset += stride;
      // add the first coordinate to the output
      simplifiedFlatCoordinates[simplifiedOffset++] = x1;
      simplifiedFlatCoordinates[simplifiedOffset++] = y1;
      // find the next coordinate that does not snap to the same value as the first
      // coordinate (P2)
      var x2, y2;
      do {
          x2 = snap(flatCoordinates[offset], tolerance);
          y2 = snap(flatCoordinates[offset + 1], tolerance);
          offset += stride;
          if (offset == end) {
              // all coordinates snap to the same value, the line collapses to a point
              // push the last snapped value anyway to ensure that the output contains
              // at least two points
              // FIXME should we really return at least two points anyway?
              simplifiedFlatCoordinates[simplifiedOffset++] = x2;
              simplifiedFlatCoordinates[simplifiedOffset++] = y2;
              return simplifiedOffset;
          }
      } while (x2 == x1 && y2 == y1);
      while (offset < end) {
          // snap the next coordinate (P3)
          var x3 = snap(flatCoordinates[offset], tolerance);
          var y3 = snap(flatCoordinates[offset + 1], tolerance);
          offset += stride;
          // skip P3 if it is equal to P2
          if (x3 == x2 && y3 == y2) {
              continue;
          }
          // calculate the delta between P1 and P2
          var dx1 = x2 - x1;
          var dy1 = y2 - y1;
          // calculate the delta between P3 and P1
          var dx2 = x3 - x1;
          var dy2 = y3 - y1;
          // if P1, P2, and P3 are colinear and P3 is further from P1 than P2 is from
          // P1 in the same direction then P2 is on the straight line between P1 and
          // P3
          if (dx1 * dy2 == dy1 * dx2 &&
              ((dx1 < 0 && dx2 < dx1) || dx1 == dx2 || (dx1 > 0 && dx2 > dx1)) &&
              ((dy1 < 0 && dy2 < dy1) || dy1 == dy2 || (dy1 > 0 && dy2 > dy1))) {
              // discard P2 and set P2 = P3
              x2 = x3;
              y2 = y3;
              continue;
          }
          // either P1, P2, and P3 are not colinear, or they are colinear but P3 is
          // between P3 and P1 or on the opposite half of the line to P2.  add P2,
          // and continue with P1 = P2 and P2 = P3
          simplifiedFlatCoordinates[simplifiedOffset++] = x2;
          simplifiedFlatCoordinates[simplifiedOffset++] = y2;
          x1 = x2;
          y1 = y2;
          x2 = x3;
          y2 = y3;
      }
      // add the last point (P2)
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      return simplifiedOffset;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {number} tolerance Tolerance.
   * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
   *     coordinates.
   * @param {number} simplifiedOffset Simplified offset.
   * @param {Array<number>} simplifiedEnds Simplified ends.
   * @return {number} Simplified offset.
   */
  function quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          simplifiedOffset = quantize(flatCoordinates, offset, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset);
          simplifiedEnds.push(simplifiedOffset);
          offset = end;
      }
      return simplifiedOffset;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {number} tolerance Tolerance.
   * @param {Array<number>} simplifiedFlatCoordinates Simplified flat
   *     coordinates.
   * @param {number} simplifiedOffset Simplified offset.
   * @param {Array<Array<number>>} simplifiedEndss Simplified endss.
   * @return {number} Simplified offset.
   */
  function quantizeMultiArray(flatCoordinates, offset, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          var simplifiedEnds = [];
          simplifiedOffset = quantizeArray(flatCoordinates, offset, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds);
          simplifiedEndss.push(simplifiedEnds);
          offset = ends[ends.length - 1];
      }
      return simplifiedOffset;
  }

  /**
   * @module ol/geom/flat/inflate
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {Array<import("../../coordinate.js").Coordinate>=} opt_coordinates Coordinates.
   * @return {Array<import("../../coordinate.js").Coordinate>} Coordinates.
   */
  function inflateCoordinates(flatCoordinates, offset, end, stride, opt_coordinates) {
      var coordinates = opt_coordinates !== undefined ? opt_coordinates : [];
      var i = 0;
      for (var j = offset; j < end; j += stride) {
          coordinates[i++] = flatCoordinates.slice(j, j + stride);
      }
      coordinates.length = i;
      return coordinates;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<Array<import("../../coordinate.js").Coordinate>>=} opt_coordinatess Coordinatess.
   * @return {Array<Array<import("../../coordinate.js").Coordinate>>} Coordinatess.
   */
  function inflateCoordinatesArray(flatCoordinates, offset, ends, stride, opt_coordinatess) {
      var coordinatess = opt_coordinatess !== undefined ? opt_coordinatess : [];
      var i = 0;
      for (var j = 0, jj = ends.length; j < jj; ++j) {
          var end = ends[j];
          coordinatess[i++] = inflateCoordinates(flatCoordinates, offset, end, stride, coordinatess[i]);
          offset = end;
      }
      coordinatess.length = i;
      return coordinatess;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {Array<Array<Array<import("../../coordinate.js").Coordinate>>>=} opt_coordinatesss
   *     Coordinatesss.
   * @return {Array<Array<Array<import("../../coordinate.js").Coordinate>>>} Coordinatesss.
   */
  function inflateMultiCoordinatesArray(flatCoordinates, offset, endss, stride, opt_coordinatesss) {
      var coordinatesss = opt_coordinatesss !== undefined ? opt_coordinatesss : [];
      var i = 0;
      for (var j = 0, jj = endss.length; j < jj; ++j) {
          var ends = endss[j];
          coordinatesss[i++] = inflateCoordinatesArray(flatCoordinates, offset, ends, stride, coordinatesss[i]);
          offset = ends[ends.length - 1];
      }
      coordinatesss.length = i;
      return coordinatesss;
  }

  /**
   * @module ol/geom/flat/area
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @return {number} Area.
   */
  function linearRing(flatCoordinates, offset, end, stride) {
      var twiceArea = 0;
      var x1 = flatCoordinates[end - stride];
      var y1 = flatCoordinates[end - stride + 1];
      for (; offset < end; offset += stride) {
          var x2 = flatCoordinates[offset];
          var y2 = flatCoordinates[offset + 1];
          twiceArea += y1 * x2 - x1 * y2;
          x1 = x2;
          y1 = y2;
      }
      return twiceArea / 2;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @return {number} Area.
   */
  function linearRings(flatCoordinates, offset, ends, stride) {
      var area = 0;
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          area += linearRing(flatCoordinates, offset, end, stride);
          offset = end;
      }
      return area;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @return {number} Area.
   */
  function linearRingss(flatCoordinates, offset, endss, stride) {
      var area = 0;
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          area += linearRings(flatCoordinates, offset, ends, stride);
          offset = ends[ends.length - 1];
      }
      return area;
  }

  var __extends$k = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Linear ring geometry. Only used as part of polygon; cannot be rendered
   * on its own.
   *
   * @api
   */
  var LinearRing = /** @class */ (function (_super) {
      __extends$k(LinearRing, _super);
      /**
       * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       */
      function LinearRing(coordinates, opt_layout) {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {number}
           */
          _this.maxDelta_ = -1;
          /**
           * @private
           * @type {number}
           */
          _this.maxDeltaRevision_ = -1;
          if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {
              _this.setFlatCoordinates(opt_layout, 
              /** @type {Array<number>} */ (coordinates));
          }
          else {
              _this.setCoordinates(
              /** @type {Array<import("../coordinate.js").Coordinate>} */ (coordinates), opt_layout);
          }
          return _this;
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!LinearRing} Clone.
       * @api
       */
      LinearRing.prototype.clone = function () {
          return new LinearRing(this.flatCoordinates.slice(), this.layout);
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      LinearRing.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
          if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
          }
          if (this.maxDeltaRevision_ != this.getRevision()) {
              this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
              this.maxDeltaRevision_ = this.getRevision();
          }
          return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
      };
      /**
       * Return the area of the linear ring on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      LinearRing.prototype.getArea = function () {
          return linearRing(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      };
      /**
       * Return the coordinates of the linear ring.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       */
      LinearRing.prototype.getCoordinates = function () {
          return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      };
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {LinearRing} Simplified LinearRing.
       * @protected
       */
      LinearRing.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
          var simplifiedFlatCoordinates = [];
          simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
          return new LinearRing(simplifiedFlatCoordinates, GeometryLayout.XY);
      };
      /**
       * Get the type of this geometry.
       * @return {import("./GeometryType.js").default} Geometry type.
       * @api
       */
      LinearRing.prototype.getType = function () {
          return GeometryType.LINEAR_RING;
      };
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      LinearRing.prototype.intersectsExtent = function (extent) {
          return false;
      };
      /**
       * Set the coordinates of the linear ring.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @api
       */
      LinearRing.prototype.setCoordinates = function (coordinates, opt_layout) {
          this.setLayout(opt_layout, coordinates, 1);
          if (!this.flatCoordinates) {
              this.flatCoordinates = [];
          }
          this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);
          this.changed();
      };
      return LinearRing;
  }(SimpleGeometry));

  var __extends$l = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Point geometry.
   *
   * @api
   */
  var Point = /** @class */ (function (_super) {
      __extends$l(Point, _super);
      /**
       * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       */
      function Point(coordinates, opt_layout) {
          var _this = _super.call(this) || this;
          _this.setCoordinates(coordinates, opt_layout);
          return _this;
      }
      /**
       * Make a complete copy of the geometry.
       * @return {!Point} Clone.
       * @api
       */
      Point.prototype.clone = function () {
          var point = new Point(this.flatCoordinates.slice(), this.layout);
          return point;
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      Point.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
          var flatCoordinates = this.flatCoordinates;
          var squaredDistance$1 = squaredDistance(x, y, flatCoordinates[0], flatCoordinates[1]);
          if (squaredDistance$1 < minSquaredDistance) {
              var stride = this.stride;
              for (var i = 0; i < stride; ++i) {
                  closestPoint[i] = flatCoordinates[i];
              }
              closestPoint.length = stride;
              return squaredDistance$1;
          }
          else {
              return minSquaredDistance;
          }
      };
      /**
       * Return the coordinate of the point.
       * @return {import("../coordinate.js").Coordinate} Coordinates.
       * @api
       */
      Point.prototype.getCoordinates = function () {
          return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
      };
      /**
       * @param {import("../extent.js").Extent} extent Extent.
       * @protected
       * @return {import("../extent.js").Extent} extent Extent.
       */
      Point.prototype.computeExtent = function (extent) {
          return createOrUpdateFromCoordinate(this.flatCoordinates, extent);
      };
      /**
       * Get the type of this geometry.
       * @return {import("./GeometryType.js").default} Geometry type.
       * @api
       */
      Point.prototype.getType = function () {
          return GeometryType.POINT;
      };
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      Point.prototype.intersectsExtent = function (extent) {
          return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
      };
      /**
       * @param {!Array<*>} coordinates Coordinates.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @api
       */
      Point.prototype.setCoordinates = function (coordinates, opt_layout) {
          this.setLayout(opt_layout, coordinates, 0);
          if (!this.flatCoordinates) {
              this.flatCoordinates = [];
          }
          this.flatCoordinates.length = deflateCoordinate(this.flatCoordinates, 0, coordinates, this.stride);
          this.changed();
      };
      return Point;
  }(SimpleGeometry));

  /**
   * @module ol/geom/flat/contains
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @return {boolean} Contains extent.
   */
  function linearRingContainsExtent(flatCoordinates, offset, end, stride, extent) {
      var outside = forEachCorner(extent, 
      /**
       * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
       * @return {boolean} Contains (x, y).
       */
      function (coordinate) {
          return !linearRingContainsXY(flatCoordinates, offset, end, stride, coordinate[0], coordinate[1]);
      });
      return !outside;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  function linearRingContainsXY(flatCoordinates, offset, end, stride, x, y) {
      // http://geomalgorithms.com/a03-_inclusion.html
      // Copyright 2000 softSurfer, 2012 Dan Sunday
      // This code may be freely used and modified for any purpose
      // providing that this copyright notice is included with it.
      // SoftSurfer makes no warranty for this code, and cannot be held
      // liable for any real or imagined damage resulting from its use.
      // Users of this code must verify correctness for their application.
      var wn = 0;
      var x1 = flatCoordinates[end - stride];
      var y1 = flatCoordinates[end - stride + 1];
      for (; offset < end; offset += stride) {
          var x2 = flatCoordinates[offset];
          var y2 = flatCoordinates[offset + 1];
          if (y1 <= y) {
              if (y2 > y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) > 0) {
                  wn++;
              }
          }
          else if (y2 <= y && (x2 - x1) * (y - y1) - (x - x1) * (y2 - y1) < 0) {
              wn--;
          }
          x1 = x2;
          y1 = y2;
      }
      return wn !== 0;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  function linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y) {
      if (ends.length === 0) {
          return false;
      }
      if (!linearRingContainsXY(flatCoordinates, offset, ends[0], stride, x, y)) {
          return false;
      }
      for (var i = 1, ii = ends.length; i < ii; ++i) {
          if (linearRingContainsXY(flatCoordinates, ends[i - 1], ends[i], stride, x, y)) {
              return false;
          }
      }
      return true;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {number} x X.
   * @param {number} y Y.
   * @return {boolean} Contains (x, y).
   */
  function linearRingssContainsXY(flatCoordinates, offset, endss, stride, x, y) {
      if (endss.length === 0) {
          return false;
      }
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
              return true;
          }
          offset = ends[ends.length - 1];
      }
      return false;
  }

  /**
   * @module ol/geom/flat/interiorpoint
   */
  /**
   * Calculates a point that is likely to lie in the interior of the linear rings.
   * Inspired by JTS's com.vividsolutions.jts.geom.Geometry#getInteriorPoint.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {Array<number>} flatCenters Flat centers.
   * @param {number} flatCentersOffset Flat center offset.
   * @param {Array<number>=} opt_dest Destination.
   * @return {Array<number>} Destination point as XYM coordinate, where M is the
   * length of the horizontal intersection that the point belongs to.
   */
  function getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, flatCentersOffset, opt_dest) {
      var i, ii, x, x1, x2, y1, y2;
      var y = flatCenters[flatCentersOffset + 1];
      /** @type {Array<number>} */
      var intersections = [];
      // Calculate intersections with the horizontal line
      for (var r = 0, rr = ends.length; r < rr; ++r) {
          var end = ends[r];
          x1 = flatCoordinates[end - stride];
          y1 = flatCoordinates[end - stride + 1];
          for (i = offset; i < end; i += stride) {
              x2 = flatCoordinates[i];
              y2 = flatCoordinates[i + 1];
              if ((y <= y1 && y2 <= y) || (y1 <= y && y <= y2)) {
                  x = ((y - y1) / (y2 - y1)) * (x2 - x1) + x1;
                  intersections.push(x);
              }
              x1 = x2;
              y1 = y2;
          }
      }
      // Find the longest segment of the horizontal line that has its center point
      // inside the linear ring.
      var pointX = NaN;
      var maxSegmentLength = -Infinity;
      intersections.sort(numberSafeCompareFunction);
      x1 = intersections[0];
      for (i = 1, ii = intersections.length; i < ii; ++i) {
          x2 = intersections[i];
          var segmentLength = Math.abs(x2 - x1);
          if (segmentLength > maxSegmentLength) {
              x = (x1 + x2) / 2;
              if (linearRingsContainsXY(flatCoordinates, offset, ends, stride, x, y)) {
                  pointX = x;
                  maxSegmentLength = segmentLength;
              }
          }
          x1 = x2;
      }
      if (isNaN(pointX)) {
          // There is no horizontal line that has its center point inside the linear
          // ring.  Use the center of the the linear ring's extent.
          pointX = flatCenters[flatCentersOffset];
      }
      if (opt_dest) {
          opt_dest.push(pointX, y, maxSegmentLength);
          return opt_dest;
      }
      else {
          return [pointX, y, maxSegmentLength];
      }
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {Array<number>} flatCenters Flat centers.
   * @return {Array<number>} Interior points as XYM coordinates, where M is the
   * length of the horizontal intersection that the point belongs to.
   */
  function getInteriorPointsOfMultiArray(flatCoordinates, offset, endss, stride, flatCenters) {
      var interiorPoints = [];
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          interiorPoints = getInteriorPointOfArray(flatCoordinates, offset, ends, stride, flatCenters, 2 * i, interiorPoints);
          offset = ends[ends.length - 1];
      }
      return interiorPoints;
  }

  /**
   * @module ol/geom/flat/segments
   */
  /**
   * This function calls `callback` for each segment of the flat coordinates
   * array. If the callback returns a truthy value the function returns that
   * value immediately. Otherwise the function returns `false`.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {function(import("../../coordinate.js").Coordinate, import("../../coordinate.js").Coordinate): T} callback Function
   *     called for each segment.
   * @return {T|boolean} Value.
   * @template T
   */
  function forEach(flatCoordinates, offset, end, stride, callback) {
      var point1 = [flatCoordinates[offset], flatCoordinates[offset + 1]];
      var point2 = [];
      var ret;
      for (; offset + stride < end; offset += stride) {
          point2[0] = flatCoordinates[offset + stride];
          point2[1] = flatCoordinates[offset + stride + 1];
          ret = callback(point1, point2);
          if (ret) {
              return ret;
          }
          point1[0] = point2[0];
          point1[1] = point2[1];
      }
      return false;
  }

  /**
   * @module ol/geom/flat/intersectsextent
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @return {boolean} True if the geometry and the extent intersect.
   */
  function intersectsLineString(flatCoordinates, offset, end, stride, extent) {
      var coordinatesExtent = extendFlatCoordinates(createEmpty(), flatCoordinates, offset, end, stride);
      if (!intersects(extent, coordinatesExtent)) {
          return false;
      }
      if (containsExtent(extent, coordinatesExtent)) {
          return true;
      }
      if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
          return true;
      }
      if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
          return true;
      }
      return forEach(flatCoordinates, offset, end, stride, 
      /**
       * @param {import("../../coordinate.js").Coordinate} point1 Start point.
       * @param {import("../../coordinate.js").Coordinate} point2 End point.
       * @return {boolean} `true` if the segment and the extent intersect,
       *     `false` otherwise.
       */
      function (point1, point2) {
          return intersectsSegment(extent, point1, point2);
      });
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @return {boolean} True if the geometry and the extent intersect.
   */
  function intersectsLineStringArray(flatCoordinates, offset, ends, stride, extent) {
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          if (intersectsLineString(flatCoordinates, offset, ends[i], stride, extent)) {
              return true;
          }
          offset = ends[i];
      }
      return false;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @return {boolean} True if the geometry and the extent intersect.
   */
  function intersectsLinearRing(flatCoordinates, offset, end, stride, extent) {
      if (intersectsLineString(flatCoordinates, offset, end, stride, extent)) {
          return true;
      }
      if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[1])) {
          return true;
      }
      if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[0], extent[3])) {
          return true;
      }
      if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[1])) {
          return true;
      }
      if (linearRingContainsXY(flatCoordinates, offset, end, stride, extent[2], extent[3])) {
          return true;
      }
      return false;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @return {boolean} True if the geometry and the extent intersect.
   */
  function intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent) {
      if (!intersectsLinearRing(flatCoordinates, offset, ends[0], stride, extent)) {
          return false;
      }
      if (ends.length === 1) {
          return true;
      }
      for (var i = 1, ii = ends.length; i < ii; ++i) {
          if (linearRingContainsExtent(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
              if (!intersectsLineString(flatCoordinates, ends[i - 1], ends[i], stride, extent)) {
                  return false;
              }
          }
      }
      return true;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @param {import("../../extent.js").Extent} extent Extent.
   * @return {boolean} True if the geometry and the extent intersect.
   */
  function intersectsLinearRingMultiArray(flatCoordinates, offset, endss, stride, extent) {
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          if (intersectsLinearRingArray(flatCoordinates, offset, ends, stride, extent)) {
              return true;
          }
          offset = ends[ends.length - 1];
      }
      return false;
  }

  /**
   * @module ol/geom/flat/reverse
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   */
  function coordinates(flatCoordinates, offset, end, stride) {
      while (offset < end - stride) {
          for (var i = 0; i < stride; ++i) {
              var tmp = flatCoordinates[offset + i];
              flatCoordinates[offset + i] = flatCoordinates[end - stride + i];
              flatCoordinates[end - stride + i] = tmp;
          }
          offset += stride;
          end -= stride;
      }
  }

  /**
   * @module ol/geom/flat/orient
   */
  /**
   * Is the linear ring oriented clockwise in a coordinate system with a bottom-left
   * coordinate origin? For a coordinate system with a top-left coordinate origin,
   * the ring's orientation is clockwise when this function returns false.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @return {boolean} Is clockwise.
   */
  function linearRingIsClockwise(flatCoordinates, offset, end, stride) {
      // https://stackoverflow.com/a/1180256/2389327
      // https://en.wikipedia.org/wiki/Curve_orientation#Orientation_of_a_simple_polygon
      var firstVertexRepeated = true;
      for (var i = 0; i < stride; ++i) {
          if (flatCoordinates[offset + i] !== flatCoordinates[end - stride + i]) {
              firstVertexRepeated = false;
              break;
          }
      }
      if (firstVertexRepeated) {
          end -= stride;
      }
      var iMinVertex = findCornerVertex(flatCoordinates, offset, end, stride);
      // Orientation matrix:
      //     [ 1  xa  ya ]
      // O = | 1  xb  yb |
      //     [ 1  xc  yc ]
      var iPreviousVertex = iMinVertex - stride;
      if (iPreviousVertex < offset) {
          iPreviousVertex = end - stride;
      }
      var iNextVertex = iMinVertex + stride;
      if (iNextVertex >= end) {
          iNextVertex = offset;
      }
      var aX = flatCoordinates[iPreviousVertex];
      var aY = flatCoordinates[iPreviousVertex + 1];
      var bX = flatCoordinates[iMinVertex];
      var bY = flatCoordinates[iMinVertex + 1];
      var cX = flatCoordinates[iNextVertex];
      var cY = flatCoordinates[iNextVertex + 1];
      var determinant = bX * cY + aX * bY + aY * cX - (aY * bX + bY * cX + aX * cY);
      return determinant < 0;
  }
  // Find vertex along one edge of bounding box.
  // In this case, we find smallest y; in case of tie also smallest x.
  function findCornerVertex(flatCoordinates, offset, end, stride) {
      var iMinVertex = -1;
      var minY = Infinity;
      var minXAtMinY = Infinity;
      for (var i = offset; i < end; i += stride) {
          var x = flatCoordinates[i];
          var y = flatCoordinates[i + 1];
          if (y > minY) {
              continue;
          }
          if (y == minY) {
              if (x >= minXAtMinY) {
                  continue;
              }
          }
          // Minimum so far.
          iMinVertex = i;
          minY = y;
          minXAtMinY = x;
      }
      return iMinVertex;
  }
  /**
   * Determines if linear rings are oriented.  By default, left-hand orientation
   * is tested (first ring must be clockwise, remaining rings counter-clockwise).
   * To test for right-hand orientation, use the `opt_right` argument.
   *
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Array of end indexes.
   * @param {number} stride Stride.
   * @param {boolean=} opt_right Test for right-hand orientation
   *     (counter-clockwise exterior ring and clockwise interior rings).
   * @return {boolean} Rings are correctly oriented.
   */
  function linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right) {
      var right = opt_right !== undefined ? opt_right : false;
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
          if (i === 0) {
              if ((right && isClockwise) || (!right && !isClockwise)) {
                  return false;
              }
          }
          else {
              if ((right && !isClockwise) || (!right && isClockwise)) {
                  return false;
              }
          }
          offset = end;
      }
      return true;
  }
  /**
   * Determines if linear rings are oriented.  By default, left-hand orientation
   * is tested (first ring must be clockwise, remaining rings counter-clockwise).
   * To test for right-hand orientation, use the `opt_right` argument.
   *
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Array of array of end indexes.
   * @param {number} stride Stride.
   * @param {boolean=} opt_right Test for right-hand orientation
   *     (counter-clockwise exterior ring and clockwise interior rings).
   * @return {boolean} Rings are correctly oriented.
   */
  function linearRingssAreOriented(flatCoordinates, offset, endss, stride, opt_right) {
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          if (!linearRingsAreOriented(flatCoordinates, offset, ends, stride, opt_right)) {
              return false;
          }
          if (ends.length) {
              offset = ends[ends.length - 1];
          }
      }
      return true;
  }
  /**
   * Orient coordinates in a flat array of linear rings.  By default, rings
   * are oriented following the left-hand rule (clockwise for exterior and
   * counter-clockwise for interior rings).  To orient according to the
   * right-hand rule, use the `opt_right` argument.
   *
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {boolean=} opt_right Follow the right-hand rule for orientation.
   * @return {number} End.
   */
  function orientLinearRings(flatCoordinates, offset, ends, stride, opt_right) {
      var right = opt_right !== undefined ? opt_right : false;
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          var isClockwise = linearRingIsClockwise(flatCoordinates, offset, end, stride);
          var reverse = i === 0
              ? (right && isClockwise) || (!right && !isClockwise)
              : (right && !isClockwise) || (!right && isClockwise);
          if (reverse) {
              coordinates(flatCoordinates, offset, end, stride);
          }
          offset = end;
      }
      return offset;
  }
  /**
   * Orient coordinates in a flat array of linear rings.  By default, rings
   * are oriented following the left-hand rule (clockwise for exterior and
   * counter-clockwise for interior rings).  To orient according to the
   * right-hand rule, use the `opt_right` argument.
   *
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Array of array of end indexes.
   * @param {number} stride Stride.
   * @param {boolean=} opt_right Follow the right-hand rule for orientation.
   * @return {number} End.
   */
  function orientLinearRingsArray(flatCoordinates, offset, endss, stride, opt_right) {
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          offset = orientLinearRings(flatCoordinates, offset, endss[i], stride, opt_right);
      }
      return offset;
  }

  var __extends$m = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Polygon geometry.
   *
   * @api
   */
  var Polygon = /** @class */ (function (_super) {
      __extends$m(Polygon, _super);
      /**
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
       *     Array of linear rings that define the polygon. The first linear ring of the
       *     array defines the outer-boundary or surface of the polygon. Each subsequent
       *     linear ring defines a hole in the surface of the polygon. A linear ring is
       *     an array of vertices' coordinates where the first coordinate and the last are
       *     equivalent. (For internal use, flat coordinates in combination with
       *     `opt_layout` and `opt_ends` are also accepted.)
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @param {Array<number>=} opt_ends Ends (for internal use with flat coordinates).
       */
      function Polygon(coordinates, opt_layout, opt_ends) {
          var _this = _super.call(this) || this;
          /**
           * @type {Array<number>}
           * @private
           */
          _this.ends_ = [];
          /**
           * @private
           * @type {number}
           */
          _this.flatInteriorPointRevision_ = -1;
          /**
           * @private
           * @type {import("../coordinate.js").Coordinate}
           */
          _this.flatInteriorPoint_ = null;
          /**
           * @private
           * @type {number}
           */
          _this.maxDelta_ = -1;
          /**
           * @private
           * @type {number}
           */
          _this.maxDeltaRevision_ = -1;
          /**
           * @private
           * @type {number}
           */
          _this.orientedRevision_ = -1;
          /**
           * @private
           * @type {Array<number>}
           */
          _this.orientedFlatCoordinates_ = null;
          if (opt_layout !== undefined && opt_ends) {
              _this.setFlatCoordinates(opt_layout, 
              /** @type {Array<number>} */ (coordinates));
              _this.ends_ = opt_ends;
          }
          else {
              _this.setCoordinates(
              /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */ (coordinates), opt_layout);
          }
          return _this;
      }
      /**
       * Append the passed linear ring to this polygon.
       * @param {LinearRing} linearRing Linear ring.
       * @api
       */
      Polygon.prototype.appendLinearRing = function (linearRing) {
          if (!this.flatCoordinates) {
              this.flatCoordinates = linearRing.getFlatCoordinates().slice();
          }
          else {
              extend(this.flatCoordinates, linearRing.getFlatCoordinates());
          }
          this.ends_.push(this.flatCoordinates.length);
          this.changed();
      };
      /**
       * Make a complete copy of the geometry.
       * @return {!Polygon} Clone.
       * @api
       */
      Polygon.prototype.clone = function () {
          return new Polygon(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      Polygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
          if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
          }
          if (this.maxDeltaRevision_ != this.getRevision()) {
              this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
              this.maxDeltaRevision_ = this.getRevision();
          }
          return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */
      Polygon.prototype.containsXY = function (x, y) {
          return linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, x, y);
      };
      /**
       * Return the area of the polygon on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      Polygon.prototype.getArea = function () {
          return linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride);
      };
      /**
       * Get the coordinate array for this geometry.  This array has the structure
       * of a GeoJSON coordinate array for polygons.
       *
       * @param {boolean=} opt_right Orient coordinates according to the right-hand
       *     rule (counter-clockwise for exterior and clockwise for interior rings).
       *     If `false`, coordinates will be oriented according to the left-hand rule
       *     (clockwise for exterior and counter-clockwise for interior rings).
       *     By default, coordinate orientation will depend on how the geometry was
       *     constructed.
       * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
       * @api
       */
      Polygon.prototype.getCoordinates = function (opt_right) {
          var flatCoordinates;
          if (opt_right !== undefined) {
              flatCoordinates = this.getOrientedFlatCoordinates().slice();
              orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, opt_right);
          }
          else {
              flatCoordinates = this.flatCoordinates;
          }
          return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);
      };
      /**
       * @return {Array<number>} Ends.
       */
      Polygon.prototype.getEnds = function () {
          return this.ends_;
      };
      /**
       * @return {Array<number>} Interior point.
       */
      Polygon.prototype.getFlatInteriorPoint = function () {
          if (this.flatInteriorPointRevision_ != this.getRevision()) {
              var flatCenter = getCenter(this.getExtent());
              this.flatInteriorPoint_ = getInteriorPointOfArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, flatCenter, 0);
              this.flatInteriorPointRevision_ = this.getRevision();
          }
          return this.flatInteriorPoint_;
      };
      /**
       * Return an interior point of the polygon.
       * @return {Point} Interior point as XYM coordinate, where M is the
       * length of the horizontal intersection that the point belongs to.
       * @api
       */
      Polygon.prototype.getInteriorPoint = function () {
          return new Point(this.getFlatInteriorPoint(), GeometryLayout.XYM);
      };
      /**
       * Return the number of rings of the polygon,  this includes the exterior
       * ring and any interior rings.
       *
       * @return {number} Number of rings.
       * @api
       */
      Polygon.prototype.getLinearRingCount = function () {
          return this.ends_.length;
      };
      /**
       * Return the Nth linear ring of the polygon geometry. Return `null` if the
       * given index is out of range.
       * The exterior linear ring is available at index `0` and the interior rings
       * at index `1` and beyond.
       *
       * @param {number} index Index.
       * @return {LinearRing} Linear ring.
       * @api
       */
      Polygon.prototype.getLinearRing = function (index) {
          if (index < 0 || this.ends_.length <= index) {
              return null;
          }
          return new LinearRing(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
      };
      /**
       * Return the linear rings of the polygon.
       * @return {Array<LinearRing>} Linear rings.
       * @api
       */
      Polygon.prototype.getLinearRings = function () {
          var layout = this.layout;
          var flatCoordinates = this.flatCoordinates;
          var ends = this.ends_;
          var linearRings = [];
          var offset = 0;
          for (var i = 0, ii = ends.length; i < ii; ++i) {
              var end = ends[i];
              var linearRing = new LinearRing(flatCoordinates.slice(offset, end), layout);
              linearRings.push(linearRing);
              offset = end;
          }
          return linearRings;
      };
      /**
       * @return {Array<number>} Oriented flat coordinates.
       */
      Polygon.prototype.getOrientedFlatCoordinates = function () {
          if (this.orientedRevision_ != this.getRevision()) {
              var flatCoordinates = this.flatCoordinates;
              if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
                  this.orientedFlatCoordinates_ = flatCoordinates;
              }
              else {
                  this.orientedFlatCoordinates_ = flatCoordinates.slice();
                  this.orientedFlatCoordinates_.length = orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride);
              }
              this.orientedRevision_ = this.getRevision();
          }
          return this.orientedFlatCoordinates_;
      };
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {Polygon} Simplified Polygon.
       * @protected
       */
      Polygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
          var simplifiedFlatCoordinates = [];
          var simplifiedEnds = [];
          simplifiedFlatCoordinates.length = quantizeArray(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEnds);
          return new Polygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);
      };
      /**
       * Get the type of this geometry.
       * @return {import("./GeometryType.js").default} Geometry type.
       * @api
       */
      Polygon.prototype.getType = function () {
          return GeometryType.POLYGON;
      };
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      Polygon.prototype.intersectsExtent = function (extent) {
          return intersectsLinearRingArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, extent);
      };
      /**
       * Set the coordinates of the polygon.
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @api
       */
      Polygon.prototype.setCoordinates = function (coordinates, opt_layout) {
          this.setLayout(opt_layout, coordinates, 2);
          if (!this.flatCoordinates) {
              this.flatCoordinates = [];
          }
          var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
          this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
          this.changed();
      };
      return Polygon;
  }(SimpleGeometry));
  /**
   * Create a polygon from an extent. The layout used is `XY`.
   * @param {import("../extent.js").Extent} extent The extent.
   * @return {Polygon} The polygon.
   * @api
   */
  function fromExtent(extent) {
      var minX = extent[0];
      var minY = extent[1];
      var maxX = extent[2];
      var maxY = extent[3];
      var flatCoordinates = [
          minX,
          minY,
          minX,
          maxY,
          maxX,
          maxY,
          maxX,
          minY,
          minX,
          minY,
      ];
      return new Polygon(flatCoordinates, GeometryLayout.XY, [
          flatCoordinates.length,
      ]);
  }

  var __extends$n = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * An animation configuration
   *
   * @typedef {Object} Animation
   * @property {import("./coordinate.js").Coordinate} [sourceCenter]
   * @property {import("./coordinate.js").Coordinate} [targetCenter]
   * @property {number} [sourceResolution]
   * @property {number} [targetResolution]
   * @property {number} [sourceRotation]
   * @property {number} [targetRotation]
   * @property {import("./coordinate.js").Coordinate} [anchor]
   * @property {number} start
   * @property {number} duration
   * @property {boolean} complete
   * @property {function(number):number} easing
   * @property {function(boolean):void} callback
   */
  /**
   * @typedef {Object} Constraints
   * @property {import("./centerconstraint.js").Type} center
   * @property {import("./resolutionconstraint.js").Type} resolution
   * @property {import("./rotationconstraint.js").Type} rotation
   */
  /**
   * @typedef {Object} FitOptions
   * @property {import("./size.js").Size} [size] The size in pixels of the box to fit
   * the extent into. Default is the current size of the first map in the DOM that
   * uses this view, or `[100, 100]` if no such map is found.
   * @property {!Array<number>} [padding=[0, 0, 0, 0]] Padding (in pixels) to be
   * cleared inside the view. Values in the array are top, right, bottom and left
   * padding.
   * @property {boolean} [nearest=false] If the view `constrainResolution` option is `true`,
   * get the nearest extent instead of the closest that actually fits the view.
   * @property {number} [minResolution=0] Minimum resolution that we zoom to.
   * @property {number} [maxZoom] Maximum zoom level that we zoom to. If
   * `minResolution` is given, this property is ignored.
   * @property {number} [duration] The duration of the animation in milliseconds.
   * By default, there is no animation to the target extent.
   * @property {function(number):number} [easing] The easing function used during
   * the animation (defaults to {@link module:ol/easing~inAndOut}).
   * The function will be called for each frame with a number representing a
   * fraction of the animation's duration.  The function should return a number
   * between 0 and 1 representing the progress toward the destination state.
   * @property {function(boolean):void} [callback] Function called when the view is in
   * its final position. The callback will be called with `true` if the animation
   * series completed on its own or `false` if it was cancelled.
   */
  /**
   * @typedef {Object} ViewOptions
   * @property {import("./coordinate.js").Coordinate} [center] The initial center for
   * the view. If a user projection is not set, the coordinate system for the center is
   * specified with the `projection` option. Layer sources will not be fetched if this
   * is not set, but the center can be set later with {@link #setCenter}.
   * @property {boolean|number} [constrainRotation=true] Rotation constraint.
   * `false` means no constraint. `true` means no constraint, but snap to zero
   * near zero. A number constrains the rotation to that number of values. For
   * example, `4` will constrain the rotation to 0, 90, 180, and 270 degrees.
   * @property {boolean} [enableRotation=true] Enable rotation.
   * If `false`, a rotation constraint that always sets the rotation to zero is
   * used. The `constrainRotation` option has no effect if `enableRotation` is
   * `false`.
   * @property {import("./extent.js").Extent} [extent] The extent that constrains the
   * view, in other words, nothing outside of this extent can be visible on the map.
   * @property {boolean} [constrainOnlyCenter=false] If true, the extent
   * constraint will only apply to the view center and not the whole extent.
   * @property {boolean} [smoothExtentConstraint=true] If true, the extent
   * constraint will be applied smoothly, i.e. allow the view to go slightly outside
   * of the given `extent`.
   * @property {number} [maxResolution] The maximum resolution used to determine
   * the resolution constraint. It is used together with `minResolution` (or
   * `maxZoom`) and `zoomFactor`. If unspecified it is calculated in such a way
   * that the projection's validity extent fits in a 256x256 px tile. If the
   * projection is Spherical Mercator (the default) then `maxResolution` defaults
   * to `40075016.68557849 / 256 = 156543.03392804097`.
   * @property {number} [minResolution] The minimum resolution used to determine
   * the resolution constraint.  It is used together with `maxResolution` (or
   * `minZoom`) and `zoomFactor`.  If unspecified it is calculated assuming 29
   * zoom levels (with a factor of 2). If the projection is Spherical Mercator
   * (the default) then `minResolution` defaults to
   * `40075016.68557849 / 256 / Math.pow(2, 28) = 0.0005831682455839253`.
   * @property {number} [maxZoom=28] The maximum zoom level used to determine the
   * resolution constraint. It is used together with `minZoom` (or
   * `maxResolution`) and `zoomFactor`.  Note that if `minResolution` is also
   * provided, it is given precedence over `maxZoom`.
   * @property {number} [minZoom=0] The minimum zoom level used to determine the
   * resolution constraint. It is used together with `maxZoom` (or
   * `minResolution`) and `zoomFactor`.  Note that if `maxResolution` is also
   * provided, it is given precedence over `minZoom`.
   * @property {boolean} [multiWorld=false] If `false` the view is constrained so
   * only one world is visible, and you cannot pan off the edge.  If `true` the map
   * may show multiple worlds at low zoom levels.  Only used if the `projection` is
   * global.  Note that if `extent` is also provided it is given precedence.
   * @property {boolean} [constrainResolution=false] If true, the view will always
   * animate to the closest zoom level after an interaction; false means
   * intermediary zoom levels are allowed.
   * @property {boolean} [smoothResolutionConstraint=true] If true, the resolution
   * min/max values will be applied smoothly, i. e. allow the view to exceed slightly
   * the given resolution or zoom bounds.
   * @property {boolean} [showFullExtent=false] Allow the view to be zoomed out to
   * show the full configured extent. By default, when a view is configured with an
   * extent, users will not be able to zoom out so the viewport exceeds the extent in
   * either dimension. This means the full extent may not be visible if the viewport
   * is taller or wider than the aspect ratio of the configured extent. If
   * showFullExtent is true, the user will be able to zoom out so that the viewport
   * exceeds the height or width of the configured extent, but not both, allowing the
   * full extent to be shown.
   * @property {import("./proj.js").ProjectionLike} [projection='EPSG:3857'] The
   * projection. The default is Spherical Mercator.
   * @property {number} [resolution] The initial resolution for the view. The
   * units are `projection` units per pixel (e.g. meters per pixel). An
   * alternative to setting this is to set `zoom`. Layer sources will not be
   * fetched if neither this nor `zoom` are defined, but they can be set later
   * with {@link #setZoom} or {@link #setResolution}.
   * @property {Array<number>} [resolutions] Resolutions to determine the
   * resolution constraint. If set the `maxResolution`, `minResolution`,
   * `minZoom`, `maxZoom`, and `zoomFactor` options are ignored.
   * @property {number} [rotation=0] The initial rotation for the view in radians
   * (positive rotation clockwise, 0 means North).
   * @property {number} [zoom] Only used if `resolution` is not defined. Zoom
   * level used to calculate the initial resolution for the view.
   * @property {number} [zoomFactor=2] The zoom factor used to compute the
   * corresponding resolution.
   */
  /**
   * @typedef {Object} AnimationOptions
   * @property {import("./coordinate.js").Coordinate} [center] The center of the view at the end of
   * the animation.
   * @property {number} [zoom] The zoom level of the view at the end of the
   * animation. This takes precedence over `resolution`.
   * @property {number} [resolution] The resolution of the view at the end
   * of the animation.  If `zoom` is also provided, this option will be ignored.
   * @property {number} [rotation] The rotation of the view at the end of
   * the animation.
   * @property {import("./coordinate.js").Coordinate} [anchor] Optional anchor to remain fixed
   * during a rotation or resolution animation.
   * @property {number} [duration=1000] The duration of the animation in milliseconds.
   * @property {function(number):number} [easing] The easing function used
   * during the animation (defaults to {@link module:ol/easing~inAndOut}).
   * The function will be called for each frame with a number representing a
   * fraction of the animation's duration.  The function should return a number
   * between 0 and 1 representing the progress toward the destination state.
   */
  /**
   * @typedef {Object} State
   * @property {import("./coordinate.js").Coordinate} center
   * @property {import("./proj/Projection.js").default} projection
   * @property {number} resolution
   * @property {number} rotation
   * @property {number} zoom
   */
  /**
   * Default min zoom level for the map view.
   * @type {number}
   */
  var DEFAULT_MIN_ZOOM = 0;
  /**
   * @classdesc
   * A View object represents a simple 2D view of the map.
   *
   * This is the object to act upon to change the center, resolution,
   * and rotation of the map.
   *
   * A View has a `projection`. The projection determines the
   * coordinate system of the center, and its units determine the units of the
   * resolution (projection units per pixel). The default projection is
   * Spherical Mercator (EPSG:3857).
   *
   * ### The view states
   *
   * A View is determined by three states: `center`, `resolution`,
   * and `rotation`. Each state has a corresponding getter and setter, e.g.
   * `getCenter` and `setCenter` for the `center` state.
   *
   * The `zoom` state is actually not saved on the view: all computations
   * internally use the `resolution` state. Still, the `setZoom` and `getZoom`
   * methods are available, as well as `getResolutionForZoom` and
   * `getZoomForResolution` to switch from one system to the other.
   *
   * ### The constraints
   *
   * `setCenter`, `setResolution` and `setRotation` can be used to change the
   * states of the view, but any constraint defined in the constructor will
   * be applied along the way.
   *
   * A View object can have a *resolution constraint*, a *rotation constraint*
   * and a *center constraint*.
   *
   * The *resolution constraint* typically restricts min/max values and
   * snaps to specific resolutions. It is determined by the following
   * options: `resolutions`, `maxResolution`, `maxZoom` and `zoomFactor`.
   * If `resolutions` is set, the other three options are ignored. See
   * documentation for each option for more information. By default, the view
   * only has a min/max restriction and allow intermediary zoom levels when
   * pinch-zooming for example.
   *
   * The *rotation constraint* snaps to specific angles. It is determined
   * by the following options: `enableRotation` and `constrainRotation`.
   * By default rotation is allowed and its value is snapped to zero when approaching the
   * horizontal.
   *
   * The *center constraint* is determined by the `extent` option. By
   * default the view center is not constrained at all.
   *
   * ### Changing the view state
   *
   * It is important to note that `setZoom`, `setResolution`, `setCenter` and
   * `setRotation` are subject to the above mentioned constraints. As such, it
   * may sometimes not be possible to know in advance the resulting state of the
   * View. For example, calling `setResolution(10)` does not guarantee that
   * `getResolution()` will return `10`.
   *
   * A consequence of this is that, when applying a delta on the view state, one
   * should use `adjustCenter`, `adjustRotation`, `adjustZoom` and `adjustResolution`
   * rather than the corresponding setters. This will let view do its internal
   * computations. Besides, the `adjust*` methods also take an `opt_anchor`
   * argument which allows specifying an origin for the transformation.
   *
   * ### Interacting with the view
   *
   * View constraints are usually only applied when the view is *at rest*, meaning that
   * no interaction or animation is ongoing. As such, if the user puts the view in a
   * state that is not equivalent to a constrained one (e.g. rotating the view when
   * the snap angle is 0), an animation will be triggered at the interaction end to
   * put back the view to a stable state;
   *
   * @api
   */
  var View = /** @class */ (function (_super) {
      __extends$n(View, _super);
      /**
       * @param {ViewOptions=} opt_options View options.
       */
      function View(opt_options) {
          var _this = _super.call(this) || this;
          var options = assign({}, opt_options);
          /**
           * @private
           * @type {Array<number>}
           */
          _this.hints_ = [0, 0];
          /**
           * @private
           * @type {Array<Array<Animation>>}
           */
          _this.animations_ = [];
          /**
           * @private
           * @type {number|undefined}
           */
          _this.updateAnimationKey_;
          /**
           * @private
           * @const
           * @type {import("./proj/Projection.js").default}
           */
          _this.projection_ = createProjection(options.projection, 'EPSG:3857');
          /**
           * @private
           * @type {import("./size.js").Size}
           */
          _this.viewportSize_ = [100, 100];
          /**
           * @private
           * @type {import("./coordinate.js").Coordinate|undefined}
           */
          _this.targetCenter_ = null;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.targetResolution_;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.targetRotation_;
          /**
           * @private
           * @type {import("./coordinate.js").Coordinate|undefined}
           */
          _this.cancelAnchor_ = undefined;
          if (options.center) {
              options.center = fromUserCoordinate(options.center, _this.projection_);
          }
          if (options.extent) {
              options.extent = fromUserExtent(options.extent, _this.projection_);
          }
          _this.applyOptions_(options);
          return _this;
      }
      /**
       * Set up the view with the given options.
       * @param {ViewOptions} options View options.
       */
      View.prototype.applyOptions_ = function (options) {
          /**
           * @type {Object<string, *>}
           */
          var properties = {};
          var resolutionConstraintInfo = createResolutionConstraint(options);
          /**
           * @private
           * @type {number}
           */
          this.maxResolution_ = resolutionConstraintInfo.maxResolution;
          /**
           * @private
           * @type {number}
           */
          this.minResolution_ = resolutionConstraintInfo.minResolution;
          /**
           * @private
           * @type {number}
           */
          this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
          /**
           * @private
           * @type {Array<number>|undefined}
           */
          this.resolutions_ = options.resolutions;
          /**
           * @private
           * @type {number}
           */
          this.minZoom_ = resolutionConstraintInfo.minZoom;
          var centerConstraint = createCenterConstraint(options);
          var resolutionConstraint = resolutionConstraintInfo.constraint;
          var rotationConstraint = createRotationConstraint(options);
          /**
           * @private
           * @type {Constraints}
           */
          this.constraints_ = {
              center: centerConstraint,
              resolution: resolutionConstraint,
              rotation: rotationConstraint,
          };
          this.setRotation(options.rotation !== undefined ? options.rotation : 0);
          this.setCenterInternal(options.center !== undefined ? options.center : null);
          if (options.resolution !== undefined) {
              this.setResolution(options.resolution);
          }
          else if (options.zoom !== undefined) {
              this.setZoom(options.zoom);
          }
          this.setProperties(properties);
          /**
           * @private
           * @type {ViewOptions}
           */
          this.options_ = options;
      };
      /**
       * Get an updated version of the view options used to construct the view.  The
       * current resolution (or zoom), center, and rotation are applied to any stored
       * options.  The provided options can be used to apply new min/max zoom or
       * resolution limits.
       * @param {ViewOptions} newOptions New options to be applied.
       * @return {ViewOptions} New options updated with the current view state.
       */
      View.prototype.getUpdatedOptions_ = function (newOptions) {
          var options = assign({}, this.options_);
          // preserve resolution (or zoom)
          if (options.resolution !== undefined) {
              options.resolution = this.getResolution();
          }
          else {
              options.zoom = this.getZoom();
          }
          // preserve center
          options.center = this.getCenterInternal();
          // preserve rotation
          options.rotation = this.getRotation();
          return assign({}, options, newOptions);
      };
      /**
       * Animate the view.  The view's center, zoom (or resolution), and rotation
       * can be animated for smooth transitions between view states.  For example,
       * to animate the view to a new zoom level:
       *
       *     view.animate({zoom: view.getZoom() + 1});
       *
       * By default, the animation lasts one second and uses in-and-out easing.  You
       * can customize this behavior by including `duration` (in milliseconds) and
       * `easing` options (see {@link module:ol/easing}).
       *
       * To chain together multiple animations, call the method with multiple
       * animation objects.  For example, to first zoom and then pan:
       *
       *     view.animate({zoom: 10}, {center: [0, 0]});
       *
       * If you provide a function as the last argument to the animate method, it
       * will get called at the end of an animation series.  The callback will be
       * called with `true` if the animation series completed on its own or `false`
       * if it was cancelled.
       *
       * Animations are cancelled by user interactions (e.g. dragging the map) or by
       * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
       * (or another method that calls one of these).
       *
       * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
       *     options.  Multiple animations can be run in series by passing multiple
       *     options objects.  To run multiple animations in parallel, call the method
       *     multiple times.  An optional callback can be provided as a final
       *     argument.  The callback will be called with a boolean indicating whether
       *     the animation completed without being cancelled.
       * @api
       */
      View.prototype.animate = function (var_args) {
          if (this.isDef() && !this.getAnimating()) {
              this.resolveConstraints(0);
          }
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; ++i) {
              var options = arguments[i];
              if (options.center) {
                  options = assign({}, options);
                  options.center = fromUserCoordinate(options.center, this.getProjection());
              }
              if (options.anchor) {
                  options = assign({}, options);
                  options.anchor = fromUserCoordinate(options.anchor, this.getProjection());
              }
              args[i] = options;
          }
          this.animateInternal.apply(this, args);
      };
      /**
       * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
       */
      View.prototype.animateInternal = function (var_args) {
          var animationCount = arguments.length;
          var callback;
          if (animationCount > 1 &&
              typeof arguments[animationCount - 1] === 'function') {
              callback = arguments[animationCount - 1];
              --animationCount;
          }
          if (!this.isDef()) {
              // if view properties are not yet set, shortcut to the final state
              var state = arguments[animationCount - 1];
              if (state.center) {
                  this.setCenterInternal(state.center);
              }
              if (state.zoom !== undefined) {
                  this.setZoom(state.zoom);
              }
              if (state.rotation !== undefined) {
                  this.setRotation(state.rotation);
              }
              if (callback) {
                  animationCallback(callback, true);
              }
              return;
          }
          var start = Date.now();
          var center = this.targetCenter_.slice();
          var resolution = this.targetResolution_;
          var rotation = this.targetRotation_;
          var series = [];
          for (var i = 0; i < animationCount; ++i) {
              var options = /** @type {AnimationOptions} */ (arguments[i]);
              var animation = {
                  start: start,
                  complete: false,
                  anchor: options.anchor,
                  duration: options.duration !== undefined ? options.duration : 1000,
                  easing: options.easing || inAndOut,
                  callback: callback,
              };
              if (options.center) {
                  animation.sourceCenter = center;
                  animation.targetCenter = options.center.slice();
                  center = animation.targetCenter;
              }
              if (options.zoom !== undefined) {
                  animation.sourceResolution = resolution;
                  animation.targetResolution = this.getResolutionForZoom(options.zoom);
                  resolution = animation.targetResolution;
              }
              else if (options.resolution) {
                  animation.sourceResolution = resolution;
                  animation.targetResolution = options.resolution;
                  resolution = animation.targetResolution;
              }
              if (options.rotation !== undefined) {
                  animation.sourceRotation = rotation;
                  var delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
                  animation.targetRotation = rotation + delta;
                  rotation = animation.targetRotation;
              }
              // check if animation is a no-op
              if (isNoopAnimation(animation)) {
                  animation.complete = true;
                  // we still push it onto the series for callback handling
              }
              else {
                  start += animation.duration;
              }
              series.push(animation);
          }
          this.animations_.push(series);
          this.setHint(ViewHint.ANIMATING, 1);
          this.updateAnimations_();
      };
      /**
       * Determine if the view is being animated.
       * @return {boolean} The view is being animated.
       * @api
       */
      View.prototype.getAnimating = function () {
          return this.hints_[ViewHint.ANIMATING] > 0;
      };
      /**
       * Determine if the user is interacting with the view, such as panning or zooming.
       * @return {boolean} The view is being interacted with.
       * @api
       */
      View.prototype.getInteracting = function () {
          return this.hints_[ViewHint.INTERACTING] > 0;
      };
      /**
       * Cancel any ongoing animations.
       * @api
       */
      View.prototype.cancelAnimations = function () {
          this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);
          var anchor;
          for (var i = 0, ii = this.animations_.length; i < ii; ++i) {
              var series = this.animations_[i];
              if (series[0].callback) {
                  animationCallback(series[0].callback, false);
              }
              if (!anchor) {
                  for (var j = 0, jj = series.length; j < jj; ++j) {
                      var animation = series[j];
                      if (!animation.complete) {
                          anchor = animation.anchor;
                          break;
                      }
                  }
              }
          }
          this.animations_.length = 0;
          this.cancelAnchor_ = anchor;
      };
      /**
       * Update all animations.
       */
      View.prototype.updateAnimations_ = function () {
          if (this.updateAnimationKey_ !== undefined) {
              cancelAnimationFrame(this.updateAnimationKey_);
              this.updateAnimationKey_ = undefined;
          }
          if (!this.getAnimating()) {
              return;
          }
          var now = Date.now();
          var more = false;
          for (var i = this.animations_.length - 1; i >= 0; --i) {
              var series = this.animations_[i];
              var seriesComplete = true;
              for (var j = 0, jj = series.length; j < jj; ++j) {
                  var animation = series[j];
                  if (animation.complete) {
                      continue;
                  }
                  var elapsed = now - animation.start;
                  var fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
                  if (fraction >= 1) {
                      animation.complete = true;
                      fraction = 1;
                  }
                  else {
                      seriesComplete = false;
                  }
                  var progress = animation.easing(fraction);
                  if (animation.sourceCenter) {
                      var x0 = animation.sourceCenter[0];
                      var y0 = animation.sourceCenter[1];
                      var x1 = animation.targetCenter[0];
                      var y1 = animation.targetCenter[1];
                      var x = x0 + progress * (x1 - x0);
                      var y = y0 + progress * (y1 - y0);
                      this.targetCenter_ = [x, y];
                  }
                  if (animation.sourceResolution && animation.targetResolution) {
                      var resolution = progress === 1
                          ? animation.targetResolution
                          : animation.sourceResolution +
                              progress *
                                  (animation.targetResolution - animation.sourceResolution);
                      if (animation.anchor) {
                          var size = this.getViewportSize_(this.getRotation());
                          var constrainedResolution = this.constraints_.resolution(resolution, 0, size, true);
                          this.targetCenter_ = this.calculateCenterZoom(constrainedResolution, animation.anchor);
                      }
                      this.targetResolution_ = resolution;
                      this.applyTargetState_(true);
                  }
                  if (animation.sourceRotation !== undefined &&
                      animation.targetRotation !== undefined) {
                      var rotation = progress === 1
                          ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) -
                              Math.PI
                          : animation.sourceRotation +
                              progress *
                                  (animation.targetRotation - animation.sourceRotation);
                      if (animation.anchor) {
                          var constrainedRotation = this.constraints_.rotation(rotation, true);
                          this.targetCenter_ = this.calculateCenterRotate(constrainedRotation, animation.anchor);
                      }
                      this.targetRotation_ = rotation;
                  }
                  this.applyTargetState_(true);
                  more = true;
                  if (!animation.complete) {
                      break;
                  }
              }
              if (seriesComplete) {
                  this.animations_[i] = null;
                  this.setHint(ViewHint.ANIMATING, -1);
                  var callback = series[0].callback;
                  if (callback) {
                      animationCallback(callback, true);
                  }
              }
          }
          // prune completed series
          this.animations_ = this.animations_.filter(Boolean);
          if (more && this.updateAnimationKey_ === undefined) {
              this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this));
          }
      };
      /**
       * @param {number} rotation Target rotation.
       * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
       * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
       */
      View.prototype.calculateCenterRotate = function (rotation, anchor) {
          var center;
          var currentCenter = this.getCenterInternal();
          if (currentCenter !== undefined) {
              center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
              rotate$1(center, rotation - this.getRotation());
              add$2(center, anchor);
          }
          return center;
      };
      /**
       * @param {number} resolution Target resolution.
       * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
       * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
       */
      View.prototype.calculateCenterZoom = function (resolution, anchor) {
          var center;
          var currentCenter = this.getCenterInternal();
          var currentResolution = this.getResolution();
          if (currentCenter !== undefined && currentResolution !== undefined) {
              var x = anchor[0] -
                  (resolution * (anchor[0] - currentCenter[0])) / currentResolution;
              var y = anchor[1] -
                  (resolution * (anchor[1] - currentCenter[1])) / currentResolution;
              center = [x, y];
          }
          return center;
      };
      /**
       * Returns the current viewport size.
       * @private
       * @param {number=} opt_rotation Take into account the rotation of the viewport when giving the size
       * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
       */
      View.prototype.getViewportSize_ = function (opt_rotation) {
          var size = this.viewportSize_;
          if (opt_rotation) {
              var w = size[0];
              var h = size[1];
              return [
                  Math.abs(w * Math.cos(opt_rotation)) +
                      Math.abs(h * Math.sin(opt_rotation)),
                  Math.abs(w * Math.sin(opt_rotation)) +
                      Math.abs(h * Math.cos(opt_rotation)),
              ];
          }
          else {
              return size;
          }
      };
      /**
       * Stores the viewport size on the view. The viewport size is not read every time from the DOM
       * to avoid performance hit and layout reflow.
       * This should be done on map size change.
       * Note: the constraints are not resolved during an animation to avoid stopping it
       * @param {import("./size.js").Size=} opt_size Viewport size; if undefined, [100, 100] is assumed
       */
      View.prototype.setViewportSize = function (opt_size) {
          this.viewportSize_ = Array.isArray(opt_size)
              ? opt_size.slice()
              : [100, 100];
          if (!this.getAnimating()) {
              this.resolveConstraints(0);
          }
      };
      /**
       * Get the view center.
       * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
       * @observable
       * @api
       */
      View.prototype.getCenter = function () {
          var center = this.getCenterInternal();
          if (!center) {
              return center;
          }
          return toUserCoordinate(center, this.getProjection());
      };
      /**
       * Get the view center without transforming to user projection.
       * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
       */
      View.prototype.getCenterInternal = function () {
          return /** @type {import("./coordinate.js").Coordinate|undefined} */ (this.get(ViewProperty.CENTER));
      };
      /**
       * @return {Constraints} Constraints.
       */
      View.prototype.getConstraints = function () {
          return this.constraints_;
      };
      /**
       * @return {boolean} Resolution constraint is set
       */
      View.prototype.getConstrainResolution = function () {
          return this.options_.constrainResolution;
      };
      /**
       * @param {Array<number>=} opt_hints Destination array.
       * @return {Array<number>} Hint.
       */
      View.prototype.getHints = function (opt_hints) {
          if (opt_hints !== undefined) {
              opt_hints[0] = this.hints_[0];
              opt_hints[1] = this.hints_[1];
              return opt_hints;
          }
          else {
              return this.hints_.slice();
          }
      };
      /**
       * Calculate the extent for the current view state and the passed size.
       * The size is the pixel dimensions of the box into which the calculated extent
       * should fit. In most cases you want to get the extent of the entire map,
       * that is `map.getSize()`.
       * @param {import("./size.js").Size=} opt_size Box pixel size. If not provided, the size
       * of the map that uses this view will be used.
       * @return {import("./extent.js").Extent} Extent.
       * @api
       */
      View.prototype.calculateExtent = function (opt_size) {
          var extent = this.calculateExtentInternal(opt_size);
          return toUserExtent(extent, this.getProjection());
      };
      /**
       * @param {import("./size.js").Size=} opt_size Box pixel size. If not provided, the size of the
       * first map that uses this view will be used.
       * @return {import("./extent.js").Extent} Extent.
       */
      View.prototype.calculateExtentInternal = function (opt_size) {
          var size = opt_size || this.getViewportSize_();
          var center = /** @type {!import("./coordinate.js").Coordinate} */ (this.getCenterInternal());
          assert(center, 1); // The view center is not defined
          var resolution = /** @type {!number} */ (this.getResolution());
          assert(resolution !== undefined, 2); // The view resolution is not defined
          var rotation = /** @type {!number} */ (this.getRotation());
          assert(rotation !== undefined, 3); // The view rotation is not defined
          return getForViewAndSize(center, resolution, rotation, size);
      };
      /**
       * Get the maximum resolution of the view.
       * @return {number} The maximum resolution of the view.
       * @api
       */
      View.prototype.getMaxResolution = function () {
          return this.maxResolution_;
      };
      /**
       * Get the minimum resolution of the view.
       * @return {number} The minimum resolution of the view.
       * @api
       */
      View.prototype.getMinResolution = function () {
          return this.minResolution_;
      };
      /**
       * Get the maximum zoom level for the view.
       * @return {number} The maximum zoom level.
       * @api
       */
      View.prototype.getMaxZoom = function () {
          return /** @type {number} */ (this.getZoomForResolution(this.minResolution_));
      };
      /**
       * Set a new maximum zoom level for the view.
       * @param {number} zoom The maximum zoom level.
       * @api
       */
      View.prototype.setMaxZoom = function (zoom) {
          this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));
      };
      /**
       * Get the minimum zoom level for the view.
       * @return {number} The minimum zoom level.
       * @api
       */
      View.prototype.getMinZoom = function () {
          return /** @type {number} */ (this.getZoomForResolution(this.maxResolution_));
      };
      /**
       * Set a new minimum zoom level for the view.
       * @param {number} zoom The minimum zoom level.
       * @api
       */
      View.prototype.setMinZoom = function (zoom) {
          this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));
      };
      /**
       * Set whether the view shoud allow intermediary zoom levels.
       * @param {boolean} enabled Whether the resolution is constrained.
       * @api
       */
      View.prototype.setConstrainResolution = function (enabled) {
          this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: enabled }));
      };
      /**
       * Get the view projection.
       * @return {import("./proj/Projection.js").default} The projection of the view.
       * @api
       */
      View.prototype.getProjection = function () {
          return this.projection_;
      };
      /**
       * Get the view resolution.
       * @return {number|undefined} The resolution of the view.
       * @observable
       * @api
       */
      View.prototype.getResolution = function () {
          return /** @type {number|undefined} */ (this.get(ViewProperty.RESOLUTION));
      };
      /**
       * Get the resolutions for the view. This returns the array of resolutions
       * passed to the constructor of the View, or undefined if none were given.
       * @return {Array<number>|undefined} The resolutions of the view.
       * @api
       */
      View.prototype.getResolutions = function () {
          return this.resolutions_;
      };
      /**
       * Get the resolution for a provided extent (in map units) and size (in pixels).
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {import("./size.js").Size=} opt_size Box pixel size.
       * @return {number} The resolution at which the provided extent will render at
       *     the given size.
       * @api
       */
      View.prototype.getResolutionForExtent = function (extent, opt_size) {
          return this.getResolutionForExtentInternal(fromUserExtent(extent, this.getProjection()), opt_size);
      };
      /**
       * Get the resolution for a provided extent (in map units) and size (in pixels).
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {import("./size.js").Size=} opt_size Box pixel size.
       * @return {number} The resolution at which the provided extent will render at
       *     the given size.
       */
      View.prototype.getResolutionForExtentInternal = function (extent, opt_size) {
          var size = opt_size || this.getViewportSize_();
          var xResolution = getWidth(extent) / size[0];
          var yResolution = getHeight(extent) / size[1];
          return Math.max(xResolution, yResolution);
      };
      /**
       * Return a function that returns a value between 0 and 1 for a
       * resolution. Exponential scaling is assumed.
       * @param {number=} opt_power Power.
       * @return {function(number): number} Resolution for value function.
       */
      View.prototype.getResolutionForValueFunction = function (opt_power) {
          var power = opt_power || 2;
          var maxResolution = this.getConstrainedResolution(this.maxResolution_);
          var minResolution = this.minResolution_;
          var max = Math.log(maxResolution / minResolution) / Math.log(power);
          return (
          /**
           * @param {number} value Value.
           * @return {number} Resolution.
           */
          function (value) {
              var resolution = maxResolution / Math.pow(power, value * max);
              return resolution;
          });
      };
      /**
       * Get the view rotation.
       * @return {number} The rotation of the view in radians.
       * @observable
       * @api
       */
      View.prototype.getRotation = function () {
          return /** @type {number} */ (this.get(ViewProperty.ROTATION));
      };
      /**
       * Return a function that returns a resolution for a value between
       * 0 and 1. Exponential scaling is assumed.
       * @param {number=} opt_power Power.
       * @return {function(number): number} Value for resolution function.
       */
      View.prototype.getValueForResolutionFunction = function (opt_power) {
          var logPower = Math.log(opt_power || 2);
          var maxResolution = this.getConstrainedResolution(this.maxResolution_);
          var minResolution = this.minResolution_;
          var max = Math.log(maxResolution / minResolution) / logPower;
          return (
          /**
           * @param {number} resolution Resolution.
           * @return {number} Value.
           */
          function (resolution) {
              var value = Math.log(maxResolution / resolution) / logPower / max;
              return value;
          });
      };
      /**
       * @return {State} View state.
       */
      View.prototype.getState = function () {
          var center = /** @type {import("./coordinate.js").Coordinate} */ (this.getCenterInternal());
          var projection = this.getProjection();
          var resolution = /** @type {number} */ (this.getResolution());
          var rotation = this.getRotation();
          return {
              center: center.slice(0),
              projection: projection !== undefined ? projection : null,
              resolution: resolution,
              rotation: rotation,
              zoom: this.getZoom(),
          };
      };
      /**
       * Get the current zoom level. This method may return non-integer zoom levels
       * if the view does not constrain the resolution, or if an interaction or
       * animation is underway.
       * @return {number|undefined} Zoom.
       * @api
       */
      View.prototype.getZoom = function () {
          var zoom;
          var resolution = this.getResolution();
          if (resolution !== undefined) {
              zoom = this.getZoomForResolution(resolution);
          }
          return zoom;
      };
      /**
       * Get the zoom level for a resolution.
       * @param {number} resolution The resolution.
       * @return {number|undefined} The zoom level for the provided resolution.
       * @api
       */
      View.prototype.getZoomForResolution = function (resolution) {
          var offset = this.minZoom_ || 0;
          var max, zoomFactor;
          if (this.resolutions_) {
              var nearest = linearFindNearest(this.resolutions_, resolution, 1);
              offset = nearest;
              max = this.resolutions_[nearest];
              if (nearest == this.resolutions_.length - 1) {
                  zoomFactor = 2;
              }
              else {
                  zoomFactor = max / this.resolutions_[nearest + 1];
              }
          }
          else {
              max = this.maxResolution_;
              zoomFactor = this.zoomFactor_;
          }
          return offset + Math.log(max / resolution) / Math.log(zoomFactor);
      };
      /**
       * Get the resolution for a zoom level.
       * @param {number} zoom Zoom level.
       * @return {number} The view resolution for the provided zoom level.
       * @api
       */
      View.prototype.getResolutionForZoom = function (zoom) {
          if (this.resolutions_) {
              if (this.resolutions_.length <= 1) {
                  return 0;
              }
              var baseLevel = clamp(Math.floor(zoom), 0, this.resolutions_.length - 2);
              var zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
              return (this.resolutions_[baseLevel] /
                  Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1)));
          }
          else {
              return (this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_));
          }
      };
      /**
       * Fit the given geometry or extent based on the given map size and border.
       * The size is pixel dimensions of the box to fit the extent into.
       * In most cases you will want to use the map size, that is `map.getSize()`.
       * Takes care of the map angle.
       * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
       *     extent to fit the view to.
       * @param {FitOptions=} opt_options Options.
       * @api
       */
      View.prototype.fit = function (geometryOrExtent, opt_options) {
          var options = assign({ size: this.getViewportSize_() }, opt_options || {});
          /** @type {import("./geom/SimpleGeometry.js").default} */
          var geometry;
          assert(Array.isArray(geometryOrExtent) ||
              typeof ( /** @type {?} */(geometryOrExtent).getSimplifiedGeometry) ===
                  'function', 24); // Invalid extent or geometry provided as `geometry`
          if (Array.isArray(geometryOrExtent)) {
              assert(!isEmpty(geometryOrExtent), 25); // Cannot fit empty extent provided as `geometry`
              var extent = fromUserExtent(geometryOrExtent, this.getProjection());
              geometry = fromExtent(extent);
          }
          else if (geometryOrExtent.getType() === GeometryType.CIRCLE) {
              var extent = fromUserExtent(geometryOrExtent.getExtent(), this.getProjection());
              geometry = fromExtent(extent);
              geometry.rotate(this.getRotation(), getCenter(extent));
          }
          else {
              var userProjection = getUserProjection();
              if (userProjection) {
                  geometry = /** @type {import("./geom/SimpleGeometry.js").default} */ (geometryOrExtent
                      .clone()
                      .transform(userProjection, this.getProjection()));
              }
              else {
                  geometry = geometryOrExtent;
              }
          }
          this.fitInternal(geometry, options);
      };
      /**
       * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
       * @param {FitOptions=} opt_options Options.
       */
      View.prototype.fitInternal = function (geometry, opt_options) {
          var options = opt_options || {};
          var size = options.size;
          if (!size) {
              size = this.getViewportSize_();
          }
          var padding = options.padding !== undefined ? options.padding : [0, 0, 0, 0];
          var nearest = options.nearest !== undefined ? options.nearest : false;
          var minResolution;
          if (options.minResolution !== undefined) {
              minResolution = options.minResolution;
          }
          else if (options.maxZoom !== undefined) {
              minResolution = this.getResolutionForZoom(options.maxZoom);
          }
          else {
              minResolution = 0;
          }
          var coords = geometry.getFlatCoordinates();
          // calculate rotated extent
          var rotation = this.getRotation();
          var cosAngle = Math.cos(-rotation);
          var sinAngle = Math.sin(-rotation);
          var minRotX = +Infinity;
          var minRotY = +Infinity;
          var maxRotX = -Infinity;
          var maxRotY = -Infinity;
          var stride = geometry.getStride();
          for (var i = 0, ii = coords.length; i < ii; i += stride) {
              var rotX = coords[i] * cosAngle - coords[i + 1] * sinAngle;
              var rotY = coords[i] * sinAngle + coords[i + 1] * cosAngle;
              minRotX = Math.min(minRotX, rotX);
              minRotY = Math.min(minRotY, rotY);
              maxRotX = Math.max(maxRotX, rotX);
              maxRotY = Math.max(maxRotY, rotY);
          }
          // calculate resolution
          var resolution = this.getResolutionForExtentInternal([minRotX, minRotY, maxRotX, maxRotY], [size[0] - padding[1] - padding[3], size[1] - padding[0] - padding[2]]);
          resolution = isNaN(resolution)
              ? minResolution
              : Math.max(resolution, minResolution);
          resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
          // calculate center
          sinAngle = -sinAngle; // go back to original rotation
          var centerRotX = (minRotX + maxRotX) / 2;
          var centerRotY = (minRotY + maxRotY) / 2;
          centerRotX += ((padding[1] - padding[3]) / 2) * resolution;
          centerRotY += ((padding[0] - padding[2]) / 2) * resolution;
          var centerX = centerRotX * cosAngle - centerRotY * sinAngle;
          var centerY = centerRotY * cosAngle + centerRotX * sinAngle;
          var center = [centerX, centerY];
          var callback = options.callback ? options.callback : VOID;
          if (options.duration !== undefined) {
              this.animateInternal({
                  resolution: resolution,
                  center: this.getConstrainedCenter(center, resolution),
                  duration: options.duration,
                  easing: options.easing,
              }, callback);
          }
          else {
              this.targetResolution_ = resolution;
              this.targetCenter_ = center;
              this.applyTargetState_(false, true);
              animationCallback(callback, true);
          }
      };
      /**
       * Center on coordinate and view position.
       * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("./size.js").Size} size Box pixel size.
       * @param {import("./pixel.js").Pixel} position Position on the view to center on.
       * @api
       */
      View.prototype.centerOn = function (coordinate, size, position) {
          this.centerOnInternal(fromUserCoordinate(coordinate, this.getProjection()), size, position);
      };
      /**
       * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("./size.js").Size} size Box pixel size.
       * @param {import("./pixel.js").Pixel} position Position on the view to center on.
       */
      View.prototype.centerOnInternal = function (coordinate, size, position) {
          // calculate rotated position
          var rotation = this.getRotation();
          var cosAngle = Math.cos(-rotation);
          var sinAngle = Math.sin(-rotation);
          var rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
          var rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
          var resolution = this.getResolution();
          rotX += (size[0] / 2 - position[0]) * resolution;
          rotY += (position[1] - size[1] / 2) * resolution;
          // go back to original angle
          sinAngle = -sinAngle; // go back to original rotation
          var centerX = rotX * cosAngle - rotY * sinAngle;
          var centerY = rotY * cosAngle + rotX * sinAngle;
          this.setCenterInternal([centerX, centerY]);
      };
      /**
       * @return {boolean} Is defined.
       */
      View.prototype.isDef = function () {
          return !!this.getCenterInternal() && this.getResolution() !== undefined;
      };
      /**
       * Adds relative coordinates to the center of the view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
       * @api
       */
      View.prototype.adjustCenter = function (deltaCoordinates) {
          var center = toUserCoordinate(this.targetCenter_, this.getProjection());
          this.setCenter([
              center[0] + deltaCoordinates[0],
              center[1] + deltaCoordinates[1],
          ]);
      };
      /**
       * Adds relative coordinates to the center of the view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
       */
      View.prototype.adjustCenterInternal = function (deltaCoordinates) {
          var center = this.targetCenter_;
          this.setCenterInternal([
              center[0] + deltaCoordinates[0],
              center[1] + deltaCoordinates[1],
          ]);
      };
      /**
       * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} ratio The ratio to apply on the view resolution.
       * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
       * @api
       */
      View.prototype.adjustResolution = function (ratio, opt_anchor) {
          var anchor = opt_anchor && fromUserCoordinate(opt_anchor, this.getProjection());
          this.adjustResolutionInternal(ratio, anchor);
      };
      /**
       * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} ratio The ratio to apply on the view resolution.
       * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
       */
      View.prototype.adjustResolutionInternal = function (ratio, opt_anchor) {
          var isMoving = this.getAnimating() || this.getInteracting();
          var size = this.getViewportSize_(this.getRotation());
          var newResolution = this.constraints_.resolution(this.targetResolution_ * ratio, 0, size, isMoving);
          if (opt_anchor) {
              this.targetCenter_ = this.calculateCenterZoom(newResolution, opt_anchor);
          }
          this.targetResolution_ *= ratio;
          this.applyTargetState_();
      };
      /**
       * Adds a value to the view zoom level, optionally using an anchor. Any resolution
       * constraint will apply.
       * @param {number} delta Relative value to add to the zoom level.
       * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
       * @api
       */
      View.prototype.adjustZoom = function (delta, opt_anchor) {
          this.adjustResolution(Math.pow(this.zoomFactor_, -delta), opt_anchor);
      };
      /**
       * Adds a value to the view rotation, optionally using an anchor. Any rotation
       * constraint will apply.
       * @param {number} delta Relative value to add to the zoom rotation, in radians.
       * @param {import("./coordinate.js").Coordinate=} opt_anchor The rotation center.
       * @api
       */
      View.prototype.adjustRotation = function (delta, opt_anchor) {
          if (opt_anchor) {
              opt_anchor = fromUserCoordinate(opt_anchor, this.getProjection());
          }
          this.adjustRotationInternal(delta, opt_anchor);
      };
      /**
       * @param {number} delta Relative value to add to the zoom rotation, in radians.
       * @param {import("./coordinate.js").Coordinate=} opt_anchor The rotation center.
       */
      View.prototype.adjustRotationInternal = function (delta, opt_anchor) {
          var isMoving = this.getAnimating() || this.getInteracting();
          var newRotation = this.constraints_.rotation(this.targetRotation_ + delta, isMoving);
          if (opt_anchor) {
              this.targetCenter_ = this.calculateCenterRotate(newRotation, opt_anchor);
          }
          this.targetRotation_ += delta;
          this.applyTargetState_();
      };
      /**
       * Set the center of the current view. Any extent constraint will apply.
       * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
       * @observable
       * @api
       */
      View.prototype.setCenter = function (center) {
          this.setCenterInternal(fromUserCoordinate(center, this.getProjection()));
      };
      /**
       * Set the center using the view projection (not the user projection).
       * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
       */
      View.prototype.setCenterInternal = function (center) {
          this.targetCenter_ = center;
          this.applyTargetState_();
      };
      /**
       * @param {import("./ViewHint.js").default} hint Hint.
       * @param {number} delta Delta.
       * @return {number} New value.
       */
      View.prototype.setHint = function (hint, delta) {
          this.hints_[hint] += delta;
          this.changed();
          return this.hints_[hint];
      };
      /**
       * Set the resolution for this view. Any resolution constraint will apply.
       * @param {number|undefined} resolution The resolution of the view.
       * @observable
       * @api
       */
      View.prototype.setResolution = function (resolution) {
          this.targetResolution_ = resolution;
          this.applyTargetState_();
      };
      /**
       * Set the rotation for this view. Any rotation constraint will apply.
       * @param {number} rotation The rotation of the view in radians.
       * @observable
       * @api
       */
      View.prototype.setRotation = function (rotation) {
          this.targetRotation_ = rotation;
          this.applyTargetState_();
      };
      /**
       * Zoom to a specific zoom level. Any resolution constrain will apply.
       * @param {number} zoom Zoom level.
       * @api
       */
      View.prototype.setZoom = function (zoom) {
          this.setResolution(this.getResolutionForZoom(zoom));
      };
      /**
       * Recompute rotation/resolution/center based on target values.
       * Note: we have to compute rotation first, then resolution and center considering that
       * parameters can influence one another in case a view extent constraint is present.
       * @param {boolean=} opt_doNotCancelAnims Do not cancel animations.
       * @param {boolean=} opt_forceMoving Apply constraints as if the view is moving.
       * @private
       */
      View.prototype.applyTargetState_ = function (opt_doNotCancelAnims, opt_forceMoving) {
          var isMoving = this.getAnimating() || this.getInteracting() || opt_forceMoving;
          // compute rotation
          var newRotation = this.constraints_.rotation(this.targetRotation_, isMoving);
          var size = this.getViewportSize_(newRotation);
          var newResolution = this.constraints_.resolution(this.targetResolution_, 0, size, isMoving);
          var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size, isMoving);
          if (this.get(ViewProperty.ROTATION) !== newRotation) {
              this.set(ViewProperty.ROTATION, newRotation);
          }
          if (this.get(ViewProperty.RESOLUTION) !== newResolution) {
              this.set(ViewProperty.RESOLUTION, newResolution);
          }
          if (!this.get(ViewProperty.CENTER) ||
              !equals$2(this.get(ViewProperty.CENTER), newCenter)) {
              this.set(ViewProperty.CENTER, newCenter);
          }
          if (this.getAnimating() && !opt_doNotCancelAnims) {
              this.cancelAnimations();
          }
          this.cancelAnchor_ = undefined;
      };
      /**
       * If any constraints need to be applied, an animation will be triggered.
       * This is typically done on interaction end.
       * Note: calling this with a duration of 0 will apply the constrained values straight away,
       * without animation.
       * @param {number=} opt_duration The animation duration in ms.
       * @param {number=} opt_resolutionDirection Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
       */
      View.prototype.resolveConstraints = function (opt_duration, opt_resolutionDirection, opt_anchor) {
          var duration = opt_duration !== undefined ? opt_duration : 200;
          var direction = opt_resolutionDirection || 0;
          var newRotation = this.constraints_.rotation(this.targetRotation_);
          var size = this.getViewportSize_(newRotation);
          var newResolution = this.constraints_.resolution(this.targetResolution_, direction, size);
          var newCenter = this.constraints_.center(this.targetCenter_, newResolution, size);
          if (duration === 0 && !this.cancelAnchor_) {
              this.targetResolution_ = newResolution;
              this.targetRotation_ = newRotation;
              this.targetCenter_ = newCenter;
              this.applyTargetState_();
              return;
          }
          var anchor = opt_anchor || (duration === 0 ? this.cancelAnchor_ : undefined);
          this.cancelAnchor_ = undefined;
          if (this.getResolution() !== newResolution ||
              this.getRotation() !== newRotation ||
              !this.getCenterInternal() ||
              !equals$2(this.getCenterInternal(), newCenter)) {
              if (this.getAnimating()) {
                  this.cancelAnimations();
              }
              this.animateInternal({
                  rotation: newRotation,
                  center: newCenter,
                  resolution: newResolution,
                  duration: duration,
                  easing: easeOut,
                  anchor: anchor,
              });
          }
      };
      /**
       * Notify the View that an interaction has started.
       * The view state will be resolved to a stable one if needed
       * (depending on its constraints).
       * @api
       */
      View.prototype.beginInteraction = function () {
          this.resolveConstraints(0);
          this.setHint(ViewHint.INTERACTING, 1);
      };
      /**
       * Notify the View that an interaction has ended. The view state will be resolved
       * to a stable one if needed (depending on its constraints).
       * @param {number=} opt_duration Animation duration in ms.
       * @param {number=} opt_resolutionDirection Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
       * @api
       */
      View.prototype.endInteraction = function (opt_duration, opt_resolutionDirection, opt_anchor) {
          var anchor = opt_anchor && fromUserCoordinate(opt_anchor, this.getProjection());
          this.endInteractionInternal(opt_duration, opt_resolutionDirection, anchor);
      };
      /**
       * Notify the View that an interaction has ended. The view state will be resolved
       * to a stable one if needed (depending on its constraints).
       * @param {number=} opt_duration Animation duration in ms.
       * @param {number=} opt_resolutionDirection Which direction to zoom.
       * @param {import("./coordinate.js").Coordinate=} opt_anchor The origin of the transformation.
       */
      View.prototype.endInteractionInternal = function (opt_duration, opt_resolutionDirection, opt_anchor) {
          this.setHint(ViewHint.INTERACTING, -1);
          this.resolveConstraints(opt_duration, opt_resolutionDirection, opt_anchor);
      };
      /**
       * Get a valid position for the view center according to the current constraints.
       * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
       * @param {number=} opt_targetResolution Target resolution. If not supplied, the current one will be used.
       * This is useful to guess a valid center position at a different zoom level.
       * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
       */
      View.prototype.getConstrainedCenter = function (targetCenter, opt_targetResolution) {
          var size = this.getViewportSize_(this.getRotation());
          return this.constraints_.center(targetCenter, opt_targetResolution || this.getResolution(), size);
      };
      /**
       * Get a valid zoom level according to the current view constraints.
       * @param {number|undefined} targetZoom Target zoom.
       * @param {number=} [opt_direction=0] Indicate which resolution should be used
       * by a renderer if the view resolution does not match any resolution of the tile source.
       * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
       * will be used. If -1, the nearest higher resolution will be used.
       * @return {number|undefined} Valid zoom level.
       */
      View.prototype.getConstrainedZoom = function (targetZoom, opt_direction) {
          var targetRes = this.getResolutionForZoom(targetZoom);
          return this.getZoomForResolution(this.getConstrainedResolution(targetRes, opt_direction));
      };
      /**
       * Get a valid resolution according to the current view constraints.
       * @param {number|undefined} targetResolution Target resolution.
       * @param {number=} [opt_direction=0] Indicate which resolution should be used
       * by a renderer if the view resolution does not match any resolution of the tile source.
       * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
       * will be used. If -1, the nearest higher resolution will be used.
       * @return {number|undefined} Valid resolution.
       */
      View.prototype.getConstrainedResolution = function (targetResolution, opt_direction) {
          var direction = opt_direction || 0;
          var size = this.getViewportSize_(this.getRotation());
          return this.constraints_.resolution(targetResolution, direction, size);
      };
      return View;
  }(BaseObject));
  /**
   * @param {Function} callback Callback.
   * @param {*} returnValue Return value.
   */
  function animationCallback(callback, returnValue) {
      setTimeout(function () {
          callback(returnValue);
      }, 0);
  }
  /**
   * @param {ViewOptions} options View options.
   * @return {import("./centerconstraint.js").Type} The constraint.
   */
  function createCenterConstraint(options) {
      if (options.extent !== undefined) {
          var smooth = options.smoothExtentConstraint !== undefined
              ? options.smoothExtentConstraint
              : true;
          return createExtent(options.extent, options.constrainOnlyCenter, smooth);
      }
      var projection = createProjection(options.projection, 'EPSG:3857');
      if (options.multiWorld !== true && projection.isGlobal()) {
          var extent = projection.getExtent().slice();
          extent[0] = -Infinity;
          extent[2] = Infinity;
          return createExtent(extent, false, false);
      }
      return none;
  }
  /**
   * @param {ViewOptions} options View options.
   * @return {{constraint: import("./resolutionconstraint.js").Type, maxResolution: number,
   *     minResolution: number, minZoom: number, zoomFactor: number}} The constraint.
   */
  function createResolutionConstraint(options) {
      var resolutionConstraint;
      var maxResolution;
      var minResolution;
      // TODO: move these to be ol constants
      // see https://github.com/openlayers/openlayers/issues/2076
      var defaultMaxZoom = 28;
      var defaultZoomFactor = 2;
      var minZoom = options.minZoom !== undefined ? options.minZoom : DEFAULT_MIN_ZOOM;
      var maxZoom = options.maxZoom !== undefined ? options.maxZoom : defaultMaxZoom;
      var zoomFactor = options.zoomFactor !== undefined ? options.zoomFactor : defaultZoomFactor;
      var multiWorld = options.multiWorld !== undefined ? options.multiWorld : false;
      var smooth = options.smoothResolutionConstraint !== undefined
          ? options.smoothResolutionConstraint
          : true;
      var showFullExtent = options.showFullExtent !== undefined ? options.showFullExtent : false;
      var projection = createProjection(options.projection, 'EPSG:3857');
      var projExtent = projection.getExtent();
      var constrainOnlyCenter = options.constrainOnlyCenter;
      var extent = options.extent;
      if (!multiWorld && !extent && projection.isGlobal()) {
          constrainOnlyCenter = false;
          extent = projExtent;
      }
      if (options.resolutions !== undefined) {
          var resolutions = options.resolutions;
          maxResolution = resolutions[minZoom];
          minResolution =
              resolutions[maxZoom] !== undefined
                  ? resolutions[maxZoom]
                  : resolutions[resolutions.length - 1];
          if (options.constrainResolution) {
              resolutionConstraint = createSnapToResolutions(resolutions, smooth, !constrainOnlyCenter && extent, showFullExtent);
          }
          else {
              resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
          }
      }
      else {
          // calculate the default min and max resolution
          var size = !projExtent
              ? // use an extent that can fit the whole world if need be
                  (360 * METERS_PER_UNIT[Units.DEGREES]) / projection.getMetersPerUnit()
              : Math.max(getWidth(projExtent), getHeight(projExtent));
          var defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
          var defaultMinResolution = defaultMaxResolution /
              Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
          // user provided maxResolution takes precedence
          maxResolution = options.maxResolution;
          if (maxResolution !== undefined) {
              minZoom = 0;
          }
          else {
              maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
          }
          // user provided minResolution takes precedence
          minResolution = options.minResolution;
          if (minResolution === undefined) {
              if (options.maxZoom !== undefined) {
                  if (options.maxResolution !== undefined) {
                      minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
                  }
                  else {
                      minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
                  }
              }
              else {
                  minResolution = defaultMinResolution;
              }
          }
          // given discrete zoom levels, minResolution may be different than provided
          maxZoom =
              minZoom +
                  Math.floor(Math.log(maxResolution / minResolution) / Math.log(zoomFactor));
          minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
          if (options.constrainResolution) {
              resolutionConstraint = createSnapToPower(zoomFactor, maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
          }
          else {
              resolutionConstraint = createMinMaxResolution(maxResolution, minResolution, smooth, !constrainOnlyCenter && extent, showFullExtent);
          }
      }
      return {
          constraint: resolutionConstraint,
          maxResolution: maxResolution,
          minResolution: minResolution,
          minZoom: minZoom,
          zoomFactor: zoomFactor,
      };
  }
  /**
   * @param {ViewOptions} options View options.
   * @return {import("./rotationconstraint.js").Type} Rotation constraint.
   */
  function createRotationConstraint(options) {
      var enableRotation = options.enableRotation !== undefined ? options.enableRotation : true;
      if (enableRotation) {
          var constrainRotation = options.constrainRotation;
          if (constrainRotation === undefined || constrainRotation === true) {
              return createSnapToZero();
          }
          else if (constrainRotation === false) {
              return none$1;
          }
          else if (typeof constrainRotation === 'number') {
              return createSnapToN(constrainRotation);
          }
          else {
              return none$1;
          }
      }
      else {
          return disable;
      }
  }
  /**
   * Determine if an animation involves no view change.
   * @param {Animation} animation The animation.
   * @return {boolean} The animation involves no view change.
   */
  function isNoopAnimation(animation) {
      if (animation.sourceCenter && animation.targetCenter) {
          if (!equals$2(animation.sourceCenter, animation.targetCenter)) {
              return false;
          }
      }
      if (animation.sourceResolution !== animation.targetResolution) {
          return false;
      }
      if (animation.sourceRotation !== animation.targetRotation) {
          return false;
      }
      return true;
  }

  /**
   * @module ol/size
   */
  /**
   * An array of numbers representing a size: `[width, height]`.
   * @typedef {Array<number>} Size
   * @api
   */
  /**
   * Returns a buffered size.
   * @param {Size} size Size.
   * @param {number} num The amount by which to buffer.
   * @param {Size=} opt_size Optional reusable size array.
   * @return {Size} The buffered size.
   */
  function buffer$1(size, num, opt_size) {
      if (opt_size === undefined) {
          opt_size = [0, 0];
      }
      opt_size[0] = size[0] + 2 * num;
      opt_size[1] = size[1] + 2 * num;
      return opt_size;
  }
  /**
   * Determines if a size has a positive area.
   * @param {Size} size The size to test.
   * @return {boolean} The size has a positive area.
   */
  function hasArea(size) {
      return size[0] > 0 && size[1] > 0;
  }
  /**
   * Returns a size scaled by a ratio. The result will be an array of integers.
   * @param {Size} size Size.
   * @param {number} ratio Ratio.
   * @param {Size=} opt_size Optional reusable size array.
   * @return {Size} The scaled size.
   */
  function scale$2(size, ratio, opt_size) {
      if (opt_size === undefined) {
          opt_size = [0, 0];
      }
      opt_size[0] = (size[0] * ratio + 0.5) | 0;
      opt_size[1] = (size[1] * ratio + 0.5) | 0;
      return opt_size;
  }
  /**
   * Returns an `Size` array for the passed in number (meaning: square) or
   * `Size` array.
   * (meaning: non-square),
   * @param {number|Size} size Width and height.
   * @param {Size=} opt_size Optional reusable size array.
   * @return {Size} Size.
   * @api
   */
  function toSize(size, opt_size) {
      if (Array.isArray(size)) {
          return size;
      }
      else {
          if (opt_size === undefined) {
              opt_size = [size, size];
          }
          else {
              opt_size[0] = size;
              opt_size[1] = size;
          }
          return opt_size;
      }
  }

  var __extends$o = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * State of the current frame. Only `pixelRatio`, `time` and `viewState` should
   * be used in applications.
   * @typedef {Object} FrameState
   * @property {number} pixelRatio The pixel ratio of the frame.
   * @property {number} time The time when rendering of the frame was requested.
   * @property {import("./View.js").State} viewState The state of the current view.
   * @property {boolean} animate
   * @property {import("./transform.js").Transform} coordinateToPixelTransform
   * @property {null|import("./extent.js").Extent} extent
   * @property {Array<DeclutterItems>} declutterItems
   * @property {number} index
   * @property {Array<import("./layer/Layer.js").State>} layerStatesArray
   * @property {number} layerIndex
   * @property {import("./transform.js").Transform} pixelToCoordinateTransform
   * @property {Array<PostRenderFunction>} postRenderFunctions
   * @property {import("./size.js").Size} size
   * @property {TileQueue} tileQueue
   * @property {!Object<string, Object<string, boolean>>} usedTiles
   * @property {Array<number>} viewHints
   * @property {!Object<string, Object<string, boolean>>} wantedTiles
   */
  /**
   * @typedef {Object} DeclutterItems
   * @property {Array<*>} items Declutter items of an executor.
   * @property {number} opacity Layer opacity.
   */
  /**
   * @typedef {function(PluggableMap, ?FrameState): any} PostRenderFunction
   */
  /**
   * @typedef {Object} AtPixelOptions
   * @property {undefined|function(import("./layer/Layer.js").default): boolean} [layerFilter] Layer filter
   * function. The filter function will receive one argument, the
   * {@link module:ol/layer/Layer layer-candidate} and it should return a boolean value.
   * Only layers which are visible and for which this function returns `true`
   * will be tested for features. By default, all visible layers will be tested.
   * @property {number} [hitTolerance=0] Hit-detection tolerance in pixels. Pixels
   * inside the radius around the given position will be checked for features.
   * @property {boolean} [checkWrapped=true] Check-Wrapped Will check for for wrapped geometries inside the range of
   *   +/- 1 world width. Works only if a projection is used that can be wrapped.
   */
  /**
   * @typedef {Object} MapOptionsInternal
   * @property {Collection<import("./control/Control.js").default>} [controls]
   * @property {Collection<import("./interaction/Interaction.js").default>} [interactions]
   * @property {HTMLElement|Document} keyboardEventTarget
   * @property {Collection<import("./Overlay.js").default>} overlays
   * @property {Object<string, *>} values
   */
  /**
   * Object literal with config options for the map.
   * @typedef {Object} MapOptions
   * @property {Collection<import("./control/Control.js").default>|Array<import("./control/Control.js").default>} [controls]
   * Controls initially added to the map. If not specified,
   * {@link module:ol/control~defaults} is used.
   * @property {number} [pixelRatio=window.devicePixelRatio] The ratio between
   * physical pixels and device-independent pixels (dips) on the device.
   * @property {Collection<import("./interaction/Interaction.js").default>|Array<import("./interaction/Interaction.js").default>} [interactions]
   * Interactions that are initially added to the map. If not specified,
   * {@link module:ol/interaction~defaults} is used.
   * @property {HTMLElement|Document|string} [keyboardEventTarget] The element to
   * listen to keyboard events on. This determines when the `KeyboardPan` and
   * `KeyboardZoom` interactions trigger. For example, if this option is set to
   * `document` the keyboard interactions will always trigger. If this option is
   * not specified, the element the library listens to keyboard events on is the
   * map target (i.e. the user-provided div for the map). If this is not
   * `document`, the target element needs to be focused for key events to be
   * emitted, requiring that the target element has a `tabindex` attribute.
   * @property {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>|LayerGroup} [layers]
   * Layers. If this is not defined, a map with no layers will be rendered. Note
   * that layers are rendered in the order supplied, so if you want, for example,
   * a vector layer to appear on top of a tile layer, it must come after the tile
   * layer.
   * @property {number} [maxTilesLoading=16] Maximum number tiles to load
   * simultaneously.
   * @property {number} [moveTolerance=1] The minimum distance in pixels the
   * cursor must move to be detected as a map move event instead of a click.
   * Increasing this value can make it easier to click on the map.
   * @property {Collection<import("./Overlay.js").default>|Array<import("./Overlay.js").default>} [overlays]
   * Overlays initially added to the map. By default, no overlays are added.
   * @property {HTMLElement|string} [target] The container for the map, either the
   * element itself or the `id` of the element. If not specified at construction
   * time, {@link module:ol/Map~Map#setTarget} must be called for the map to be
   * rendered.
   * @property {View} [view] The map's view.  No layer sources will be
   * fetched unless this is specified at construction time or through
   * {@link module:ol/Map~Map#setView}.
   */
  /**
   * @fires import("./MapBrowserEvent.js").MapBrowserEvent
   * @fires import("./MapEvent.js").MapEvent
   * @fires import("./render/Event.js").default#precompose
   * @fires import("./render/Event.js").default#postcompose
   * @fires import("./render/Event.js").default#rendercomplete
   * @api
   */
  var PluggableMap = /** @class */ (function (_super) {
      __extends$o(PluggableMap, _super);
      /**
       * @param {MapOptions} options Map options.
       */
      function PluggableMap(options) {
          var _this = _super.call(this) || this;
          var optionsInternal = createOptionsInternal(options);
          /** @private */
          _this.boundHandleBrowserEvent_ = _this.handleBrowserEvent.bind(_this);
          /**
           * @type {number}
           * @private
           */
          _this.maxTilesLoading_ =
              options.maxTilesLoading !== undefined ? options.maxTilesLoading : 16;
          /**
           * @private
           * @type {number}
           */
          _this.pixelRatio_ =
              options.pixelRatio !== undefined
                  ? options.pixelRatio
                  : DEVICE_PIXEL_RATIO;
          /**
           * @private
           * @type {*}
           */
          _this.postRenderTimeoutHandle_;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.animationDelayKey_;
          /**
           * @private
           */
          _this.animationDelay_ = function () {
              this.animationDelayKey_ = undefined;
              this.renderFrame_(Date.now());
          }.bind(_this);
          /**
           * @private
           * @type {import("./transform.js").Transform}
           */
          _this.coordinateToPixelTransform_ = create();
          /**
           * @private
           * @type {import("./transform.js").Transform}
           */
          _this.pixelToCoordinateTransform_ = create();
          /**
           * @private
           * @type {number}
           */
          _this.frameIndex_ = 0;
          /**
           * @private
           * @type {?FrameState}
           */
          _this.frameState_ = null;
          /**
           * The extent at the previous 'moveend' event.
           * @private
           * @type {import("./extent.js").Extent}
           */
          _this.previousExtent_ = null;
          /**
           * @private
           * @type {?import("./events.js").EventsKey}
           */
          _this.viewPropertyListenerKey_ = null;
          /**
           * @private
           * @type {?import("./events.js").EventsKey}
           */
          _this.viewChangeListenerKey_ = null;
          /**
           * @private
           * @type {?Array<import("./events.js").EventsKey>}
           */
          _this.layerGroupPropertyListenerKeys_ = null;
          /**
           * @private
           * @type {!HTMLElement}
           */
          _this.viewport_ = document.createElement('div');
          _this.viewport_.className =
              'ol-viewport' + ('ontouchstart' in window ? ' ol-touch' : '');
          _this.viewport_.style.position = 'relative';
          _this.viewport_.style.overflow = 'hidden';
          _this.viewport_.style.width = '100%';
          _this.viewport_.style.height = '100%';
          /**
           * @private
           * @type {!HTMLElement}
           */
          _this.overlayContainer_ = document.createElement('div');
          _this.overlayContainer_.style.position = 'absolute';
          _this.overlayContainer_.style.zIndex = '0';
          _this.overlayContainer_.style.width = '100%';
          _this.overlayContainer_.style.height = '100%';
          _this.overlayContainer_.style.pointerEvents = 'none';
          _this.overlayContainer_.className = 'ol-overlaycontainer';
          _this.viewport_.appendChild(_this.overlayContainer_);
          /**
           * @private
           * @type {!HTMLElement}
           */
          _this.overlayContainerStopEvent_ = document.createElement('div');
          _this.overlayContainerStopEvent_.style.position = 'absolute';
          _this.overlayContainerStopEvent_.style.zIndex = '0';
          _this.overlayContainerStopEvent_.style.width = '100%';
          _this.overlayContainerStopEvent_.style.height = '100%';
          _this.overlayContainerStopEvent_.style.pointerEvents = 'none';
          _this.overlayContainerStopEvent_.className = 'ol-overlaycontainer-stopevent';
          _this.viewport_.appendChild(_this.overlayContainerStopEvent_);
          /**
           * @private
           * @type {MapBrowserEventHandler}
           */
          _this.mapBrowserEventHandler_ = null;
          /**
           * @private
           * @type {number}
           */
          _this.moveTolerance_ = options.moveTolerance;
          /**
           * @private
           * @type {HTMLElement|Document}
           */
          _this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
          /**
           * @private
           * @type {?Array<import("./events.js").EventsKey>}
           */
          _this.keyHandlerKeys_ = null;
          /**
           * @type {Collection<import("./control/Control.js").default>}
           * @protected
           */
          _this.controls = optionsInternal.controls || new Collection();
          /**
           * @type {Collection<import("./interaction/Interaction.js").default>}
           * @protected
           */
          _this.interactions = optionsInternal.interactions || new Collection();
          /**
           * @type {Collection<import("./Overlay.js").default>}
           * @private
           */
          _this.overlays_ = optionsInternal.overlays;
          /**
           * A lookup of overlays by id.
           * @private
           * @type {Object<string, import("./Overlay.js").default>}
           */
          _this.overlayIdIndex_ = {};
          /**
           * @type {import("./renderer/Map.js").default}
           * @private
           */
          _this.renderer_ = null;
          /**
           * @type {undefined|function(Event): void}
           * @private
           */
          _this.handleResize_;
          /**
           * @private
           * @type {!Array<PostRenderFunction>}
           */
          _this.postRenderFunctions_ = [];
          /**
           * @private
           * @type {TileQueue}
           */
          _this.tileQueue_ = new TileQueue(_this.getTilePriority.bind(_this), _this.handleTileChange_.bind(_this));
          _this.addEventListener(getChangeEventType(MapProperty.LAYERGROUP), _this.handleLayerGroupChanged_);
          _this.addEventListener(getChangeEventType(MapProperty.VIEW), _this.handleViewChanged_);
          _this.addEventListener(getChangeEventType(MapProperty.SIZE), _this.handleSizeChanged_);
          _this.addEventListener(getChangeEventType(MapProperty.TARGET), _this.handleTargetChanged_);
          // setProperties will trigger the rendering of the map if the map
          // is "defined" already.
          _this.setProperties(optionsInternal.values);
          _this.controls.forEach(
          /**
           * @param {import("./control/Control.js").default} control Control.
           * @this {PluggableMap}
           */
          function (control) {
              control.setMap(this);
          }.bind(_this));
          _this.controls.addEventListener(CollectionEventType.ADD, 
          /**
           * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
           */
          function (event) {
              event.element.setMap(this);
          }.bind(_this));
          _this.controls.addEventListener(CollectionEventType.REMOVE, 
          /**
           * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
           */
          function (event) {
              event.element.setMap(null);
          }.bind(_this));
          _this.interactions.forEach(
          /**
           * @param {import("./interaction/Interaction.js").default} interaction Interaction.
           * @this {PluggableMap}
           */
          function (interaction) {
              interaction.setMap(this);
          }.bind(_this));
          _this.interactions.addEventListener(CollectionEventType.ADD, 
          /**
           * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
           */
          function (event) {
              event.element.setMap(this);
          }.bind(_this));
          _this.interactions.addEventListener(CollectionEventType.REMOVE, 
          /**
           * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
           */
          function (event) {
              event.element.setMap(null);
          }.bind(_this));
          _this.overlays_.forEach(_this.addOverlayInternal_.bind(_this));
          _this.overlays_.addEventListener(CollectionEventType.ADD, 
          /**
           * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
           */
          function (event) {
              this.addOverlayInternal_(
              /** @type {import("./Overlay.js").default} */ (event.element));
          }.bind(_this));
          _this.overlays_.addEventListener(CollectionEventType.REMOVE, 
          /**
           * @param {import("./Collection.js").CollectionEvent} event CollectionEvent.
           */
          function (event) {
              var overlay = /** @type {import("./Overlay.js").default} */ (event.element);
              var id = overlay.getId();
              if (id !== undefined) {
                  delete this.overlayIdIndex_[id.toString()];
              }
              event.element.setMap(null);
          }.bind(_this));
          return _this;
      }
      /**
       * @abstract
       * @return {import("./renderer/Map.js").default} The map renderer
       */
      PluggableMap.prototype.createRenderer = function () {
          throw new Error('Use a map type that has a createRenderer method');
      };
      /**
       * Add the given control to the map.
       * @param {import("./control/Control.js").default} control Control.
       * @api
       */
      PluggableMap.prototype.addControl = function (control) {
          this.getControls().push(control);
      };
      /**
       * Add the given interaction to the map. If you want to add an interaction
       * at another point of the collection use `getInteraction()` and the methods
       * available on {@link module:ol/Collection~Collection}. This can be used to
       * stop the event propagation from the handleEvent function. The interactions
       * get to handle the events in the reverse order of this collection.
       * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
       * @api
       */
      PluggableMap.prototype.addInteraction = function (interaction) {
          this.getInteractions().push(interaction);
      };
      /**
       * Adds the given layer to the top of this map. If you want to add a layer
       * elsewhere in the stack, use `getLayers()` and the methods available on
       * {@link module:ol/Collection~Collection}.
       * @param {import("./layer/Base.js").default} layer Layer.
       * @api
       */
      PluggableMap.prototype.addLayer = function (layer) {
          var layers = this.getLayerGroup().getLayers();
          layers.push(layer);
      };
      /**
       * Add the given overlay to the map.
       * @param {import("./Overlay.js").default} overlay Overlay.
       * @api
       */
      PluggableMap.prototype.addOverlay = function (overlay) {
          this.getOverlays().push(overlay);
      };
      /**
       * This deals with map's overlay collection changes.
       * @param {import("./Overlay.js").default} overlay Overlay.
       * @private
       */
      PluggableMap.prototype.addOverlayInternal_ = function (overlay) {
          var id = overlay.getId();
          if (id !== undefined) {
              this.overlayIdIndex_[id.toString()] = overlay;
          }
          overlay.setMap(this);
      };
      /**
       *
       * Clean up.
       */
      PluggableMap.prototype.disposeInternal = function () {
          this.setTarget(null);
          _super.prototype.disposeInternal.call(this);
      };
      /**
       * Detect features that intersect a pixel on the viewport, and execute a
       * callback with each intersecting feature. Layers included in the detection can
       * be configured through the `layerFilter` option in `opt_options`.
       * @param {import("./pixel.js").Pixel} pixel Pixel.
       * @param {function(this: S, import("./Feature.js").FeatureLike,
       *     import("./layer/Layer.js").default): T} callback Feature callback. The callback will be
       *     called with two arguments. The first argument is one
       *     {@link module:ol/Feature feature} or
       *     {@link module:ol/render/Feature render feature} at the pixel, the second is
       *     the {@link module:ol/layer/Layer layer} of the feature and will be null for
       *     unmanaged layers. To stop detection, callback functions can return a
       *     truthy value.
       * @param {AtPixelOptions=} opt_options Optional options.
       * @return {T|undefined} Callback result, i.e. the return value of last
       * callback execution, or the first truthy callback return value.
       * @template S,T
       * @api
       */
      PluggableMap.prototype.forEachFeatureAtPixel = function (pixel, callback, opt_options) {
          if (!this.frameState_) {
              return;
          }
          var coordinate = this.getCoordinateFromPixelInternal(pixel);
          opt_options = opt_options !== undefined ? opt_options : {};
          var hitTolerance = opt_options.hitTolerance !== undefined
              ? opt_options.hitTolerance * this.frameState_.pixelRatio
              : 0;
          var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;
          var checkWrapped = opt_options.checkWrapped !== false;
          return this.renderer_.forEachFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, callback, null, layerFilter, null);
      };
      /**
       * Get all features that intersect a pixel on the viewport.
       * @param {import("./pixel.js").Pixel} pixel Pixel.
       * @param {AtPixelOptions=} opt_options Optional options.
       * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
       * an empty array if none were found.
       * @api
       */
      PluggableMap.prototype.getFeaturesAtPixel = function (pixel, opt_options) {
          var features = [];
          this.forEachFeatureAtPixel(pixel, function (feature) {
              features.push(feature);
          }, opt_options);
          return features;
      };
      /**
       * Detect layers that have a color value at a pixel on the viewport, and
       * execute a callback with each matching layer. Layers included in the
       * detection can be configured through `opt_layerFilter`.
       *
       * Note: this may give false positives unless the map layers have had different `className`
       * properties assigned to them.
       *
       * @param {import("./pixel.js").Pixel} pixel Pixel.
       * @param {function(this: S, import("./layer/Layer.js").default, (Uint8ClampedArray|Uint8Array)): T} callback
       *     Layer callback. This callback will receive two arguments: first is the
       *     {@link module:ol/layer/Layer layer}, second argument is an array representing
       *     [R, G, B, A] pixel values (0 - 255) and will be `null` for layer types
       *     that do not currently support this argument. To stop detection, callback
       *     functions can return a truthy value.
       * @param {AtPixelOptions=} opt_options Configuration options.
       * @return {T|undefined} Callback result, i.e. the return value of last
       * callback execution, or the first truthy callback return value.
       * @template S,T
       * @api
       */
      PluggableMap.prototype.forEachLayerAtPixel = function (pixel, callback, opt_options) {
          if (!this.frameState_) {
              return;
          }
          var options = opt_options || {};
          var hitTolerance = options.hitTolerance !== undefined
              ? options.hitTolerance * this.frameState_.pixelRatio
              : 0;
          var layerFilter = options.layerFilter || TRUE;
          return this.renderer_.forEachLayerAtPixel(pixel, this.frameState_, hitTolerance, callback, layerFilter);
      };
      /**
       * Detect if features intersect a pixel on the viewport. Layers included in the
       * detection can be configured through `opt_layerFilter`.
       * @param {import("./pixel.js").Pixel} pixel Pixel.
       * @param {AtPixelOptions=} opt_options Optional options.
       * @return {boolean} Is there a feature at the given pixel?
       * @api
       */
      PluggableMap.prototype.hasFeatureAtPixel = function (pixel, opt_options) {
          if (!this.frameState_) {
              return false;
          }
          var coordinate = this.getCoordinateFromPixelInternal(pixel);
          opt_options = opt_options !== undefined ? opt_options : {};
          var layerFilter = opt_options.layerFilter !== undefined ? opt_options.layerFilter : TRUE;
          var hitTolerance = opt_options.hitTolerance !== undefined
              ? opt_options.hitTolerance * this.frameState_.pixelRatio
              : 0;
          var checkWrapped = opt_options.checkWrapped !== false;
          return this.renderer_.hasFeatureAtCoordinate(coordinate, this.frameState_, hitTolerance, checkWrapped, layerFilter, null);
      };
      /**
       * Returns the coordinate in user projection for a browser event.
       * @param {MouseEvent} event Event.
       * @return {import("./coordinate.js").Coordinate} Coordinate.
       * @api
       */
      PluggableMap.prototype.getEventCoordinate = function (event) {
          return this.getCoordinateFromPixel(this.getEventPixel(event));
      };
      /**
       * Returns the coordinate in view projection for a browser event.
       * @param {MouseEvent} event Event.
       * @return {import("./coordinate.js").Coordinate} Coordinate.
       */
      PluggableMap.prototype.getEventCoordinateInternal = function (event) {
          return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
      };
      /**
       * Returns the map pixel position for a browser event relative to the viewport.
       * @param {UIEvent} event Event.
       * @return {import("./pixel.js").Pixel} Pixel.
       * @api
       */
      PluggableMap.prototype.getEventPixel = function (event) {
          var viewportPosition = this.viewport_.getBoundingClientRect();
          var eventPosition = 
          //FIXME Are we really calling this with a TouchEvent anywhere?
          'changedTouches' in event
              ? /** @type {TouchEvent} */ (event).changedTouches[0]
              : /** @type {MouseEvent} */ (event);
          return [
              eventPosition.clientX - viewportPosition.left,
              eventPosition.clientY - viewportPosition.top,
          ];
      };
      /**
       * Get the target in which this map is rendered.
       * Note that this returns what is entered as an option or in setTarget:
       * if that was an element, it returns an element; if a string, it returns that.
       * @return {HTMLElement|string|undefined} The Element or id of the Element that the
       *     map is rendered in.
       * @observable
       * @api
       */
      PluggableMap.prototype.getTarget = function () {
          return /** @type {HTMLElement|string|undefined} */ (this.get(MapProperty.TARGET));
      };
      /**
       * Get the DOM element into which this map is rendered. In contrast to
       * `getTarget` this method always return an `Element`, or `null` if the
       * map has no target.
       * @return {HTMLElement} The element that the map is rendered in.
       * @api
       */
      PluggableMap.prototype.getTargetElement = function () {
          var target = this.getTarget();
          if (target !== undefined) {
              return typeof target === 'string'
                  ? document.getElementById(target)
                  : target;
          }
          else {
              return null;
          }
      };
      /**
       * Get the coordinate for a given pixel.  This returns a coordinate in the
       * user projection.
       * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
       * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
       * @api
       */
      PluggableMap.prototype.getCoordinateFromPixel = function (pixel) {
          return toUserCoordinate(this.getCoordinateFromPixelInternal(pixel), this.getView().getProjection());
      };
      /**
       * Get the coordinate for a given pixel.  This returns a coordinate in the
       * map view projection.
       * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
       * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
       */
      PluggableMap.prototype.getCoordinateFromPixelInternal = function (pixel) {
          var frameState = this.frameState_;
          if (!frameState) {
              return null;
          }
          else {
              return apply(frameState.pixelToCoordinateTransform, pixel.slice());
          }
      };
      /**
       * Get the map controls. Modifying this collection changes the controls
       * associated with the map.
       * @return {Collection<import("./control/Control.js").default>} Controls.
       * @api
       */
      PluggableMap.prototype.getControls = function () {
          return this.controls;
      };
      /**
       * Get the map overlays. Modifying this collection changes the overlays
       * associated with the map.
       * @return {Collection<import("./Overlay.js").default>} Overlays.
       * @api
       */
      PluggableMap.prototype.getOverlays = function () {
          return this.overlays_;
      };
      /**
       * Get an overlay by its identifier (the value returned by overlay.getId()).
       * Note that the index treats string and numeric identifiers as the same. So
       * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
       * @param {string|number} id Overlay identifier.
       * @return {import("./Overlay.js").default} Overlay.
       * @api
       */
      PluggableMap.prototype.getOverlayById = function (id) {
          var overlay = this.overlayIdIndex_[id.toString()];
          return overlay !== undefined ? overlay : null;
      };
      /**
       * Get the map interactions. Modifying this collection changes the interactions
       * associated with the map.
       *
       * Interactions are used for e.g. pan, zoom and rotate.
       * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
       * @api
       */
      PluggableMap.prototype.getInteractions = function () {
          return this.interactions;
      };
      /**
       * Get the layergroup associated with this map.
       * @return {LayerGroup} A layer group containing the layers in this map.
       * @observable
       * @api
       */
      PluggableMap.prototype.getLayerGroup = function () {
          return /** @type {LayerGroup} */ (this.get(MapProperty.LAYERGROUP));
      };
      /**
       * Get the collection of layers associated with this map.
       * @return {!Collection<import("./layer/Base.js").default>} Layers.
       * @api
       */
      PluggableMap.prototype.getLayers = function () {
          var layers = this.getLayerGroup().getLayers();
          return layers;
      };
      /**
       * @return {boolean} Layers have sources that are still loading.
       */
      PluggableMap.prototype.getLoading = function () {
          var layerStatesArray = this.getLayerGroup().getLayerStatesArray();
          for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
              var layer = layerStatesArray[i].layer;
              var source = /** @type {import("./layer/Layer.js").default} */ (layer).getSource();
              if (source && source.loading) {
                  return true;
              }
          }
          return false;
      };
      /**
       * Get the pixel for a coordinate.  This takes a coordinate in the user
       * projection and returns the corresponding pixel.
       * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
       * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
       * @api
       */
      PluggableMap.prototype.getPixelFromCoordinate = function (coordinate) {
          var viewCoordinate = fromUserCoordinate(coordinate, this.getView().getProjection());
          return this.getPixelFromCoordinateInternal(viewCoordinate);
      };
      /**
       * Get the pixel for a coordinate.  This takes a coordinate in the map view
       * projection and returns the corresponding pixel.
       * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
       * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
       */
      PluggableMap.prototype.getPixelFromCoordinateInternal = function (coordinate) {
          var frameState = this.frameState_;
          if (!frameState) {
              return null;
          }
          else {
              return apply(frameState.coordinateToPixelTransform, coordinate.slice(0, 2));
          }
      };
      /**
       * Get the map renderer.
       * @return {import("./renderer/Map.js").default} Renderer
       */
      PluggableMap.prototype.getRenderer = function () {
          return this.renderer_;
      };
      /**
       * Get the size of this map.
       * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
       * @observable
       * @api
       */
      PluggableMap.prototype.getSize = function () {
          return /** @type {import("./size.js").Size|undefined} */ (this.get(MapProperty.SIZE));
      };
      /**
       * Get the view associated with this map. A view manages properties such as
       * center and resolution.
       * @return {View} The view that controls this map.
       * @observable
       * @api
       */
      PluggableMap.prototype.getView = function () {
          return /** @type {View} */ (this.get(MapProperty.VIEW));
      };
      /**
       * Get the element that serves as the map viewport.
       * @return {HTMLElement} Viewport.
       * @api
       */
      PluggableMap.prototype.getViewport = function () {
          return this.viewport_;
      };
      /**
       * Get the element that serves as the container for overlays.  Elements added to
       * this container will let mousedown and touchstart events through to the map,
       * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
       * events.
       * @return {!HTMLElement} The map's overlay container.
       */
      PluggableMap.prototype.getOverlayContainer = function () {
          return this.overlayContainer_;
      };
      /**
       * Get the element that serves as a container for overlays that don't allow
       * event propagation. Elements added to this container won't let mousedown and
       * touchstart events through to the map, so clicks and gestures on an overlay
       * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
       * @return {!HTMLElement} The map's overlay container that stops events.
       */
      PluggableMap.prototype.getOverlayContainerStopEvent = function () {
          return this.overlayContainerStopEvent_;
      };
      /**
       * @param {import("./Tile.js").default} tile Tile.
       * @param {string} tileSourceKey Tile source key.
       * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
       * @param {number} tileResolution Tile resolution.
       * @return {number} Tile priority.
       */
      PluggableMap.prototype.getTilePriority = function (tile, tileSourceKey, tileCenter, tileResolution) {
          return getTilePriority(this.frameState_, tile, tileSourceKey, tileCenter, tileResolution);
      };
      /**
       * @param {UIEvent} browserEvent Browser event.
       * @param {string=} opt_type Type.
       */
      PluggableMap.prototype.handleBrowserEvent = function (browserEvent, opt_type) {
          var type = opt_type || browserEvent.type;
          var mapBrowserEvent = new MapBrowserEvent(type, this, browserEvent);
          this.handleMapBrowserEvent(mapBrowserEvent);
      };
      /**
       * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
       */
      PluggableMap.prototype.handleMapBrowserEvent = function (mapBrowserEvent) {
          if (!this.frameState_) {
              // With no view defined, we cannot translate pixels into geographical
              // coordinates so interactions cannot be used.
              return;
          }
          var originalEvent = /** @type {PointerEvent} */ (mapBrowserEvent.originalEvent);
          var eventType = originalEvent.type;
          if (eventType === PointerEventType.POINTERDOWN ||
              eventType === EventType.WHEEL ||
              eventType === EventType.KEYDOWN) {
              var rootNode = this.viewport_.getRootNode
                  ? this.viewport_.getRootNode()
                  : document;
              var target = rootNode === document
                  ? /** @type {Node} */ (originalEvent.target)
                  : /** @type {ShadowRoot} */ (rootNode).elementFromPoint(originalEvent.clientX, originalEvent.clientY);
              if (
              // Abort if the target is a child of the container for elements whose events are not meant
              // to be handled by map interactions.
              this.overlayContainerStopEvent_.contains(target) ||
                  // Abort if the event target is a child of the container that is no longer in the page.
                  // It's possible for the target to no longer be in the page if it has been removed in an
                  // event listener, this might happen in a Control that recreates it's content based on
                  // user interaction either manually or via a render in something like https://reactjs.org/
                  !(rootNode === document ? document.documentElement : rootNode).contains(target)) {
                  return;
              }
          }
          mapBrowserEvent.frameState = this.frameState_;
          var interactionsArray = this.getInteractions().getArray();
          if (this.dispatchEvent(mapBrowserEvent) !== false) {
              for (var i = interactionsArray.length - 1; i >= 0; i--) {
                  var interaction = interactionsArray[i];
                  if (!interaction.getActive()) {
                      continue;
                  }
                  var cont = interaction.handleEvent(mapBrowserEvent);
                  if (!cont) {
                      break;
                  }
              }
          }
      };
      /**
       * @protected
       */
      PluggableMap.prototype.handlePostRender = function () {
          var frameState = this.frameState_;
          // Manage the tile queue
          // Image loads are expensive and a limited resource, so try to use them
          // efficiently:
          // * When the view is static we allow a large number of parallel tile loads
          //   to complete the frame as quickly as possible.
          // * When animating or interacting, image loads can cause janks, so we reduce
          //   the maximum number of loads per frame and limit the number of parallel
          //   tile loads to remain reactive to view changes and to reduce the chance of
          //   loading tiles that will quickly disappear from view.
          var tileQueue = this.tileQueue_;
          if (!tileQueue.isEmpty()) {
              var maxTotalLoading = this.maxTilesLoading_;
              var maxNewLoads = maxTotalLoading;
              if (frameState) {
                  var hints = frameState.viewHints;
                  if (hints[ViewHint.ANIMATING] || hints[ViewHint.INTERACTING]) {
                      var lowOnFrameBudget = !IMAGE_DECODE && Date.now() - frameState.time > 8;
                      maxTotalLoading = lowOnFrameBudget ? 0 : 8;
                      maxNewLoads = lowOnFrameBudget ? 0 : 2;
                  }
              }
              if (tileQueue.getTilesLoading() < maxTotalLoading) {
                  tileQueue.reprioritize(); // FIXME only call if view has changed
                  tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
              }
          }
          if (frameState &&
              this.hasListener(EventType$1.RENDERCOMPLETE) &&
              !frameState.animate &&
              !this.tileQueue_.getTilesLoading() &&
              !this.getLoading()) {
              this.renderer_.dispatchRenderEvent(EventType$1.RENDERCOMPLETE, frameState);
          }
          var postRenderFunctions = this.postRenderFunctions_;
          for (var i = 0, ii = postRenderFunctions.length; i < ii; ++i) {
              postRenderFunctions[i](this, frameState);
          }
          postRenderFunctions.length = 0;
      };
      /**
       * @private
       */
      PluggableMap.prototype.handleSizeChanged_ = function () {
          if (this.getView() && !this.getView().getAnimating()) {
              this.getView().resolveConstraints(0);
          }
          this.render();
      };
      /**
       * @private
       */
      PluggableMap.prototype.handleTargetChanged_ = function () {
          // target may be undefined, null, a string or an Element.
          // If it's a string we convert it to an Element before proceeding.
          // If it's not now an Element we remove the viewport from the DOM.
          // If it's an Element we append the viewport element to it.
          var targetElement;
          if (this.getTarget()) {
              targetElement = this.getTargetElement();
          }
          if (this.mapBrowserEventHandler_) {
              for (var i = 0, ii = this.keyHandlerKeys_.length; i < ii; ++i) {
                  unlistenByKey(this.keyHandlerKeys_[i]);
              }
              this.keyHandlerKeys_ = null;
              this.viewport_.removeEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_);
              this.viewport_.removeEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_);
              if (this.handleResize_ !== undefined) {
                  removeEventListener(EventType.RESIZE, this.handleResize_, false);
                  this.handleResize_ = undefined;
              }
              this.mapBrowserEventHandler_.dispose();
              this.mapBrowserEventHandler_ = null;
              removeNode(this.viewport_);
          }
          if (!targetElement) {
              if (this.renderer_) {
                  clearTimeout(this.postRenderTimeoutHandle_);
                  this.postRenderFunctions_.length = 0;
                  this.renderer_.dispose();
                  this.renderer_ = null;
              }
              if (this.animationDelayKey_) {
                  cancelAnimationFrame(this.animationDelayKey_);
                  this.animationDelayKey_ = undefined;
              }
          }
          else {
              targetElement.appendChild(this.viewport_);
              if (!this.renderer_) {
                  this.renderer_ = this.createRenderer();
              }
              this.mapBrowserEventHandler_ = new MapBrowserEventHandler(this, this.moveTolerance_);
              for (var key in MapBrowserEventType) {
                  this.mapBrowserEventHandler_.addEventListener(MapBrowserEventType[key], this.handleMapBrowserEvent.bind(this));
              }
              this.viewport_.addEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_, false);
              this.viewport_.addEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_, PASSIVE_EVENT_LISTENERS ? { passive: false } : false);
              var keyboardEventTarget = !this.keyboardEventTarget_
                  ? targetElement
                  : this.keyboardEventTarget_;
              this.keyHandlerKeys_ = [
                  listen(keyboardEventTarget, EventType.KEYDOWN, this.handleBrowserEvent, this),
                  listen(keyboardEventTarget, EventType.KEYPRESS, this.handleBrowserEvent, this),
              ];
              if (!this.handleResize_) {
                  this.handleResize_ = this.updateSize.bind(this);
                  window.addEventListener(EventType.RESIZE, this.handleResize_, false);
              }
          }
          this.updateSize();
          // updateSize calls setSize, so no need to call this.render
          // ourselves here.
      };
      /**
       * @private
       */
      PluggableMap.prototype.handleTileChange_ = function () {
          this.render();
      };
      /**
       * @private
       */
      PluggableMap.prototype.handleViewPropertyChanged_ = function () {
          this.render();
      };
      /**
       * @private
       */
      PluggableMap.prototype.handleViewChanged_ = function () {
          if (this.viewPropertyListenerKey_) {
              unlistenByKey(this.viewPropertyListenerKey_);
              this.viewPropertyListenerKey_ = null;
          }
          if (this.viewChangeListenerKey_) {
              unlistenByKey(this.viewChangeListenerKey_);
              this.viewChangeListenerKey_ = null;
          }
          var view = this.getView();
          if (view) {
              this.updateViewportSize_();
              this.viewPropertyListenerKey_ = listen(view, ObjectEventType.PROPERTYCHANGE, this.handleViewPropertyChanged_, this);
              this.viewChangeListenerKey_ = listen(view, EventType.CHANGE, this.handleViewPropertyChanged_, this);
              view.resolveConstraints(0);
          }
          this.render();
      };
      /**
       * @private
       */
      PluggableMap.prototype.handleLayerGroupChanged_ = function () {
          if (this.layerGroupPropertyListenerKeys_) {
              this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);
              this.layerGroupPropertyListenerKeys_ = null;
          }
          var layerGroup = this.getLayerGroup();
          if (layerGroup) {
              this.layerGroupPropertyListenerKeys_ = [
                  listen(layerGroup, ObjectEventType.PROPERTYCHANGE, this.render, this),
                  listen(layerGroup, EventType.CHANGE, this.render, this),
              ];
          }
          this.render();
      };
      /**
       * @return {boolean} Is rendered.
       */
      PluggableMap.prototype.isRendered = function () {
          return !!this.frameState_;
      };
      /**
       * Requests an immediate render in a synchronous manner.
       * @api
       */
      PluggableMap.prototype.renderSync = function () {
          if (this.animationDelayKey_) {
              cancelAnimationFrame(this.animationDelayKey_);
          }
          this.animationDelay_();
      };
      /**
       * Redraws all text after new fonts have loaded
       */
      PluggableMap.prototype.redrawText = function () {
          var layerStates = this.getLayerGroup().getLayerStatesArray();
          for (var i = 0, ii = layerStates.length; i < ii; ++i) {
              var layer = layerStates[i].layer;
              if (layer.hasRenderer()) {
                  layer.getRenderer().handleFontsChanged();
              }
          }
      };
      /**
       * Request a map rendering (at the next animation frame).
       * @api
       */
      PluggableMap.prototype.render = function () {
          if (this.renderer_ && this.animationDelayKey_ === undefined) {
              this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
          }
      };
      /**
       * Remove the given control from the map.
       * @param {import("./control/Control.js").default} control Control.
       * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
       *     if the control was not found).
       * @api
       */
      PluggableMap.prototype.removeControl = function (control) {
          return this.getControls().remove(control);
      };
      /**
       * Remove the given interaction from the map.
       * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
       * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
       *     undefined if the interaction was not found).
       * @api
       */
      PluggableMap.prototype.removeInteraction = function (interaction) {
          return this.getInteractions().remove(interaction);
      };
      /**
       * Removes the given layer from the map.
       * @param {import("./layer/Base.js").default} layer Layer.
       * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
       *     layer was not found).
       * @api
       */
      PluggableMap.prototype.removeLayer = function (layer) {
          var layers = this.getLayerGroup().getLayers();
          return layers.remove(layer);
      };
      /**
       * Remove the given overlay from the map.
       * @param {import("./Overlay.js").default} overlay Overlay.
       * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
       *     if the overlay was not found).
       * @api
       */
      PluggableMap.prototype.removeOverlay = function (overlay) {
          return this.getOverlays().remove(overlay);
      };
      /**
       * @param {number} time Time.
       * @private
       */
      PluggableMap.prototype.renderFrame_ = function (time) {
          var size = this.getSize();
          var view = this.getView();
          var previousFrameState = this.frameState_;
          /** @type {?FrameState} */
          var frameState = null;
          if (size !== undefined && hasArea(size) && view && view.isDef()) {
              var viewHints = view.getHints(this.frameState_ ? this.frameState_.viewHints : undefined);
              var viewState = view.getState();
              frameState = {
                  animate: false,
                  coordinateToPixelTransform: this.coordinateToPixelTransform_,
                  declutterItems: previousFrameState
                      ? previousFrameState.declutterItems
                      : [],
                  extent: getForViewAndSize(viewState.center, viewState.resolution, viewState.rotation, size),
                  index: this.frameIndex_++,
                  layerIndex: 0,
                  layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
                  pixelRatio: this.pixelRatio_,
                  pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
                  postRenderFunctions: [],
                  size: size,
                  tileQueue: this.tileQueue_,
                  time: time,
                  usedTiles: {},
                  viewState: viewState,
                  viewHints: viewHints,
                  wantedTiles: {},
              };
          }
          this.frameState_ = frameState;
          this.renderer_.renderFrame(frameState);
          if (frameState) {
              if (frameState.animate) {
                  this.render();
              }
              Array.prototype.push.apply(this.postRenderFunctions_, frameState.postRenderFunctions);
              if (previousFrameState) {
                  var moveStart = !this.previousExtent_ ||
                      (!isEmpty(this.previousExtent_) &&
                          !equals$1(frameState.extent, this.previousExtent_));
                  if (moveStart) {
                      this.dispatchEvent(new MapEvent(MapEventType.MOVESTART, this, previousFrameState));
                      this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);
                  }
              }
              var idle = this.previousExtent_ &&
                  !frameState.viewHints[ViewHint.ANIMATING] &&
                  !frameState.viewHints[ViewHint.INTERACTING] &&
                  !equals$1(frameState.extent, this.previousExtent_);
              if (idle) {
                  this.dispatchEvent(new MapEvent(MapEventType.MOVEEND, this, frameState));
                  clone(frameState.extent, this.previousExtent_);
              }
          }
          this.dispatchEvent(new MapEvent(MapEventType.POSTRENDER, this, frameState));
          this.postRenderTimeoutHandle_ = setTimeout(this.handlePostRender.bind(this), 0);
      };
      /**
       * Sets the layergroup of this map.
       * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
       * @observable
       * @api
       */
      PluggableMap.prototype.setLayerGroup = function (layerGroup) {
          this.set(MapProperty.LAYERGROUP, layerGroup);
      };
      /**
       * Set the size of this map.
       * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
       * @observable
       * @api
       */
      PluggableMap.prototype.setSize = function (size) {
          this.set(MapProperty.SIZE, size);
      };
      /**
       * Set the target element to render this map into.
       * @param {HTMLElement|string|undefined} target The Element or id of the Element
       *     that the map is rendered in.
       * @observable
       * @api
       */
      PluggableMap.prototype.setTarget = function (target) {
          this.set(MapProperty.TARGET, target);
      };
      /**
       * Set the view for this map.
       * @param {View} view The view that controls this map.
       * @observable
       * @api
       */
      PluggableMap.prototype.setView = function (view) {
          this.set(MapProperty.VIEW, view);
      };
      /**
       * Force a recalculation of the map viewport size.  This should be called when
       * third-party code changes the size of the map viewport.
       * @api
       */
      PluggableMap.prototype.updateSize = function () {
          var targetElement = this.getTargetElement();
          if (!targetElement) {
              this.setSize(undefined);
          }
          else {
              var computedStyle = getComputedStyle(targetElement);
              this.setSize([
                  targetElement.offsetWidth -
                      parseFloat(computedStyle['borderLeftWidth']) -
                      parseFloat(computedStyle['paddingLeft']) -
                      parseFloat(computedStyle['paddingRight']) -
                      parseFloat(computedStyle['borderRightWidth']),
                  targetElement.offsetHeight -
                      parseFloat(computedStyle['borderTopWidth']) -
                      parseFloat(computedStyle['paddingTop']) -
                      parseFloat(computedStyle['paddingBottom']) -
                      parseFloat(computedStyle['borderBottomWidth']),
              ]);
          }
          this.updateViewportSize_();
      };
      /**
       * Recomputes the viewport size and save it on the view object (if any)
       * @private
       */
      PluggableMap.prototype.updateViewportSize_ = function () {
          var view = this.getView();
          if (view) {
              var size = undefined;
              var computedStyle = getComputedStyle(this.viewport_);
              if (computedStyle.width && computedStyle.height) {
                  size = [
                      parseInt(computedStyle.width, 10),
                      parseInt(computedStyle.height, 10),
                  ];
              }
              view.setViewportSize(size);
          }
      };
      return PluggableMap;
  }(BaseObject));
  /**
   * @param {MapOptions} options Map options.
   * @return {MapOptionsInternal} Internal map options.
   */
  function createOptionsInternal(options) {
      /**
       * @type {HTMLElement|Document}
       */
      var keyboardEventTarget = null;
      if (options.keyboardEventTarget !== undefined) {
          keyboardEventTarget =
              typeof options.keyboardEventTarget === 'string'
                  ? document.getElementById(options.keyboardEventTarget)
                  : options.keyboardEventTarget;
      }
      /**
       * @type {Object<string, *>}
       */
      var values = {};
      var layerGroup = options.layers &&
          typeof ( /** @type {?} */(options.layers).getLayers) === 'function'
          ? /** @type {LayerGroup} */ (options.layers)
          : new LayerGroup({ layers: /** @type {Collection} */ (options.layers) });
      values[MapProperty.LAYERGROUP] = layerGroup;
      values[MapProperty.TARGET] = options.target;
      values[MapProperty.VIEW] =
          options.view !== undefined ? options.view : new View();
      var controls;
      if (options.controls !== undefined) {
          if (Array.isArray(options.controls)) {
              controls = new Collection(options.controls.slice());
          }
          else {
              assert(typeof ( /** @type {?} */(options.controls).getArray) === 'function', 47); // Expected `controls` to be an array or an `import("./Collection.js").Collection`
              controls = /** @type {Collection} */ (options.controls);
          }
      }
      var interactions;
      if (options.interactions !== undefined) {
          if (Array.isArray(options.interactions)) {
              interactions = new Collection(options.interactions.slice());
          }
          else {
              assert(typeof ( /** @type {?} */(options.interactions).getArray) ===
                  'function', 48); // Expected `interactions` to be an array or an `import("./Collection.js").Collection`
              interactions = /** @type {Collection} */ (options.interactions);
          }
      }
      var overlays;
      if (options.overlays !== undefined) {
          if (Array.isArray(options.overlays)) {
              overlays = new Collection(options.overlays.slice());
          }
          else {
              assert(typeof ( /** @type {?} */(options.overlays).getArray) === 'function', 49); // Expected `overlays` to be an array or an `import("./Collection.js").Collection`
              overlays = options.overlays;
          }
      }
      else {
          overlays = new Collection();
      }
      return {
          controls: controls,
          interactions: interactions,
          keyboardEventTarget: keyboardEventTarget,
          overlays: overlays,
          values: values,
      };
  }

  var __extends$p = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {HTMLElement} [element] The element is the control's
   * container element. This only needs to be specified if you're developing
   * a custom control.
   * @property {function(import("../MapEvent.js").default):void} [render] Function called when
   * the control should be re-rendered. This is called in a `requestAnimationFrame`
   * callback.
   * @property {HTMLElement|string} [target] Specify a target if you want
   * the control to be rendered outside of the map's viewport.
   */
  /**
   * @classdesc
   * A control is a visible widget with a DOM element in a fixed position on the
   * screen. They can involve user input (buttons), or be informational only;
   * the position is determined using CSS. By default these are placed in the
   * container with CSS class name `ol-overlaycontainer-stopevent`, but can use
   * any outside DOM element.
   *
   * This is the base class for controls. You can use it for simple custom
   * controls by creating the element with listeners, creating an instance:
   * ```js
   * var myControl = new Control({element: myElement});
   * ```
   * and then adding this to the map.
   *
   * The main advantage of having this as a control rather than a simple separate
   * DOM element is that preventing propagation is handled for you. Controls
   * will also be objects in a {@link module:ol/Collection~Collection}, so you can use their methods.
   *
   * You can also extend this base for your own control class. See
   * examples/custom-controls for an example of how to do this.
   *
   * @api
   */
  var Control = /** @class */ (function (_super) {
      __extends$p(Control, _super);
      /**
       * @param {Options} options Control options.
       */
      function Control(options) {
          var _this = _super.call(this) || this;
          var element = options.element;
          if (element && !options.target && !element.style.pointerEvents) {
              element.style.pointerEvents = 'auto';
          }
          /**
           * @protected
           * @type {HTMLElement}
           */
          _this.element = element ? element : null;
          /**
           * @private
           * @type {HTMLElement}
           */
          _this.target_ = null;
          /**
           * @private
           * @type {import("../PluggableMap.js").default}
           */
          _this.map_ = null;
          /**
           * @protected
           * @type {!Array<import("../events.js").EventsKey>}
           */
          _this.listenerKeys = [];
          if (options.render) {
              _this.render = options.render;
          }
          if (options.target) {
              _this.setTarget(options.target);
          }
          return _this;
      }
      /**
       * Clean up.
       */
      Control.prototype.disposeInternal = function () {
          removeNode(this.element);
          _super.prototype.disposeInternal.call(this);
      };
      /**
       * Get the map associated with this control.
       * @return {import("../PluggableMap.js").default} Map.
       * @api
       */
      Control.prototype.getMap = function () {
          return this.map_;
      };
      /**
       * Remove the control from its current map and attach it to the new map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../PluggableMap.js").default} map Map.
       * @api
       */
      Control.prototype.setMap = function (map) {
          if (this.map_) {
              removeNode(this.element);
          }
          for (var i = 0, ii = this.listenerKeys.length; i < ii; ++i) {
              unlistenByKey(this.listenerKeys[i]);
          }
          this.listenerKeys.length = 0;
          this.map_ = map;
          if (this.map_) {
              var target = this.target_
                  ? this.target_
                  : map.getOverlayContainerStopEvent();
              target.appendChild(this.element);
              if (this.render !== VOID) {
                  this.listenerKeys.push(listen(map, MapEventType.POSTRENDER, this.render, this));
              }
              map.render();
          }
      };
      /**
       * Renders the control.
       * @param {import("../MapEvent.js").default} mapEvent Map event.
       * @api
       */
      Control.prototype.render = function (mapEvent) { };
      /**
       * This function is used to set a target element for the control. It has no
       * effect if it is called after the control has been added to the map (i.e.
       * after `setMap` is called on the control). If no `target` is set in the
       * options passed to the control constructor and if `setTarget` is not called
       * then the control is added to the map's overlay container.
       * @param {HTMLElement|string} target Target.
       * @api
       */
      Control.prototype.setTarget = function (target) {
          this.target_ =
              typeof target === 'string' ? document.getElementById(target) : target;
      };
      return Control;
  }(BaseObject));

  var __extends$q = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-attribution'] CSS class name.
   * @property {HTMLElement|string} [target] Specify a target if you
   * want the control to be rendered outside of the map's
   * viewport.
   * @property {boolean} [collapsible] Specify if attributions can
   * be collapsed. If not specified, sources control this behavior with their
   * `attributionsCollapsible` setting.
   * @property {boolean} [collapsed=true] Specify if attributions should
   * be collapsed at startup.
   * @property {string} [tipLabel='Attributions'] Text label to use for the button tip.
   * @property {string} [label='i'] Text label to use for the
   * collapsed attributions button.
   * Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {string|HTMLElement} [collapseLabel='»'] Text label to use
   * for the expanded attributions button.
   * Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {function(import("../MapEvent.js").default):void} [render] Function called when
   * the control should be re-rendered. This is called in a `requestAnimationFrame`
   * callback.
   */
  /**
   * @classdesc
   * Control to show all the attributions associated with the layer sources
   * in the map. This control is one of the default controls included in maps.
   * By default it will show in the bottom right portion of the map, but this can
   * be changed by using a css selector for `.ol-attribution`.
   *
   * @api
   */
  var Attribution = /** @class */ (function (_super) {
      __extends$q(Attribution, _super);
      /**
       * @param {Options=} opt_options Attribution options.
       */
      function Attribution(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, {
              element: document.createElement('div'),
              render: options.render,
              target: options.target,
          }) || this;
          /**
           * @private
           * @type {HTMLElement}
           */
          _this.ulElement_ = document.createElement('ul');
          /**
           * @private
           * @type {boolean}
           */
          _this.collapsed_ =
              options.collapsed !== undefined ? options.collapsed : true;
          /**
           * @private
           * @type {boolean}
           */
          _this.overrideCollapsible_ = options.collapsible !== undefined;
          /**
           * @private
           * @type {boolean}
           */
          _this.collapsible_ =
              options.collapsible !== undefined ? options.collapsible : true;
          if (!_this.collapsible_) {
              _this.collapsed_ = false;
          }
          var className = options.className !== undefined ? options.className : 'ol-attribution';
          var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Attributions';
          var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\u00BB';
          if (typeof collapseLabel === 'string') {
              /**
               * @private
               * @type {HTMLElement}
               */
              _this.collapseLabel_ = document.createElement('span');
              _this.collapseLabel_.textContent = collapseLabel;
          }
          else {
              _this.collapseLabel_ = collapseLabel;
          }
          var label = options.label !== undefined ? options.label : 'i';
          if (typeof label === 'string') {
              /**
               * @private
               * @type {HTMLElement}
               */
              _this.label_ = document.createElement('span');
              _this.label_.textContent = label;
          }
          else {
              _this.label_ = label;
          }
          var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;
          var button = document.createElement('button');
          button.setAttribute('type', 'button');
          button.title = tipLabel;
          button.appendChild(activeLabel);
          button.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this), false);
          var cssClasses = className +
              ' ' +
              CLASS_UNSELECTABLE +
              ' ' +
              CLASS_CONTROL +
              (_this.collapsed_ && _this.collapsible_ ? ' ' + CLASS_COLLAPSED : '') +
              (_this.collapsible_ ? '' : ' ol-uncollapsible');
          var element = _this.element;
          element.className = cssClasses;
          element.appendChild(_this.ulElement_);
          element.appendChild(button);
          /**
           * A list of currently rendered resolutions.
           * @type {Array<string>}
           * @private
           */
          _this.renderedAttributions_ = [];
          /**
           * @private
           * @type {boolean}
           */
          _this.renderedVisible_ = true;
          return _this;
      }
      /**
       * Collect a list of visible attributions and set the collapsible state.
       * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
       * @return {Array<string>} Attributions.
       * @private
       */
      Attribution.prototype.collectSourceAttributions_ = function (frameState) {
          /**
           * Used to determine if an attribution already exists.
           * @type {!Object<string, boolean>}
           */
          var lookup = {};
          /**
           * A list of visible attributions.
           * @type {Array<string>}
           */
          var visibleAttributions = [];
          var layerStatesArray = frameState.layerStatesArray;
          for (var i = 0, ii = layerStatesArray.length; i < ii; ++i) {
              var layerState = layerStatesArray[i];
              if (!inView(layerState, frameState.viewState)) {
                  continue;
              }
              var source = /** @type {import("../layer/Layer.js").default} */ (layerState.layer).getSource();
              if (!source) {
                  continue;
              }
              var attributionGetter = source.getAttributions();
              if (!attributionGetter) {
                  continue;
              }
              var attributions = attributionGetter(frameState);
              if (!attributions) {
                  continue;
              }
              if (!this.overrideCollapsible_ &&
                  source.getAttributionsCollapsible() === false) {
                  this.setCollapsible(false);
              }
              if (Array.isArray(attributions)) {
                  for (var j = 0, jj = attributions.length; j < jj; ++j) {
                      if (!(attributions[j] in lookup)) {
                          visibleAttributions.push(attributions[j]);
                          lookup[attributions[j]] = true;
                      }
                  }
              }
              else {
                  if (!(attributions in lookup)) {
                      visibleAttributions.push(attributions);
                      lookup[attributions] = true;
                  }
              }
          }
          return visibleAttributions;
      };
      /**
       * @private
       * @param {?import("../PluggableMap.js").FrameState} frameState Frame state.
       */
      Attribution.prototype.updateElement_ = function (frameState) {
          if (!frameState) {
              if (this.renderedVisible_) {
                  this.element.style.display = 'none';
                  this.renderedVisible_ = false;
              }
              return;
          }
          var attributions = this.collectSourceAttributions_(frameState);
          var visible = attributions.length > 0;
          if (this.renderedVisible_ != visible) {
              this.element.style.display = visible ? '' : 'none';
              this.renderedVisible_ = visible;
          }
          if (equals(attributions, this.renderedAttributions_)) {
              return;
          }
          removeChildren(this.ulElement_);
          // append the attributions
          for (var i = 0, ii = attributions.length; i < ii; ++i) {
              var element = document.createElement('li');
              element.innerHTML = attributions[i];
              this.ulElement_.appendChild(element);
          }
          this.renderedAttributions_ = attributions;
      };
      /**
       * @param {MouseEvent} event The event to handle
       * @private
       */
      Attribution.prototype.handleClick_ = function (event) {
          event.preventDefault();
          this.handleToggle_();
      };
      /**
       * @private
       */
      Attribution.prototype.handleToggle_ = function () {
          this.element.classList.toggle(CLASS_COLLAPSED);
          if (this.collapsed_) {
              replaceNode(this.collapseLabel_, this.label_);
          }
          else {
              replaceNode(this.label_, this.collapseLabel_);
          }
          this.collapsed_ = !this.collapsed_;
      };
      /**
       * Return `true` if the attribution is collapsible, `false` otherwise.
       * @return {boolean} True if the widget is collapsible.
       * @api
       */
      Attribution.prototype.getCollapsible = function () {
          return this.collapsible_;
      };
      /**
       * Set whether the attribution should be collapsible.
       * @param {boolean} collapsible True if the widget is collapsible.
       * @api
       */
      Attribution.prototype.setCollapsible = function (collapsible) {
          if (this.collapsible_ === collapsible) {
              return;
          }
          this.collapsible_ = collapsible;
          this.element.classList.toggle('ol-uncollapsible');
          if (!collapsible && this.collapsed_) {
              this.handleToggle_();
          }
      };
      /**
       * Collapse or expand the attribution according to the passed parameter. Will
       * not do anything if the attribution isn't collapsible or if the current
       * collapsed state is already the one requested.
       * @param {boolean} collapsed True if the widget is collapsed.
       * @api
       */
      Attribution.prototype.setCollapsed = function (collapsed) {
          if (!this.collapsible_ || this.collapsed_ === collapsed) {
              return;
          }
          this.handleToggle_();
      };
      /**
       * Return `true` when the attribution is currently collapsed or `false`
       * otherwise.
       * @return {boolean} True if the widget is collapsed.
       * @api
       */
      Attribution.prototype.getCollapsed = function () {
          return this.collapsed_;
      };
      /**
       * Update the attribution element.
       * @param {import("../MapEvent.js").default} mapEvent Map event.
       * @override
       */
      Attribution.prototype.render = function (mapEvent) {
          this.updateElement_(mapEvent.frameState);
      };
      return Attribution;
  }(Control));

  var __extends$r = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-rotate'] CSS class name.
   * @property {string|HTMLElement} [label='⇧'] Text label to use for the rotate button.
   * Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {string} [tipLabel='Reset rotation'] Text label to use for the rotate tip.
   * @property {number} [duration=250] Animation duration in milliseconds.
   * @property {boolean} [autoHide=true] Hide the control when rotation is 0.
   * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control should
   * be re-rendered. This is called in a `requestAnimationFrame` callback.
   * @property {function():void} [resetNorth] Function called when the control is clicked.
   * This will override the default `resetNorth`.
   * @property {HTMLElement|string} [target] Specify a target if you want the control to be
   * rendered outside of the map's viewport.
   */
  /**
   * @classdesc
   * A button control to reset rotation to 0.
   * To style this control use css selector `.ol-rotate`. A `.ol-hidden` css
   * selector is added to the button when the rotation is 0.
   *
   * @api
   */
  var Rotate = /** @class */ (function (_super) {
      __extends$r(Rotate, _super);
      /**
       * @param {Options=} opt_options Rotate options.
       */
      function Rotate(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, {
              element: document.createElement('div'),
              render: options.render,
              target: options.target,
          }) || this;
          var className = options.className !== undefined ? options.className : 'ol-rotate';
          var label = options.label !== undefined ? options.label : '\u21E7';
          /**
           * @type {HTMLElement}
           * @private
           */
          _this.label_ = null;
          if (typeof label === 'string') {
              _this.label_ = document.createElement('span');
              _this.label_.className = 'ol-compass';
              _this.label_.textContent = label;
          }
          else {
              _this.label_ = label;
              _this.label_.classList.add('ol-compass');
          }
          var tipLabel = options.tipLabel ? options.tipLabel : 'Reset rotation';
          var button = document.createElement('button');
          button.className = className + '-reset';
          button.setAttribute('type', 'button');
          button.title = tipLabel;
          button.appendChild(_this.label_);
          button.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this), false);
          var cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;
          var element = _this.element;
          element.className = cssClasses;
          element.appendChild(button);
          _this.callResetNorth_ = options.resetNorth ? options.resetNorth : undefined;
          /**
           * @type {number}
           * @private
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 250;
          /**
           * @type {boolean}
           * @private
           */
          _this.autoHide_ = options.autoHide !== undefined ? options.autoHide : true;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.rotation_ = undefined;
          if (_this.autoHide_) {
              _this.element.classList.add(CLASS_HIDDEN);
          }
          return _this;
      }
      /**
       * @param {MouseEvent} event The event to handle
       * @private
       */
      Rotate.prototype.handleClick_ = function (event) {
          event.preventDefault();
          if (this.callResetNorth_ !== undefined) {
              this.callResetNorth_();
          }
          else {
              this.resetNorth_();
          }
      };
      /**
       * @private
       */
      Rotate.prototype.resetNorth_ = function () {
          var map = this.getMap();
          var view = map.getView();
          if (!view) {
              // the map does not have a view, so we can't act
              // upon it
              return;
          }
          var rotation = view.getRotation();
          if (rotation !== undefined) {
              if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
                  view.animate({
                      rotation: 0,
                      duration: this.duration_,
                      easing: easeOut,
                  });
              }
              else {
                  view.setRotation(0);
              }
          }
      };
      /**
       * Update the rotate control element.
       * @param {import("../MapEvent.js").default} mapEvent Map event.
       * @override
       */
      Rotate.prototype.render = function (mapEvent) {
          var frameState = mapEvent.frameState;
          if (!frameState) {
              return;
          }
          var rotation = frameState.viewState.rotation;
          if (rotation != this.rotation_) {
              var transform = 'rotate(' + rotation + 'rad)';
              if (this.autoHide_) {
                  var contains = this.element.classList.contains(CLASS_HIDDEN);
                  if (!contains && rotation === 0) {
                      this.element.classList.add(CLASS_HIDDEN);
                  }
                  else if (contains && rotation !== 0) {
                      this.element.classList.remove(CLASS_HIDDEN);
                  }
              }
              this.label_.style.transform = transform;
          }
          this.rotation_ = rotation;
      };
      return Rotate;
  }(Control));

  var __extends$s = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {number} [duration=250] Animation duration in milliseconds.
   * @property {string} [className='ol-zoom'] CSS class name.
   * @property {string|HTMLElement} [zoomInLabel='+'] Text label to use for the zoom-in
   * button. Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {string|HTMLElement} [zoomOutLabel='-'] Text label to use for the zoom-out button.
   * Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {string} [zoomInTipLabel='Zoom in'] Text label to use for the button tip.
   * @property {string} [zoomOutTipLabel='Zoom out'] Text label to use for the button tip.
   * @property {number} [delta=1] The zoom delta applied on each click.
   * @property {HTMLElement|string} [target] Specify a target if you want the control to be
   * rendered outside of the map's viewport.
   */
  /**
   * @classdesc
   * A control with 2 buttons, one for zoom in and one for zoom out.
   * This control is one of the default controls of a map. To style this control
   * use css selectors `.ol-zoom-in` and `.ol-zoom-out`.
   *
   * @api
   */
  var Zoom = /** @class */ (function (_super) {
      __extends$s(Zoom, _super);
      /**
       * @param {Options=} opt_options Zoom options.
       */
      function Zoom(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, {
              element: document.createElement('div'),
              target: options.target,
          }) || this;
          var className = options.className !== undefined ? options.className : 'ol-zoom';
          var delta = options.delta !== undefined ? options.delta : 1;
          var zoomInLabel = options.zoomInLabel !== undefined ? options.zoomInLabel : '+';
          var zoomOutLabel = options.zoomOutLabel !== undefined ? options.zoomOutLabel : '\u2212';
          var zoomInTipLabel = options.zoomInTipLabel !== undefined ? options.zoomInTipLabel : 'Zoom in';
          var zoomOutTipLabel = options.zoomOutTipLabel !== undefined
              ? options.zoomOutTipLabel
              : 'Zoom out';
          var inElement = document.createElement('button');
          inElement.className = className + '-in';
          inElement.setAttribute('type', 'button');
          inElement.title = zoomInTipLabel;
          inElement.appendChild(typeof zoomInLabel === 'string'
              ? document.createTextNode(zoomInLabel)
              : zoomInLabel);
          inElement.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this, delta), false);
          var outElement = document.createElement('button');
          outElement.className = className + '-out';
          outElement.setAttribute('type', 'button');
          outElement.title = zoomOutTipLabel;
          outElement.appendChild(typeof zoomOutLabel === 'string'
              ? document.createTextNode(zoomOutLabel)
              : zoomOutLabel);
          outElement.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this, -delta), false);
          var cssClasses = className + ' ' + CLASS_UNSELECTABLE + ' ' + CLASS_CONTROL;
          var element = _this.element;
          element.className = cssClasses;
          element.appendChild(inElement);
          element.appendChild(outElement);
          /**
           * @type {number}
           * @private
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 250;
          return _this;
      }
      /**
       * @param {number} delta Zoom delta.
       * @param {MouseEvent} event The event to handle
       * @private
       */
      Zoom.prototype.handleClick_ = function (delta, event) {
          event.preventDefault();
          this.zoomByDelta_(delta);
      };
      /**
       * @param {number} delta Zoom delta.
       * @private
       */
      Zoom.prototype.zoomByDelta_ = function (delta) {
          var map = this.getMap();
          var view = map.getView();
          if (!view) {
              // the map does not have a view, so we can't act
              // upon it
              return;
          }
          var currentZoom = view.getZoom();
          if (currentZoom !== undefined) {
              var newZoom = view.getConstrainedZoom(currentZoom + delta);
              if (this.duration_ > 0) {
                  if (view.getAnimating()) {
                      view.cancelAnimations();
                  }
                  view.animate({
                      zoom: newZoom,
                      duration: this.duration_,
                      easing: easeOut,
                  });
              }
              else {
                  view.setZoom(newZoom);
              }
          }
      };
      return Zoom;
  }(Control));

  /**
   * @module ol/control/MousePosition
   */
  var __extends$t = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @type {string}
   */
  var PROJECTION = 'projection';
  /**
   * @type {string}
   */
  var COORDINATE_FORMAT = 'coordinateFormat';
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-mouse-position'] CSS class name.
   * @property {import("../coordinate.js").CoordinateFormat} [coordinateFormat] Coordinate format.
   * @property {import("../proj.js").ProjectionLike} [projection] Projection. Default is the view projection.
   * @property {function(import("../MapEvent.js").default):void} [render] Function called when the
   * control should be re-rendered. This is called in a `requestAnimationFrame`
   * callback.
   * @property {HTMLElement|string} [target] Specify a target if you want the
   * control to be rendered outside of the map's viewport.
   * @property {string} [undefinedHTML='&#160;'] Markup to show when coordinates are not
   * available (e.g. when the pointer leaves the map viewport).  By default, the last position
   * will be replaced with `'&#160;'` (`&nbsp;`) when the pointer leaves the viewport.  To
   * retain the last rendered position, set this option to something falsey (like an empty
   * string `''`).
   */
  /**
   * @classdesc
   * A control to show the 2D coordinates of the mouse cursor. By default, these
   * are in the view projection, but can be in any supported projection.
   * By default the control is shown in the top right corner of the map, but this
   * can be changed by using the css selector `.ol-mouse-position`.
   *
   * On touch devices, which usually do not have a mouse cursor, the coordinates
   * of the currently touched position are shown.
   *
   * @api
   */
  var MousePosition = /** @class */ (function (_super) {
      __extends$t(MousePosition, _super);
      /**
       * @param {Options=} opt_options Mouse position options.
       */
      function MousePosition(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          var element = document.createElement('div');
          element.className =
              options.className !== undefined ? options.className : 'ol-mouse-position';
          _this = _super.call(this, {
              element: element,
              render: options.render,
              target: options.target,
          }) || this;
          _this.addEventListener(getChangeEventType(PROJECTION), _this.handleProjectionChanged_);
          if (options.coordinateFormat) {
              _this.setCoordinateFormat(options.coordinateFormat);
          }
          if (options.projection) {
              _this.setProjection(options.projection);
          }
          /**
           * @private
           * @type {string}
           */
          _this.undefinedHTML_ =
              options.undefinedHTML !== undefined ? options.undefinedHTML : '&#160;';
          /**
           * @private
           * @type {boolean}
           */
          _this.renderOnMouseOut_ = !!_this.undefinedHTML_;
          /**
           * @private
           * @type {string}
           */
          _this.renderedHTML_ = element.innerHTML;
          /**
           * @private
           * @type {?import("../proj/Projection.js").default}
           */
          _this.mapProjection_ = null;
          /**
           * @private
           * @type {?import("../proj.js").TransformFunction}
           */
          _this.transform_ = null;
          return _this;
      }
      /**
       * @private
       */
      MousePosition.prototype.handleProjectionChanged_ = function () {
          this.transform_ = null;
      };
      /**
       * Return the coordinate format type used to render the current position or
       * undefined.
       * @return {import("../coordinate.js").CoordinateFormat|undefined} The format to render the current
       *     position in.
       * @observable
       * @api
       */
      MousePosition.prototype.getCoordinateFormat = function () {
          return /** @type {import("../coordinate.js").CoordinateFormat|undefined} */ (this.get(COORDINATE_FORMAT));
      };
      /**
       * Return the projection that is used to report the mouse position.
       * @return {import("../proj/Projection.js").default|undefined} The projection to report mouse
       *     position in.
       * @observable
       * @api
       */
      MousePosition.prototype.getProjection = function () {
          return /** @type {import("../proj/Projection.js").default|undefined} */ (this.get(PROJECTION));
      };
      /**
       * @param {MouseEvent} event Browser event.
       * @protected
       */
      MousePosition.prototype.handleMouseMove = function (event) {
          var map = this.getMap();
          this.updateHTML_(map.getEventPixel(event));
      };
      /**
       * @param {Event} event Browser event.
       * @protected
       */
      MousePosition.prototype.handleMouseOut = function (event) {
          this.updateHTML_(null);
      };
      /**
       * Remove the control from its current map and attach it to the new map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../PluggableMap.js").default} map Map.
       * @api
       */
      MousePosition.prototype.setMap = function (map) {
          _super.prototype.setMap.call(this, map);
          if (map) {
              var viewport = map.getViewport();
              this.listenerKeys.push(listen(viewport, PointerEventType.POINTERMOVE, this.handleMouseMove, this));
              if (this.renderOnMouseOut_) {
                  this.listenerKeys.push(listen(viewport, PointerEventType.POINTEROUT, this.handleMouseOut, this));
              }
          }
      };
      /**
       * Set the coordinate format type used to render the current position.
       * @param {import("../coordinate.js").CoordinateFormat} format The format to render the current
       *     position in.
       * @observable
       * @api
       */
      MousePosition.prototype.setCoordinateFormat = function (format) {
          this.set(COORDINATE_FORMAT, format);
      };
      /**
       * Set the projection that is used to report the mouse position.
       * @param {import("../proj.js").ProjectionLike} projection The projection to report mouse
       *     position in.
       * @observable
       * @api
       */
      MousePosition.prototype.setProjection = function (projection) {
          this.set(PROJECTION, get$2(projection));
      };
      /**
       * @param {?import("../pixel.js").Pixel} pixel Pixel.
       * @private
       */
      MousePosition.prototype.updateHTML_ = function (pixel) {
          var html = this.undefinedHTML_;
          if (pixel && this.mapProjection_) {
              if (!this.transform_) {
                  var projection = this.getProjection();
                  if (projection) {
                      this.transform_ = getTransformFromProjections(this.mapProjection_, projection);
                  }
                  else {
                      this.transform_ = identityTransform;
                  }
              }
              var map = this.getMap();
              var coordinate = map.getCoordinateFromPixelInternal(pixel);
              if (coordinate) {
                  var userProjection = getUserProjection();
                  if (userProjection) {
                      this.transform_ = getTransformFromProjections(this.mapProjection_, userProjection);
                  }
                  this.transform_(coordinate, coordinate);
                  var coordinateFormat = this.getCoordinateFormat();
                  if (coordinateFormat) {
                      html = coordinateFormat(coordinate);
                  }
                  else {
                      html = coordinate.toString();
                  }
              }
          }
          if (!this.renderedHTML_ || html !== this.renderedHTML_) {
              this.element.innerHTML = html;
              this.renderedHTML_ = html;
          }
      };
      /**
       * Update the projection. Rendering of the coordinates is done in
       * `handleMouseMove` and `handleMouseUp`.
       * @param {import("../MapEvent.js").default} mapEvent Map event.
       * @override
       */
      MousePosition.prototype.render = function (mapEvent) {
          var frameState = mapEvent.frameState;
          if (!frameState) {
              this.mapProjection_ = null;
          }
          else {
              if (this.mapProjection_ != frameState.viewState.projection) {
                  this.mapProjection_ = frameState.viewState.projection;
                  this.transform_ = null;
              }
          }
      };
      return MousePosition;
  }(Control));

  /**
   * @module ol/OverlayPositioning
   */
  /**
   * Overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,
   * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
   * `'top-center'`, `'top-right'`
   * @enum {string}
   */
  var OverlayPositioning = {
      BOTTOM_LEFT: 'bottom-left',
      BOTTOM_CENTER: 'bottom-center',
      BOTTOM_RIGHT: 'bottom-right',
      CENTER_LEFT: 'center-left',
      CENTER_CENTER: 'center-center',
      CENTER_RIGHT: 'center-right',
      TOP_LEFT: 'top-left',
      TOP_CENTER: 'top-center',
      TOP_RIGHT: 'top-right',
  };

  var __extends$u = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {number|string} [id] Set the overlay id. The overlay id can be used
   * with the {@link module:ol/Map~Map#getOverlayById} method.
   * @property {HTMLElement} [element] The overlay element.
   * @property {Array<number>} [offset=[0, 0]] Offsets in pixels used when positioning
   * the overlay. The first element in the
   * array is the horizontal offset. A positive value shifts the overlay right.
   * The second element in the array is the vertical offset. A positive value
   * shifts the overlay down.
   * @property {import("./coordinate.js").Coordinate} [position] The overlay position
   * in map projection.
   * @property {import("./OverlayPositioning.js").default} [positioning='top-left'] Defines how
   * the overlay is actually positioned with respect to its `position` property.
   * Possible values are `'bottom-left'`, `'bottom-center'`, `'bottom-right'`,
   * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
   * `'top-center'`, and `'top-right'`.
   * @property {boolean} [stopEvent=true] Whether event propagation to the map
   * viewport should be stopped. If `true` the overlay is placed in the same
   * container as that of the controls (CSS class name
   * `ol-overlaycontainer-stopevent`); if `false` it is placed in the container
   * with CSS class name specified by the `className` property.
   * @property {boolean} [insertFirst=true] Whether the overlay is inserted first
   * in the overlay container, or appended. If the overlay is placed in the same
   * container as that of the controls (see the `stopEvent` option) you will
   * probably set `insertFirst` to `true` so the overlay is displayed below the
   * controls.
   * @property {PanIntoViewOptions|boolean} [autoPan=false] Pan the map when calling
   * `setPosition`, so that the overlay is entirely visible in the current viewport?
   * If `true` (deprecated), then `autoPanAnimation` and `autoPanMargin` will be
   * used to determine the panning parameters; if an object is supplied then other
   * parameters are ignored.
   * @property {PanOptions} [autoPanAnimation] The animation options used to pan
   * the overlay into view. This animation is only used when `autoPan` is enabled.
   * A `duration` and `easing` may be provided to customize the animation.
   * Deprecated and ignored if `autoPan` is supplied as an object.
   * @property {number} [autoPanMargin=20] The margin (in pixels) between the
   * overlay and the borders of the map when autopanning. Deprecated and ignored
   * if `autoPan` is supplied as an object.
   * @property {PanIntoViewOptions} [autoPanOptions] The options to use for the
   * autoPan. This is only used when `autoPan` is enabled and has preference over
   * the individual `autoPanMargin` and `autoPanOptions`.
   * @property {string} [className='ol-overlay-container ol-selectable'] CSS class
   * name.
   */
  /**
   * @typedef {Object} PanOptions
   * @property {number} [duration=1000] The duration of the animation in
   * milliseconds.
   * @property {function(number):number} [easing] The easing function to use. Can
   * be one from {@link module:ol/easing} or a custom function.
   * Default is {@link module:ol/easing~inAndOut}.
   */
  /**
   * @typedef {Object} PanIntoViewOptions
   * @property {PanOptions} [animation={}] The animation parameters for the pan
   * @property {number} [margin=20] The margin (in pixels) between the
   * overlay and the borders of the map when panning into view.
   */
  /**
   * @enum {string}
   * @protected
   */
  var Property$2 = {
      ELEMENT: 'element',
      MAP: 'map',
      OFFSET: 'offset',
      POSITION: 'position',
      POSITIONING: 'positioning',
  };
  /**
   * @classdesc
   * An element to be displayed over the map and attached to a single map
   * location.  Like {@link module:ol/control/Control~Control}, Overlays are
   * visible widgets. Unlike Controls, they are not in a fixed position on the
   * screen, but are tied to a geographical coordinate, so panning the map will
   * move an Overlay but not a Control.
   *
   * Example:
   *
   *     import Overlay from 'ol/Overlay';
   *
   *     var popup = new Overlay({
   *       element: document.getElementById('popup')
   *     });
   *     popup.setPosition(coordinate);
   *     map.addOverlay(popup);
   *
   * @api
   */
  var Overlay = /** @class */ (function (_super) {
      __extends$u(Overlay, _super);
      /**
       * @param {Options} options Overlay options.
       */
      function Overlay(options) {
          var _this = _super.call(this) || this;
          /**
           * @protected
           * @type {Options}
           */
          _this.options = options;
          /**
           * @protected
           * @type {number|string|undefined}
           */
          _this.id = options.id;
          /**
           * @protected
           * @type {boolean}
           */
          _this.insertFirst =
              options.insertFirst !== undefined ? options.insertFirst : true;
          /**
           * @protected
           * @type {boolean}
           */
          _this.stopEvent = options.stopEvent !== undefined ? options.stopEvent : true;
          /**
           * @protected
           * @type {HTMLElement}
           */
          _this.element = document.createElement('div');
          _this.element.className =
              options.className !== undefined
                  ? options.className
                  : 'ol-overlay-container ' + CLASS_SELECTABLE;
          _this.element.style.position = 'absolute';
          _this.element.style.pointerEvents = 'auto';
          var autoPan = options.autoPan;
          if (autoPan && 'object' !== typeof autoPan) {
              autoPan = {
                  animation: options.autoPanAnimation,
                  margin: options.autoPanMargin,
              };
          }
          /**
           * @protected
           * @type {PanIntoViewOptions|false}
           */
          _this.autoPan = /** @type {PanIntoViewOptions} */ (autoPan) || false;
          /**
           * @protected
           * @type {{transform_: string,
           *         visible: boolean}}
           */
          _this.rendered = {
              transform_: '',
              visible: true,
          };
          /**
           * @protected
           * @type {?import("./events.js").EventsKey}
           */
          _this.mapPostrenderListenerKey = null;
          _this.addEventListener(getChangeEventType(Property$2.ELEMENT), _this.handleElementChanged);
          _this.addEventListener(getChangeEventType(Property$2.MAP), _this.handleMapChanged);
          _this.addEventListener(getChangeEventType(Property$2.OFFSET), _this.handleOffsetChanged);
          _this.addEventListener(getChangeEventType(Property$2.POSITION), _this.handlePositionChanged);
          _this.addEventListener(getChangeEventType(Property$2.POSITIONING), _this.handlePositioningChanged);
          if (options.element !== undefined) {
              _this.setElement(options.element);
          }
          _this.setOffset(options.offset !== undefined ? options.offset : [0, 0]);
          _this.setPositioning(options.positioning !== undefined
              ? /** @type {import("./OverlayPositioning.js").default} */ (options.positioning)
              : OverlayPositioning.TOP_LEFT);
          if (options.position !== undefined) {
              _this.setPosition(options.position);
          }
          return _this;
      }
      /**
       * Get the DOM element of this overlay.
       * @return {HTMLElement|undefined} The Element containing the overlay.
       * @observable
       * @api
       */
      Overlay.prototype.getElement = function () {
          return /** @type {HTMLElement|undefined} */ (this.get(Property$2.ELEMENT));
      };
      /**
       * Get the overlay identifier which is set on constructor.
       * @return {number|string|undefined} Id.
       * @api
       */
      Overlay.prototype.getId = function () {
          return this.id;
      };
      /**
       * Get the map associated with this overlay.
       * @return {import("./PluggableMap.js").default|undefined} The map that the
       * overlay is part of.
       * @observable
       * @api
       */
      Overlay.prototype.getMap = function () {
          return /** @type {import("./PluggableMap.js").default|undefined} */ (this.get(Property$2.MAP));
      };
      /**
       * Get the offset of this overlay.
       * @return {Array<number>} The offset.
       * @observable
       * @api
       */
      Overlay.prototype.getOffset = function () {
          return /** @type {Array<number>} */ (this.get(Property$2.OFFSET));
      };
      /**
       * Get the current position of this overlay.
       * @return {import("./coordinate.js").Coordinate|undefined} The spatial point that the overlay is
       *     anchored at.
       * @observable
       * @api
       */
      Overlay.prototype.getPosition = function () {
          return /** @type {import("./coordinate.js").Coordinate|undefined} */ (this.get(Property$2.POSITION));
      };
      /**
       * Get the current positioning of this overlay.
       * @return {import("./OverlayPositioning.js").default} How the overlay is positioned
       *     relative to its point on the map.
       * @observable
       * @api
       */
      Overlay.prototype.getPositioning = function () {
          return /** @type {import("./OverlayPositioning.js").default} */ (this.get(Property$2.POSITIONING));
      };
      /**
       * @protected
       */
      Overlay.prototype.handleElementChanged = function () {
          removeChildren(this.element);
          var element = this.getElement();
          if (element) {
              this.element.appendChild(element);
          }
      };
      /**
       * @protected
       */
      Overlay.prototype.handleMapChanged = function () {
          if (this.mapPostrenderListenerKey) {
              removeNode(this.element);
              unlistenByKey(this.mapPostrenderListenerKey);
              this.mapPostrenderListenerKey = null;
          }
          var map = this.getMap();
          if (map) {
              this.mapPostrenderListenerKey = listen(map, MapEventType.POSTRENDER, this.render, this);
              this.updatePixelPosition();
              var container = this.stopEvent
                  ? map.getOverlayContainerStopEvent()
                  : map.getOverlayContainer();
              if (this.insertFirst) {
                  container.insertBefore(this.element, container.childNodes[0] || null);
              }
              else {
                  container.appendChild(this.element);
              }
              this.performAutoPan();
          }
      };
      /**
       * @protected
       */
      Overlay.prototype.render = function () {
          this.updatePixelPosition();
      };
      /**
       * @protected
       */
      Overlay.prototype.handleOffsetChanged = function () {
          this.updatePixelPosition();
      };
      /**
       * @protected
       */
      Overlay.prototype.handlePositionChanged = function () {
          this.updatePixelPosition();
          this.performAutoPan();
      };
      /**
       * @protected
       */
      Overlay.prototype.handlePositioningChanged = function () {
          this.updatePixelPosition();
      };
      /**
       * Set the DOM element to be associated with this overlay.
       * @param {HTMLElement|undefined} element The Element containing the overlay.
       * @observable
       * @api
       */
      Overlay.prototype.setElement = function (element) {
          this.set(Property$2.ELEMENT, element);
      };
      /**
       * Set the map to be associated with this overlay.
       * @param {import("./PluggableMap.js").default|undefined} map The map that the
       * overlay is part of.
       * @observable
       * @api
       */
      Overlay.prototype.setMap = function (map) {
          this.set(Property$2.MAP, map);
      };
      /**
       * Set the offset for this overlay.
       * @param {Array<number>} offset Offset.
       * @observable
       * @api
       */
      Overlay.prototype.setOffset = function (offset) {
          this.set(Property$2.OFFSET, offset);
      };
      /**
       * Set the position for this overlay. If the position is `undefined` the
       * overlay is hidden.
       * @param {import("./coordinate.js").Coordinate|undefined} position The spatial point that the overlay
       *     is anchored at.
       * @observable
       * @api
       */
      Overlay.prototype.setPosition = function (position) {
          this.set(Property$2.POSITION, position);
      };
      /**
       * Pan the map so that the overlay is entirely visisble in the current viewport
       * (if necessary) using the configured autoPan parameters
       * @protected
       */
      Overlay.prototype.performAutoPan = function () {
          if (this.autoPan) {
              this.panIntoView(this.autoPan);
          }
      };
      /**
       * Pan the map so that the overlay is entirely visible in the current viewport
       * (if necessary).
       * @param {PanIntoViewOptions=} opt_panIntoViewOptions Options for the pan action
       * @api
       */
      Overlay.prototype.panIntoView = function (opt_panIntoViewOptions) {
          var map = this.getMap();
          if (!map || !map.getTargetElement() || !this.get(Property$2.POSITION)) {
              return;
          }
          var mapRect = this.getRect(map.getTargetElement(), map.getSize());
          var element = this.getElement();
          var overlayRect = this.getRect(element, [
              outerWidth(element),
              outerHeight(element),
          ]);
          var panIntoViewOptions = opt_panIntoViewOptions || {};
          var myMargin = panIntoViewOptions.margin === undefined ? 20 : panIntoViewOptions.margin;
          if (!containsExtent(mapRect, overlayRect)) {
              // the overlay is not completely inside the viewport, so pan the map
              var offsetLeft = overlayRect[0] - mapRect[0];
              var offsetRight = mapRect[2] - overlayRect[2];
              var offsetTop = overlayRect[1] - mapRect[1];
              var offsetBottom = mapRect[3] - overlayRect[3];
              var delta = [0, 0];
              if (offsetLeft < 0) {
                  // move map to the left
                  delta[0] = offsetLeft - myMargin;
              }
              else if (offsetRight < 0) {
                  // move map to the right
                  delta[0] = Math.abs(offsetRight) + myMargin;
              }
              if (offsetTop < 0) {
                  // move map up
                  delta[1] = offsetTop - myMargin;
              }
              else if (offsetBottom < 0) {
                  // move map down
                  delta[1] = Math.abs(offsetBottom) + myMargin;
              }
              if (delta[0] !== 0 || delta[1] !== 0) {
                  var center = /** @type {import("./coordinate.js").Coordinate} */ (map
                      .getView()
                      .getCenterInternal());
                  var centerPx = map.getPixelFromCoordinateInternal(center);
                  var newCenterPx = [centerPx[0] + delta[0], centerPx[1] + delta[1]];
                  var panOptions = panIntoViewOptions.animation || {};
                  map.getView().animateInternal({
                      center: map.getCoordinateFromPixelInternal(newCenterPx),
                      duration: panOptions.duration,
                      easing: panOptions.easing,
                  });
              }
          }
      };
      /**
       * Get the extent of an element relative to the document
       * @param {HTMLElement} element The element.
       * @param {import("./size.js").Size} size The size of the element.
       * @return {import("./extent.js").Extent} The extent.
       * @protected
       */
      Overlay.prototype.getRect = function (element, size) {
          var box = element.getBoundingClientRect();
          var offsetX = box.left + window.pageXOffset;
          var offsetY = box.top + window.pageYOffset;
          return [offsetX, offsetY, offsetX + size[0], offsetY + size[1]];
      };
      /**
       * Set the positioning for this overlay.
       * @param {import("./OverlayPositioning.js").default} positioning how the overlay is
       *     positioned relative to its point on the map.
       * @observable
       * @api
       */
      Overlay.prototype.setPositioning = function (positioning) {
          this.set(Property$2.POSITIONING, positioning);
      };
      /**
       * Modify the visibility of the element.
       * @param {boolean} visible Element visibility.
       * @protected
       */
      Overlay.prototype.setVisible = function (visible) {
          if (this.rendered.visible !== visible) {
              this.element.style.display = visible ? '' : 'none';
              this.rendered.visible = visible;
          }
      };
      /**
       * Update pixel position.
       * @protected
       */
      Overlay.prototype.updatePixelPosition = function () {
          var map = this.getMap();
          var position = this.getPosition();
          if (!map || !map.isRendered() || !position) {
              this.setVisible(false);
              return;
          }
          var pixel = map.getPixelFromCoordinate(position);
          var mapSize = map.getSize();
          this.updateRenderedPosition(pixel, mapSize);
      };
      /**
       * @param {import("./pixel.js").Pixel} pixel The pixel location.
       * @param {import("./size.js").Size|undefined} mapSize The map size.
       * @protected
       */
      Overlay.prototype.updateRenderedPosition = function (pixel, mapSize) {
          var style = this.element.style;
          var offset = this.getOffset();
          var positioning = this.getPositioning();
          this.setVisible(true);
          var x = Math.round(pixel[0] + offset[0]) + 'px';
          var y = Math.round(pixel[1] + offset[1]) + 'px';
          var posX = '0%';
          var posY = '0%';
          if (positioning == OverlayPositioning.BOTTOM_RIGHT ||
              positioning == OverlayPositioning.CENTER_RIGHT ||
              positioning == OverlayPositioning.TOP_RIGHT) {
              posX = '-100%';
          }
          else if (positioning == OverlayPositioning.BOTTOM_CENTER ||
              positioning == OverlayPositioning.CENTER_CENTER ||
              positioning == OverlayPositioning.TOP_CENTER) {
              posX = '-50%';
          }
          if (positioning == OverlayPositioning.BOTTOM_LEFT ||
              positioning == OverlayPositioning.BOTTOM_CENTER ||
              positioning == OverlayPositioning.BOTTOM_RIGHT) {
              posY = '-100%';
          }
          else if (positioning == OverlayPositioning.CENTER_LEFT ||
              positioning == OverlayPositioning.CENTER_CENTER ||
              positioning == OverlayPositioning.CENTER_RIGHT) {
              posY = '-50%';
          }
          var transform = "translate(" + posX + ", " + posY + ") translate(" + x + ", " + y + ")";
          if (this.rendered.transform_ != transform) {
              this.rendered.transform_ = transform;
              style.transform = transform;
              // @ts-ignore IE9
              style.msTransform = transform;
          }
      };
      /**
       * returns the options this Overlay has been created with
       * @return {Options} overlay options
       */
      Overlay.prototype.getOptions = function () {
          return this.options;
      };
      return Overlay;
  }(BaseObject));

  var __extends$v = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * Maximum width and/or height extent ratio that determines when the overview
   * map should be zoomed out.
   * @type {number}
   */
  var MAX_RATIO = 0.75;
  /**
   * Minimum width and/or height extent ratio that determines when the overview
   * map should be zoomed in.
   * @type {number}
   */
  var MIN_RATIO = 0.1;
  var ControlledMap = /** @class */ (function (_super) {
      __extends$v(ControlledMap, _super);
      function ControlledMap() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      ControlledMap.prototype.createRenderer = function () {
          return new CompositeMapRenderer(this);
      };
      return ControlledMap;
  }(PluggableMap));
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-overviewmap'] CSS class name.
   * @property {boolean} [collapsed=true] Whether the control should start collapsed or not (expanded).
   * @property {string|HTMLElement} [collapseLabel='«'] Text label to use for the
   * expanded overviewmap button. Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {boolean} [collapsible=true] Whether the control can be collapsed or not.
   * @property {string|HTMLElement} [label='»'] Text label to use for the collapsed
   * overviewmap button. Instead of text, also an element (e.g. a `span` element) can be used.
   * @property {Array<import("../layer/Layer.js").default>|import("../Collection.js").default<import("../layer/Layer.js").default>} [layers]
   * Layers for the overview map.
   * @property {function(import("../MapEvent.js").default):void} [render] Function called when the control
   * should be re-rendered. This is called in a `requestAnimationFrame` callback.
   * @property {boolean} [rotateWithView=false] Whether the control view should rotate with the main map view.
   * @property {HTMLElement|string} [target] Specify a target if you want the control
   * to be rendered outside of the map's viewport.
   * @property {string} [tipLabel='Overview map'] Text label to use for the button tip.
   * @property {View} [view] Custom view for the overview map (should use same projection as main map). If not provided,
   * a default view with the same projection as the main map will be used.
   */
  /**
   * Create a new control with a map acting as an overview map for another
   * defined map.
   *
   * @api
   */
  var OverviewMap = /** @class */ (function (_super) {
      __extends$v(OverviewMap, _super);
      /**
       * @param {Options=} opt_options OverviewMap options.
       */
      function OverviewMap(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, {
              element: document.createElement('div'),
              render: options.render,
              target: options.target,
          }) || this;
          /**
           * @private
           */
          _this.boundHandleRotationChanged_ = _this.handleRotationChanged_.bind(_this);
          /**
           * @type {boolean}
           * @private
           */
          _this.collapsed_ =
              options.collapsed !== undefined ? options.collapsed : true;
          /**
           * @private
           * @type {boolean}
           */
          _this.collapsible_ =
              options.collapsible !== undefined ? options.collapsible : true;
          if (!_this.collapsible_) {
              _this.collapsed_ = false;
          }
          /**
           * @private
           * @type {boolean}
           */
          _this.rotateWithView_ =
              options.rotateWithView !== undefined ? options.rotateWithView : false;
          /**
           * @private
           * @type {import("../extent.js").Extent|undefined}
           */
          _this.viewExtent_ = undefined;
          var className = options.className !== undefined ? options.className : 'ol-overviewmap';
          var tipLabel = options.tipLabel !== undefined ? options.tipLabel : 'Overview map';
          var collapseLabel = options.collapseLabel !== undefined ? options.collapseLabel : '\u00AB';
          if (typeof collapseLabel === 'string') {
              /**
               * @private
               * @type {HTMLElement}
               */
              _this.collapseLabel_ = document.createElement('span');
              _this.collapseLabel_.textContent = collapseLabel;
          }
          else {
              _this.collapseLabel_ = collapseLabel;
          }
          var label = options.label !== undefined ? options.label : '\u00BB';
          if (typeof label === 'string') {
              /**
               * @private
               * @type {HTMLElement}
               */
              _this.label_ = document.createElement('span');
              _this.label_.textContent = label;
          }
          else {
              _this.label_ = label;
          }
          var activeLabel = _this.collapsible_ && !_this.collapsed_ ? _this.collapseLabel_ : _this.label_;
          var button = document.createElement('button');
          button.setAttribute('type', 'button');
          button.title = tipLabel;
          button.appendChild(activeLabel);
          button.addEventListener(EventType.CLICK, _this.handleClick_.bind(_this), false);
          /**
           * @type {HTMLElement}
           * @private
           */
          _this.ovmapDiv_ = document.createElement('div');
          _this.ovmapDiv_.className = 'ol-overviewmap-map';
          /**
           * Explicitly given view to be used instead of a view derived from the main map.
           * @type {View}
           * @private
           */
          _this.view_ = options.view;
          /**
           * @type {ControlledMap}
           * @private
           */
          _this.ovmap_ = new ControlledMap({
              view: options.view,
          });
          var ovmap = _this.ovmap_;
          if (options.layers) {
              options.layers.forEach(function (layer) {
                  ovmap.addLayer(layer);
              });
          }
          var box = document.createElement('div');
          box.className = 'ol-overviewmap-box';
          box.style.boxSizing = 'border-box';
          /**
           * @type {import("../Overlay.js").default}
           * @private
           */
          _this.boxOverlay_ = new Overlay({
              position: [0, 0],
              positioning: OverlayPositioning.CENTER_CENTER,
              element: box,
          });
          _this.ovmap_.addOverlay(_this.boxOverlay_);
          var cssClasses = className +
              ' ' +
              CLASS_UNSELECTABLE +
              ' ' +
              CLASS_CONTROL +
              (_this.collapsed_ && _this.collapsible_ ? ' ' + CLASS_COLLAPSED : '') +
              (_this.collapsible_ ? '' : ' ol-uncollapsible');
          var element = _this.element;
          element.className = cssClasses;
          element.appendChild(_this.ovmapDiv_);
          element.appendChild(button);
          /* Interactive map */
          var scope = _this;
          var overlay = _this.boxOverlay_;
          var overlayBox = _this.boxOverlay_.getElement();
          /* Functions definition */
          var computeDesiredMousePosition = function (mousePosition) {
              return {
                  clientX: mousePosition.clientX,
                  clientY: mousePosition.clientY,
              };
          };
          var move = function (event) {
              var position = /** @type {?} */ (computeDesiredMousePosition(event));
              var coordinates = ovmap.getEventCoordinateInternal(
              /** @type {MouseEvent} */ (position));
              overlay.setPosition(coordinates);
          };
          var endMoving = function (event) {
              var coordinates = ovmap.getEventCoordinateInternal(event);
              scope.getMap().getView().setCenterInternal(coordinates);
              window.removeEventListener('mousemove', move);
              window.removeEventListener('mouseup', endMoving);
          };
          /* Binding */
          overlayBox.addEventListener('mousedown', function () {
              window.addEventListener('mousemove', move);
              window.addEventListener('mouseup', endMoving);
          });
          return _this;
      }
      /**
       * Remove the control from its current map and attach it to the new map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../PluggableMap.js").default} map Map.
       * @api
       */
      OverviewMap.prototype.setMap = function (map) {
          var oldMap = this.getMap();
          if (map === oldMap) {
              return;
          }
          if (oldMap) {
              var oldView = oldMap.getView();
              if (oldView) {
                  this.unbindView_(oldView);
              }
              this.ovmap_.setTarget(null);
          }
          _super.prototype.setMap.call(this, map);
          if (map) {
              this.ovmap_.setTarget(this.ovmapDiv_);
              this.listenerKeys.push(listen(map, ObjectEventType.PROPERTYCHANGE, this.handleMapPropertyChange_, this));
              var view = map.getView();
              if (view) {
                  this.bindView_(view);
                  if (view.isDef()) {
                      this.ovmap_.updateSize();
                      this.resetExtent_();
                  }
              }
          }
      };
      /**
       * Handle map property changes.  This only deals with changes to the map's view.
       * @param {import("../Object.js").ObjectEvent} event The propertychange event.
       * @private
       */
      OverviewMap.prototype.handleMapPropertyChange_ = function (event) {
          if (event.key === MapProperty.VIEW) {
              var oldView = /** @type {import("../View.js").default} */ (event.oldValue);
              if (oldView) {
                  this.unbindView_(oldView);
              }
              var newView = this.getMap().getView();
              this.bindView_(newView);
          }
      };
      /**
       * Register listeners for view property changes.
       * @param {import("../View.js").default} view The view.
       * @private
       */
      OverviewMap.prototype.bindView_ = function (view) {
          if (!this.view_) {
              // Unless an explicit view definition was given, derive default from whatever main map uses.
              var newView = new View({
                  projection: view.getProjection(),
              });
              this.ovmap_.setView(newView);
          }
          view.addEventListener(getChangeEventType(ViewProperty.ROTATION), this.boundHandleRotationChanged_);
          // Sync once with the new view
          this.handleRotationChanged_();
      };
      /**
       * Unregister listeners for view property changes.
       * @param {import("../View.js").default} view The view.
       * @private
       */
      OverviewMap.prototype.unbindView_ = function (view) {
          view.removeEventListener(getChangeEventType(ViewProperty.ROTATION), this.boundHandleRotationChanged_);
      };
      /**
       * Handle rotation changes to the main map.
       * @private
       */
      OverviewMap.prototype.handleRotationChanged_ = function () {
          if (this.rotateWithView_) {
              this.ovmap_.getView().setRotation(this.getMap().getView().getRotation());
          }
      };
      /**
       * Reset the overview map extent if the box size (width or
       * height) is less than the size of the overview map size times minRatio
       * or is greater than the size of the overview size times maxRatio.
       *
       * If the map extent was not reset, the box size can fits in the defined
       * ratio sizes. This method then checks if is contained inside the overview
       * map current extent. If not, recenter the overview map to the current
       * main map center location.
       * @private
       */
      OverviewMap.prototype.validateExtent_ = function () {
          var map = this.getMap();
          var ovmap = this.ovmap_;
          if (!map.isRendered() || !ovmap.isRendered()) {
              return;
          }
          var mapSize = /** @type {import("../size.js").Size} */ (map.getSize());
          var view = map.getView();
          var extent = view.calculateExtentInternal(mapSize);
          if (this.viewExtent_ && equals$1(extent, this.viewExtent_)) {
              // repeats of the same extent may indicate constraint conflicts leading to an endless cycle
              return;
          }
          this.viewExtent_ = extent;
          var ovmapSize = /** @type {import("../size.js").Size} */ (ovmap.getSize());
          var ovview = ovmap.getView();
          var ovextent = ovview.calculateExtentInternal(ovmapSize);
          var topLeftPixel = ovmap.getPixelFromCoordinateInternal(getTopLeft(extent));
          var bottomRightPixel = ovmap.getPixelFromCoordinateInternal(getBottomRight(extent));
          var boxWidth = Math.abs(topLeftPixel[0] - bottomRightPixel[0]);
          var boxHeight = Math.abs(topLeftPixel[1] - bottomRightPixel[1]);
          var ovmapWidth = ovmapSize[0];
          var ovmapHeight = ovmapSize[1];
          if (boxWidth < ovmapWidth * MIN_RATIO ||
              boxHeight < ovmapHeight * MIN_RATIO ||
              boxWidth > ovmapWidth * MAX_RATIO ||
              boxHeight > ovmapHeight * MAX_RATIO) {
              this.resetExtent_();
          }
          else if (!containsExtent(ovextent, extent)) {
              this.recenter_();
          }
      };
      /**
       * Reset the overview map extent to half calculated min and max ratio times
       * the extent of the main map.
       * @private
       */
      OverviewMap.prototype.resetExtent_ = function () {
          var map = this.getMap();
          var ovmap = this.ovmap_;
          var mapSize = /** @type {import("../size.js").Size} */ (map.getSize());
          var view = map.getView();
          var extent = view.calculateExtentInternal(mapSize);
          var ovview = ovmap.getView();
          // get how many times the current map overview could hold different
          // box sizes using the min and max ratio, pick the step in the middle used
          // to calculate the extent from the main map to set it to the overview map,
          var steps = Math.log(MAX_RATIO / MIN_RATIO) / Math.LN2;
          var ratio = 1 / (Math.pow(2, steps / 2) * MIN_RATIO);
          scaleFromCenter(extent, ratio);
          ovview.fitInternal(fromExtent(extent));
      };
      /**
       * Set the center of the overview map to the map center without changing its
       * resolution.
       * @private
       */
      OverviewMap.prototype.recenter_ = function () {
          var map = this.getMap();
          var ovmap = this.ovmap_;
          var view = map.getView();
          var ovview = ovmap.getView();
          ovview.setCenterInternal(view.getCenterInternal());
      };
      /**
       * Update the box using the main map extent
       * @private
       */
      OverviewMap.prototype.updateBox_ = function () {
          var map = this.getMap();
          var ovmap = this.ovmap_;
          if (!map.isRendered() || !ovmap.isRendered()) {
              return;
          }
          var mapSize = /** @type {import("../size.js").Size} */ (map.getSize());
          var view = map.getView();
          var ovview = ovmap.getView();
          var rotation = this.rotateWithView_ ? 0 : -view.getRotation();
          var overlay = this.boxOverlay_;
          var box = this.boxOverlay_.getElement();
          var center = view.getCenterInternal();
          var resolution = view.getResolution();
          var ovresolution = ovview.getResolution();
          var width = (mapSize[0] * resolution) / ovresolution;
          var height = (mapSize[1] * resolution) / ovresolution;
          // set position using center coordinates
          overlay.setPosition(center);
          // set box size calculated from map extent size and overview map resolution
          if (box) {
              box.style.width = width + 'px';
              box.style.height = height + 'px';
              var transform = 'rotate(' + rotation + 'rad)';
              box.style.transform = transform;
          }
      };
      /**
       * @param {MouseEvent} event The event to handle
       * @private
       */
      OverviewMap.prototype.handleClick_ = function (event) {
          event.preventDefault();
          this.handleToggle_();
      };
      /**
       * @private
       */
      OverviewMap.prototype.handleToggle_ = function () {
          this.element.classList.toggle(CLASS_COLLAPSED);
          if (this.collapsed_) {
              replaceNode(this.collapseLabel_, this.label_);
          }
          else {
              replaceNode(this.label_, this.collapseLabel_);
          }
          this.collapsed_ = !this.collapsed_;
          // manage overview map if it had not been rendered before and control
          // is expanded
          var ovmap = this.ovmap_;
          if (!this.collapsed_) {
              if (ovmap.isRendered()) {
                  this.viewExtent_ = undefined;
                  ovmap.render();
                  return;
              }
              ovmap.updateSize();
              this.resetExtent_();
              listenOnce(ovmap, MapEventType.POSTRENDER, function (event) {
                  this.updateBox_();
              }, this);
          }
      };
      /**
       * Return `true` if the overview map is collapsible, `false` otherwise.
       * @return {boolean} True if the widget is collapsible.
       * @api
       */
      OverviewMap.prototype.getCollapsible = function () {
          return this.collapsible_;
      };
      /**
       * Set whether the overview map should be collapsible.
       * @param {boolean} collapsible True if the widget is collapsible.
       * @api
       */
      OverviewMap.prototype.setCollapsible = function (collapsible) {
          if (this.collapsible_ === collapsible) {
              return;
          }
          this.collapsible_ = collapsible;
          this.element.classList.toggle('ol-uncollapsible');
          if (!collapsible && this.collapsed_) {
              this.handleToggle_();
          }
      };
      /**
       * Collapse or expand the overview map according to the passed parameter. Will
       * not do anything if the overview map isn't collapsible or if the current
       * collapsed state is already the one requested.
       * @param {boolean} collapsed True if the widget is collapsed.
       * @api
       */
      OverviewMap.prototype.setCollapsed = function (collapsed) {
          if (!this.collapsible_ || this.collapsed_ === collapsed) {
              return;
          }
          this.handleToggle_();
      };
      /**
       * Determine if the overview map is collapsed.
       * @return {boolean} The overview map is collapsed.
       * @api
       */
      OverviewMap.prototype.getCollapsed = function () {
          return this.collapsed_;
      };
      /**
       * Return `true` if the overview map view can rotate, `false` otherwise.
       * @return {boolean} True if the control view can rotate.
       * @api
       */
      OverviewMap.prototype.getRotateWithView = function () {
          return this.rotateWithView_;
      };
      /**
       * Set whether the overview map view should rotate with the main map view.
       * @param {boolean} rotateWithView True if the control view should rotate.
       * @api
       */
      OverviewMap.prototype.setRotateWithView = function (rotateWithView) {
          if (this.rotateWithView_ === rotateWithView) {
              return;
          }
          this.rotateWithView_ = rotateWithView;
          if (this.getMap().getView().getRotation() !== 0) {
              if (this.rotateWithView_) {
                  this.handleRotationChanged_();
              }
              else {
                  this.ovmap_.getView().setRotation(0);
              }
              this.viewExtent_ = undefined;
              this.validateExtent_();
              this.updateBox_();
          }
      };
      /**
       * Return the overview map.
       * @return {import("../PluggableMap.js").default} Overview map.
       * @api
       */
      OverviewMap.prototype.getOverviewMap = function () {
          return this.ovmap_;
      };
      /**
       * Update the overview map element.
       * @param {import("../MapEvent.js").default} mapEvent Map event.
       * @override
       */
      OverviewMap.prototype.render = function (mapEvent) {
          this.validateExtent_();
          this.updateBox_();
      };
      return OverviewMap;
  }(Control));

  /**
   * @module ol/control
   */
  /**
   * @typedef {Object} DefaultsOptions
   * @property {boolean} [attribution=true] Include
   * {@link module:ol/control/Attribution~Attribution}.
   * @property {import("./control/Attribution.js").Options} [attributionOptions]
   * Options for {@link module:ol/control/Attribution~Attribution}.
   * @property {boolean} [rotate=true] Include
   * {@link module:ol/control/Rotate~Rotate}.
   * @property {import("./control/Rotate.js").Options} [rotateOptions] Options
   * for {@link module:ol/control/Rotate~Rotate}.
   * @property {boolean} [zoom] Include {@link module:ol/control/Zoom~Zoom}.
   * @property {import("./control/Zoom.js").Options} [zoomOptions] Options for
   * {@link module:ol/control/Zoom~Zoom}.
   * @api
   */
  /**
   * Set of controls included in maps by default. Unless configured otherwise,
   * this returns a collection containing an instance of each of the following
   * controls:
   * * {@link module:ol/control/Zoom~Zoom}
   * * {@link module:ol/control/Rotate~Rotate}
   * * {@link module:ol/control/Attribution~Attribution}
   *
   * @param {DefaultsOptions=} opt_options
   * Defaults options.
   * @return {Collection<import("./control/Control.js").default>}
   * Controls.
   * @api
   */
  function defaults(opt_options) {
      var options = opt_options ? opt_options : {};
      var controls = new Collection();
      var zoomControl = options.zoom !== undefined ? options.zoom : true;
      if (zoomControl) {
          controls.push(new Zoom(options.zoomOptions));
      }
      var rotateControl = options.rotate !== undefined ? options.rotate : true;
      if (rotateControl) {
          controls.push(new Rotate(options.rotateOptions));
      }
      var attributionControl = options.attribution !== undefined ? options.attribution : true;
      if (attributionControl) {
          controls.push(new Attribution(options.attributionOptions));
      }
      return controls;
  }

  /**
   * @module ol/interaction/Property
   */
  /**
   * @enum {string}
   */
  var InteractionProperty = {
      ACTIVE: 'active',
  };

  var __extends$w = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * Object literal with config options for interactions.
   * @typedef {Object} InteractionOptions
   * @property {function(import("../MapBrowserEvent.js").default):boolean} handleEvent
   * Method called by the map to notify the interaction that a browser event was
   * dispatched to the map. If the function returns a falsy value, propagation of
   * the event to other interactions in the map's interactions chain will be
   * prevented (this includes functions with no explicit return). The interactions
   * are traversed in reverse order of the interactions collection of the map.
   */
  /**
   * @classdesc
   * Abstract base class; normally only used for creating subclasses and not
   * instantiated in apps.
   * User actions that change the state of the map. Some are similar to controls,
   * but are not associated with a DOM element.
   * For example, {@link module:ol/interaction/KeyboardZoom~KeyboardZoom} is
   * functionally the same as {@link module:ol/control/Zoom~Zoom}, but triggered
   * by a keyboard event not a button element event.
   * Although interactions do not have a DOM element, some of them do render
   * vectors and so are visible on the screen.
   * @api
   */
  var Interaction = /** @class */ (function (_super) {
      __extends$w(Interaction, _super);
      /**
       * @param {InteractionOptions=} opt_options Options.
       */
      function Interaction(opt_options) {
          var _this = _super.call(this) || this;
          if (opt_options && opt_options.handleEvent) {
              _this.handleEvent = opt_options.handleEvent;
          }
          /**
           * @private
           * @type {import("../PluggableMap.js").default}
           */
          _this.map_ = null;
          _this.setActive(true);
          return _this;
      }
      /**
       * Return whether the interaction is currently active.
       * @return {boolean} `true` if the interaction is active, `false` otherwise.
       * @observable
       * @api
       */
      Interaction.prototype.getActive = function () {
          return /** @type {boolean} */ (this.get(InteractionProperty.ACTIVE));
      };
      /**
       * Get the map associated with this interaction.
       * @return {import("../PluggableMap.js").default} Map.
       * @api
       */
      Interaction.prototype.getMap = function () {
          return this.map_;
      };
      /**
       * Handles the {@link module:ol/MapBrowserEvent map browser event}.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       * @api
       */
      Interaction.prototype.handleEvent = function (mapBrowserEvent) {
          return true;
      };
      /**
       * Activate or deactivate the interaction.
       * @param {boolean} active Active.
       * @observable
       * @api
       */
      Interaction.prototype.setActive = function (active) {
          this.set(InteractionProperty.ACTIVE, active);
      };
      /**
       * Remove the interaction from its current map and attach it to the new map.
       * Subclasses may set up event handlers to get notified about changes to
       * the map here.
       * @param {import("../PluggableMap.js").default} map Map.
       */
      Interaction.prototype.setMap = function (map) {
          this.map_ = map;
      };
      return Interaction;
  }(BaseObject));
  /**
   * @param {import("../View.js").default} view View.
   * @param {import("../coordinate.js").Coordinate} delta Delta.
   * @param {number=} opt_duration Duration.
   */
  function pan(view, delta, opt_duration) {
      var currentCenter = view.getCenterInternal();
      if (currentCenter) {
          var center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];
          view.animateInternal({
              duration: opt_duration !== undefined ? opt_duration : 250,
              easing: linear,
              center: view.getConstrainedCenter(center),
          });
      }
  }
  /**
   * @param {import("../View.js").default} view View.
   * @param {number} delta Delta from previous zoom level.
   * @param {import("../coordinate.js").Coordinate=} opt_anchor Anchor coordinate in the user projection.
   * @param {number=} opt_duration Duration.
   */
  function zoomByDelta(view, delta, opt_anchor, opt_duration) {
      var currentZoom = view.getZoom();
      if (currentZoom === undefined) {
          return;
      }
      var newZoom = view.getConstrainedZoom(currentZoom + delta);
      var newResolution = view.getResolutionForZoom(newZoom);
      if (view.getAnimating()) {
          view.cancelAnimations();
      }
      view.animate({
          resolution: newResolution,
          anchor: opt_anchor,
          duration: opt_duration !== undefined ? opt_duration : 250,
          easing: easeOut,
      });
  }

  var __extends$x = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {number} [duration=250] Animation duration in milliseconds.
   * @property {number} [delta=1] The zoom delta applied on each double click.
   */
  /**
   * @classdesc
   * Allows the user to zoom by double-clicking on the map.
   * @api
   */
  var DoubleClickZoom = /** @class */ (function (_super) {
      __extends$x(DoubleClickZoom, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function DoubleClickZoom(opt_options) {
          var _this = _super.call(this) || this;
          var options = opt_options ? opt_options : {};
          /**
           * @private
           * @type {number}
           */
          _this.delta_ = options.delta ? options.delta : 1;
          /**
           * @private
           * @type {number}
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 250;
          return _this;
      }
      /**
       * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a
       * doubleclick) and eventually zooms the map.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       */
      DoubleClickZoom.prototype.handleEvent = function (mapBrowserEvent) {
          var stopEvent = false;
          if (mapBrowserEvent.type == MapBrowserEventType.DBLCLICK) {
              var browserEvent = /** @type {MouseEvent} */ (mapBrowserEvent.originalEvent);
              var map = mapBrowserEvent.map;
              var anchor = mapBrowserEvent.coordinate;
              var delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
              var view = map.getView();
              zoomByDelta(view, delta, anchor, this.duration_);
              mapBrowserEvent.preventDefault();
              stopEvent = true;
          }
          return !stopEvent;
      };
      return DoubleClickZoom;
  }(Interaction));

  var __extends$y = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleDownEvent]
   * Function handling "down" events. If the function returns `true` then a drag
   * sequence is started.
   * @property {function(import("../MapBrowserEvent.js").default):void} [handleDragEvent]
   * Function handling "drag" events. This function is called on "move" events
   * during a drag sequence.
   * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleEvent]
   * Method called by the map to notify the interaction that a browser event was
   * dispatched to the map. The function may return `false` to prevent the
   * propagation of the event to other interactions in the map's interactions
   * chain.
   * @property {function(import("../MapBrowserEvent.js").default):void} [handleMoveEvent]
   * Function handling "move" events. This function is called on "move" events.
   * This functions is also called during a drag sequence, so during a drag
   * sequence both the `handleDragEvent` function and this function are called.
   * If `handleDownEvent` is defined and it returns true this function will not
   * be called during a drag sequence.
   * @property {function(import("../MapBrowserEvent.js").default):boolean} [handleUpEvent]
   *  Function handling "up" events. If the function returns `false` then the
   * current drag sequence is stopped.
   * @property {function(boolean):boolean} [stopDown]
   * Should the down event be propagated to other interactions, or should be
   * stopped?
   */
  /**
   * @classdesc
   * Base class that calls user-defined functions on `down`, `move` and `up`
   * events. This class also manages "drag sequences".
   *
   * When the `handleDownEvent` user function returns `true` a drag sequence is
   * started. During a drag sequence the `handleDragEvent` user function is
   * called on `move` events. The drag sequence ends when the `handleUpEvent`
   * user function is called and returns `false`.
   * @api
   */
  var PointerInteraction = /** @class */ (function (_super) {
      __extends$y(PointerInteraction, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function PointerInteraction(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, 
          /** @type {import("./Interaction.js").InteractionOptions} */ (options)) || this;
          if (options.handleDownEvent) {
              _this.handleDownEvent = options.handleDownEvent;
          }
          if (options.handleDragEvent) {
              _this.handleDragEvent = options.handleDragEvent;
          }
          if (options.handleMoveEvent) {
              _this.handleMoveEvent = options.handleMoveEvent;
          }
          if (options.handleUpEvent) {
              _this.handleUpEvent = options.handleUpEvent;
          }
          if (options.stopDown) {
              _this.stopDown = options.stopDown;
          }
          /**
           * @type {boolean}
           * @protected
           */
          _this.handlingDownUpSequence = false;
          /**
           * @type {!Object<string, PointerEvent>}
           * @private
           */
          _this.trackedPointers_ = {};
          /**
           * @type {Array<PointerEvent>}
           * @protected
           */
          _this.targetPointers = [];
          return _this;
      }
      /**
       * Returns the current number of pointers involved in the interaction,
       * e.g. `2` when two fingers are used.
       * @return {number} The number of pointers.
       * @api
       */
      PointerInteraction.prototype.getPointerCount = function () {
          return this.targetPointers.length;
      };
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       * @protected
       */
      PointerInteraction.prototype.handleDownEvent = function (mapBrowserEvent) {
          return false;
      };
      /**
       * Handle pointer drag events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @protected
       */
      PointerInteraction.prototype.handleDragEvent = function (mapBrowserEvent) { };
      /**
       * Handles the {@link module:ol/MapBrowserEvent map browser event} and may call into
       * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
       * detected.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       * @api
       */
      PointerInteraction.prototype.handleEvent = function (mapBrowserEvent) {
          if (!mapBrowserEvent.originalEvent) {
              return true;
          }
          var stopEvent = false;
          this.updateTrackedPointers_(mapBrowserEvent);
          if (this.handlingDownUpSequence) {
              if (mapBrowserEvent.type == MapBrowserEventType.POINTERDRAG) {
                  this.handleDragEvent(mapBrowserEvent);
                  // prevent page scrolling during dragging
                  mapBrowserEvent.preventDefault();
              }
              else if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {
                  var handledUp = this.handleUpEvent(mapBrowserEvent);
                  this.handlingDownUpSequence =
                      handledUp && this.targetPointers.length > 0;
              }
          }
          else {
              if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {
                  var handled = this.handleDownEvent(mapBrowserEvent);
                  this.handlingDownUpSequence = handled;
                  stopEvent = this.stopDown(handled);
              }
              else if (mapBrowserEvent.type == MapBrowserEventType.POINTERMOVE) {
                  this.handleMoveEvent(mapBrowserEvent);
              }
          }
          return !stopEvent;
      };
      /**
       * Handle pointer move events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @protected
       */
      PointerInteraction.prototype.handleMoveEvent = function (mapBrowserEvent) { };
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       * @protected
       */
      PointerInteraction.prototype.handleUpEvent = function (mapBrowserEvent) {
          return false;
      };
      /**
       * This function is used to determine if "down" events should be propagated
       * to other interactions or should be stopped.
       * @param {boolean} handled Was the event handled by the interaction?
       * @return {boolean} Should the `down` event be stopped?
       */
      PointerInteraction.prototype.stopDown = function (handled) {
          return handled;
      };
      /**
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @private
       */
      PointerInteraction.prototype.updateTrackedPointers_ = function (mapBrowserEvent) {
          if (isPointerDraggingEvent(mapBrowserEvent)) {
              var event_1 = mapBrowserEvent.originalEvent;
              var id = event_1.pointerId.toString();
              if (mapBrowserEvent.type == MapBrowserEventType.POINTERUP) {
                  delete this.trackedPointers_[id];
              }
              else if (mapBrowserEvent.type == MapBrowserEventType.POINTERDOWN) {
                  this.trackedPointers_[id] = event_1;
              }
              else if (id in this.trackedPointers_) {
                  // update only when there was a pointerdown event for this pointer
                  this.trackedPointers_[id] = event_1;
              }
              this.targetPointers = getValues(this.trackedPointers_);
          }
      };
      return PointerInteraction;
  }(Interaction));
  /**
   * @param {Array<PointerEvent>} pointerEvents List of events.
   * @return {import("../pixel.js").Pixel} Centroid pixel.
   */
  function centroid(pointerEvents) {
      var length = pointerEvents.length;
      var clientX = 0;
      var clientY = 0;
      for (var i = 0; i < length; i++) {
          clientX += pointerEvents[i].clientX;
          clientY += pointerEvents[i].clientY;
      }
      return [clientX / length, clientY / length];
  }
  /**
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
   * @return {boolean} Whether the event is a pointerdown, pointerdrag
   *     or pointerup event.
   */
  function isPointerDraggingEvent(mapBrowserEvent) {
      var type = mapBrowserEvent.type;
      return (type === MapBrowserEventType.POINTERDOWN ||
          type === MapBrowserEventType.POINTERDRAG ||
          type === MapBrowserEventType.POINTERUP);
  }

  /**
   * @module ol/events/condition
   */
  /**
   * A function that takes an {@link module:ol/MapBrowserEvent} and returns a
   * `{boolean}`. If the condition is met, true should be returned.
   *
   * @typedef {function(this: ?, import("../MapBrowserEvent.js").default): boolean} Condition
   */
  /**
   * Creates a condition function that passes when all provided conditions pass.
   * @param {...Condition} var_args Conditions to check.
   * @return {Condition} Condition function.
   */
  function all(var_args) {
      var conditions = arguments;
      /**
       * @param {import("../MapBrowserEvent.js").default} event Event.
       * @return {boolean} All conditions passed.
       */
      return function (event) {
          var pass = true;
          for (var i = 0, ii = conditions.length; i < ii; ++i) {
              pass = pass && conditions[i](event);
              if (!pass) {
                  break;
              }
          }
          return pass;
      };
  }
  /**
   * Return `true` if only the alt-key and shift-key is pressed, `false` otherwise
   * (e.g. when additionally the platform-modifier-key is pressed).
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True if only the alt and shift keys are pressed.
   * @api
   */
  var altShiftKeysOnly = function (mapBrowserEvent) {
      var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
      return (originalEvent.altKey &&
          !(originalEvent.metaKey || originalEvent.ctrlKey) &&
          originalEvent.shiftKey);
  };
  /**
   * Return `true` if the map has the focus. This condition requires a map target
   * element with a `tabindex` attribute, e.g. `<div id="map" tabindex="1">`.
   *
   * @param {import("../MapBrowserEvent.js").default} event Map browser event.
   * @return {boolean} The map has the focus.
   * @api
   */
  var focus = function (event) {
      return event.target.getTargetElement().contains(document.activeElement);
  };
  /**
   * Return `true` if the map has the focus or no 'tabindex' attribute set.
   *
   * @param {import("../MapBrowserEvent.js").default} event Map browser event.
   * @return {boolean} The map container has the focus or no 'tabindex' attribute.
   */
  var focusWithTabindex = function (event) {
      return event.map.getTargetElement().hasAttribute('tabindex')
          ? focus(event)
          : true;
  };
  /**
   * Return always true.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True.
   * @api
   */
  var always = TRUE;
  /**
   * Return `true` if the event has an "action"-producing mouse button.
   *
   * By definition, this includes left-click on windows/linux, and left-click
   * without the ctrl key on Macs.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} The result.
   */
  var mouseActionButton = function (mapBrowserEvent) {
      var originalEvent = /** @type {MouseEvent} */ (mapBrowserEvent.originalEvent);
      return originalEvent.button == 0 && !(WEBKIT && MAC && originalEvent.ctrlKey);
  };
  /**
   * Return always false.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} False.
   * @api
   */
  var never = FALSE;
  /**
   * Return `true` if the event is a map `singleclick` event, `false` otherwise.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True if the event is a map `singleclick` event.
   * @api
   */
  var singleClick = function (mapBrowserEvent) {
      return mapBrowserEvent.type == MapBrowserEventType.SINGLECLICK;
  };
  /**
   * Return `true` if no modifier key (alt-, shift- or platform-modifier-key) is
   * pressed.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True only if there no modifier keys are pressed.
   * @api
   */
  var noModifierKeys = function (mapBrowserEvent) {
      var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
      return (!originalEvent.altKey &&
          !(originalEvent.metaKey || originalEvent.ctrlKey) &&
          !originalEvent.shiftKey);
  };
  /**
   * Return `true` if only the shift-key is pressed, `false` otherwise (e.g. when
   * additionally the alt-key is pressed).
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True if only the shift key is pressed.
   * @api
   */
  var shiftKeyOnly = function (mapBrowserEvent) {
      var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
      return (!originalEvent.altKey &&
          !(originalEvent.metaKey || originalEvent.ctrlKey) &&
          originalEvent.shiftKey);
  };
  /**
   * Return `true` if the target element is not editable, i.e. not a `<input>`-,
   * `<select>`- or `<textarea>`-element, `false` otherwise.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True only if the target element is not editable.
   * @api
   */
  var targetNotEditable = function (mapBrowserEvent) {
      var originalEvent = /** @type {KeyboardEvent|MouseEvent|TouchEvent} */ (mapBrowserEvent.originalEvent);
      var tagName = /** @type {Element} */ (originalEvent.target).tagName;
      return tagName !== 'INPUT' && tagName !== 'SELECT' && tagName !== 'TEXTAREA';
  };
  /**
   * Return `true` if the event originates from a mouse device.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True if the event originates from a mouse device.
   * @api
   */
  var mouseOnly = function (mapBrowserEvent) {
      var pointerEvent = /** @type {import("../MapBrowserEvent").default} */ (mapBrowserEvent)
          .originalEvent;
      assert(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event
      // see http://www.w3.org/TR/pointerevents/#widl-PointerEvent-pointerType
      return pointerEvent.pointerType == 'mouse';
  };
  /**
   * Return `true` if the event originates from a primary pointer in
   * contact with the surface or if the left mouse button is pressed.
   * See http://www.w3.org/TR/pointerevents/#button-states.
   *
   * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
   * @return {boolean} True if the event originates from a primary pointer.
   * @api
   */
  var primaryAction = function (mapBrowserEvent) {
      var pointerEvent = /** @type {import("../MapBrowserEvent").default} */ (mapBrowserEvent)
          .originalEvent;
      assert(pointerEvent !== undefined, 56); // mapBrowserEvent must originate from a pointer event
      return pointerEvent.isPrimary && pointerEvent.button === 0;
  };

  var __extends$z = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
   * to indicate whether that event should be handled.
   * Default is {@link module:ol/events/condition~noModifierKeys} and {@link module:ol/events/condition~primaryAction}.
   * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
   * the interaction will only handle events when the map has the focus.
   * @property {import("../Kinetic.js").default} [kinetic] Kinetic inertia to apply to the pan.
   */
  /**
   * @classdesc
   * Allows the user to pan the map by dragging the map.
   * @api
   */
  var DragPan = /** @class */ (function (_super) {
      __extends$z(DragPan, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function DragPan(opt_options) {
          var _this = _super.call(this, {
              stopDown: FALSE,
          }) || this;
          var options = opt_options ? opt_options : {};
          /**
           * @private
           * @type {import("../Kinetic.js").default|undefined}
           */
          _this.kinetic_ = options.kinetic;
          /**
           * @type {import("../pixel.js").Pixel}
           */
          _this.lastCentroid = null;
          /**
           * @type {number}
           */
          _this.lastPointersCount_;
          /**
           * @type {boolean}
           */
          _this.panning_ = false;
          var condition = options.condition
              ? options.condition
              : all(noModifierKeys, primaryAction);
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.condition_ = options.onFocusOnly
              ? all(focusWithTabindex, condition)
              : condition;
          /**
           * @private
           * @type {boolean}
           */
          _this.noKinetic_ = false;
          return _this;
      }
      /**
       * Handle pointer drag events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       */
      DragPan.prototype.handleDragEvent = function (mapBrowserEvent) {
          if (!this.panning_) {
              this.panning_ = true;
              this.getMap().getView().beginInteraction();
          }
          var targetPointers = this.targetPointers;
          var centroid$1 = centroid(targetPointers);
          if (targetPointers.length == this.lastPointersCount_) {
              if (this.kinetic_) {
                  this.kinetic_.update(centroid$1[0], centroid$1[1]);
              }
              if (this.lastCentroid) {
                  var delta = [
                      this.lastCentroid[0] - centroid$1[0],
                      centroid$1[1] - this.lastCentroid[1],
                  ];
                  var map = mapBrowserEvent.map;
                  var view = map.getView();
                  scale$1(delta, view.getResolution());
                  rotate$1(delta, view.getRotation());
                  view.adjustCenterInternal(delta);
              }
          }
          else if (this.kinetic_) {
              // reset so we don't overestimate the kinetic energy after
              // after one finger down, tiny drag, second finger down
              this.kinetic_.begin();
          }
          this.lastCentroid = centroid$1;
          this.lastPointersCount_ = targetPointers.length;
          mapBrowserEvent.originalEvent.preventDefault();
      };
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      DragPan.prototype.handleUpEvent = function (mapBrowserEvent) {
          var map = mapBrowserEvent.map;
          var view = map.getView();
          if (this.targetPointers.length === 0) {
              if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
                  var distance = this.kinetic_.getDistance();
                  var angle = this.kinetic_.getAngle();
                  var center = view.getCenterInternal();
                  var centerpx = map.getPixelFromCoordinateInternal(center);
                  var dest = map.getCoordinateFromPixelInternal([
                      centerpx[0] - distance * Math.cos(angle),
                      centerpx[1] - distance * Math.sin(angle),
                  ]);
                  view.animateInternal({
                      center: view.getConstrainedCenter(dest),
                      duration: 500,
                      easing: easeOut,
                  });
              }
              if (this.panning_) {
                  this.panning_ = false;
                  view.endInteraction();
              }
              return false;
          }
          else {
              if (this.kinetic_) {
                  // reset so we don't overestimate the kinetic energy after
                  // after one finger up, tiny drag, second finger up
                  this.kinetic_.begin();
              }
              this.lastCentroid = null;
              return true;
          }
      };
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      DragPan.prototype.handleDownEvent = function (mapBrowserEvent) {
          if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
              var map = mapBrowserEvent.map;
              var view = map.getView();
              this.lastCentroid = null;
              // stop any current animation
              if (view.getAnimating()) {
                  view.cancelAnimations();
              }
              if (this.kinetic_) {
                  this.kinetic_.begin();
              }
              // No kinetic as soon as more than one pointer on the screen is
              // detected. This is to prevent nasty pans after pinch.
              this.noKinetic_ = this.targetPointers.length > 1;
              return true;
          }
          else {
              return false;
          }
      };
      return DragPan;
  }(PointerInteraction));

  var __extends$A = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {import("../events/condition.js").Condition} [condition] A function that takes an
   * {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
   * to indicate whether that event should be handled.
   * Default is {@link module:ol/events/condition~altShiftKeysOnly}.
   * @property {number} [duration=250] Animation duration in milliseconds.
   */
  /**
   * @classdesc
   * Allows the user to rotate the map by clicking and dragging on the map,
   * normally combined with an {@link module:ol/events/condition} that limits
   * it to when the alt and shift keys are held down.
   *
   * This interaction is only supported for mouse devices.
   * @api
   */
  var DragRotate = /** @class */ (function (_super) {
      __extends$A(DragRotate, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function DragRotate(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, {
              stopDown: FALSE,
          }) || this;
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.condition_ = options.condition ? options.condition : altShiftKeysOnly;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.lastAngle_ = undefined;
          /**
           * @private
           * @type {number}
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 250;
          return _this;
      }
      /**
       * Handle pointer drag events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       */
      DragRotate.prototype.handleDragEvent = function (mapBrowserEvent) {
          if (!mouseOnly(mapBrowserEvent)) {
              return;
          }
          var map = mapBrowserEvent.map;
          var view = map.getView();
          if (view.getConstraints().rotation === disable) {
              return;
          }
          var size = map.getSize();
          var offset = mapBrowserEvent.pixel;
          var theta = Math.atan2(size[1] / 2 - offset[1], offset[0] - size[0] / 2);
          if (this.lastAngle_ !== undefined) {
              var delta = theta - this.lastAngle_;
              view.adjustRotationInternal(-delta);
          }
          this.lastAngle_ = theta;
      };
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      DragRotate.prototype.handleUpEvent = function (mapBrowserEvent) {
          if (!mouseOnly(mapBrowserEvent)) {
              return true;
          }
          var map = mapBrowserEvent.map;
          var view = map.getView();
          view.endInteraction(this.duration_);
          return false;
      };
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      DragRotate.prototype.handleDownEvent = function (mapBrowserEvent) {
          if (!mouseOnly(mapBrowserEvent)) {
              return false;
          }
          if (mouseActionButton(mapBrowserEvent) &&
              this.condition_(mapBrowserEvent)) {
              var map = mapBrowserEvent.map;
              map.getView().beginInteraction();
              this.lastAngle_ = undefined;
              return true;
          }
          else {
              return false;
          }
      };
      return DragRotate;
  }(PointerInteraction));

  /**
   * @module ol/render/Box
   */
  var __extends$B = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var RenderBox = /** @class */ (function (_super) {
      __extends$B(RenderBox, _super);
      /**
       * @param {string} className CSS class name.
       */
      function RenderBox(className) {
          var _this = _super.call(this) || this;
          /**
           * @type {import("../geom/Polygon.js").default}
           * @private
           */
          _this.geometry_ = null;
          /**
           * @type {HTMLDivElement}
           * @private
           */
          _this.element_ = document.createElement('div');
          _this.element_.style.position = 'absolute';
          _this.element_.style.pointerEvents = 'auto';
          _this.element_.className = 'ol-box ' + className;
          /**
           * @private
           * @type {import("../PluggableMap.js").default}
           */
          _this.map_ = null;
          /**
           * @private
           * @type {import("../pixel.js").Pixel}
           */
          _this.startPixel_ = null;
          /**
           * @private
           * @type {import("../pixel.js").Pixel}
           */
          _this.endPixel_ = null;
          return _this;
      }
      /**
       * Clean up.
       */
      RenderBox.prototype.disposeInternal = function () {
          this.setMap(null);
      };
      /**
       * @private
       */
      RenderBox.prototype.render_ = function () {
          var startPixel = this.startPixel_;
          var endPixel = this.endPixel_;
          var px = 'px';
          var style = this.element_.style;
          style.left = Math.min(startPixel[0], endPixel[0]) + px;
          style.top = Math.min(startPixel[1], endPixel[1]) + px;
          style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
          style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
      };
      /**
       * @param {import("../PluggableMap.js").default} map Map.
       */
      RenderBox.prototype.setMap = function (map) {
          if (this.map_) {
              this.map_.getOverlayContainer().removeChild(this.element_);
              var style = this.element_.style;
              style.left = 'inherit';
              style.top = 'inherit';
              style.width = 'inherit';
              style.height = 'inherit';
          }
          this.map_ = map;
          if (this.map_) {
              this.map_.getOverlayContainer().appendChild(this.element_);
          }
      };
      /**
       * @param {import("../pixel.js").Pixel} startPixel Start pixel.
       * @param {import("../pixel.js").Pixel} endPixel End pixel.
       */
      RenderBox.prototype.setPixels = function (startPixel, endPixel) {
          this.startPixel_ = startPixel;
          this.endPixel_ = endPixel;
          this.createOrUpdateGeometry();
          this.render_();
      };
      /**
       * Creates or updates the cached geometry.
       */
      RenderBox.prototype.createOrUpdateGeometry = function () {
          var startPixel = this.startPixel_;
          var endPixel = this.endPixel_;
          var pixels = [
              startPixel,
              [startPixel[0], endPixel[1]],
              endPixel,
              [endPixel[0], startPixel[1]],
          ];
          var coordinates = pixels.map(this.map_.getCoordinateFromPixelInternal, this.map_);
          // close the polygon
          coordinates[4] = coordinates[0].slice();
          if (!this.geometry_) {
              this.geometry_ = new Polygon([coordinates]);
          }
          else {
              this.geometry_.setCoordinates([coordinates]);
          }
      };
      /**
       * @return {import("../geom/Polygon.js").default} Geometry.
       */
      RenderBox.prototype.getGeometry = function () {
          return this.geometry_;
      };
      return RenderBox;
  }(Disposable));

  var __extends$C = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * A function that takes a {@link module:ol/MapBrowserEvent} and two
   * {@link module:ol/pixel~Pixel}s and returns a `{boolean}`. If the condition is met,
   * true should be returned.
   * @typedef {function(this: ?, import("../MapBrowserEvent.js").default, import("../pixel.js").Pixel, import("../pixel.js").Pixel):boolean} EndCondition
   */
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-dragbox'] CSS class name for styling the box.
   * @property {import("../events/condition.js").Condition} [condition] A function that takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a boolean
   * to indicate whether that event should be handled.
   * Default is {@link ol/events/condition~mouseActionButton}.
   * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the default
   * `boxEndCondition` function.
   * @property {EndCondition} [boxEndCondition] A function that takes a {@link module:ol/MapBrowserEvent~MapBrowserEvent} and two
   * {@link module:ol/pixel~Pixel}s to indicate whether a `boxend` event should be fired.
   * Default is `true` if the area of the box is bigger than the `minArea` option.
   * @property {function(this:DragBox, import("../MapBrowserEvent.js").default):void} [onBoxEnd] Code to execute just
   * before `boxend` is fired.
   */
  /**
   * @enum {string}
   */
  var DragBoxEventType = {
      /**
       * Triggered upon drag box start.
       * @event DragBoxEvent#boxstart
       * @api
       */
      BOXSTART: 'boxstart',
      /**
       * Triggered on drag when box is active.
       * @event DragBoxEvent#boxdrag
       * @api
       */
      BOXDRAG: 'boxdrag',
      /**
       * Triggered upon drag box end.
       * @event DragBoxEvent#boxend
       * @api
       */
      BOXEND: 'boxend',
  };
  /**
   * @classdesc
   * Events emitted by {@link module:ol/interaction/DragBox~DragBox} instances are instances of
   * this type.
   */
  var DragBoxEvent = /** @class */ (function (_super) {
      __extends$C(DragBoxEvent, _super);
      /**
       * @param {string} type The event type.
       * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
       */
      function DragBoxEvent(type, coordinate, mapBrowserEvent) {
          var _this = _super.call(this, type) || this;
          /**
           * The coordinate of the drag event.
           * @const
           * @type {import("../coordinate.js").Coordinate}
           * @api
           */
          _this.coordinate = coordinate;
          /**
           * @const
           * @type {import("../MapBrowserEvent.js").default}
           * @api
           */
          _this.mapBrowserEvent = mapBrowserEvent;
          return _this;
      }
      return DragBoxEvent;
  }(BaseEvent));
  /**
   * @classdesc
   * Allows the user to draw a vector box by clicking and dragging on the map,
   * normally combined with an {@link module:ol/events/condition} that limits
   * it to when the shift or other key is held down. This is used, for example,
   * for zooming to a specific area of the map
   * (see {@link module:ol/interaction/DragZoom~DragZoom} and
   * {@link module:ol/interaction/DragRotateAndZoom}).
   *
   * @fires DragBoxEvent
   * @api
   */
  var DragBox = /** @class */ (function (_super) {
      __extends$C(DragBox, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function DragBox(opt_options) {
          var _this = _super.call(this) || this;
          var options = opt_options ? opt_options : {};
          /**
           * @type {import("../render/Box.js").default}
           * @private
           */
          _this.box_ = new RenderBox(options.className || 'ol-dragbox');
          /**
           * @type {number}
           * @private
           */
          _this.minArea_ = options.minArea !== undefined ? options.minArea : 64;
          if (options.onBoxEnd) {
              _this.onBoxEnd = options.onBoxEnd;
          }
          /**
           * @type {import("../pixel.js").Pixel}
           * @private
           */
          _this.startPixel_ = null;
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.condition_ = options.condition ? options.condition : mouseActionButton;
          /**
           * @private
           * @type {EndCondition}
           */
          _this.boxEndCondition_ = options.boxEndCondition
              ? options.boxEndCondition
              : _this.defaultBoxEndCondition;
          return _this;
      }
      /**
       * The default condition for determining whether the boxend event
       * should fire.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
       *     leading to the box end.
       * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
       * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
       * @return {boolean} Whether or not the boxend condition should be fired.
       */
      DragBox.prototype.defaultBoxEndCondition = function (mapBrowserEvent, startPixel, endPixel) {
          var width = endPixel[0] - startPixel[0];
          var height = endPixel[1] - startPixel[1];
          return width * width + height * height >= this.minArea_;
      };
      /**
       * Returns geometry of last drawn box.
       * @return {import("../geom/Polygon.js").default} Geometry.
       * @api
       */
      DragBox.prototype.getGeometry = function () {
          return this.box_.getGeometry();
      };
      /**
       * Handle pointer drag events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       */
      DragBox.prototype.handleDragEvent = function (mapBrowserEvent) {
          this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
          this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG, mapBrowserEvent.coordinate, mapBrowserEvent));
      };
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      DragBox.prototype.handleUpEvent = function (mapBrowserEvent) {
          this.box_.setMap(null);
          if (this.boxEndCondition_(mapBrowserEvent, this.startPixel_, mapBrowserEvent.pixel)) {
              this.onBoxEnd(mapBrowserEvent);
              this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXEND, mapBrowserEvent.coordinate, mapBrowserEvent));
          }
          return false;
      };
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      DragBox.prototype.handleDownEvent = function (mapBrowserEvent) {
          if (this.condition_(mapBrowserEvent)) {
              this.startPixel_ = mapBrowserEvent.pixel;
              this.box_.setMap(mapBrowserEvent.map);
              this.box_.setPixels(this.startPixel_, this.startPixel_);
              this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART, mapBrowserEvent.coordinate, mapBrowserEvent));
              return true;
          }
          else {
              return false;
          }
      };
      /**
       * Function to execute just before `onboxend` is fired
       * @param {import("../MapBrowserEvent.js").default} event Event.
       */
      DragBox.prototype.onBoxEnd = function (event) { };
      return DragBox;
  }(PointerInteraction));

  var __extends$D = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-dragzoom'] CSS class name for styling the
   * box.
   * @property {import("../events/condition.js").Condition} [condition] A function that
   * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled.
   * Default is {@link module:ol/events/condition~shiftKeyOnly}.
   * @property {number} [duration=200] Animation duration in milliseconds.
   * @property {boolean} [out=false] Use interaction for zooming out.
   * @property {number} [minArea=64] The minimum area of the box in pixel, this value is used by the parent default
   * `boxEndCondition` function.
   */
  /**
   * @classdesc
   * Allows the user to zoom the map by clicking and dragging on the map,
   * normally combined with an {@link module:ol/events/condition} that limits
   * it to when a key, shift by default, is held down.
   *
   * To change the style of the box, use CSS and the `.ol-dragzoom` selector, or
   * your custom one configured with `className`.
   * @api
   */
  var DragZoom = /** @class */ (function (_super) {
      __extends$D(DragZoom, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function DragZoom(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          var condition = options.condition ? options.condition : shiftKeyOnly;
          _this = _super.call(this, {
              condition: condition,
              className: options.className || 'ol-dragzoom',
              minArea: options.minArea,
          }) || this;
          /**
           * @private
           * @type {number}
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 200;
          /**
           * @private
           * @type {boolean}
           */
          _this.out_ = options.out !== undefined ? options.out : false;
          return _this;
      }
      /**
       * Function to execute just before `onboxend` is fired
       * @param {import("../MapBrowserEvent.js").default} event Event.
       */
      DragZoom.prototype.onBoxEnd = function (event) {
          var map = this.getMap();
          var view = /** @type {!import("../View.js").default} */ (map.getView());
          var size = /** @type {!import("../size.js").Size} */ (map.getSize());
          var extent = this.getGeometry().getExtent();
          if (this.out_) {
              var mapExtent = view.calculateExtentInternal(size);
              var boxPixelExtent = createOrUpdateFromCoordinates([
                  map.getPixelFromCoordinateInternal(getBottomLeft(extent)),
                  map.getPixelFromCoordinateInternal(getTopRight(extent)),
              ]);
              var factor = view.getResolutionForExtentInternal(boxPixelExtent, size);
              scaleFromCenter(mapExtent, 1 / factor);
              extent = mapExtent;
          }
          var resolution = view.getConstrainedResolution(view.getResolutionForExtentInternal(extent, size));
          var center = view.getConstrainedCenter(getCenter(extent), resolution);
          view.animateInternal({
              resolution: resolution,
              center: center,
              duration: this.duration_,
              easing: easeOut,
          });
      };
      return DragZoom;
  }(DragBox));

  /**
   * @module ol/events/KeyCode
   */
  /**
   * @enum {number}
   * @const
   */
  var KeyCode = {
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40,
  };

  var __extends$E = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {import("../events/condition.js").Condition} [condition] A function that
   * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled. Default is
   * {@link module:ol/events/condition~noModifierKeys} and
   * {@link module:ol/events/condition~targetNotEditable}.
   * @property {number} [duration=100] Animation duration in milliseconds.
   * @property {number} [pixelDelta=128] The amount of pixels to pan on each key
   * press.
   */
  /**
   * @classdesc
   * Allows the user to pan the map using keyboard arrows.
   * Note that, although this interaction is by default included in maps,
   * the keys can only be used when browser focus is on the element to which
   * the keyboard events are attached. By default, this is the map div,
   * though you can change this with the `keyboardEventTarget` in
   * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
   * element, focus will have to be on, and returned to, this element if the keys
   * are to function.
   * See also {@link module:ol/interaction/KeyboardZoom~KeyboardZoom}.
   * @api
   */
  var KeyboardPan = /** @class */ (function (_super) {
      __extends$E(KeyboardPan, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function KeyboardPan(opt_options) {
          var _this = _super.call(this) || this;
          var options = opt_options || {};
          /**
           * @private
           * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Browser event.
           * @return {boolean} Combined condition result.
           */
          _this.defaultCondition_ = function (mapBrowserEvent) {
              return (noModifierKeys(mapBrowserEvent) && targetNotEditable(mapBrowserEvent));
          };
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.condition_ =
              options.condition !== undefined
                  ? options.condition
                  : _this.defaultCondition_;
          /**
           * @private
           * @type {number}
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 100;
          /**
           * @private
           * @type {number}
           */
          _this.pixelDelta_ =
              options.pixelDelta !== undefined ? options.pixelDelta : 128;
          return _this;
      }
      /**
       * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a
       * `KeyEvent`, and decides the direction to pan to (if an arrow key was
       * pressed).
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       * @this {KeyboardPan}
       */
      KeyboardPan.prototype.handleEvent = function (mapBrowserEvent) {
          var stopEvent = false;
          if (mapBrowserEvent.type == EventType.KEYDOWN) {
              var keyEvent = /** @type {KeyboardEvent} */ (mapBrowserEvent.originalEvent);
              var keyCode = keyEvent.keyCode;
              if (this.condition_(mapBrowserEvent) &&
                  (keyCode == KeyCode.DOWN ||
                      keyCode == KeyCode.LEFT ||
                      keyCode == KeyCode.RIGHT ||
                      keyCode == KeyCode.UP)) {
                  var map = mapBrowserEvent.map;
                  var view = map.getView();
                  var mapUnitsDelta = view.getResolution() * this.pixelDelta_;
                  var deltaX = 0, deltaY = 0;
                  if (keyCode == KeyCode.DOWN) {
                      deltaY = -mapUnitsDelta;
                  }
                  else if (keyCode == KeyCode.LEFT) {
                      deltaX = -mapUnitsDelta;
                  }
                  else if (keyCode == KeyCode.RIGHT) {
                      deltaX = mapUnitsDelta;
                  }
                  else {
                      deltaY = mapUnitsDelta;
                  }
                  var delta = [deltaX, deltaY];
                  rotate$1(delta, view.getRotation());
                  pan(view, delta, this.duration_);
                  mapBrowserEvent.preventDefault();
                  stopEvent = true;
              }
          }
          return !stopEvent;
      };
      return KeyboardPan;
  }(Interaction));

  var __extends$F = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {number} [duration=100] Animation duration in milliseconds.
   * @property {import("../events/condition.js").Condition} [condition] A function that
   * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled. Default is
   * {@link module:ol/events/condition~targetNotEditable}.
   * @property {number} [delta=1] The zoom level delta on each key press.
   */
  /**
   * @classdesc
   * Allows the user to zoom the map using keyboard + and -.
   * Note that, although this interaction is by default included in maps,
   * the keys can only be used when browser focus is on the element to which
   * the keyboard events are attached. By default, this is the map div,
   * though you can change this with the `keyboardEventTarget` in
   * {@link module:ol/Map~Map}. `document` never loses focus but, for any other
   * element, focus will have to be on, and returned to, this element if the keys
   * are to function.
   * See also {@link module:ol/interaction/KeyboardPan~KeyboardPan}.
   * @api
   */
  var KeyboardZoom = /** @class */ (function (_super) {
      __extends$F(KeyboardZoom, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function KeyboardZoom(opt_options) {
          var _this = _super.call(this) || this;
          var options = opt_options ? opt_options : {};
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.condition_ = options.condition ? options.condition : targetNotEditable;
          /**
           * @private
           * @type {number}
           */
          _this.delta_ = options.delta ? options.delta : 1;
          /**
           * @private
           * @type {number}
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 100;
          return _this;
      }
      /**
       * Handles the {@link module:ol/MapBrowserEvent map browser event} if it was a
       * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
       * key pressed was '+' or '-').
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       * @this {KeyboardZoom}
       */
      KeyboardZoom.prototype.handleEvent = function (mapBrowserEvent) {
          var stopEvent = false;
          if (mapBrowserEvent.type == EventType.KEYDOWN ||
              mapBrowserEvent.type == EventType.KEYPRESS) {
              var keyEvent = /** @type {KeyboardEvent} */ (mapBrowserEvent.originalEvent);
              var charCode = keyEvent.charCode;
              if (this.condition_(mapBrowserEvent) &&
                  (charCode == '+'.charCodeAt(0) || charCode == '-'.charCodeAt(0))) {
                  var map = mapBrowserEvent.map;
                  var delta = charCode == '+'.charCodeAt(0) ? this.delta_ : -this.delta_;
                  var view = map.getView();
                  zoomByDelta(view, delta, undefined, this.duration_);
                  mapBrowserEvent.preventDefault();
                  stopEvent = true;
              }
          }
          return !stopEvent;
      };
      return KeyboardZoom;
  }(Interaction));

  /**
   * @module ol/Kinetic
   */
  /**
   * @classdesc
   * Implementation of inertial deceleration for map movement.
   *
   * @api
   */
  var Kinetic = /** @class */ (function () {
      /**
       * @param {number} decay Rate of decay (must be negative).
       * @param {number} minVelocity Minimum velocity (pixels/millisecond).
       * @param {number} delay Delay to consider to calculate the kinetic
       *     initial values (milliseconds).
       */
      function Kinetic(decay, minVelocity, delay) {
          /**
           * @private
           * @type {number}
           */
          this.decay_ = decay;
          /**
           * @private
           * @type {number}
           */
          this.minVelocity_ = minVelocity;
          /**
           * @private
           * @type {number}
           */
          this.delay_ = delay;
          /**
           * @private
           * @type {Array<number>}
           */
          this.points_ = [];
          /**
           * @private
           * @type {number}
           */
          this.angle_ = 0;
          /**
           * @private
           * @type {number}
           */
          this.initialVelocity_ = 0;
      }
      /**
       * FIXME empty description for jsdoc
       */
      Kinetic.prototype.begin = function () {
          this.points_.length = 0;
          this.angle_ = 0;
          this.initialVelocity_ = 0;
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       */
      Kinetic.prototype.update = function (x, y) {
          this.points_.push(x, y, Date.now());
      };
      /**
       * @return {boolean} Whether we should do kinetic animation.
       */
      Kinetic.prototype.end = function () {
          if (this.points_.length < 6) {
              // at least 2 points are required (i.e. there must be at least 6 elements
              // in the array)
              return false;
          }
          var delay = Date.now() - this.delay_;
          var lastIndex = this.points_.length - 3;
          if (this.points_[lastIndex + 2] < delay) {
              // the last tracked point is too old, which means that the user stopped
              // panning before releasing the map
              return false;
          }
          // get the first point which still falls into the delay time
          var firstIndex = lastIndex - 3;
          while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
              firstIndex -= 3;
          }
          var duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
          // we don't want a duration of 0 (divide by zero)
          // we also make sure the user panned for a duration of at least one frame
          // (1/60s) to compute sane displacement values
          if (duration < 1000 / 60) {
              return false;
          }
          var dx = this.points_[lastIndex] - this.points_[firstIndex];
          var dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
          this.angle_ = Math.atan2(dy, dx);
          this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
          return this.initialVelocity_ > this.minVelocity_;
      };
      /**
       * @return {number} Total distance travelled (pixels).
       */
      Kinetic.prototype.getDistance = function () {
          return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
      };
      /**
       * @return {number} Angle of the kinetic panning animation (radians).
       */
      Kinetic.prototype.getAngle = function () {
          return this.angle_;
      };
      return Kinetic;
  }());

  var __extends$G = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @enum {string}
   */
  var Mode = {
      TRACKPAD: 'trackpad',
      WHEEL: 'wheel',
  };
  /**
   * @typedef {Object} Options
   * @property {import("../events/condition.js").Condition} [condition] A function that
   * takes an {@link module:ol/MapBrowserEvent~MapBrowserEvent} and returns a
   * boolean to indicate whether that event should be handled. Default is
   * {@link module:ol/events/condition~always}.
   * @property {boolean} [onFocusOnly=false] When the map's target has a `tabindex` attribute set,
   * the interaction will only handle events when the map has the focus.
   * @property {number} [maxDelta=1] Maximum mouse wheel delta.
   * @property {number} [duration=250] Animation duration in milliseconds.
   * @property {number} [timeout=80] Mouse wheel timeout duration in milliseconds.
   * @property {boolean} [useAnchor=true] Enable zooming using the mouse's
   * location as the anchor. When set to `false`, zooming in and out will zoom to
   * the center of the screen instead of zooming on the mouse's location.
   * @property {boolean} [constrainResolution=false] If true, the mouse wheel zoom
   * event will always animate to the closest zoom level after an interaction;
   * false means intermediary zoom levels are allowed.
   */
  /**
   * @classdesc
   * Allows the user to zoom the map by scrolling the mouse wheel.
   * @api
   */
  var MouseWheelZoom = /** @class */ (function (_super) {
      __extends$G(MouseWheelZoom, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function MouseWheelZoom(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, 
          /** @type {import("./Interaction.js").InteractionOptions} */ (options)) || this;
          /**
           * @private
           * @type {number}
           */
          _this.totalDelta_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.lastDelta_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.maxDelta_ = options.maxDelta !== undefined ? options.maxDelta : 1;
          /**
           * @private
           * @type {number}
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 250;
          /**
           * @private
           * @type {number}
           */
          _this.timeout_ = options.timeout !== undefined ? options.timeout : 80;
          /**
           * @private
           * @type {boolean}
           */
          _this.useAnchor_ =
              options.useAnchor !== undefined ? options.useAnchor : true;
          /**
           * @private
           * @type {boolean}
           */
          _this.constrainResolution_ =
              options.constrainResolution !== undefined
                  ? options.constrainResolution
                  : false;
          var condition = options.condition ? options.condition : always;
          /**
           * @private
           * @type {import("../events/condition.js").Condition}
           */
          _this.condition_ = options.onFocusOnly
              ? all(focusWithTabindex, condition)
              : condition;
          /**
           * @private
           * @type {?import("../coordinate.js").Coordinate}
           */
          _this.lastAnchor_ = null;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.startTime_ = undefined;
          /**
           * @private
           * @type {?}
           */
          _this.timeoutId_;
          /**
           * @private
           * @type {Mode|undefined}
           */
          _this.mode_ = undefined;
          /**
           * Trackpad events separated by this delay will be considered separate
           * interactions.
           * @type {number}
           */
          _this.trackpadEventGap_ = 400;
          /**
           * @type {?}
           */
          _this.trackpadTimeoutId_;
          /**
           * The number of delta values per zoom level
           * @private
           * @type {number}
           */
          _this.deltaPerZoom_ = 300;
          return _this;
      }
      /**
       * @private
       */
      MouseWheelZoom.prototype.endInteraction_ = function () {
          this.trackpadTimeoutId_ = undefined;
          var view = this.getMap().getView();
          view.endInteraction(undefined, this.lastDelta_ ? (this.lastDelta_ > 0 ? 1 : -1) : 0, this.lastAnchor_);
      };
      /**
       * Handles the {@link module:ol/MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
       * zooms the map.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
       * @return {boolean} `false` to stop event propagation.
       */
      MouseWheelZoom.prototype.handleEvent = function (mapBrowserEvent) {
          if (!this.condition_(mapBrowserEvent)) {
              return true;
          }
          var type = mapBrowserEvent.type;
          if (type !== EventType.WHEEL) {
              return true;
          }
          mapBrowserEvent.preventDefault();
          var map = mapBrowserEvent.map;
          var wheelEvent = /** @type {WheelEvent} */ (mapBrowserEvent.originalEvent);
          if (this.useAnchor_) {
              this.lastAnchor_ = mapBrowserEvent.coordinate;
          }
          // Delta normalisation inspired by
          // https://github.com/mapbox/mapbox-gl-js/blob/001c7b9/js/ui/handler/scroll_zoom.js
          var delta;
          if (mapBrowserEvent.type == EventType.WHEEL) {
              delta = wheelEvent.deltaY;
              if (FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
                  delta /= DEVICE_PIXEL_RATIO;
              }
              if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
                  delta *= 40;
              }
          }
          if (delta === 0) {
              return false;
          }
          else {
              this.lastDelta_ = delta;
          }
          var now = Date.now();
          if (this.startTime_ === undefined) {
              this.startTime_ = now;
          }
          if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
              this.mode_ = Math.abs(delta) < 4 ? Mode.TRACKPAD : Mode.WHEEL;
          }
          var view = map.getView();
          if (this.mode_ === Mode.TRACKPAD &&
              !(view.getConstrainResolution() || this.constrainResolution_)) {
              if (this.trackpadTimeoutId_) {
                  clearTimeout(this.trackpadTimeoutId_);
              }
              else {
                  if (view.getAnimating()) {
                      view.cancelAnimations();
                  }
                  view.beginInteraction();
              }
              this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_);
              view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);
              this.startTime_ = now;
              return false;
          }
          this.totalDelta_ += delta;
          var timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
          clearTimeout(this.timeoutId_);
          this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, map), timeLeft);
          return false;
      };
      /**
       * @private
       * @param {import("../PluggableMap.js").default} map Map.
       */
      MouseWheelZoom.prototype.handleWheelZoom_ = function (map) {
          var view = map.getView();
          if (view.getAnimating()) {
              view.cancelAnimations();
          }
          var delta = -clamp(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;
          if (view.getConstrainResolution() || this.constrainResolution_) {
              // view has a zoom constraint, zoom by 1
              delta = delta ? (delta > 0 ? 1 : -1) : 0;
          }
          zoomByDelta(view, delta, this.lastAnchor_, this.duration_);
          this.mode_ = undefined;
          this.totalDelta_ = 0;
          this.lastAnchor_ = null;
          this.startTime_ = undefined;
          this.timeoutId_ = undefined;
      };
      /**
       * Enable or disable using the mouse's location as an anchor when zooming
       * @param {boolean} useAnchor true to zoom to the mouse's location, false
       * to zoom to the center of the map
       * @api
       */
      MouseWheelZoom.prototype.setMouseAnchor = function (useAnchor) {
          this.useAnchor_ = useAnchor;
          if (!useAnchor) {
              this.lastAnchor_ = null;
          }
      };
      return MouseWheelZoom;
  }(Interaction));

  var __extends$H = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {number} [duration=250] The duration of the animation in
   * milliseconds.
   * @property {number} [threshold=0.3] Minimal angle in radians to start a rotation.
   */
  /**
   * @classdesc
   * Allows the user to rotate the map by twisting with two fingers
   * on a touch screen.
   * @api
   */
  var PinchRotate = /** @class */ (function (_super) {
      __extends$H(PinchRotate, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function PinchRotate(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          var pointerOptions = /** @type {import("./Pointer.js").Options} */ (options);
          if (!pointerOptions.stopDown) {
              pointerOptions.stopDown = FALSE;
          }
          _this = _super.call(this, pointerOptions) || this;
          /**
           * @private
           * @type {import("../coordinate.js").Coordinate}
           */
          _this.anchor_ = null;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.lastAngle_ = undefined;
          /**
           * @private
           * @type {boolean}
           */
          _this.rotating_ = false;
          /**
           * @private
           * @type {number}
           */
          _this.rotationDelta_ = 0.0;
          /**
           * @private
           * @type {number}
           */
          _this.threshold_ = options.threshold !== undefined ? options.threshold : 0.3;
          /**
           * @private
           * @type {number}
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 250;
          return _this;
      }
      /**
       * Handle pointer drag events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       */
      PinchRotate.prototype.handleDragEvent = function (mapBrowserEvent) {
          var rotationDelta = 0.0;
          var touch0 = this.targetPointers[0];
          var touch1 = this.targetPointers[1];
          // angle between touches
          var angle = Math.atan2(touch1.clientY - touch0.clientY, touch1.clientX - touch0.clientX);
          if (this.lastAngle_ !== undefined) {
              var delta = angle - this.lastAngle_;
              this.rotationDelta_ += delta;
              if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
                  this.rotating_ = true;
              }
              rotationDelta = delta;
          }
          this.lastAngle_ = angle;
          var map = mapBrowserEvent.map;
          var view = map.getView();
          if (view.getConstraints().rotation === disable) {
              return;
          }
          // rotate anchor point.
          // FIXME: should be the intersection point between the lines:
          //     touch0,touch1 and previousTouch0,previousTouch1
          var viewportPosition = map.getViewport().getBoundingClientRect();
          var centroid$1 = centroid(this.targetPointers);
          centroid$1[0] -= viewportPosition.left;
          centroid$1[1] -= viewportPosition.top;
          this.anchor_ = map.getCoordinateFromPixelInternal(centroid$1);
          // rotate
          if (this.rotating_) {
              map.render();
              view.adjustRotationInternal(rotationDelta, this.anchor_);
          }
      };
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      PinchRotate.prototype.handleUpEvent = function (mapBrowserEvent) {
          if (this.targetPointers.length < 2) {
              var map = mapBrowserEvent.map;
              var view = map.getView();
              view.endInteraction(this.duration_);
              return false;
          }
          else {
              return true;
          }
      };
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      PinchRotate.prototype.handleDownEvent = function (mapBrowserEvent) {
          if (this.targetPointers.length >= 2) {
              var map = mapBrowserEvent.map;
              this.anchor_ = null;
              this.lastAngle_ = undefined;
              this.rotating_ = false;
              this.rotationDelta_ = 0.0;
              if (!this.handlingDownUpSequence) {
                  map.getView().beginInteraction();
              }
              return true;
          }
          else {
              return false;
          }
      };
      return PinchRotate;
  }(PointerInteraction));

  var __extends$I = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {number} [duration=400] Animation duration in milliseconds.
   */
  /**
   * @classdesc
   * Allows the user to zoom the map by pinching with two fingers
   * on a touch screen.
   * @api
   */
  var PinchZoom = /** @class */ (function (_super) {
      __extends$I(PinchZoom, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function PinchZoom(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          var pointerOptions = /** @type {import("./Pointer.js").Options} */ (options);
          if (!pointerOptions.stopDown) {
              pointerOptions.stopDown = FALSE;
          }
          _this = _super.call(this, pointerOptions) || this;
          /**
           * @private
           * @type {import("../coordinate.js").Coordinate}
           */
          _this.anchor_ = null;
          /**
           * @private
           * @type {number}
           */
          _this.duration_ = options.duration !== undefined ? options.duration : 400;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.lastDistance_ = undefined;
          /**
           * @private
           * @type {number}
           */
          _this.lastScaleDelta_ = 1;
          return _this;
      }
      /**
       * Handle pointer drag events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       */
      PinchZoom.prototype.handleDragEvent = function (mapBrowserEvent) {
          var scaleDelta = 1.0;
          var touch0 = this.targetPointers[0];
          var touch1 = this.targetPointers[1];
          var dx = touch0.clientX - touch1.clientX;
          var dy = touch0.clientY - touch1.clientY;
          // distance between touches
          var distance = Math.sqrt(dx * dx + dy * dy);
          if (this.lastDistance_ !== undefined) {
              scaleDelta = this.lastDistance_ / distance;
          }
          this.lastDistance_ = distance;
          var map = mapBrowserEvent.map;
          var view = map.getView();
          if (scaleDelta != 1.0) {
              this.lastScaleDelta_ = scaleDelta;
          }
          // scale anchor point.
          var viewportPosition = map.getViewport().getBoundingClientRect();
          var centroid$1 = centroid(this.targetPointers);
          centroid$1[0] -= viewportPosition.left;
          centroid$1[1] -= viewportPosition.top;
          this.anchor_ = map.getCoordinateFromPixelInternal(centroid$1);
          // scale, bypass the resolution constraint
          map.render();
          view.adjustResolutionInternal(scaleDelta, this.anchor_);
      };
      /**
       * Handle pointer up events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      PinchZoom.prototype.handleUpEvent = function (mapBrowserEvent) {
          if (this.targetPointers.length < 2) {
              var map = mapBrowserEvent.map;
              var view = map.getView();
              var direction = this.lastScaleDelta_ > 1 ? 1 : -1;
              view.endInteraction(this.duration_, direction);
              return false;
          }
          else {
              return true;
          }
      };
      /**
       * Handle pointer down events.
       * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
       * @return {boolean} If the event was consumed.
       */
      PinchZoom.prototype.handleDownEvent = function (mapBrowserEvent) {
          if (this.targetPointers.length >= 2) {
              var map = mapBrowserEvent.map;
              this.anchor_ = null;
              this.lastDistance_ = undefined;
              this.lastScaleDelta_ = 1;
              if (!this.handlingDownUpSequence) {
                  map.getView().beginInteraction();
              }
              return true;
          }
          else {
              return false;
          }
      };
      return PinchZoom;
  }(PointerInteraction));

  var __extends$J = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {typeof Feature|typeof import("./render/Feature.js").default} FeatureClass
   */
  /**
   * @typedef {Feature|import("./render/Feature.js").default} FeatureLike
   */
  /**
   * @classdesc
   * A vector object for geographic features with a geometry and other
   * attribute properties, similar to the features in vector file formats like
   * GeoJSON.
   *
   * Features can be styled individually with `setStyle`; otherwise they use the
   * style of their vector layer.
   *
   * Note that attribute properties are set as {@link module:ol/Object} properties on
   * the feature object, so they are observable, and have get/set accessors.
   *
   * Typically, a feature has a single geometry property. You can set the
   * geometry using the `setGeometry` method and get it with `getGeometry`.
   * It is possible to store more than one geometry on a feature using attribute
   * properties. By default, the geometry used for rendering is identified by
   * the property name `geometry`. If you want to use another geometry property
   * for rendering, use the `setGeometryName` method to change the attribute
   * property associated with the geometry for the feature.  For example:
   *
   * ```js
   *
   * import Feature from 'ol/Feature';
   * import Polygon from 'ol/geom/Polygon';
   * import Point from 'ol/geom/Point';
   *
   * var feature = new Feature({
   *   geometry: new Polygon(polyCoords),
   *   labelPoint: new Point(labelCoords),
   *   name: 'My Polygon'
   * });
   *
   * // get the polygon geometry
   * var poly = feature.getGeometry();
   *
   * // Render the feature as a point using the coordinates from labelPoint
   * feature.setGeometryName('labelPoint');
   *
   * // get the point geometry
   * var point = feature.getGeometry();
   * ```
   *
   * @api
   * @template {import("./geom/Geometry.js").default} Geometry
   */
  var Feature = /** @class */ (function (_super) {
      __extends$J(Feature, _super);
      /**
       * @param {Geometry|Object<string, *>=} opt_geometryOrProperties
       *     You may pass a Geometry object directly, or an object literal containing
       *     properties. If you pass an object literal, you may include a Geometry
       *     associated with a `geometry` key.
       */
      function Feature(opt_geometryOrProperties) {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {number|string|undefined}
           */
          _this.id_ = undefined;
          /**
           * @type {string}
           * @private
           */
          _this.geometryName_ = 'geometry';
          /**
           * User provided style.
           * @private
           * @type {import("./style/Style.js").StyleLike}
           */
          _this.style_ = null;
          /**
           * @private
           * @type {import("./style/Style.js").StyleFunction|undefined}
           */
          _this.styleFunction_ = undefined;
          /**
           * @private
           * @type {?import("./events.js").EventsKey}
           */
          _this.geometryChangeKey_ = null;
          _this.addEventListener(getChangeEventType(_this.geometryName_), _this.handleGeometryChanged_);
          if (opt_geometryOrProperties) {
              if (typeof (
              /** @type {?} */ (opt_geometryOrProperties).getSimplifiedGeometry) === 'function') {
                  var geometry = /** @type {Geometry} */ (opt_geometryOrProperties);
                  _this.setGeometry(geometry);
              }
              else {
                  /** @type {Object<string, *>} */
                  var properties = opt_geometryOrProperties;
                  _this.setProperties(properties);
              }
          }
          return _this;
      }
      /**
       * Clone this feature. If the original feature has a geometry it
       * is also cloned. The feature id is not set in the clone.
       * @return {Feature} The clone.
       * @api
       */
      Feature.prototype.clone = function () {
          var clone = new Feature(this.hasProperties() ? this.getProperties() : null);
          clone.setGeometryName(this.getGeometryName());
          var geometry = this.getGeometry();
          if (geometry) {
              clone.setGeometry(geometry.clone());
          }
          var style = this.getStyle();
          if (style) {
              clone.setStyle(style);
          }
          return clone;
      };
      /**
       * Get the feature's default geometry.  A feature may have any number of named
       * geometries.  The "default" geometry (the one that is rendered by default) is
       * set when calling {@link module:ol/Feature~Feature#setGeometry}.
       * @return {Geometry|undefined} The default geometry for the feature.
       * @api
       * @observable
       */
      Feature.prototype.getGeometry = function () {
          return /** @type {Geometry|undefined} */ (this.get(this.geometryName_));
      };
      /**
       * Get the feature identifier.  This is a stable identifier for the feature and
       * is either set when reading data from a remote source or set explicitly by
       * calling {@link module:ol/Feature~Feature#setId}.
       * @return {number|string|undefined} Id.
       * @api
       */
      Feature.prototype.getId = function () {
          return this.id_;
      };
      /**
       * Get the name of the feature's default geometry.  By default, the default
       * geometry is named `geometry`.
       * @return {string} Get the property name associated with the default geometry
       *     for this feature.
       * @api
       */
      Feature.prototype.getGeometryName = function () {
          return this.geometryName_;
      };
      /**
       * Get the feature's style. Will return what was provided to the
       * {@link module:ol/Feature~Feature#setStyle} method.
       * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
       * @api
       */
      Feature.prototype.getStyle = function () {
          return this.style_;
      };
      /**
       * Get the feature's style function.
       * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
       * representing the current style of this feature.
       * @api
       */
      Feature.prototype.getStyleFunction = function () {
          return this.styleFunction_;
      };
      /**
       * @private
       */
      Feature.prototype.handleGeometryChange_ = function () {
          this.changed();
      };
      /**
       * @private
       */
      Feature.prototype.handleGeometryChanged_ = function () {
          if (this.geometryChangeKey_) {
              unlistenByKey(this.geometryChangeKey_);
              this.geometryChangeKey_ = null;
          }
          var geometry = this.getGeometry();
          if (geometry) {
              this.geometryChangeKey_ = listen(geometry, EventType.CHANGE, this.handleGeometryChange_, this);
          }
          this.changed();
      };
      /**
       * Set the default geometry for the feature.  This will update the property
       * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
       * @param {Geometry|undefined} geometry The new geometry.
       * @api
       * @observable
       */
      Feature.prototype.setGeometry = function (geometry) {
          this.set(this.geometryName_, geometry);
      };
      /**
       * Set the style for the feature to override the layer style.  This can be a
       * single style object, an array of styles, or a function that takes a
       * resolution and returns an array of styles. To unset the feature style, call
       * `setStyle()` without arguments or a falsey value.
       * @param {import("./style/Style.js").StyleLike=} opt_style Style for this feature.
       * @api
       * @fires module:ol/events/Event~BaseEvent#event:change
       */
      Feature.prototype.setStyle = function (opt_style) {
          this.style_ = opt_style;
          this.styleFunction_ = !opt_style
              ? undefined
              : createStyleFunction(opt_style);
          this.changed();
      };
      /**
       * Set the feature id.  The feature id is considered stable and may be used when
       * requesting features or comparing identifiers returned from a remote source.
       * The feature id can be used with the
       * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
       * @param {number|string|undefined} id The feature id.
       * @api
       * @fires module:ol/events/Event~BaseEvent#event:change
       */
      Feature.prototype.setId = function (id) {
          this.id_ = id;
          this.changed();
      };
      /**
       * Set the property name to be used when getting the feature's default geometry.
       * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
       * this name will be returned.
       * @param {string} name The property name of the default geometry.
       * @api
       */
      Feature.prototype.setGeometryName = function (name) {
          this.removeEventListener(getChangeEventType(this.geometryName_), this.handleGeometryChanged_);
          this.geometryName_ = name;
          this.addEventListener(getChangeEventType(this.geometryName_), this.handleGeometryChanged_);
          this.handleGeometryChanged_();
      };
      return Feature;
  }(BaseObject));
  /**
   * Convert the provided object into a feature style function.  Functions passed
   * through unchanged.  Arrays of Style or single style objects wrapped
   * in a new feature style function.
   * @param {!import("./style/Style.js").StyleFunction|!Array<import("./style/Style.js").default>|!import("./style/Style.js").default} obj
   *     A feature style function, a single style, or an array of styles.
   * @return {import("./style/Style.js").StyleFunction} A style function.
   */
  function createStyleFunction(obj) {
      if (typeof obj === 'function') {
          return obj;
      }
      else {
          /**
           * @type {Array<import("./style/Style.js").default>}
           */
          var styles_1;
          if (Array.isArray(obj)) {
              styles_1 = obj;
          }
          else {
              assert(typeof ( /** @type {?} */(obj).getZIndex) === 'function', 41); // Expected an `import("./style/Style.js").Style` or an array of `import("./style/Style.js").Style`
              var style = /** @type {import("./style/Style.js").default} */ (obj);
              styles_1 = [style];
          }
          return function () {
              return styles_1;
          };
      }
  }

  /**
   * @module ol/geom/flat/interpolate
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} fraction Fraction.
   * @param {Array<number>=} opt_dest Destination.
   * @param {number=} opt_dimension Destination dimension (default is `2`)
   * @return {Array<number>} Destination.
   */
  function interpolatePoint(flatCoordinates, offset, end, stride, fraction, opt_dest, opt_dimension) {
      var o, t;
      var n = (end - offset) / stride;
      if (n === 1) {
          o = offset;
      }
      else if (n === 2) {
          o = offset;
          t = fraction;
      }
      else if (n !== 0) {
          var x1 = flatCoordinates[offset];
          var y1 = flatCoordinates[offset + 1];
          var length_1 = 0;
          var cumulativeLengths = [0];
          for (var i = offset + stride; i < end; i += stride) {
              var x2 = flatCoordinates[i];
              var y2 = flatCoordinates[i + 1];
              length_1 += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
              cumulativeLengths.push(length_1);
              x1 = x2;
              y1 = y2;
          }
          var target = fraction * length_1;
          var index = binarySearch(cumulativeLengths, target);
          if (index < 0) {
              t =
                  (target - cumulativeLengths[-index - 2]) /
                      (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
              o = offset + (-index - 2) * stride;
          }
          else {
              o = offset + index * stride;
          }
      }
      var dimension = opt_dimension > 1 ? opt_dimension : 2;
      var dest = opt_dest ? opt_dest : new Array(dimension);
      for (var i = 0; i < dimension; ++i) {
          dest[i] =
              o === undefined
                  ? NaN
                  : t === undefined
                      ? flatCoordinates[o + i]
                      : lerp(flatCoordinates[o + i], flatCoordinates[o + stride + i], t);
      }
      return dest;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @param {number} m M.
   * @param {boolean} extrapolate Extrapolate.
   * @return {import("../../coordinate.js").Coordinate} Coordinate.
   */
  function lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, extrapolate) {
      if (end == offset) {
          return null;
      }
      var coordinate;
      if (m < flatCoordinates[offset + stride - 1]) {
          if (extrapolate) {
              coordinate = flatCoordinates.slice(offset, offset + stride);
              coordinate[stride - 1] = m;
              return coordinate;
          }
          else {
              return null;
          }
      }
      else if (flatCoordinates[end - 1] < m) {
          if (extrapolate) {
              coordinate = flatCoordinates.slice(end - stride, end);
              coordinate[stride - 1] = m;
              return coordinate;
          }
          else {
              return null;
          }
      }
      // FIXME use O(1) search
      if (m == flatCoordinates[offset + stride - 1]) {
          return flatCoordinates.slice(offset, offset + stride);
      }
      var lo = offset / stride;
      var hi = end / stride;
      while (lo < hi) {
          var mid = (lo + hi) >> 1;
          if (m < flatCoordinates[(mid + 1) * stride - 1]) {
              hi = mid;
          }
          else {
              lo = mid + 1;
          }
      }
      var m0 = flatCoordinates[lo * stride - 1];
      if (m == m0) {
          return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
      }
      var m1 = flatCoordinates[(lo + 1) * stride - 1];
      var t = (m - m0) / (m1 - m0);
      coordinate = [];
      for (var i = 0; i < stride - 1; ++i) {
          coordinate.push(lerp(flatCoordinates[(lo - 1) * stride + i], flatCoordinates[lo * stride + i], t));
      }
      coordinate.push(m);
      return coordinate;
  }
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<number>} ends Ends.
   * @param {number} stride Stride.
   * @param {number} m M.
   * @param {boolean} extrapolate Extrapolate.
   * @param {boolean} interpolate Interpolate.
   * @return {import("../../coordinate.js").Coordinate} Coordinate.
   */
  function lineStringsCoordinateAtM(flatCoordinates, offset, ends, stride, m, extrapolate, interpolate) {
      if (interpolate) {
          return lineStringCoordinateAtM(flatCoordinates, offset, ends[ends.length - 1], stride, m, extrapolate);
      }
      var coordinate;
      if (m < flatCoordinates[stride - 1]) {
          if (extrapolate) {
              coordinate = flatCoordinates.slice(0, stride);
              coordinate[stride - 1] = m;
              return coordinate;
          }
          else {
              return null;
          }
      }
      if (flatCoordinates[flatCoordinates.length - 1] < m) {
          if (extrapolate) {
              coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
              coordinate[stride - 1] = m;
              return coordinate;
          }
          else {
              return null;
          }
      }
      for (var i = 0, ii = ends.length; i < ii; ++i) {
          var end = ends[i];
          if (offset == end) {
              continue;
          }
          if (m < flatCoordinates[offset + stride - 1]) {
              return null;
          }
          else if (m <= flatCoordinates[end - 1]) {
              return lineStringCoordinateAtM(flatCoordinates, offset, end, stride, m, false);
          }
          offset = end;
      }
      return null;
  }

  /**
   * @module ol/geom/flat/length
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @return {number} Length.
   */
  function lineStringLength(flatCoordinates, offset, end, stride) {
      var x1 = flatCoordinates[offset];
      var y1 = flatCoordinates[offset + 1];
      var length = 0;
      for (var i = offset + stride; i < end; i += stride) {
          var x2 = flatCoordinates[i];
          var y2 = flatCoordinates[i + 1];
          length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
          x1 = x2;
          y1 = y2;
      }
      return length;
  }

  var __extends$K = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Linestring geometry.
   *
   * @api
   */
  var LineString = /** @class */ (function (_super) {
      __extends$K(LineString, _super);
      /**
       * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       */
      function LineString(coordinates, opt_layout) {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {import("../coordinate.js").Coordinate}
           */
          _this.flatMidpoint_ = null;
          /**
           * @private
           * @type {number}
           */
          _this.flatMidpointRevision_ = -1;
          /**
           * @private
           * @type {number}
           */
          _this.maxDelta_ = -1;
          /**
           * @private
           * @type {number}
           */
          _this.maxDeltaRevision_ = -1;
          if (opt_layout !== undefined && !Array.isArray(coordinates[0])) {
              _this.setFlatCoordinates(opt_layout, 
              /** @type {Array<number>} */ (coordinates));
          }
          else {
              _this.setCoordinates(
              /** @type {Array<import("../coordinate.js").Coordinate>} */ (coordinates), opt_layout);
          }
          return _this;
      }
      /**
       * Append the passed coordinate to the coordinates of the linestring.
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @api
       */
      LineString.prototype.appendCoordinate = function (coordinate) {
          if (!this.flatCoordinates) {
              this.flatCoordinates = coordinate.slice();
          }
          else {
              extend(this.flatCoordinates, coordinate);
          }
          this.changed();
      };
      /**
       * Make a complete copy of the geometry.
       * @return {!LineString} Clone.
       * @api
       */
      LineString.prototype.clone = function () {
          return new LineString(this.flatCoordinates.slice(), this.layout);
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      LineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
          if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
          }
          if (this.maxDeltaRevision_ != this.getRevision()) {
              this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0));
              this.maxDeltaRevision_ = this.getRevision();
          }
          return assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
      };
      /**
       * Iterate over each segment, calling the provided callback.
       * If the callback returns a truthy value the function returns that
       * value immediately. Otherwise the function returns `false`.
       *
       * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
       *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
       * @return {T|boolean} Value.
       * @template T,S
       * @api
       */
      LineString.prototype.forEachSegment = function (callback) {
          return forEach(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, callback);
      };
      /**
       * Returns the coordinate at `m` using linear interpolation, or `null` if no
       * such coordinate exists.
       *
       * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
       * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
       * M will return the first coordinate and Ms greater than the last M will
       * return the last coordinate.
       *
       * @param {number} m M.
       * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
       * @return {import("../coordinate.js").Coordinate} Coordinate.
       * @api
       */
      LineString.prototype.getCoordinateAtM = function (m, opt_extrapolate) {
          if (this.layout != GeometryLayout.XYM &&
              this.layout != GeometryLayout.XYZM) {
              return null;
          }
          var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
          return lineStringCoordinateAtM(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, m, extrapolate);
      };
      /**
       * Return the coordinates of the linestring.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       */
      LineString.prototype.getCoordinates = function () {
          return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      };
      /**
       * Return the coordinate at the provided fraction along the linestring.
       * The `fraction` is a number between 0 and 1, where 0 is the start of the
       * linestring and 1 is the end.
       * @param {number} fraction Fraction.
       * @param {import("../coordinate.js").Coordinate=} opt_dest Optional coordinate whose values will
       *     be modified. If not provided, a new coordinate will be returned.
       * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
       * @api
       */
      LineString.prototype.getCoordinateAt = function (fraction, opt_dest) {
          return interpolatePoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, fraction, opt_dest, this.stride);
      };
      /**
       * Return the length of the linestring on projected plane.
       * @return {number} Length (on projected plane).
       * @api
       */
      LineString.prototype.getLength = function () {
          return lineStringLength(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      };
      /**
       * @return {Array<number>} Flat midpoint.
       */
      LineString.prototype.getFlatMidpoint = function () {
          if (this.flatMidpointRevision_ != this.getRevision()) {
              this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);
              this.flatMidpointRevision_ = this.getRevision();
          }
          return this.flatMidpoint_;
      };
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {LineString} Simplified LineString.
       * @protected
       */
      LineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
          var simplifiedFlatCoordinates = [];
          simplifiedFlatCoordinates.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0);
          return new LineString(simplifiedFlatCoordinates, GeometryLayout.XY);
      };
      /**
       * Get the type of this geometry.
       * @return {import("./GeometryType.js").default} Geometry type.
       * @api
       */
      LineString.prototype.getType = function () {
          return GeometryType.LINE_STRING;
      };
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      LineString.prototype.intersectsExtent = function (extent) {
          return intersectsLineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, extent);
      };
      /**
       * Set the coordinates of the linestring.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @api
       */
      LineString.prototype.setCoordinates = function (coordinates, opt_layout) {
          this.setLayout(opt_layout, coordinates, 1);
          if (!this.flatCoordinates) {
              this.flatCoordinates = [];
          }
          this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);
          this.changed();
      };
      return LineString;
  }(SimpleGeometry));

  var __extends$L = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Multi-linestring geometry.
   *
   * @api
   */
  var MultiLineString = /** @class */ (function (_super) {
      __extends$L(MultiLineString, _super);
      /**
       * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
       *     Coordinates or LineString geometries. (For internal use, flat coordinates in
       *     combination with `opt_layout` and `opt_ends` are also accepted.)
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @param {Array<number>=} opt_ends Flat coordinate ends for internal use.
       */
      function MultiLineString(coordinates, opt_layout, opt_ends) {
          var _this = _super.call(this) || this;
          /**
           * @type {Array<number>}
           * @private
           */
          _this.ends_ = [];
          /**
           * @private
           * @type {number}
           */
          _this.maxDelta_ = -1;
          /**
           * @private
           * @type {number}
           */
          _this.maxDeltaRevision_ = -1;
          if (Array.isArray(coordinates[0])) {
              _this.setCoordinates(
              /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */ (coordinates), opt_layout);
          }
          else if (opt_layout !== undefined && opt_ends) {
              _this.setFlatCoordinates(opt_layout, 
              /** @type {Array<number>} */ (coordinates));
              _this.ends_ = opt_ends;
          }
          else {
              var layout = _this.getLayout();
              var lineStrings = /** @type {Array<LineString>} */ (coordinates);
              var flatCoordinates = [];
              var ends = [];
              for (var i = 0, ii = lineStrings.length; i < ii; ++i) {
                  var lineString = lineStrings[i];
                  if (i === 0) {
                      layout = lineString.getLayout();
                  }
                  extend(flatCoordinates, lineString.getFlatCoordinates());
                  ends.push(flatCoordinates.length);
              }
              _this.setFlatCoordinates(layout, flatCoordinates);
              _this.ends_ = ends;
          }
          return _this;
      }
      /**
       * Append the passed linestring to the multilinestring.
       * @param {LineString} lineString LineString.
       * @api
       */
      MultiLineString.prototype.appendLineString = function (lineString) {
          if (!this.flatCoordinates) {
              this.flatCoordinates = lineString.getFlatCoordinates().slice();
          }
          else {
              extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());
          }
          this.ends_.push(this.flatCoordinates.length);
          this.changed();
      };
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiLineString} Clone.
       * @api
       */
      MultiLineString.prototype.clone = function () {
          return new MultiLineString(this.flatCoordinates.slice(), this.layout, this.ends_.slice());
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      MultiLineString.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
          if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
          }
          if (this.maxDeltaRevision_ != this.getRevision()) {
              this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0));
              this.maxDeltaRevision_ = this.getRevision();
          }
          return assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, false, x, y, closestPoint, minSquaredDistance);
      };
      /**
       * Returns the coordinate at `m` using linear interpolation, or `null` if no
       * such coordinate exists.
       *
       * `opt_extrapolate` controls extrapolation beyond the range of Ms in the
       * MultiLineString. If `opt_extrapolate` is `true` then Ms less than the first
       * M will return the first coordinate and Ms greater than the last M will
       * return the last coordinate.
       *
       * `opt_interpolate` controls interpolation between consecutive LineStrings
       * within the MultiLineString. If `opt_interpolate` is `true` the coordinates
       * will be linearly interpolated between the last coordinate of one LineString
       * and the first coordinate of the next LineString.  If `opt_interpolate` is
       * `false` then the function will return `null` for Ms falling between
       * LineStrings.
       *
       * @param {number} m M.
       * @param {boolean=} opt_extrapolate Extrapolate. Default is `false`.
       * @param {boolean=} opt_interpolate Interpolate. Default is `false`.
       * @return {import("../coordinate.js").Coordinate} Coordinate.
       * @api
       */
      MultiLineString.prototype.getCoordinateAtM = function (m, opt_extrapolate, opt_interpolate) {
          if ((this.layout != GeometryLayout.XYM &&
              this.layout != GeometryLayout.XYZM) ||
              this.flatCoordinates.length === 0) {
              return null;
          }
          var extrapolate = opt_extrapolate !== undefined ? opt_extrapolate : false;
          var interpolate = opt_interpolate !== undefined ? opt_interpolate : false;
          return lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, m, extrapolate, interpolate);
      };
      /**
       * Return the coordinates of the multilinestring.
       * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
       * @api
       */
      MultiLineString.prototype.getCoordinates = function () {
          return inflateCoordinatesArray(this.flatCoordinates, 0, this.ends_, this.stride);
      };
      /**
       * @return {Array<number>} Ends.
       */
      MultiLineString.prototype.getEnds = function () {
          return this.ends_;
      };
      /**
       * Return the linestring at the specified index.
       * @param {number} index Index.
       * @return {LineString} LineString.
       * @api
       */
      MultiLineString.prototype.getLineString = function (index) {
          if (index < 0 || this.ends_.length <= index) {
              return null;
          }
          return new LineString(this.flatCoordinates.slice(index === 0 ? 0 : this.ends_[index - 1], this.ends_[index]), this.layout);
      };
      /**
       * Return the linestrings of this multilinestring.
       * @return {Array<LineString>} LineStrings.
       * @api
       */
      MultiLineString.prototype.getLineStrings = function () {
          var flatCoordinates = this.flatCoordinates;
          var ends = this.ends_;
          var layout = this.layout;
          /** @type {Array<LineString>} */
          var lineStrings = [];
          var offset = 0;
          for (var i = 0, ii = ends.length; i < ii; ++i) {
              var end = ends[i];
              var lineString = new LineString(flatCoordinates.slice(offset, end), layout);
              lineStrings.push(lineString);
              offset = end;
          }
          return lineStrings;
      };
      /**
       * @return {Array<number>} Flat midpoints.
       */
      MultiLineString.prototype.getFlatMidpoints = function () {
          var midpoints = [];
          var flatCoordinates = this.flatCoordinates;
          var offset = 0;
          var ends = this.ends_;
          var stride = this.stride;
          for (var i = 0, ii = ends.length; i < ii; ++i) {
              var end = ends[i];
              var midpoint = interpolatePoint(flatCoordinates, offset, end, stride, 0.5);
              extend(midpoints, midpoint);
              offset = end;
          }
          return midpoints;
      };
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {MultiLineString} Simplified MultiLineString.
       * @protected
       */
      MultiLineString.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
          var simplifiedFlatCoordinates = [];
          var simplifiedEnds = [];
          simplifiedFlatCoordinates.length = douglasPeuckerArray(this.flatCoordinates, 0, this.ends_, this.stride, squaredTolerance, simplifiedFlatCoordinates, 0, simplifiedEnds);
          return new MultiLineString(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEnds);
      };
      /**
       * Get the type of this geometry.
       * @return {import("./GeometryType.js").default} Geometry type.
       * @api
       */
      MultiLineString.prototype.getType = function () {
          return GeometryType.MULTI_LINE_STRING;
      };
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      MultiLineString.prototype.intersectsExtent = function (extent) {
          return intersectsLineStringArray(this.flatCoordinates, 0, this.ends_, this.stride, extent);
      };
      /**
       * Set the coordinates of the multilinestring.
       * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
       * @param {GeometryLayout=} opt_layout Layout.
       * @api
       */
      MultiLineString.prototype.setCoordinates = function (coordinates, opt_layout) {
          this.setLayout(opt_layout, coordinates, 2);
          if (!this.flatCoordinates) {
              this.flatCoordinates = [];
          }
          var ends = deflateCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.ends_);
          this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
          this.changed();
      };
      return MultiLineString;
  }(SimpleGeometry));

  var __extends$M = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Multi-point geometry.
   *
   * @api
   */
  var MultiPoint = /** @class */ (function (_super) {
      __extends$M(MultiPoint, _super);
      /**
       * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `opt_layout` are also accepted.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       */
      function MultiPoint(coordinates, opt_layout) {
          var _this = _super.call(this) || this;
          if (opt_layout && !Array.isArray(coordinates[0])) {
              _this.setFlatCoordinates(opt_layout, 
              /** @type {Array<number>} */ (coordinates));
          }
          else {
              _this.setCoordinates(
              /** @type {Array<import("../coordinate.js").Coordinate>} */ (coordinates), opt_layout);
          }
          return _this;
      }
      /**
       * Append the passed point to this multipoint.
       * @param {Point} point Point.
       * @api
       */
      MultiPoint.prototype.appendPoint = function (point) {
          if (!this.flatCoordinates) {
              this.flatCoordinates = point.getFlatCoordinates().slice();
          }
          else {
              extend(this.flatCoordinates, point.getFlatCoordinates());
          }
          this.changed();
      };
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiPoint} Clone.
       * @api
       */
      MultiPoint.prototype.clone = function () {
          var multiPoint = new MultiPoint(this.flatCoordinates.slice(), this.layout);
          return multiPoint;
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      MultiPoint.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
          if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
          }
          var flatCoordinates = this.flatCoordinates;
          var stride = this.stride;
          for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
              var squaredDistance$1 = squaredDistance(x, y, flatCoordinates[i], flatCoordinates[i + 1]);
              if (squaredDistance$1 < minSquaredDistance) {
                  minSquaredDistance = squaredDistance$1;
                  for (var j = 0; j < stride; ++j) {
                      closestPoint[j] = flatCoordinates[i + j];
                  }
                  closestPoint.length = stride;
              }
          }
          return minSquaredDistance;
      };
      /**
       * Return the coordinates of the multipoint.
       * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
       * @api
       */
      MultiPoint.prototype.getCoordinates = function () {
          return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride);
      };
      /**
       * Return the point at the specified index.
       * @param {number} index Index.
       * @return {Point} Point.
       * @api
       */
      MultiPoint.prototype.getPoint = function (index) {
          var n = !this.flatCoordinates
              ? 0
              : this.flatCoordinates.length / this.stride;
          if (index < 0 || n <= index) {
              return null;
          }
          return new Point(this.flatCoordinates.slice(index * this.stride, (index + 1) * this.stride), this.layout);
      };
      /**
       * Return the points of this multipoint.
       * @return {Array<Point>} Points.
       * @api
       */
      MultiPoint.prototype.getPoints = function () {
          var flatCoordinates = this.flatCoordinates;
          var layout = this.layout;
          var stride = this.stride;
          /** @type {Array<Point>} */
          var points = [];
          for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
              var point = new Point(flatCoordinates.slice(i, i + stride), layout);
              points.push(point);
          }
          return points;
      };
      /**
       * Get the type of this geometry.
       * @return {import("./GeometryType.js").default} Geometry type.
       * @api
       */
      MultiPoint.prototype.getType = function () {
          return GeometryType.MULTI_POINT;
      };
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      MultiPoint.prototype.intersectsExtent = function (extent) {
          var flatCoordinates = this.flatCoordinates;
          var stride = this.stride;
          for (var i = 0, ii = flatCoordinates.length; i < ii; i += stride) {
              var x = flatCoordinates[i];
              var y = flatCoordinates[i + 1];
              if (containsXY(extent, x, y)) {
                  return true;
              }
          }
          return false;
      };
      /**
       * Set the coordinates of the multipoint.
       * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @api
       */
      MultiPoint.prototype.setCoordinates = function (coordinates, opt_layout) {
          this.setLayout(opt_layout, coordinates, 1);
          if (!this.flatCoordinates) {
              this.flatCoordinates = [];
          }
          this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, coordinates, this.stride);
          this.changed();
      };
      return MultiPoint;
  }(SimpleGeometry));

  /**
   * @module ol/geom/flat/center
   */
  /**
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {Array<Array<number>>} endss Endss.
   * @param {number} stride Stride.
   * @return {Array<number>} Flat centers.
   */
  function linearRingss$1(flatCoordinates, offset, endss, stride) {
      var flatCenters = [];
      var extent = createEmpty();
      for (var i = 0, ii = endss.length; i < ii; ++i) {
          var ends = endss[i];
          extent = createOrUpdateFromFlatCoordinates(flatCoordinates, offset, ends[0], stride);
          flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
          offset = ends[ends.length - 1];
      }
      return flatCenters;
  }

  var __extends$N = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @classdesc
   * Multi-polygon geometry.
   *
   * @api
   */
  var MultiPolygon = /** @class */ (function (_super) {
      __extends$N(MultiPolygon, _super);
      /**
       * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
       *     For internal use, flat coordinates in combination with `opt_layout` and `opt_endss` are also accepted.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @param {Array<Array<number>>=} opt_endss Array of ends for internal use with flat coordinates.
       */
      function MultiPolygon(coordinates, opt_layout, opt_endss) {
          var _this = _super.call(this) || this;
          /**
           * @type {Array<Array<number>>}
           * @private
           */
          _this.endss_ = [];
          /**
           * @private
           * @type {number}
           */
          _this.flatInteriorPointsRevision_ = -1;
          /**
           * @private
           * @type {Array<number>}
           */
          _this.flatInteriorPoints_ = null;
          /**
           * @private
           * @type {number}
           */
          _this.maxDelta_ = -1;
          /**
           * @private
           * @type {number}
           */
          _this.maxDeltaRevision_ = -1;
          /**
           * @private
           * @type {number}
           */
          _this.orientedRevision_ = -1;
          /**
           * @private
           * @type {Array<number>}
           */
          _this.orientedFlatCoordinates_ = null;
          if (!opt_endss && !Array.isArray(coordinates[0])) {
              var layout = _this.getLayout();
              var polygons = /** @type {Array<Polygon>} */ (coordinates);
              var flatCoordinates = [];
              var endss = [];
              for (var i = 0, ii = polygons.length; i < ii; ++i) {
                  var polygon = polygons[i];
                  if (i === 0) {
                      layout = polygon.getLayout();
                  }
                  var offset = flatCoordinates.length;
                  var ends = polygon.getEnds();
                  for (var j = 0, jj = ends.length; j < jj; ++j) {
                      ends[j] += offset;
                  }
                  extend(flatCoordinates, polygon.getFlatCoordinates());
                  endss.push(ends);
              }
              opt_layout = layout;
              coordinates = flatCoordinates;
              opt_endss = endss;
          }
          if (opt_layout !== undefined && opt_endss) {
              _this.setFlatCoordinates(opt_layout, 
              /** @type {Array<number>} */ (coordinates));
              _this.endss_ = opt_endss;
          }
          else {
              _this.setCoordinates(
              /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */ (coordinates), opt_layout);
          }
          return _this;
      }
      /**
       * Append the passed polygon to this multipolygon.
       * @param {Polygon} polygon Polygon.
       * @api
       */
      MultiPolygon.prototype.appendPolygon = function (polygon) {
          /** @type {Array<number>} */
          var ends;
          if (!this.flatCoordinates) {
              this.flatCoordinates = polygon.getFlatCoordinates().slice();
              ends = polygon.getEnds().slice();
              this.endss_.push();
          }
          else {
              var offset = this.flatCoordinates.length;
              extend(this.flatCoordinates, polygon.getFlatCoordinates());
              ends = polygon.getEnds().slice();
              for (var i = 0, ii = ends.length; i < ii; ++i) {
                  ends[i] += offset;
              }
          }
          this.endss_.push(ends);
          this.changed();
      };
      /**
       * Make a complete copy of the geometry.
       * @return {!MultiPolygon} Clone.
       * @api
       */
      MultiPolygon.prototype.clone = function () {
          var len = this.endss_.length;
          var newEndss = new Array(len);
          for (var i = 0; i < len; ++i) {
              newEndss[i] = this.endss_[i].slice();
          }
          return new MultiPolygon(this.flatCoordinates.slice(), this.layout, newEndss);
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
       * @param {number} minSquaredDistance Minimum squared distance.
       * @return {number} Minimum squared distance.
       */
      MultiPolygon.prototype.closestPointXY = function (x, y, closestPoint, minSquaredDistance) {
          if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x, y)) {
              return minSquaredDistance;
          }
          if (this.maxDeltaRevision_ != this.getRevision()) {
              this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0));
              this.maxDeltaRevision_ = this.getRevision();
          }
          return assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, true, x, y, closestPoint, minSquaredDistance);
      };
      /**
       * @param {number} x X.
       * @param {number} y Y.
       * @return {boolean} Contains (x, y).
       */
      MultiPolygon.prototype.containsXY = function (x, y) {
          return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, x, y);
      };
      /**
       * Return the area of the multipolygon on projected plane.
       * @return {number} Area (on projected plane).
       * @api
       */
      MultiPolygon.prototype.getArea = function () {
          return linearRingss(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride);
      };
      /**
       * Get the coordinate array for this geometry.  This array has the structure
       * of a GeoJSON coordinate array for multi-polygons.
       *
       * @param {boolean=} opt_right Orient coordinates according to the right-hand
       *     rule (counter-clockwise for exterior and clockwise for interior rings).
       *     If `false`, coordinates will be oriented according to the left-hand rule
       *     (clockwise for exterior and counter-clockwise for interior rings).
       *     By default, coordinate orientation will depend on how the geometry was
       *     constructed.
       * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
       * @api
       */
      MultiPolygon.prototype.getCoordinates = function (opt_right) {
          var flatCoordinates;
          if (opt_right !== undefined) {
              flatCoordinates = this.getOrientedFlatCoordinates().slice();
              orientLinearRingsArray(flatCoordinates, 0, this.endss_, this.stride, opt_right);
          }
          else {
              flatCoordinates = this.flatCoordinates;
          }
          return inflateMultiCoordinatesArray(flatCoordinates, 0, this.endss_, this.stride);
      };
      /**
       * @return {Array<Array<number>>} Endss.
       */
      MultiPolygon.prototype.getEndss = function () {
          return this.endss_;
      };
      /**
       * @return {Array<number>} Flat interior points.
       */
      MultiPolygon.prototype.getFlatInteriorPoints = function () {
          if (this.flatInteriorPointsRevision_ != this.getRevision()) {
              var flatCenters = linearRingss$1(this.flatCoordinates, 0, this.endss_, this.stride);
              this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, flatCenters);
              this.flatInteriorPointsRevision_ = this.getRevision();
          }
          return this.flatInteriorPoints_;
      };
      /**
       * Return the interior points as {@link module:ol/geom/MultiPoint multipoint}.
       * @return {MultiPoint} Interior points as XYM coordinates, where M is
       * the length of the horizontal intersection that the point belongs to.
       * @api
       */
      MultiPolygon.prototype.getInteriorPoints = function () {
          return new MultiPoint(this.getFlatInteriorPoints().slice(), GeometryLayout.XYM);
      };
      /**
       * @return {Array<number>} Oriented flat coordinates.
       */
      MultiPolygon.prototype.getOrientedFlatCoordinates = function () {
          if (this.orientedRevision_ != this.getRevision()) {
              var flatCoordinates = this.flatCoordinates;
              if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {
                  this.orientedFlatCoordinates_ = flatCoordinates;
              }
              else {
                  this.orientedFlatCoordinates_ = flatCoordinates.slice();
                  this.orientedFlatCoordinates_.length = orientLinearRingsArray(this.orientedFlatCoordinates_, 0, this.endss_, this.stride);
              }
              this.orientedRevision_ = this.getRevision();
          }
          return this.orientedFlatCoordinates_;
      };
      /**
       * @param {number} squaredTolerance Squared tolerance.
       * @return {MultiPolygon} Simplified MultiPolygon.
       * @protected
       */
      MultiPolygon.prototype.getSimplifiedGeometryInternal = function (squaredTolerance) {
          var simplifiedFlatCoordinates = [];
          var simplifiedEndss = [];
          simplifiedFlatCoordinates.length = quantizeMultiArray(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(squaredTolerance), simplifiedFlatCoordinates, 0, simplifiedEndss);
          return new MultiPolygon(simplifiedFlatCoordinates, GeometryLayout.XY, simplifiedEndss);
      };
      /**
       * Return the polygon at the specified index.
       * @param {number} index Index.
       * @return {Polygon} Polygon.
       * @api
       */
      MultiPolygon.prototype.getPolygon = function (index) {
          if (index < 0 || this.endss_.length <= index) {
              return null;
          }
          var offset;
          if (index === 0) {
              offset = 0;
          }
          else {
              var prevEnds = this.endss_[index - 1];
              offset = prevEnds[prevEnds.length - 1];
          }
          var ends = this.endss_[index].slice();
          var end = ends[ends.length - 1];
          if (offset !== 0) {
              for (var i = 0, ii = ends.length; i < ii; ++i) {
                  ends[i] -= offset;
              }
          }
          return new Polygon(this.flatCoordinates.slice(offset, end), this.layout, ends);
      };
      /**
       * Return the polygons of this multipolygon.
       * @return {Array<Polygon>} Polygons.
       * @api
       */
      MultiPolygon.prototype.getPolygons = function () {
          var layout = this.layout;
          var flatCoordinates = this.flatCoordinates;
          var endss = this.endss_;
          var polygons = [];
          var offset = 0;
          for (var i = 0, ii = endss.length; i < ii; ++i) {
              var ends = endss[i].slice();
              var end = ends[ends.length - 1];
              if (offset !== 0) {
                  for (var j = 0, jj = ends.length; j < jj; ++j) {
                      ends[j] -= offset;
                  }
              }
              var polygon = new Polygon(flatCoordinates.slice(offset, end), layout, ends);
              polygons.push(polygon);
              offset = end;
          }
          return polygons;
      };
      /**
       * Get the type of this geometry.
       * @return {import("./GeometryType.js").default} Geometry type.
       * @api
       */
      MultiPolygon.prototype.getType = function () {
          return GeometryType.MULTI_POLYGON;
      };
      /**
       * Test if the geometry and the passed extent intersect.
       * @param {import("../extent.js").Extent} extent Extent.
       * @return {boolean} `true` if the geometry and the extent intersect.
       * @api
       */
      MultiPolygon.prototype.intersectsExtent = function (extent) {
          return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, extent);
      };
      /**
       * Set the coordinates of the multipolygon.
       * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
       * @param {import("./GeometryLayout.js").default=} opt_layout Layout.
       * @api
       */
      MultiPolygon.prototype.setCoordinates = function (coordinates, opt_layout) {
          this.setLayout(opt_layout, coordinates, 3);
          if (!this.flatCoordinates) {
              this.flatCoordinates = [];
          }
          var endss = deflateMultiCoordinatesArray(this.flatCoordinates, 0, coordinates, this.stride, this.endss_);
          if (endss.length === 0) {
              this.flatCoordinates.length = 0;
          }
          else {
              var lastEnds = endss[endss.length - 1];
              this.flatCoordinates.length =
                  lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
          }
          this.changed();
      };
      return MultiPolygon;
  }(SimpleGeometry));

  /**
   * @module ol/style/Image
   */
  /**
   * @typedef {Object} Options
   * @property {number} opacity
   * @property {boolean} rotateWithView
   * @property {number} rotation
   * @property {number|import("../size.js").Size} scale
   * @property {Array<number>} displacement
   */
  /**
   * @classdesc
   * A base class used for creating subclasses and not instantiated in
   * apps. Base class for {@link module:ol/style/Icon~Icon}, {@link module:ol/style/Circle~CircleStyle} and
   * {@link module:ol/style/RegularShape~RegularShape}.
   * @abstract
   * @api
   */
  var ImageStyle = /** @class */ (function () {
      /**
       * @param {Options} options Options.
       */
      function ImageStyle(options) {
          /**
           * @private
           * @type {number}
           */
          this.opacity_ = options.opacity;
          /**
           * @private
           * @type {boolean}
           */
          this.rotateWithView_ = options.rotateWithView;
          /**
           * @private
           * @type {number}
           */
          this.rotation_ = options.rotation;
          /**
           * @private
           * @type {number|import("../size.js").Size}
           */
          this.scale_ = options.scale;
          /**
           * @private
           * @type {import("../size.js").Size}
           */
          this.scaleArray_ = toSize(options.scale);
          /**
           * @private
           * @type {Array<number>}
           */
          this.displacement_ = options.displacement;
      }
      /**
       * Clones the style.
       * @return {ImageStyle} The cloned style.
       * @api
       */
      ImageStyle.prototype.clone = function () {
          var scale = this.getScale();
          return new ImageStyle({
              opacity: this.getOpacity(),
              scale: Array.isArray(scale) ? scale.slice() : scale,
              rotation: this.getRotation(),
              rotateWithView: this.getRotateWithView(),
              displacement: this.getDisplacement().slice(),
          });
      };
      /**
       * Get the symbolizer opacity.
       * @return {number} Opacity.
       * @api
       */
      ImageStyle.prototype.getOpacity = function () {
          return this.opacity_;
      };
      /**
       * Determine whether the symbolizer rotates with the map.
       * @return {boolean} Rotate with map.
       * @api
       */
      ImageStyle.prototype.getRotateWithView = function () {
          return this.rotateWithView_;
      };
      /**
       * Get the symoblizer rotation.
       * @return {number} Rotation.
       * @api
       */
      ImageStyle.prototype.getRotation = function () {
          return this.rotation_;
      };
      /**
       * Get the symbolizer scale.
       * @return {number|import("../size.js").Size} Scale.
       * @api
       */
      ImageStyle.prototype.getScale = function () {
          return this.scale_;
      };
      /**
       * Get the symbolizer scale array.
       * @return {import("../size.js").Size} Scale array.
       */
      ImageStyle.prototype.getScaleArray = function () {
          return this.scaleArray_;
      };
      /**
       * Get the displacement of the shape
       * @return {Array<number>} Shape's center displacement
       * @api
       */
      ImageStyle.prototype.getDisplacement = function () {
          return this.displacement_;
      };
      /**
       * Get the anchor point in pixels. The anchor determines the center point for the
       * symbolizer.
       * @abstract
       * @return {Array<number>} Anchor.
       */
      ImageStyle.prototype.getAnchor = function () {
          return abstract();
      };
      /**
       * Get the image element for the symbolizer.
       * @abstract
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
       */
      ImageStyle.prototype.getImage = function (pixelRatio) {
          return abstract();
      };
      /**
       * @abstract
       * @return {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} Image element.
       */
      ImageStyle.prototype.getHitDetectionImage = function () {
          return abstract();
      };
      /*
       * Get the image pixel ratio.
       * @param {number} pixelRatio Pixel ratio.
       * */
      ImageStyle.prototype.getPixelRatio = function (pixelRatio) {
          return 1;
      };
      /**
       * @abstract
       * @return {import("../ImageState.js").default} Image state.
       */
      ImageStyle.prototype.getImageState = function () {
          return abstract();
      };
      /**
       * @abstract
       * @return {import("../size.js").Size} Image size.
       */
      ImageStyle.prototype.getImageSize = function () {
          return abstract();
      };
      /**
       * @abstract
       * @return {import("../size.js").Size} Size of the hit-detection image.
       */
      ImageStyle.prototype.getHitDetectionImageSize = function () {
          return abstract();
      };
      /**
       * Get the origin of the symbolizer.
       * @abstract
       * @return {Array<number>} Origin.
       */
      ImageStyle.prototype.getOrigin = function () {
          return abstract();
      };
      /**
       * Get the size of the symbolizer (in pixels).
       * @abstract
       * @return {import("../size.js").Size} Size.
       */
      ImageStyle.prototype.getSize = function () {
          return abstract();
      };
      /**
       * Set the opacity.
       *
       * @param {number} opacity Opacity.
       * @api
       */
      ImageStyle.prototype.setOpacity = function (opacity) {
          this.opacity_ = opacity;
      };
      /**
       * Set whether to rotate the style with the view.
       *
       * @param {boolean} rotateWithView Rotate with map.
       * @api
       */
      ImageStyle.prototype.setRotateWithView = function (rotateWithView) {
          this.rotateWithView_ = rotateWithView;
      };
      /**
       * Set the rotation.
       *
       * @param {number} rotation Rotation.
       * @api
       */
      ImageStyle.prototype.setRotation = function (rotation) {
          this.rotation_ = rotation;
      };
      /**
       * Set the scale.
       *
       * @param {number|import("../size.js").Size} scale Scale.
       * @api
       */
      ImageStyle.prototype.setScale = function (scale) {
          this.scale_ = scale;
          this.scaleArray_ = toSize(scale);
      };
      /**
       * @abstract
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      ImageStyle.prototype.listenImageChange = function (listener) {
          abstract();
      };
      /**
       * Load not yet loaded URI.
       * @abstract
       */
      ImageStyle.prototype.load = function () {
          abstract();
      };
      /**
       * @abstract
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      ImageStyle.prototype.unlistenImageChange = function (listener) {
          abstract();
      };
      return ImageStyle;
  }());

  /**
   * @module ol/style/RegularShape
   */
  var __extends$O = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * Specify radius for regular polygons, or radius1 and radius2 for stars.
   * @typedef {Object} Options
   * @property {import("./Fill.js").default} [fill] Fill style.
   * @property {number} points Number of points for stars and regular polygons. In case of a polygon, the number of points
   * is the number of sides.
   * @property {number} [radius] Radius of a regular polygon.
   * @property {number} [radius1] Outer radius of a star.
   * @property {number} [radius2] Inner radius of a star.
   * @property {number} [angle=0] Shape's angle in radians. A value of 0 will have one of the shape's point facing up.
   * @property {Array<number>} [displacement=[0,0]] Displacement of the shape
   * @property {import("./Stroke.js").default} [stroke] Stroke style.
   * @property {number} [rotation=0] Rotation in radians (positive rotation clockwise).
   * @property {boolean} [rotateWithView=false] Whether to rotate the shape with the view.
   */
  /**
   * @typedef {Object} RenderOptions
   * @property {import("../colorlike.js").ColorLike} [strokeStyle]
   * @property {number} strokeWidth
   * @property {number} size
   * @property {CanvasLineCap} lineCap
   * @property {Array<number>} lineDash
   * @property {number} lineDashOffset
   * @property {CanvasLineJoin} lineJoin
   * @property {number} miterLimit
   */
  /**
   * @classdesc
   * Set regular shape style for vector features. The resulting shape will be
   * a regular polygon when `radius` is provided, or a star when `radius1` and
   * `radius2` are provided.
   * @api
   */
  var RegularShape = /** @class */ (function (_super) {
      __extends$O(RegularShape, _super);
      /**
       * @param {Options} options Options.
       */
      function RegularShape(options) {
          var _this = this;
          /**
           * @type {boolean}
           */
          var rotateWithView = options.rotateWithView !== undefined ? options.rotateWithView : false;
          _this = _super.call(this, {
              opacity: 1,
              rotateWithView: rotateWithView,
              rotation: options.rotation !== undefined ? options.rotation : 0,
              scale: 1,
              displacement: options.displacement !== undefined ? options.displacement : [0, 0],
          }) || this;
          /**
           * @private
           * @type {Object<number, HTMLCanvasElement>}
           */
          _this.canvas_ = {};
          /**
           * @private
           * @type {HTMLCanvasElement}
           */
          _this.hitDetectionCanvas_ = null;
          /**
           * @private
           * @type {import("./Fill.js").default}
           */
          _this.fill_ = options.fill !== undefined ? options.fill : null;
          /**
           * @private
           * @type {Array<number>}
           */
          _this.origin_ = [0, 0];
          /**
           * @private
           * @type {number}
           */
          _this.points_ = options.points;
          /**
           * @protected
           * @type {number}
           */
          _this.radius_ =
              options.radius !== undefined ? options.radius : options.radius1;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.radius2_ = options.radius2;
          /**
           * @private
           * @type {number}
           */
          _this.angle_ = options.angle !== undefined ? options.angle : 0;
          /**
           * @private
           * @type {import("./Stroke.js").default}
           */
          _this.stroke_ = options.stroke !== undefined ? options.stroke : null;
          /**
           * @private
           * @type {Array<number>}
           */
          _this.anchor_ = null;
          /**
           * @private
           * @type {import("../size.js").Size}
           */
          _this.size_ = null;
          /**
           * @private
           * @type {import("../size.js").Size}
           */
          _this.imageSize_ = null;
          /**
           * @private
           * @type {import("../size.js").Size}
           */
          _this.hitDetectionImageSize_ = null;
          _this.render();
          return _this;
      }
      /**
       * Clones the style.
       * @return {RegularShape} The cloned style.
       * @api
       */
      RegularShape.prototype.clone = function () {
          var style = new RegularShape({
              fill: this.getFill() ? this.getFill().clone() : undefined,
              points: this.getPoints(),
              radius: this.getRadius(),
              radius2: this.getRadius2(),
              angle: this.getAngle(),
              stroke: this.getStroke() ? this.getStroke().clone() : undefined,
              rotation: this.getRotation(),
              rotateWithView: this.getRotateWithView(),
              displacement: this.getDisplacement().slice(),
          });
          style.setOpacity(this.getOpacity());
          style.setScale(this.getScale());
          return style;
      };
      /**
       * Get the anchor point in pixels. The anchor determines the center point for the
       * symbolizer.
       * @return {Array<number>} Anchor.
       * @api
       */
      RegularShape.prototype.getAnchor = function () {
          return this.anchor_;
      };
      /**
       * Get the angle used in generating the shape.
       * @return {number} Shape's rotation in radians.
       * @api
       */
      RegularShape.prototype.getAngle = function () {
          return this.angle_;
      };
      /**
       * Get the fill style for the shape.
       * @return {import("./Fill.js").default} Fill style.
       * @api
       */
      RegularShape.prototype.getFill = function () {
          return this.fill_;
      };
      /**
       * @return {HTMLCanvasElement} Image element.
       */
      RegularShape.prototype.getHitDetectionImage = function () {
          if (!this.hitDetectionCanvas_) {
              var renderOptions = this.createRenderOptions();
              this.createHitDetectionCanvas_(renderOptions);
          }
          return this.hitDetectionCanvas_;
      };
      /**
       * Get the image icon.
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLCanvasElement} Image or Canvas element.
       * @api
       */
      RegularShape.prototype.getImage = function (pixelRatio) {
          if (!this.canvas_[pixelRatio || 1]) {
              var renderOptions = this.createRenderOptions();
              var context = createCanvasContext2D(renderOptions.size * pixelRatio || 1, renderOptions.size * pixelRatio || 1);
              this.draw_(renderOptions, context, 0, 0, pixelRatio || 1);
              this.canvas_[pixelRatio || 1] = context.canvas;
          }
          return this.canvas_[pixelRatio || 1];
      };
      /*
       * Get the image pixel ratio.
       * @param {number} pixelRatio Pixel ratio.
       * */
      RegularShape.prototype.getPixelRatio = function (pixelRatio) {
          return pixelRatio;
      };
      /**
       * @return {import("../size.js").Size} Image size.
       */
      RegularShape.prototype.getImageSize = function () {
          return this.imageSize_;
      };
      /**
       * @return {import("../size.js").Size} Size of the hit-detection image.
       */
      RegularShape.prototype.getHitDetectionImageSize = function () {
          return this.hitDetectionImageSize_;
      };
      /**
       * @return {import("../ImageState.js").default} Image state.
       */
      RegularShape.prototype.getImageState = function () {
          return ImageState.LOADED;
      };
      /**
       * Get the origin of the symbolizer.
       * @return {Array<number>} Origin.
       * @api
       */
      RegularShape.prototype.getOrigin = function () {
          return this.origin_;
      };
      /**
       * Get the number of points for generating the shape.
       * @return {number} Number of points for stars and regular polygons.
       * @api
       */
      RegularShape.prototype.getPoints = function () {
          return this.points_;
      };
      /**
       * Get the (primary) radius for the shape.
       * @return {number} Radius.
       * @api
       */
      RegularShape.prototype.getRadius = function () {
          return this.radius_;
      };
      /**
       * Get the secondary radius for the shape.
       * @return {number|undefined} Radius2.
       * @api
       */
      RegularShape.prototype.getRadius2 = function () {
          return this.radius2_;
      };
      /**
       * Get the size of the symbolizer (in pixels).
       * @return {import("../size.js").Size} Size.
       * @api
       */
      RegularShape.prototype.getSize = function () {
          return this.size_;
      };
      /**
       * Get the stroke style for the shape.
       * @return {import("./Stroke.js").default} Stroke style.
       * @api
       */
      RegularShape.prototype.getStroke = function () {
          return this.stroke_;
      };
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      RegularShape.prototype.listenImageChange = function (listener) { };
      /**
       * Load not yet loaded URI.
       */
      RegularShape.prototype.load = function () { };
      /**
       * @param {function(import("../events/Event.js").default): void} listener Listener function.
       */
      RegularShape.prototype.unlistenImageChange = function (listener) { };
      /**
       * @returns {RenderOptions}  The render options
       * @protected
       */
      RegularShape.prototype.createRenderOptions = function () {
          var lineCap = defaultLineCap;
          var lineJoin = defaultLineJoin;
          var miterLimit = 0;
          var lineDash = null;
          var lineDashOffset = 0;
          var strokeStyle;
          var strokeWidth = 0;
          if (this.stroke_) {
              strokeStyle = this.stroke_.getColor();
              if (strokeStyle === null) {
                  strokeStyle = defaultStrokeStyle;
              }
              strokeStyle = asColorLike(strokeStyle);
              strokeWidth = this.stroke_.getWidth();
              if (strokeWidth === undefined) {
                  strokeWidth = defaultLineWidth;
              }
              lineDash = this.stroke_.getLineDash();
              lineDashOffset = this.stroke_.getLineDashOffset();
              lineJoin = this.stroke_.getLineJoin();
              if (lineJoin === undefined) {
                  lineJoin = defaultLineJoin;
              }
              lineCap = this.stroke_.getLineCap();
              if (lineCap === undefined) {
                  lineCap = defaultLineCap;
              }
              miterLimit = this.stroke_.getMiterLimit();
              if (miterLimit === undefined) {
                  miterLimit = defaultMiterLimit;
              }
          }
          var size = 2 * (this.radius_ + strokeWidth) + 1;
          return {
              strokeStyle: strokeStyle,
              strokeWidth: strokeWidth,
              size: size,
              lineCap: lineCap,
              lineDash: lineDash,
              lineDashOffset: lineDashOffset,
              lineJoin: lineJoin,
              miterLimit: miterLimit,
          };
      };
      /**
       * @protected
       */
      RegularShape.prototype.render = function () {
          var renderOptions = this.createRenderOptions();
          var context = createCanvasContext2D(renderOptions.size, renderOptions.size);
          this.draw_(renderOptions, context, 0, 0, 1);
          this.canvas_[1] = context.canvas;
          // canvas.width and height are rounded to the closest integer
          var size = context.canvas.width;
          var imageSize = size;
          var displacement = this.getDisplacement();
          this.hitDetectionImageSize_ = [renderOptions.size, renderOptions.size];
          this.createHitDetectionCanvas_(renderOptions);
          this.anchor_ = [size / 2 - displacement[0], size / 2 + displacement[1]];
          this.size_ = [size, size];
          this.imageSize_ = [imageSize, imageSize];
      };
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       * @param {CanvasRenderingContext2D} context The rendering context.
       * @param {number} x The origin for the symbol (x).
       * @param {number} y The origin for the symbol (y).
       * @param {number} pixelRatio The pixel ratio.
       */
      RegularShape.prototype.draw_ = function (renderOptions, context, x, y, pixelRatio) {
          var i, angle0, radiusC;
          // reset transform
          context.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
          // then move to (x, y)
          context.translate(x, y);
          context.beginPath();
          var points = this.points_;
          if (points === Infinity) {
              context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);
          }
          else {
              var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;
              if (radius2 !== this.radius_) {
                  points = 2 * points;
              }
              for (i = 0; i <= points; i++) {
                  angle0 = (i * 2 * Math.PI) / points - Math.PI / 2 + this.angle_;
                  radiusC = i % 2 === 0 ? this.radius_ : radius2;
                  context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));
              }
          }
          if (this.fill_) {
              var color = this.fill_.getColor();
              if (color === null) {
                  color = defaultFillStyle;
              }
              context.fillStyle = asColorLike(color);
              context.fill();
          }
          if (this.stroke_) {
              context.strokeStyle = renderOptions.strokeStyle;
              context.lineWidth = renderOptions.strokeWidth;
              if (context.setLineDash && renderOptions.lineDash) {
                  context.setLineDash(renderOptions.lineDash);
                  context.lineDashOffset = renderOptions.lineDashOffset;
              }
              context.lineCap = renderOptions.lineCap;
              context.lineJoin = renderOptions.lineJoin;
              context.miterLimit = renderOptions.miterLimit;
              context.stroke();
          }
          context.closePath();
      };
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       */
      RegularShape.prototype.createHitDetectionCanvas_ = function (renderOptions) {
          this.hitDetectionCanvas_ = this.getImage(1);
          if (this.fill_) {
              var color = this.fill_.getColor();
              // determine if fill is transparent (or pattern or gradient)
              var opacity = 0;
              if (typeof color === 'string') {
                  color = asArray(color);
              }
              if (color === null) {
                  opacity = 1;
              }
              else if (Array.isArray(color)) {
                  opacity = color.length === 4 ? color[3] : 1;
              }
              if (opacity === 0) {
                  // if a transparent fill style is set, create an extra hit-detection image
                  // with a default fill style
                  var context = createCanvasContext2D(renderOptions.size, renderOptions.size);
                  this.hitDetectionCanvas_ = context.canvas;
                  this.drawHitDetectionCanvas_(renderOptions, context, 0, 0);
              }
          }
      };
      /**
       * @private
       * @param {RenderOptions} renderOptions Render options.
       * @param {CanvasRenderingContext2D} context The context.
       * @param {number} x The origin for the symbol (x).
       * @param {number} y The origin for the symbol (y).
       */
      RegularShape.prototype.drawHitDetectionCanvas_ = function (renderOptions, context, x, y) {
          // move to (x, y)
          context.translate(x, y);
          context.beginPath();
          var points = this.points_;
          if (points === Infinity) {
              context.arc(renderOptions.size / 2, renderOptions.size / 2, this.radius_, 0, 2 * Math.PI, true);
          }
          else {
              var radius2 = this.radius2_ !== undefined ? this.radius2_ : this.radius_;
              if (radius2 !== this.radius_) {
                  points = 2 * points;
              }
              var i = void 0, radiusC = void 0, angle0 = void 0;
              for (i = 0; i <= points; i++) {
                  angle0 = (i * 2 * Math.PI) / points - Math.PI / 2 + this.angle_;
                  radiusC = i % 2 === 0 ? this.radius_ : radius2;
                  context.lineTo(renderOptions.size / 2 + radiusC * Math.cos(angle0), renderOptions.size / 2 + radiusC * Math.sin(angle0));
              }
          }
          context.fillStyle = defaultFillStyle;
          context.fill();
          if (this.stroke_) {
              context.strokeStyle = renderOptions.strokeStyle;
              context.lineWidth = renderOptions.strokeWidth;
              if (renderOptions.lineDash) {
                  context.setLineDash(renderOptions.lineDash);
                  context.lineDashOffset = renderOptions.lineDashOffset;
              }
              context.stroke();
          }
          context.closePath();
      };
      return RegularShape;
  }(ImageStyle));

  /**
   * @module ol/style/Circle
   */
  var __extends$P = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {import("./Fill.js").default} [fill] Fill style.
   * @property {number} radius Circle radius.
   * @property {import("./Stroke.js").default} [stroke] Stroke style.
   * @property {Array<number>} [displacement=[0,0]] displacement
   */
  /**
   * @classdesc
   * Set circle style for vector features.
   * @api
   */
  var CircleStyle = /** @class */ (function (_super) {
      __extends$P(CircleStyle, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function CircleStyle(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          _this = _super.call(this, {
              points: Infinity,
              fill: options.fill,
              radius: options.radius,
              stroke: options.stroke,
              displacement: options.displacement !== undefined ? options.displacement : [0, 0],
          }) || this;
          return _this;
      }
      /**
       * Clones the style.
       * @return {CircleStyle} The cloned style.
       * @api
       */
      CircleStyle.prototype.clone = function () {
          var style = new CircleStyle({
              fill: this.getFill() ? this.getFill().clone() : undefined,
              stroke: this.getStroke() ? this.getStroke().clone() : undefined,
              radius: this.getRadius(),
              displacement: this.getDisplacement().slice(),
          });
          style.setOpacity(this.getOpacity());
          style.setScale(this.getScale());
          return style;
      };
      /**
       * Set the circle radius.
       *
       * @param {number} radius Circle radius.
       * @api
       */
      CircleStyle.prototype.setRadius = function (radius) {
          this.radius_ = radius;
          this.render();
      };
      return CircleStyle;
  }(RegularShape));

  /**
   * @module ol/style/Fill
   */
  /**
   * @typedef {Object} Options
   * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color=null] A color, gradient or pattern.
   * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
   * Default null; if null, the Canvas/renderer default black will be used.
   */
  /**
   * @classdesc
   * Set fill style for vector features.
   * @api
   */
  var Fill = /** @class */ (function () {
      /**
       * @param {Options=} opt_options Options.
       */
      function Fill(opt_options) {
          var options = opt_options || {};
          /**
           * @private
           * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
           */
          this.color_ = options.color !== undefined ? options.color : null;
      }
      /**
       * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
       * @return {Fill} The cloned style.
       * @api
       */
      Fill.prototype.clone = function () {
          var color = this.getColor();
          return new Fill({
              color: Array.isArray(color) ? color.slice() : color || undefined,
          });
      };
      /**
       * Get the fill color.
       * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
       * @api
       */
      Fill.prototype.getColor = function () {
          return this.color_;
      };
      /**
       * Set the color.
       *
       * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
       * @api
       */
      Fill.prototype.setColor = function (color) {
          this.color_ = color;
      };
      return Fill;
  }());

  /**
   * @module ol/style/Stroke
   */
  /**
   * @typedef {Object} Options
   * @property {import("../color.js").Color|import("../colorlike.js").ColorLike} [color] A color, gradient or pattern.
   * See {@link module:ol/color~Color} and {@link module:ol/colorlike~ColorLike} for possible formats.
   * Default null; if null, the Canvas/renderer default black will be used.
   * @property {CanvasLineCap} [lineCap='round'] Line cap style: `butt`, `round`, or `square`.
   * @property {CanvasLineJoin} [lineJoin='round'] Line join style: `bevel`, `round`, or `miter`.
   * @property {Array<number>} [lineDash] Line dash pattern. Default is `null` (no dash).
   * Please note that Internet Explorer 10 and lower do not support the `setLineDash` method on
   * the `CanvasRenderingContext2D` and therefore this option will have no visual effect in these browsers.
   * @property {number} [lineDashOffset=0] Line dash offset.
   * @property {number} [miterLimit=10] Miter limit.
   * @property {number} [width] Width.
   */
  /**
   * @classdesc
   * Set stroke style for vector features.
   * Note that the defaults given are the Canvas defaults, which will be used if
   * option is not defined. The `get` functions return whatever was entered in
   * the options; they will not return the default.
   * @api
   */
  var Stroke = /** @class */ (function () {
      /**
       * @param {Options=} opt_options Options.
       */
      function Stroke(opt_options) {
          var options = opt_options || {};
          /**
           * @private
           * @type {import("../color.js").Color|import("../colorlike.js").ColorLike}
           */
          this.color_ = options.color !== undefined ? options.color : null;
          /**
           * @private
           * @type {CanvasLineCap|undefined}
           */
          this.lineCap_ = options.lineCap;
          /**
           * @private
           * @type {Array<number>}
           */
          this.lineDash_ = options.lineDash !== undefined ? options.lineDash : null;
          /**
           * @private
           * @type {number|undefined}
           */
          this.lineDashOffset_ = options.lineDashOffset;
          /**
           * @private
           * @type {CanvasLineJoin|undefined}
           */
          this.lineJoin_ = options.lineJoin;
          /**
           * @private
           * @type {number|undefined}
           */
          this.miterLimit_ = options.miterLimit;
          /**
           * @private
           * @type {number|undefined}
           */
          this.width_ = options.width;
      }
      /**
       * Clones the style.
       * @return {Stroke} The cloned style.
       * @api
       */
      Stroke.prototype.clone = function () {
          var color = this.getColor();
          return new Stroke({
              color: Array.isArray(color) ? color.slice() : color || undefined,
              lineCap: this.getLineCap(),
              lineDash: this.getLineDash() ? this.getLineDash().slice() : undefined,
              lineDashOffset: this.getLineDashOffset(),
              lineJoin: this.getLineJoin(),
              miterLimit: this.getMiterLimit(),
              width: this.getWidth(),
          });
      };
      /**
       * Get the stroke color.
       * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
       * @api
       */
      Stroke.prototype.getColor = function () {
          return this.color_;
      };
      /**
       * Get the line cap type for the stroke.
       * @return {CanvasLineCap|undefined} Line cap.
       * @api
       */
      Stroke.prototype.getLineCap = function () {
          return this.lineCap_;
      };
      /**
       * Get the line dash style for the stroke.
       * @return {Array<number>} Line dash.
       * @api
       */
      Stroke.prototype.getLineDash = function () {
          return this.lineDash_;
      };
      /**
       * Get the line dash offset for the stroke.
       * @return {number|undefined} Line dash offset.
       * @api
       */
      Stroke.prototype.getLineDashOffset = function () {
          return this.lineDashOffset_;
      };
      /**
       * Get the line join type for the stroke.
       * @return {CanvasLineJoin|undefined} Line join.
       * @api
       */
      Stroke.prototype.getLineJoin = function () {
          return this.lineJoin_;
      };
      /**
       * Get the miter limit for the stroke.
       * @return {number|undefined} Miter limit.
       * @api
       */
      Stroke.prototype.getMiterLimit = function () {
          return this.miterLimit_;
      };
      /**
       * Get the stroke width.
       * @return {number|undefined} Width.
       * @api
       */
      Stroke.prototype.getWidth = function () {
          return this.width_;
      };
      /**
       * Set the color.
       *
       * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
       * @api
       */
      Stroke.prototype.setColor = function (color) {
          this.color_ = color;
      };
      /**
       * Set the line cap.
       *
       * @param {CanvasLineCap|undefined} lineCap Line cap.
       * @api
       */
      Stroke.prototype.setLineCap = function (lineCap) {
          this.lineCap_ = lineCap;
      };
      /**
       * Set the line dash.
       *
       * Please note that Internet Explorer 10 and lower [do not support][mdn] the
       * `setLineDash` method on the `CanvasRenderingContext2D` and therefore this
       * property will have no visual effect in these browsers.
       *
       * [mdn]: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/setLineDash#Browser_compatibility
       *
       * @param {Array<number>} lineDash Line dash.
       * @api
       */
      Stroke.prototype.setLineDash = function (lineDash) {
          this.lineDash_ = lineDash;
      };
      /**
       * Set the line dash offset.
       *
       * @param {number|undefined} lineDashOffset Line dash offset.
       * @api
       */
      Stroke.prototype.setLineDashOffset = function (lineDashOffset) {
          this.lineDashOffset_ = lineDashOffset;
      };
      /**
       * Set the line join.
       *
       * @param {CanvasLineJoin|undefined} lineJoin Line join.
       * @api
       */
      Stroke.prototype.setLineJoin = function (lineJoin) {
          this.lineJoin_ = lineJoin;
      };
      /**
       * Set the miter limit.
       *
       * @param {number|undefined} miterLimit Miter limit.
       * @api
       */
      Stroke.prototype.setMiterLimit = function (miterLimit) {
          this.miterLimit_ = miterLimit;
      };
      /**
       * Set the width.
       *
       * @param {number|undefined} width Width.
       * @api
       */
      Stroke.prototype.setWidth = function (width) {
          this.width_ = width;
      };
      return Stroke;
  }());

  /**
   * @module ol/style/Style
   */
  /**
   * A function that takes an {@link module:ol/Feature} and a `{number}`
   * representing the view's resolution. The function should return a
   * {@link module:ol/style/Style} or an array of them. This way e.g. a
   * vector layer can be styled. If the function returns `undefined`, the
   * feature will not be rendered.
   *
   * @typedef {function(import("../Feature.js").FeatureLike, number):(Style|Array<Style>|void)} StyleFunction
   */
  /**
   * A {@link Style}, an array of {@link Style}, or a {@link StyleFunction}.
   * @typedef {Style|Array<Style>|StyleFunction} StyleLike
   */
  /**
   * A function that takes an {@link module:ol/Feature} as argument and returns an
   * {@link module:ol/geom/Geometry} that will be rendered and styled for the feature.
   *
   * @typedef {function(import("../Feature.js").FeatureLike):
   *     (import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined)} GeometryFunction
   */
  /**
   * Custom renderer function. Takes two arguments:
   *
   * 1. The pixel coordinates of the geometry in GeoJSON notation.
   * 2. The {@link module:ol/render~State} of the layer renderer.
   *
   * @typedef {function((import("../coordinate.js").Coordinate|Array<import("../coordinate.js").Coordinate>|Array<Array<import("../coordinate.js").Coordinate>>),import("../render.js").State): void}
   * RenderFunction
   */
  /**
   * @typedef {Object} Options
   * @property {string|import("../geom/Geometry.js").default|GeometryFunction} [geometry] Feature property or geometry
   * or function returning a geometry to render for this style.
   * @property {import("./Fill.js").default} [fill] Fill style.
   * @property {import("./Image.js").default} [image] Image style.
   * @property {RenderFunction} [renderer] Custom renderer. When configured, `fill`, `stroke` and `image` will be
   * ignored, and the provided function will be called with each render frame for each geometry.
   * @property {import("./Stroke.js").default} [stroke] Stroke style.
   * @property {import("./Text.js").default} [text] Text style.
   * @property {number} [zIndex] Z index.
   */
  /**
   * @classdesc
   * Container for vector feature rendering styles. Any changes made to the style
   * or its children through `set*()` methods will not take effect until the
   * feature or layer that uses the style is re-rendered.
   *
   * ## Feature styles
   *
   * If no style is defined, the following default style is used:
   * ```js
   *  import {Fill, Stroke, Circle, Style} from 'ol/style';
   *
   *  var fill = new Fill({
   *    color: 'rgba(255,255,255,0.4)'
   *  });
   *  var stroke = new Stroke({
   *    color: '#3399CC',
   *    width: 1.25
   *  });
   *  var styles = [
   *    new Style({
   *      image: new Circle({
   *        fill: fill,
   *        stroke: stroke,
   *        radius: 5
   *      }),
   *      fill: fill,
   *      stroke: stroke
   *    })
   *  ];
   * ```
   *
   * A separate editing style has the following defaults:
   * ```js
   *  import {Fill, Stroke, Circle, Style} from 'ol/style';
   *  import GeometryType from 'ol/geom/GeometryType';
   *
   *  var white = [255, 255, 255, 1];
   *  var blue = [0, 153, 255, 1];
   *  var width = 3;
   *  styles[GeometryType.POLYGON] = [
   *    new Style({
   *      fill: new Fill({
   *        color: [255, 255, 255, 0.5]
   *      })
   *    })
   *  ];
   *  styles[GeometryType.MULTI_POLYGON] =
   *      styles[GeometryType.POLYGON];
   *  styles[GeometryType.LINE_STRING] = [
   *    new Style({
   *      stroke: new Stroke({
   *        color: white,
   *        width: width + 2
   *      })
   *    }),
   *    new Style({
   *      stroke: new Stroke({
   *        color: blue,
   *        width: width
   *      })
   *    })
   *  ];
   *  styles[GeometryType.MULTI_LINE_STRING] =
   *      styles[GeometryType.LINE_STRING];
   *  styles[GeometryType.POINT] = [
   *    new Style({
   *      image: new Circle({
   *        radius: width * 2,
   *        fill: new Fill({
   *          color: blue
   *        }),
   *        stroke: new Stroke({
   *          color: white,
   *          width: width / 2
   *        })
   *      }),
   *      zIndex: Infinity
   *    })
   *  ];
   *  styles[GeometryType.MULTI_POINT] =
   *      styles[GeometryType.POINT];
   *  styles[GeometryType.GEOMETRY_COLLECTION] =
   *      styles[GeometryType.POLYGON].concat(
   *          styles[GeometryType.LINE_STRING],
   *          styles[GeometryType.POINT]
   *      );
   * ```
   *
   * @api
   */
  var Style = /** @class */ (function () {
      /**
       * @param {Options=} opt_options Style options.
       */
      function Style(opt_options) {
          var options = opt_options || {};
          /**
           * @private
           * @type {string|import("../geom/Geometry.js").default|GeometryFunction}
           */
          this.geometry_ = null;
          /**
           * @private
           * @type {!GeometryFunction}
           */
          this.geometryFunction_ = defaultGeometryFunction;
          if (options.geometry !== undefined) {
              this.setGeometry(options.geometry);
          }
          /**
           * @private
           * @type {import("./Fill.js").default}
           */
          this.fill_ = options.fill !== undefined ? options.fill : null;
          /**
           * @private
           * @type {import("./Image.js").default}
           */
          this.image_ = options.image !== undefined ? options.image : null;
          /**
           * @private
           * @type {RenderFunction|null}
           */
          this.renderer_ = options.renderer !== undefined ? options.renderer : null;
          /**
           * @private
           * @type {import("./Stroke.js").default}
           */
          this.stroke_ = options.stroke !== undefined ? options.stroke : null;
          /**
           * @private
           * @type {import("./Text.js").default}
           */
          this.text_ = options.text !== undefined ? options.text : null;
          /**
           * @private
           * @type {number|undefined}
           */
          this.zIndex_ = options.zIndex;
      }
      /**
       * Clones the style.
       * @return {Style} The cloned style.
       * @api
       */
      Style.prototype.clone = function () {
          var geometry = this.getGeometry();
          if (geometry && typeof geometry === 'object') {
              geometry = /** @type {import("../geom/Geometry.js").default} */ (geometry).clone();
          }
          return new Style({
              geometry: geometry,
              fill: this.getFill() ? this.getFill().clone() : undefined,
              image: this.getImage() ? this.getImage().clone() : undefined,
              stroke: this.getStroke() ? this.getStroke().clone() : undefined,
              text: this.getText() ? this.getText().clone() : undefined,
              zIndex: this.getZIndex(),
          });
      };
      /**
       * Get the custom renderer function that was configured with
       * {@link #setRenderer} or the `renderer` constructor option.
       * @return {RenderFunction|null} Custom renderer function.
       * @api
       */
      Style.prototype.getRenderer = function () {
          return this.renderer_;
      };
      /**
       * Sets a custom renderer function for this style. When set, `fill`, `stroke`
       * and `image` options of the style will be ignored.
       * @param {RenderFunction|null} renderer Custom renderer function.
       * @api
       */
      Style.prototype.setRenderer = function (renderer) {
          this.renderer_ = renderer;
      };
      /**
       * Get the geometry to be rendered.
       * @return {string|import("../geom/Geometry.js").default|GeometryFunction}
       * Feature property or geometry or function that returns the geometry that will
       * be rendered with this style.
       * @api
       */
      Style.prototype.getGeometry = function () {
          return this.geometry_;
      };
      /**
       * Get the function used to generate a geometry for rendering.
       * @return {!GeometryFunction} Function that is called with a feature
       * and returns the geometry to render instead of the feature's geometry.
       * @api
       */
      Style.prototype.getGeometryFunction = function () {
          return this.geometryFunction_;
      };
      /**
       * Get the fill style.
       * @return {import("./Fill.js").default} Fill style.
       * @api
       */
      Style.prototype.getFill = function () {
          return this.fill_;
      };
      /**
       * Set the fill style.
       * @param {import("./Fill.js").default} fill Fill style.
       * @api
       */
      Style.prototype.setFill = function (fill) {
          this.fill_ = fill;
      };
      /**
       * Get the image style.
       * @return {import("./Image.js").default} Image style.
       * @api
       */
      Style.prototype.getImage = function () {
          return this.image_;
      };
      /**
       * Set the image style.
       * @param {import("./Image.js").default} image Image style.
       * @api
       */
      Style.prototype.setImage = function (image) {
          this.image_ = image;
      };
      /**
       * Get the stroke style.
       * @return {import("./Stroke.js").default} Stroke style.
       * @api
       */
      Style.prototype.getStroke = function () {
          return this.stroke_;
      };
      /**
       * Set the stroke style.
       * @param {import("./Stroke.js").default} stroke Stroke style.
       * @api
       */
      Style.prototype.setStroke = function (stroke) {
          this.stroke_ = stroke;
      };
      /**
       * Get the text style.
       * @return {import("./Text.js").default} Text style.
       * @api
       */
      Style.prototype.getText = function () {
          return this.text_;
      };
      /**
       * Set the text style.
       * @param {import("./Text.js").default} text Text style.
       * @api
       */
      Style.prototype.setText = function (text) {
          this.text_ = text;
      };
      /**
       * Get the z-index for the style.
       * @return {number|undefined} ZIndex.
       * @api
       */
      Style.prototype.getZIndex = function () {
          return this.zIndex_;
      };
      /**
       * Set a geometry that is rendered instead of the feature's geometry.
       *
       * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
       *     Feature property or geometry or function returning a geometry to render
       *     for this style.
       * @api
       */
      Style.prototype.setGeometry = function (geometry) {
          if (typeof geometry === 'function') {
              this.geometryFunction_ = geometry;
          }
          else if (typeof geometry === 'string') {
              this.geometryFunction_ = function (feature) {
                  return /** @type {import("../geom/Geometry.js").default} */ (feature.get(geometry));
              };
          }
          else if (!geometry) {
              this.geometryFunction_ = defaultGeometryFunction;
          }
          else if (geometry !== undefined) {
              this.geometryFunction_ = function () {
                  return /** @type {import("../geom/Geometry.js").default} */ (geometry);
              };
          }
          this.geometry_ = geometry;
      };
      /**
       * Set the z-index.
       *
       * @param {number|undefined} zIndex ZIndex.
       * @api
       */
      Style.prototype.setZIndex = function (zIndex) {
          this.zIndex_ = zIndex;
      };
      return Style;
  }());
  /**
   * Convert the provided object into a style function.  Functions passed through
   * unchanged.  Arrays of Style or single style objects wrapped in a
   * new style function.
   * @param {StyleFunction|Array<Style>|Style} obj
   *     A style function, a single style, or an array of styles.
   * @return {StyleFunction} A style function.
   */
  function toFunction(obj) {
      var styleFunction;
      if (typeof obj === 'function') {
          styleFunction = obj;
      }
      else {
          /**
           * @type {Array<Style>}
           */
          var styles_1;
          if (Array.isArray(obj)) {
              styles_1 = obj;
          }
          else {
              assert(typeof ( /** @type {?} */(obj).getZIndex) === 'function', 41); // Expected an `Style` or an array of `Style`
              var style = /** @type {Style} */ (obj);
              styles_1 = [style];
          }
          styleFunction = function () {
              return styles_1;
          };
      }
      return styleFunction;
  }
  /**
   * @type {Array<Style>}
   */
  var defaultStyles = null;
  /**
   * @param {import("../Feature.js").FeatureLike} feature Feature.
   * @param {number} resolution Resolution.
   * @return {Array<Style>} Style.
   */
  function createDefaultStyle(feature, resolution) {
      // We don't use an immediately-invoked function
      // and a closure so we don't get an error at script evaluation time in
      // browsers that do not support Canvas. (import("./Circle.js").CircleStyle does
      // canvas.getContext('2d') at construction time, which will cause an.error
      // in such browsers.)
      if (!defaultStyles) {
          var fill = new Fill({
              color: 'rgba(255,255,255,0.4)',
          });
          var stroke = new Stroke({
              color: '#3399CC',
              width: 1.25,
          });
          defaultStyles = [
              new Style({
                  image: new CircleStyle({
                      fill: fill,
                      stroke: stroke,
                      radius: 5,
                  }),
                  fill: fill,
                  stroke: stroke,
              }),
          ];
      }
      return defaultStyles;
  }
  /**
   * Default styles for editing features.
   * @return {Object<import("../geom/GeometryType.js").default, Array<Style>>} Styles
   */
  function createEditingStyle() {
      /** @type {Object<import("../geom/GeometryType.js").default, Array<Style>>} */
      var styles = {};
      var white = [255, 255, 255, 1];
      var blue = [0, 153, 255, 1];
      var width = 3;
      styles[GeometryType.POLYGON] = [
          new Style({
              fill: new Fill({
                  color: [255, 255, 255, 0.5],
              }),
          }),
      ];
      styles[GeometryType.MULTI_POLYGON] = styles[GeometryType.POLYGON];
      styles[GeometryType.LINE_STRING] = [
          new Style({
              stroke: new Stroke({
                  color: white,
                  width: width + 2,
              }),
          }),
          new Style({
              stroke: new Stroke({
                  color: blue,
                  width: width,
              }),
          }),
      ];
      styles[GeometryType.MULTI_LINE_STRING] = styles[GeometryType.LINE_STRING];
      styles[GeometryType.CIRCLE] = styles[GeometryType.POLYGON].concat(styles[GeometryType.LINE_STRING]);
      styles[GeometryType.POINT] = [
          new Style({
              image: new CircleStyle({
                  radius: width * 2,
                  fill: new Fill({
                      color: blue,
                  }),
                  stroke: new Stroke({
                      color: white,
                      width: width / 2,
                  }),
              }),
              zIndex: Infinity,
          }),
      ];
      styles[GeometryType.MULTI_POINT] = styles[GeometryType.POINT];
      styles[GeometryType.GEOMETRY_COLLECTION] = styles[GeometryType.POLYGON].concat(styles[GeometryType.LINE_STRING], styles[GeometryType.POINT]);
      return styles;
  }
  /**
   * Function that is called with a feature and returns its default geometry.
   * @param {import("../Feature.js").FeatureLike} feature Feature to get the geometry for.
   * @return {import("../geom/Geometry.js").default|import("../render/Feature.js").default|undefined} Geometry to render.
   */
  function defaultGeometryFunction(feature) {
      return feature.getGeometry();
  }

  var __extends$Q = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} Options
   * @property {string} [className='ol-layer'] A CSS class name to set to the layer element.
   * @property {number} [opacity=1] Opacity (0, 1).
   * @property {boolean} [visible=true] Visibility.
   * @property {import("../extent.js").Extent} [extent] The bounding extent for layer rendering.  The layer will not be
   * rendered outside of this extent.
   * @property {number} [zIndex] The z-index for layer rendering.  At rendering time, the layers
   * will be ordered, first by Z-index and then by position. When `undefined`, a `zIndex` of 0 is assumed
   * for layers that are added to the map's `layers` collection, or `Infinity` when the layer's `setMap()`
   * method was used.
   * @property {number} [minResolution] The minimum resolution (inclusive) at which this layer will be
   * visible.
   * @property {number} [maxResolution] The maximum resolution (exclusive) below which this layer will
   * be visible.
   * @property {number} [minZoom] The minimum view zoom level (exclusive) above which this layer will be
   * visible.
   * @property {number} [maxZoom] The maximum view zoom level (inclusive) at which this layer will
   * be visible.
   * @property {import("../render.js").OrderFunction} [renderOrder] Render order. Function to be used when sorting
   * features before rendering. By default features are drawn in the order that they are created. Use
   * `null` to avoid the sort, but get an undefined draw order.
   * @property {number} [renderBuffer=100] The buffer in pixels around the viewport extent used by the
   * renderer when getting features from the vector source for the rendering or hit-detection.
   * Recommended value: the size of the largest symbol, line width or label.
   * @property {import("../source/Vector.js").default} [source] Source.
   * @property {import("../PluggableMap.js").default} [map] Sets the layer as overlay on a map. The map will not manage
   * this layer in its layers collection, and the layer will be rendered on top. This is useful for
   * temporary layers. The standard way to add a layer to a map and have it managed by the map is to
   * use {@link module:ol/Map#addLayer}.
   * @property {boolean} [declutter=false] Declutter images and text. Decluttering is applied to all
   * image and text styles of all Vector and VectorTile layers that have set this to `true`. The priority
   * is defined by the z-index of the layer, the `zIndex` of the style and the render order of features.
   * Higher z-index means higher priority. Within the same z-index, a feature rendered before another has
   * higher priority.
   * @property {import("../style/Style.js").StyleLike|null} [style] Layer style. When set to `null`, only
   * features that have their own style will be rendered. See {@link module:ol/style} for default style
   * which will be used if this is not set.
   * @property {boolean} [updateWhileAnimating=false] When set to `true`, feature batches will
   * be recreated during animations. This means that no vectors will be shown clipped, but the
   * setting will have a performance impact for large amounts of vector data. When set to `false`,
   * batches will be recreated when no animation is active.
   * @property {boolean} [updateWhileInteracting=false] When set to `true`, feature batches will
   * be recreated during interactions. See also `updateWhileAnimating`.
   */
  /**
   * @enum {string}
   * @private
   */
  var Property$3 = {
      RENDER_ORDER: 'renderOrder',
  };
  /**
   * @classdesc
   * Vector data that is rendered client-side.
   * Note that any property set in the options is set as a {@link module:ol/Object~BaseObject}
   * property on the layer object; for example, setting `title: 'My Title'` in the
   * options means that `title` is observable, and has get/set accessors.
   *
   * @template {import("../source/Vector.js").default|import("../source/VectorTile.js").default} VectorSourceType
   * @extends {Layer<VectorSourceType>}
   * @api
   */
  var BaseVectorLayer = /** @class */ (function (_super) {
      __extends$Q(BaseVectorLayer, _super);
      /**
       * @param {Options=} opt_options Options.
       */
      function BaseVectorLayer(opt_options) {
          var _this = this;
          var options = opt_options ? opt_options : {};
          var baseOptions = assign({}, options);
          delete baseOptions.style;
          delete baseOptions.renderBuffer;
          delete baseOptions.updateWhileAnimating;
          delete baseOptions.updateWhileInteracting;
          _this = _super.call(this, baseOptions) || this;
          /**
           * @private
           * @type {boolean}
           */
          _this.declutter_ =
              options.declutter !== undefined ? options.declutter : false;
          /**
           * @type {number}
           * @private
           */
          _this.renderBuffer_ =
              options.renderBuffer !== undefined ? options.renderBuffer : 100;
          /**
           * User provided style.
           * @type {import("../style/Style.js").StyleLike}
           * @private
           */
          _this.style_ = null;
          /**
           * Style function for use within the library.
           * @type {import("../style/Style.js").StyleFunction|undefined}
           * @private
           */
          _this.styleFunction_ = undefined;
          _this.setStyle(options.style);
          /**
           * @type {boolean}
           * @private
           */
          _this.updateWhileAnimating_ =
              options.updateWhileAnimating !== undefined
                  ? options.updateWhileAnimating
                  : false;
          /**
           * @type {boolean}
           * @private
           */
          _this.updateWhileInteracting_ =
              options.updateWhileInteracting !== undefined
                  ? options.updateWhileInteracting
                  : false;
          return _this;
      }
      /**
       * @return {boolean} Declutter.
       */
      BaseVectorLayer.prototype.getDeclutter = function () {
          return this.declutter_;
      };
      /**
       * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
       * that resolves with an array of features. The array will either contain the topmost feature
       * when a hit was detected, or it will be empty.
       *
       * The hit detection algorithm used for this method is optimized for performance, but is less
       * accurate than the one used in {@link import("../PluggableMap.js").default#getFeaturesAtPixel}: Text
       * is not considered, and icons are only represented by their bounding box instead of the exact
       * image.
       *
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with an array of features.
       * @api
       */
      BaseVectorLayer.prototype.getFeatures = function (pixel) {
          return _super.prototype.getFeatures.call(this, pixel);
      };
      /**
       * @return {number|undefined} Render buffer.
       */
      BaseVectorLayer.prototype.getRenderBuffer = function () {
          return this.renderBuffer_;
      };
      /**
       * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
       *     order.
       */
      BaseVectorLayer.prototype.getRenderOrder = function () {
          return /** @type {import("../render.js").OrderFunction|null|undefined} */ (this.get(Property$3.RENDER_ORDER));
      };
      /**
       * Get the style for features.  This returns whatever was passed to the `style`
       * option at construction or to the `setStyle` method.
       * @return {import("../style/Style.js").StyleLike|null|undefined} Layer style.
       * @api
       */
      BaseVectorLayer.prototype.getStyle = function () {
          return this.style_;
      };
      /**
       * Get the style function.
       * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
       * @api
       */
      BaseVectorLayer.prototype.getStyleFunction = function () {
          return this.styleFunction_;
      };
      /**
       * @return {boolean} Whether the rendered layer should be updated while
       *     animating.
       */
      BaseVectorLayer.prototype.getUpdateWhileAnimating = function () {
          return this.updateWhileAnimating_;
      };
      /**
       * @return {boolean} Whether the rendered layer should be updated while
       *     interacting.
       */
      BaseVectorLayer.prototype.getUpdateWhileInteracting = function () {
          return this.updateWhileInteracting_;
      };
      /**
       * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
       *     Render order.
       */
      BaseVectorLayer.prototype.setRenderOrder = function (renderOrder) {
          this.set(Property$3.RENDER_ORDER, renderOrder);
      };
      /**
       * Set the style for features.  This can be a single style object, an array
       * of styles, or a function that takes a feature and resolution and returns
       * an array of styles. If set to `null`, the layer has no style (a `null` style),
       * so only features that have their own styles will be rendered in the layer. Call
       * `setStyle()` without arguments to reset to the default style. See
       * {@link module:ol/style} for information on the default style.
       * @param {(import("../style/Style.js").StyleLike|null)=} opt_style Layer style.
       * @api
       */
      BaseVectorLayer.prototype.setStyle = function (opt_style) {
          this.style_ = opt_style !== undefined ? opt_style : createDefaultStyle;
          this.styleFunction_ =
              opt_style === null ? undefined : toFunction(this.style_);
          this.changed();
      };
      return BaseVectorLayer;
  }(Layer));

  /**
   * @module ol/render/canvas/Instruction
   */
  /**
   * @enum {number}
   */
  var Instruction = {
      BEGIN_GEOMETRY: 0,
      BEGIN_PATH: 1,
      CIRCLE: 2,
      CLOSE_PATH: 3,
      CUSTOM: 4,
      DRAW_CHARS: 5,
      DRAW_IMAGE: 6,
      END_GEOMETRY: 7,
      FILL: 8,
      MOVE_TO_LINE_TO: 9,
      SET_FILL_STYLE: 10,
      SET_STROKE_STYLE: 11,
      STROKE: 12,
  };
  /**
   * @type {Array<Instruction>}
   */
  var fillInstruction = [Instruction.FILL];
  /**
   * @type {Array<Instruction>}
   */
  var strokeInstruction = [Instruction.STROKE];
  /**
   * @type {Array<Instruction>}
   */
  var beginPathInstruction = [Instruction.BEGIN_PATH];
  /**
   * @type {Array<Instruction>}
   */
  var closePathInstruction = [Instruction.CLOSE_PATH];

  var __extends$R = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @typedef {Object} SerializableInstructions
   * @property {Array<*>} instructions The rendering instructions.
   * @property {Array<*>} hitDetectionInstructions The rendering hit detection instructions.
   * @property {Array<number>} coordinates The array of all coordinates.
   * @property {!Object<string, import("../canvas.js").TextState>} [textStates] The text states (decluttering).
   * @property {!Object<string, import("../canvas.js").FillState>} [fillStates] The fill states (decluttering).
   * @property {!Object<string, import("../canvas.js").StrokeState>} [strokeStates] The stroke states (decluttering).
   */
  var CanvasBuilder = /** @class */ (function (_super) {
      __extends$R(CanvasBuilder, _super);
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      function CanvasBuilder(tolerance, maxExtent, resolution, pixelRatio) {
          var _this = _super.call(this) || this;
          /**
           * @protected
           * @type {number}
           */
          _this.tolerance = tolerance;
          /**
           * @protected
           * @const
           * @type {import("../../extent.js").Extent}
           */
          _this.maxExtent = maxExtent;
          /**
           * @protected
           * @type {number}
           */
          _this.pixelRatio = pixelRatio;
          /**
           * @protected
           * @type {number}
           */
          _this.maxLineWidth = 0;
          /**
           * @protected
           * @const
           * @type {number}
           */
          _this.resolution = resolution;
          /**
           * @private
           * @type {Array<*>}
           */
          _this.beginGeometryInstruction1_ = null;
          /**
           * @private
           * @type {Array<*>}
           */
          _this.beginGeometryInstruction2_ = null;
          /**
           * @private
           * @type {import("../../extent.js").Extent}
           */
          _this.bufferedMaxExtent_ = null;
          /**
           * @protected
           * @type {Array<*>}
           */
          _this.instructions = [];
          /**
           * @protected
           * @type {Array<number>}
           */
          _this.coordinates = [];
          /**
           * @private
           * @type {import("../../coordinate.js").Coordinate}
           */
          _this.tmpCoordinate_ = [];
          /**
           * @protected
           * @type {Array<*>}
           */
          _this.hitDetectionInstructions = [];
          /**
           * @protected
           * @type {import("../canvas.js").FillStrokeState}
           */
          _this.state = /** @type {import("../canvas.js").FillStrokeState} */ ({});
          return _this;
      }
      /**
       * @protected
       * @param {Array<number>} dashArray Dash array.
       * @return {Array<number>} Dash array with pixel ratio applied
       */
      CanvasBuilder.prototype.applyPixelRatio = function (dashArray) {
          var pixelRatio = this.pixelRatio;
          return pixelRatio == 1
              ? dashArray
              : dashArray.map(function (dash) {
                  return dash * pixelRatio;
              });
      };
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @param {boolean} closed Last input coordinate equals first.
       * @param {boolean} skipFirst Skip first coordinate.
       * @protected
       * @return {number} My end.
       */
      CanvasBuilder.prototype.appendFlatCoordinates = function (flatCoordinates, offset, end, stride, closed, skipFirst) {
          var myEnd = this.coordinates.length;
          var extent = this.getBufferedMaxExtent();
          if (skipFirst) {
              offset += stride;
          }
          var lastXCoord = flatCoordinates[offset];
          var lastYCoord = flatCoordinates[offset + 1];
          var nextCoord = this.tmpCoordinate_;
          var skipped = true;
          var i, lastRel, nextRel;
          for (i = offset + stride; i < end; i += stride) {
              nextCoord[0] = flatCoordinates[i];
              nextCoord[1] = flatCoordinates[i + 1];
              nextRel = coordinateRelationship(extent, nextCoord);
              if (nextRel !== lastRel) {
                  if (skipped) {
                      this.coordinates[myEnd++] = lastXCoord;
                      this.coordinates[myEnd++] = lastYCoord;
                  }
                  this.coordinates[myEnd++] = nextCoord[0];
                  this.coordinates[myEnd++] = nextCoord[1];
                  skipped = false;
              }
              else if (nextRel === Relationship.INTERSECTING) {
                  this.coordinates[myEnd++] = nextCoord[0];
                  this.coordinates[myEnd++] = nextCoord[1];
                  skipped = false;
              }
              else {
                  skipped = true;
              }
              lastXCoord = nextCoord[0];
              lastYCoord = nextCoord[1];
              lastRel = nextRel;
          }
          // Last coordinate equals first or only one point to append:
          if ((closed && skipped) || i === offset + stride) {
              this.coordinates[myEnd++] = lastXCoord;
              this.coordinates[myEnd++] = lastYCoord;
          }
          return myEnd;
      };
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @param {Array<number>} builderEnds Builder ends.
       * @return {number} Offset.
       */
      CanvasBuilder.prototype.drawCustomCoordinates_ = function (flatCoordinates, offset, ends, stride, builderEnds) {
          for (var i = 0, ii = ends.length; i < ii; ++i) {
              var end = ends[i];
              var builderEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
              builderEnds.push(builderEnd);
              offset = end;
          }
          return offset;
      };
      /**
       * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {Function} renderer Renderer.
       */
      CanvasBuilder.prototype.drawCustom = function (geometry, feature, renderer) {
          this.beginGeometry(geometry, feature);
          var type = geometry.getType();
          var stride = geometry.getStride();
          var builderBegin = this.coordinates.length;
          var flatCoordinates, builderEnd, builderEnds, builderEndss;
          var offset;
          if (type == GeometryType.MULTI_POLYGON) {
              flatCoordinates = /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry).getOrientedFlatCoordinates();
              builderEndss = [];
              var endss = /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry).getEndss();
              offset = 0;
              for (var i = 0, ii = endss.length; i < ii; ++i) {
                  var myEnds = [];
                  offset = this.drawCustomCoordinates_(flatCoordinates, offset, endss[i], stride, myEnds);
                  builderEndss.push(myEnds);
              }
              this.instructions.push([
                  Instruction.CUSTOM,
                  builderBegin,
                  builderEndss,
                  geometry,
                  renderer,
                  inflateMultiCoordinatesArray,
              ]);
          }
          else if (type == GeometryType.POLYGON ||
              type == GeometryType.MULTI_LINE_STRING) {
              builderEnds = [];
              flatCoordinates =
                  type == GeometryType.POLYGON
                      ? /** @type {import("../../geom/Polygon.js").default} */ (geometry).getOrientedFlatCoordinates()
                      : geometry.getFlatCoordinates();
              offset = this.drawCustomCoordinates_(flatCoordinates, 0, 
              /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */ (geometry).getEnds(), stride, builderEnds);
              this.instructions.push([
                  Instruction.CUSTOM,
                  builderBegin,
                  builderEnds,
                  geometry,
                  renderer,
                  inflateCoordinatesArray,
              ]);
          }
          else if (type == GeometryType.LINE_STRING ||
              type == GeometryType.MULTI_POINT) {
              flatCoordinates = geometry.getFlatCoordinates();
              builderEnd = this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
              this.instructions.push([
                  Instruction.CUSTOM,
                  builderBegin,
                  builderEnd,
                  geometry,
                  renderer,
                  inflateCoordinates,
              ]);
          }
          else if (type == GeometryType.POINT) {
              flatCoordinates = geometry.getFlatCoordinates();
              this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
              builderEnd = this.coordinates.length;
              this.instructions.push([
                  Instruction.CUSTOM,
                  builderBegin,
                  builderEnd,
                  geometry,
                  renderer,
              ]);
          }
          this.endGeometry(feature);
      };
      /**
       * @protected
       * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasBuilder.prototype.beginGeometry = function (geometry, feature) {
          var extent = geometry.getExtent();
          this.beginGeometryInstruction1_ = [
              Instruction.BEGIN_GEOMETRY,
              feature,
              0,
              extent,
          ];
          this.instructions.push(this.beginGeometryInstruction1_);
          this.beginGeometryInstruction2_ = [
              Instruction.BEGIN_GEOMETRY,
              feature,
              0,
              extent,
          ];
          this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
      };
      /**
       * @return {SerializableInstructions} the serializable instructions.
       */
      CanvasBuilder.prototype.finish = function () {
          return {
              instructions: this.instructions,
              hitDetectionInstructions: this.hitDetectionInstructions,
              coordinates: this.coordinates,
          };
      };
      /**
       * Reverse the hit detection instructions.
       */
      CanvasBuilder.prototype.reverseHitDetectionInstructions = function () {
          var hitDetectionInstructions = this.hitDetectionInstructions;
          // step 1 - reverse array
          hitDetectionInstructions.reverse();
          // step 2 - reverse instructions within geometry blocks
          var i;
          var n = hitDetectionInstructions.length;
          var instruction;
          var type;
          var begin = -1;
          for (i = 0; i < n; ++i) {
              instruction = hitDetectionInstructions[i];
              type = /** @type {import("./Instruction.js").default} */ (instruction[0]);
              if (type == Instruction.END_GEOMETRY) {
                  begin = i;
              }
              else if (type == Instruction.BEGIN_GEOMETRY) {
                  instruction[2] = i;
                  reverseSubArray(this.hitDetectionInstructions, begin, i);
                  begin = -1;
              }
          }
      };
      /**
       * @param {import("../../style/Fill.js").default} fillStyle Fill style.
       * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
       */
      CanvasBuilder.prototype.setFillStrokeStyle = function (fillStyle, strokeStyle) {
          var state = this.state;
          if (fillStyle) {
              var fillStyleColor = fillStyle.getColor();
              state.fillStyle = asColorLike(fillStyleColor ? fillStyleColor : defaultFillStyle);
          }
          else {
              state.fillStyle = undefined;
          }
          if (strokeStyle) {
              var strokeStyleColor = strokeStyle.getColor();
              state.strokeStyle = asColorLike(strokeStyleColor ? strokeStyleColor : defaultStrokeStyle);
              var strokeStyleLineCap = strokeStyle.getLineCap();
              state.lineCap =
                  strokeStyleLineCap !== undefined ? strokeStyleLineCap : defaultLineCap;
              var strokeStyleLineDash = strokeStyle.getLineDash();
              state.lineDash = strokeStyleLineDash
                  ? strokeStyleLineDash.slice()
                  : defaultLineDash;
              var strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
              state.lineDashOffset = strokeStyleLineDashOffset
                  ? strokeStyleLineDashOffset
                  : defaultLineDashOffset;
              var strokeStyleLineJoin = strokeStyle.getLineJoin();
              state.lineJoin =
                  strokeStyleLineJoin !== undefined
                      ? strokeStyleLineJoin
                      : defaultLineJoin;
              var strokeStyleWidth = strokeStyle.getWidth();
              state.lineWidth =
                  strokeStyleWidth !== undefined ? strokeStyleWidth : defaultLineWidth;
              var strokeStyleMiterLimit = strokeStyle.getMiterLimit();
              state.miterLimit =
                  strokeStyleMiterLimit !== undefined
                      ? strokeStyleMiterLimit
                      : defaultMiterLimit;
              if (state.lineWidth > this.maxLineWidth) {
                  this.maxLineWidth = state.lineWidth;
                  // invalidate the buffered max extent cache
                  this.bufferedMaxExtent_ = null;
              }
          }
          else {
              state.strokeStyle = undefined;
              state.lineCap = undefined;
              state.lineDash = null;
              state.lineDashOffset = undefined;
              state.lineJoin = undefined;
              state.lineWidth = undefined;
              state.miterLimit = undefined;
          }
      };
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @return {Array<*>} Fill instruction.
       */
      CanvasBuilder.prototype.createFill = function (state) {
          var fillStyle = state.fillStyle;
          /** @type {Array<*>} */
          var fillInstruction = [Instruction.SET_FILL_STYLE, fillStyle];
          if (typeof fillStyle !== 'string') {
              // Fill is a pattern or gradient - align it!
              fillInstruction.push(true);
          }
          return fillInstruction;
      };
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       */
      CanvasBuilder.prototype.applyStroke = function (state) {
          this.instructions.push(this.createStroke(state));
      };
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @return {Array<*>} Stroke instruction.
       */
      CanvasBuilder.prototype.createStroke = function (state) {
          return [
              Instruction.SET_STROKE_STYLE,
              state.strokeStyle,
              state.lineWidth * this.pixelRatio,
              state.lineCap,
              state.lineJoin,
              state.miterLimit,
              this.applyPixelRatio(state.lineDash),
              state.lineDashOffset * this.pixelRatio,
          ];
      };
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
       */
      CanvasBuilder.prototype.updateFillStyle = function (state, createFill) {
          var fillStyle = state.fillStyle;
          if (typeof fillStyle !== 'string' || state.currentFillStyle != fillStyle) {
              if (fillStyle !== undefined) {
                  this.instructions.push(createFill.call(this, state));
              }
              state.currentFillStyle = fillStyle;
          }
      };
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
       */
      CanvasBuilder.prototype.updateStrokeStyle = function (state, applyStroke) {
          var strokeStyle = state.strokeStyle;
          var lineCap = state.lineCap;
          var lineDash = state.lineDash;
          var lineDashOffset = state.lineDashOffset;
          var lineJoin = state.lineJoin;
          var lineWidth = state.lineWidth;
          var miterLimit = state.miterLimit;
          if (state.currentStrokeStyle != strokeStyle ||
              state.currentLineCap != lineCap ||
              (lineDash != state.currentLineDash &&
                  !equals(state.currentLineDash, lineDash)) ||
              state.currentLineDashOffset != lineDashOffset ||
              state.currentLineJoin != lineJoin ||
              state.currentLineWidth != lineWidth ||
              state.currentMiterLimit != miterLimit) {
              if (strokeStyle !== undefined) {
                  applyStroke.call(this, state);
              }
              state.currentStrokeStyle = strokeStyle;
              state.currentLineCap = lineCap;
              state.currentLineDash = lineDash;
              state.currentLineDashOffset = lineDashOffset;
              state.currentLineJoin = lineJoin;
              state.currentLineWidth = lineWidth;
              state.currentMiterLimit = miterLimit;
          }
      };
      /**
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasBuilder.prototype.endGeometry = function (feature) {
          this.beginGeometryInstruction1_[2] = this.instructions.length;
          this.beginGeometryInstruction1_ = null;
          this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
          this.beginGeometryInstruction2_ = null;
          var endGeometryInstruction = [Instruction.END_GEOMETRY, feature];
          this.instructions.push(endGeometryInstruction);
          this.hitDetectionInstructions.push(endGeometryInstruction);
      };
      /**
       * Get the buffered rendering extent.  Rendering will be clipped to the extent
       * provided to the constructor.  To account for symbolizers that may intersect
       * this extent, we calculate a buffered extent (e.g. based on stroke width).
       * @return {import("../../extent.js").Extent} The buffered rendering extent.
       * @protected
       */
      CanvasBuilder.prototype.getBufferedMaxExtent = function () {
          if (!this.bufferedMaxExtent_) {
              this.bufferedMaxExtent_ = clone(this.maxExtent);
              if (this.maxLineWidth > 0) {
                  var width = (this.resolution * (this.maxLineWidth + 1)) / 2;
                  buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
              }
          }
          return this.bufferedMaxExtent_;
      };
      return CanvasBuilder;
  }(VectorContext));

  var __extends$S = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var CanvasImageBuilder = /** @class */ (function (_super) {
      __extends$S(CanvasImageBuilder, _super);
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      function CanvasImageBuilder(tolerance, maxExtent, resolution, pixelRatio) {
          var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
          /**
           * @private
           * @type {import("../canvas.js").DeclutterGroups}
           */
          _this.declutterGroups_ = null;
          /**
           * @private
           * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
           */
          _this.hitDetectionImage_ = null;
          /**
           * @private
           * @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement}
           */
          _this.image_ = null;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.imagePixelRatio_ = undefined;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.anchorX_ = undefined;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.anchorY_ = undefined;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.height_ = undefined;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.opacity_ = undefined;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.originX_ = undefined;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.originY_ = undefined;
          /**
           * @private
           * @type {boolean|undefined}
           */
          _this.rotateWithView_ = undefined;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.rotation_ = undefined;
          /**
           * @private
           * @type {import("../../size.js").Size|undefined}
           */
          _this.scale_ = undefined;
          /**
           * @private
           * @type {number|undefined}
           */
          _this.width_ = undefined;
          return _this;
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       * @return {number} My end.
       */
      CanvasImageBuilder.prototype.drawCoordinates_ = function (flatCoordinates, offset, end, stride) {
          return this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
      };
      /**
       * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasImageBuilder.prototype.drawPoint = function (pointGeometry, feature) {
          if (!this.image_) {
              return;
          }
          this.beginGeometry(pointGeometry, feature);
          var flatCoordinates = pointGeometry.getFlatCoordinates();
          var stride = pointGeometry.getStride();
          var myBegin = this.coordinates.length;
          var myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
          this.instructions.push([
              Instruction.DRAW_IMAGE,
              myBegin,
              myEnd,
              this.image_,
              // Remaining arguments to DRAW_IMAGE are in alphabetical order
              this.anchorX_ * this.imagePixelRatio_,
              this.anchorY_ * this.imagePixelRatio_,
              this.declutterGroups_,
              Math.ceil(this.height_ * this.imagePixelRatio_),
              this.opacity_,
              this.originX_,
              this.originY_,
              this.rotateWithView_,
              this.rotation_,
              [
                  (this.scale_[0] * this.pixelRatio) / this.imagePixelRatio_,
                  (this.scale_[1] * this.pixelRatio) / this.imagePixelRatio_,
              ],
              Math.ceil(this.width_ * this.imagePixelRatio_),
          ]);
          this.hitDetectionInstructions.push([
              Instruction.DRAW_IMAGE,
              myBegin,
              myEnd,
              this.hitDetectionImage_,
              // Remaining arguments to DRAW_IMAGE are in alphabetical order
              this.anchorX_,
              this.anchorY_,
              this.declutterGroups_,
              this.height_,
              this.opacity_,
              this.originX_,
              this.originY_,
              this.rotateWithView_,
              this.rotation_,
              this.scale_,
              this.width_,
          ]);
          this.endGeometry(feature);
      };
      /**
       * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasImageBuilder.prototype.drawMultiPoint = function (multiPointGeometry, feature) {
          if (!this.image_) {
              return;
          }
          this.beginGeometry(multiPointGeometry, feature);
          var flatCoordinates = multiPointGeometry.getFlatCoordinates();
          var stride = multiPointGeometry.getStride();
          var myBegin = this.coordinates.length;
          var myEnd = this.drawCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
          this.instructions.push([
              Instruction.DRAW_IMAGE,
              myBegin,
              myEnd,
              this.image_,
              // Remaining arguments to DRAW_IMAGE are in alphabetical order
              this.anchorX_ * this.imagePixelRatio_,
              this.anchorY_ * this.imagePixelRatio_,
              this.declutterGroups_,
              Math.ceil(this.height_ * this.imagePixelRatio_),
              this.opacity_,
              this.originX_,
              this.originY_,
              this.rotateWithView_,
              this.rotation_,
              [
                  (this.scale_[0] * this.pixelRatio) / this.imagePixelRatio_,
                  (this.scale_[1] * this.pixelRatio) / this.imagePixelRatio_,
              ],
              Math.ceil(this.width_ * this.imagePixelRatio_),
          ]);
          this.hitDetectionInstructions.push([
              Instruction.DRAW_IMAGE,
              myBegin,
              myEnd,
              this.hitDetectionImage_,
              // Remaining arguments to DRAW_IMAGE are in alphabetical order
              this.anchorX_,
              this.anchorY_,
              this.declutterGroups_,
              this.height_,
              this.opacity_,
              this.originX_,
              this.originY_,
              this.rotateWithView_,
              this.rotation_,
              this.scale_,
              this.width_,
          ]);
          this.endGeometry(feature);
      };
      /**
       * @return {import("./Builder.js").SerializableInstructions} the serializable instructions.
       */
      CanvasImageBuilder.prototype.finish = function () {
          this.reverseHitDetectionInstructions();
          // FIXME this doesn't really protect us against further calls to draw*Geometry
          this.anchorX_ = undefined;
          this.anchorY_ = undefined;
          this.hitDetectionImage_ = null;
          this.image_ = null;
          this.imagePixelRatio_ = undefined;
          this.height_ = undefined;
          this.scale_ = undefined;
          this.opacity_ = undefined;
          this.originX_ = undefined;
          this.originY_ = undefined;
          this.rotateWithView_ = undefined;
          this.rotation_ = undefined;
          this.width_ = undefined;
          return _super.prototype.finish.call(this);
      };
      /**
       * @param {import("../../style/Image.js").default} imageStyle Image style.
       * @param {import("../canvas.js").DeclutterGroup} declutterGroups Declutter.
       */
      CanvasImageBuilder.prototype.setImageStyle = function (imageStyle, declutterGroups) {
          var anchor = imageStyle.getAnchor();
          var size = imageStyle.getSize();
          var hitDetectionImage = imageStyle.getHitDetectionImage();
          var image = imageStyle.getImage(this.pixelRatio);
          var origin = imageStyle.getOrigin();
          this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
          this.anchorX_ = anchor[0];
          this.anchorY_ = anchor[1];
          this.declutterGroups_ = declutterGroups;
          this.hitDetectionImage_ = hitDetectionImage;
          this.image_ = image;
          this.height_ = size[1];
          this.opacity_ = imageStyle.getOpacity();
          this.originX_ = origin[0];
          this.originY_ = origin[1];
          this.rotateWithView_ = imageStyle.getRotateWithView();
          this.rotation_ = imageStyle.getRotation();
          this.scale_ = imageStyle.getScaleArray();
          this.width_ = size[0];
      };
      return CanvasImageBuilder;
  }(CanvasBuilder));

  var __extends$T = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var CanvasLineStringBuilder = /** @class */ (function (_super) {
      __extends$T(CanvasLineStringBuilder, _super);
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      function CanvasLineStringBuilder(tolerance, maxExtent, resolution, pixelRatio) {
          return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {number} end End.
       * @param {number} stride Stride.
       * @private
       * @return {number} end.
       */
      CanvasLineStringBuilder.prototype.drawFlatCoordinates_ = function (flatCoordinates, offset, end, stride) {
          var myBegin = this.coordinates.length;
          var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, false, false);
          var moveToLineToInstruction = [
              Instruction.MOVE_TO_LINE_TO,
              myBegin,
              myEnd,
          ];
          this.instructions.push(moveToLineToInstruction);
          this.hitDetectionInstructions.push(moveToLineToInstruction);
          return end;
      };
      /**
       * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasLineStringBuilder.prototype.drawLineString = function (lineStringGeometry, feature) {
          var state = this.state;
          var strokeStyle = state.strokeStyle;
          var lineWidth = state.lineWidth;
          if (strokeStyle === undefined || lineWidth === undefined) {
              return;
          }
          this.updateStrokeStyle(state, this.applyStroke);
          this.beginGeometry(lineStringGeometry, feature);
          this.hitDetectionInstructions.push([
              Instruction.SET_STROKE_STYLE,
              state.strokeStyle,
              state.lineWidth,
              state.lineCap,
              state.lineJoin,
              state.miterLimit,
              state.lineDash,
              state.lineDashOffset,
          ], beginPathInstruction);
          var flatCoordinates = lineStringGeometry.getFlatCoordinates();
          var stride = lineStringGeometry.getStride();
          this.drawFlatCoordinates_(flatCoordinates, 0, flatCoordinates.length, stride);
          this.hitDetectionInstructions.push(strokeInstruction);
          this.endGeometry(feature);
      };
      /**
       * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasLineStringBuilder.prototype.drawMultiLineString = function (multiLineStringGeometry, feature) {
          var state = this.state;
          var strokeStyle = state.strokeStyle;
          var lineWidth = state.lineWidth;
          if (strokeStyle === undefined || lineWidth === undefined) {
              return;
          }
          this.updateStrokeStyle(state, this.applyStroke);
          this.beginGeometry(multiLineStringGeometry, feature);
          this.hitDetectionInstructions.push([
              Instruction.SET_STROKE_STYLE,
              state.strokeStyle,
              state.lineWidth,
              state.lineCap,
              state.lineJoin,
              state.miterLimit,
              state.lineDash,
              state.lineDashOffset,
          ], beginPathInstruction);
          var ends = multiLineStringGeometry.getEnds();
          var flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
          var stride = multiLineStringGeometry.getStride();
          var offset = 0;
          for (var i = 0, ii = ends.length; i < ii; ++i) {
              offset = this.drawFlatCoordinates_(flatCoordinates, offset, 
              /** @type {number} */ (ends[i]), stride);
          }
          this.hitDetectionInstructions.push(strokeInstruction);
          this.endGeometry(feature);
      };
      /**
       * @return {import("./Builder.js").SerializableInstructions} the serializable instructions.
       */
      CanvasLineStringBuilder.prototype.finish = function () {
          var state = this.state;
          if (state.lastStroke != undefined &&
              state.lastStroke != this.coordinates.length) {
              this.instructions.push(strokeInstruction);
          }
          this.reverseHitDetectionInstructions();
          this.state = null;
          return _super.prototype.finish.call(this);
      };
      /**
       * @param {import("../canvas.js").FillStrokeState} state State.
       */
      CanvasLineStringBuilder.prototype.applyStroke = function (state) {
          if (state.lastStroke != undefined &&
              state.lastStroke != this.coordinates.length) {
              this.instructions.push(strokeInstruction);
              state.lastStroke = this.coordinates.length;
          }
          state.lastStroke = 0;
          _super.prototype.applyStroke.call(this, state);
          this.instructions.push(beginPathInstruction);
      };
      return CanvasLineStringBuilder;
  }(CanvasBuilder));

  var __extends$U = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var CanvasPolygonBuilder = /** @class */ (function (_super) {
      __extends$U(CanvasPolygonBuilder, _super);
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      function CanvasPolygonBuilder(tolerance, maxExtent, resolution, pixelRatio) {
          return _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
      }
      /**
       * @param {Array<number>} flatCoordinates Flat coordinates.
       * @param {number} offset Offset.
       * @param {Array<number>} ends Ends.
       * @param {number} stride Stride.
       * @private
       * @return {number} End.
       */
      CanvasPolygonBuilder.prototype.drawFlatCoordinatess_ = function (flatCoordinates, offset, ends, stride) {
          var state = this.state;
          var fill = state.fillStyle !== undefined;
          var stroke = state.strokeStyle !== undefined;
          var numEnds = ends.length;
          this.instructions.push(beginPathInstruction);
          this.hitDetectionInstructions.push(beginPathInstruction);
          for (var i = 0; i < numEnds; ++i) {
              var end = ends[i];
              var myBegin = this.coordinates.length;
              var myEnd = this.appendFlatCoordinates(flatCoordinates, offset, end, stride, true, !stroke);
              var moveToLineToInstruction = [
                  Instruction.MOVE_TO_LINE_TO,
                  myBegin,
                  myEnd,
              ];
              this.instructions.push(moveToLineToInstruction);
              this.hitDetectionInstructions.push(moveToLineToInstruction);
              if (stroke) {
                  // Performance optimization: only call closePath() when we have a stroke.
                  // Otherwise the ring is closed already (see appendFlatCoordinates above).
                  this.instructions.push(closePathInstruction);
                  this.hitDetectionInstructions.push(closePathInstruction);
              }
              offset = end;
          }
          if (fill) {
              this.instructions.push(fillInstruction);
              this.hitDetectionInstructions.push(fillInstruction);
          }
          if (stroke) {
              this.instructions.push(strokeInstruction);
              this.hitDetectionInstructions.push(strokeInstruction);
          }
          return offset;
      };
      /**
       * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
       * @param {import("../../Feature.js").default} feature Feature.
       */
      CanvasPolygonBuilder.prototype.drawCircle = function (circleGeometry, feature) {
          var state = this.state;
          var fillStyle = state.fillStyle;
          var strokeStyle = state.strokeStyle;
          if (fillStyle === undefined && strokeStyle === undefined) {
              return;
          }
          this.setFillStrokeStyles_();
          this.beginGeometry(circleGeometry, feature);
          if (state.fillStyle !== undefined) {
              this.hitDetectionInstructions.push([
                  Instruction.SET_FILL_STYLE,
                  defaultFillStyle,
              ]);
          }
          if (state.strokeStyle !== undefined) {
              this.hitDetectionInstructions.push([
                  Instruction.SET_STROKE_STYLE,
                  state.strokeStyle,
                  state.lineWidth,
                  state.lineCap,
                  state.lineJoin,
                  state.miterLimit,
                  state.lineDash,
                  state.lineDashOffset,
              ]);
          }
          var flatCoordinates = circleGeometry.getFlatCoordinates();
          var stride = circleGeometry.getStride();
          var myBegin = this.coordinates.length;
          this.appendFlatCoordinates(flatCoordinates, 0, flatCoordinates.length, stride, false, false);
          var circleInstruction = [Instruction.CIRCLE, myBegin];
          this.instructions.push(beginPathInstruction, circleInstruction);
          this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);
          if (state.fillStyle !== undefined) {
              this.instructions.push(fillInstruction);
              this.hitDetectionInstructions.push(fillInstruction);
          }
          if (state.strokeStyle !== undefined) {
              this.instructions.push(strokeInstruction);
              this.hitDetectionInstructions.push(strokeInstruction);
          }
          this.endGeometry(feature);
      };
      /**
       * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasPolygonBuilder.prototype.drawPolygon = function (polygonGeometry, feature) {
          var state = this.state;
          var fillStyle = state.fillStyle;
          var strokeStyle = state.strokeStyle;
          if (fillStyle === undefined && strokeStyle === undefined) {
              return;
          }
          this.setFillStrokeStyles_();
          this.beginGeometry(polygonGeometry, feature);
          if (state.fillStyle !== undefined) {
              this.hitDetectionInstructions.push([
                  Instruction.SET_FILL_STYLE,
                  defaultFillStyle,
              ]);
          }
          if (state.strokeStyle !== undefined) {
              this.hitDetectionInstructions.push([
                  Instruction.SET_STROKE_STYLE,
                  state.strokeStyle,
                  state.lineWidth,
                  state.lineCap,
                  state.lineJoin,
                  state.miterLimit,
                  state.lineDash,
                  state.lineDashOffset,
              ]);
          }
          var ends = polygonGeometry.getEnds();
          var flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
          var stride = polygonGeometry.getStride();
          this.drawFlatCoordinatess_(flatCoordinates, 0, 
          /** @type {Array<number>} */ (ends), stride);
          this.endGeometry(feature);
      };
      /**
       * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasPolygonBuilder.prototype.drawMultiPolygon = function (multiPolygonGeometry, feature) {
          var state = this.state;
          var fillStyle = state.fillStyle;
          var strokeStyle = state.strokeStyle;
          if (fillStyle === undefined && strokeStyle === undefined) {
              return;
          }
          this.setFillStrokeStyles_();
          this.beginGeometry(multiPolygonGeometry, feature);
          if (state.fillStyle !== undefined) {
              this.hitDetectionInstructions.push([
                  Instruction.SET_FILL_STYLE,
                  defaultFillStyle,
              ]);
          }
          if (state.strokeStyle !== undefined) {
              this.hitDetectionInstructions.push([
                  Instruction.SET_STROKE_STYLE,
                  state.strokeStyle,
                  state.lineWidth,
                  state.lineCap,
                  state.lineJoin,
                  state.miterLimit,
                  state.lineDash,
                  state.lineDashOffset,
              ]);
          }
          var endss = multiPolygonGeometry.getEndss();
          var flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
          var stride = multiPolygonGeometry.getStride();
          var offset = 0;
          for (var i = 0, ii = endss.length; i < ii; ++i) {
              offset = this.drawFlatCoordinatess_(flatCoordinates, offset, endss[i], stride);
          }
          this.endGeometry(feature);
      };
      /**
       * @return {import("./Builder.js").SerializableInstructions} the serializable instructions.
       */
      CanvasPolygonBuilder.prototype.finish = function () {
          this.reverseHitDetectionInstructions();
          this.state = null;
          // We want to preserve topology when drawing polygons.  Polygons are
          // simplified using quantization and point elimination. However, we might
          // have received a mix of quantized and non-quantized geometries, so ensure
          // that all are quantized by quantizing all coordinates in the batch.
          var tolerance = this.tolerance;
          if (tolerance !== 0) {
              var coordinates = this.coordinates;
              for (var i = 0, ii = coordinates.length; i < ii; ++i) {
                  coordinates[i] = snap(coordinates[i], tolerance);
              }
          }
          return _super.prototype.finish.call(this);
      };
      /**
       * @private
       */
      CanvasPolygonBuilder.prototype.setFillStrokeStyles_ = function () {
          var state = this.state;
          var fillStyle = state.fillStyle;
          if (fillStyle !== undefined) {
              this.updateFillStyle(state, this.createFill);
          }
          if (state.strokeStyle !== undefined) {
              this.updateStrokeStyle(state, this.applyStroke);
          }
      };
      return CanvasPolygonBuilder;
  }(CanvasBuilder));

  /**
   * @module ol/style/TextPlacement
   */
  /**
   * Text placement. One of `'point'`, `'line'`. Default is `'point'`. Note that
   * `'line'` requires the underlying geometry to be a {@link module:ol/geom/LineString~LineString},
   * {@link module:ol/geom/Polygon~Polygon}, {@link module:ol/geom/MultiLineString~MultiLineString} or
   * {@link module:ol/geom/MultiPolygon~MultiPolygon}.
   * @enum {string}
   */
  var TextPlacement = {
      POINT: 'point',
      LINE: 'line',
  };

  /**
   * @module ol/geom/flat/straightchunk
   */
  /**
   * @param {number} maxAngle Maximum acceptable angle delta between segments.
   * @param {Array<number>} flatCoordinates Flat coordinates.
   * @param {number} offset Offset.
   * @param {number} end End.
   * @param {number} stride Stride.
   * @return {Array<number>} Start and end of the first suitable chunk of the
   * given `flatCoordinates`.
   */
  function matchingChunk(maxAngle, flatCoordinates, offset, end, stride) {
      var chunkStart = offset;
      var chunkEnd = offset;
      var chunkM = 0;
      var m = 0;
      var start = offset;
      var acos, i, m12, m23, x1, y1, x12, y12, x23, y23;
      for (i = offset; i < end; i += stride) {
          var x2 = flatCoordinates[i];
          var y2 = flatCoordinates[i + 1];
          if (x1 !== undefined) {
              x23 = x2 - x1;
              y23 = y2 - y1;
              m23 = Math.sqrt(x23 * x23 + y23 * y23);
              if (x12 !== undefined) {
                  m += m12;
                  acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
                  if (acos > maxAngle) {
                      if (m > chunkM) {
                          chunkM = m;
                          chunkStart = start;
                          chunkEnd = i;
                      }
                      m = 0;
                      start = i - stride;
                  }
              }
              m12 = m23;
              x12 = x23;
              y12 = y23;
          }
          x1 = x2;
          y1 = y2;
      }
      m += m23;
      return m > chunkM ? [start, i] : [chunkStart, chunkEnd];
  }

  var __extends$V = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @const
   * @enum {number}
   */
  var TEXT_ALIGN = {
      'left': 0,
      'end': 0,
      'center': 0.5,
      'right': 1,
      'start': 1,
      'top': 0,
      'middle': 0.5,
      'hanging': 0.2,
      'alphabetic': 0.8,
      'ideographic': 0.8,
      'bottom': 1,
  };
  var CanvasTextBuilder = /** @class */ (function (_super) {
      __extends$V(CanvasTextBuilder, _super);
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       */
      function CanvasTextBuilder(tolerance, maxExtent, resolution, pixelRatio) {
          var _this = _super.call(this, tolerance, maxExtent, resolution, pixelRatio) || this;
          /**
           * @private
           * @type {import("../canvas.js").DeclutterGroups}
           */
          _this.declutterGroups_;
          /**
           * @private
           * @type {Array<HTMLCanvasElement>}
           */
          _this.labels_ = null;
          /**
           * @private
           * @type {string}
           */
          _this.text_ = '';
          /**
           * @private
           * @type {number}
           */
          _this.textOffsetX_ = 0;
          /**
           * @private
           * @type {number}
           */
          _this.textOffsetY_ = 0;
          /**
           * @private
           * @type {boolean|undefined}
           */
          _this.textRotateWithView_ = undefined;
          /**
           * @private
           * @type {number}
           */
          _this.textRotation_ = 0;
          /**
           * @private
           * @type {?import("../canvas.js").FillState}
           */
          _this.textFillState_ = null;
          /**
           * @type {!Object<string, import("../canvas.js").FillState>}
           */
          _this.fillStates = {};
          /**
           * @private
           * @type {?import("../canvas.js").StrokeState}
           */
          _this.textStrokeState_ = null;
          /**
           * @type {!Object<string, import("../canvas.js").StrokeState>}
           */
          _this.strokeStates = {};
          /**
           * @private
           * @type {import("../canvas.js").TextState}
           */
          _this.textState_ = /** @type {import("../canvas.js").TextState} */ ({});
          /**
           * @type {!Object<string, import("../canvas.js").TextState>}
           */
          _this.textStates = {};
          /**
           * @private
           * @type {string}
           */
          _this.textKey_ = '';
          /**
           * @private
           * @type {string}
           */
          _this.fillKey_ = '';
          /**
           * @private
           * @type {string}
           */
          _this.strokeKey_ = '';
          return _this;
      }
      /**
       * @return {import("./Builder.js").SerializableInstructions} the serializable instructions.
       */
      CanvasTextBuilder.prototype.finish = function () {
          var instructions = _super.prototype.finish.call(this);
          instructions.textStates = this.textStates;
          instructions.fillStates = this.fillStates;
          instructions.strokeStates = this.strokeStates;
          return instructions;
      };
      /**
       * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       */
      CanvasTextBuilder.prototype.drawText = function (geometry, feature) {
          var fillState = this.textFillState_;
          var strokeState = this.textStrokeState_;
          var textState = this.textState_;
          if (this.text_ === '' || !textState || (!fillState && !strokeState)) {
              return;
          }
          var begin = this.coordinates.length;
          var geometryType = geometry.getType();
          var flatCoordinates = null;
          var end = 2;
          var stride = geometry.getStride();
          var i, ii;
          if (textState.placement === TextPlacement.LINE) {
              if (!intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {
                  return;
              }
              var ends = void 0;
              flatCoordinates = geometry.getFlatCoordinates();
              if (geometryType == GeometryType.LINE_STRING) {
                  ends = [flatCoordinates.length];
              }
              else if (geometryType == GeometryType.MULTI_LINE_STRING) {
                  ends = /** @type {import("../../geom/MultiLineString.js").default} */ (geometry).getEnds();
              }
              else if (geometryType == GeometryType.POLYGON) {
                  ends = /** @type {import("../../geom/Polygon.js").default} */ (geometry)
                      .getEnds()
                      .slice(0, 1);
              }
              else if (geometryType == GeometryType.MULTI_POLYGON) {
                  var endss = /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry).getEndss();
                  ends = [];
                  for (i = 0, ii = endss.length; i < ii; ++i) {
                      ends.push(endss[i][0]);
                  }
              }
              this.beginGeometry(geometry, feature);
              var textAlign = textState.textAlign;
              var flatOffset = 0;
              var flatEnd = void 0;
              for (var o = 0, oo = ends.length; o < oo; ++o) {
                  if (textAlign == undefined) {
                      var range = matchingChunk(textState.maxAngle, flatCoordinates, flatOffset, ends[o], stride);
                      flatOffset = range[0];
                      flatEnd = range[1];
                  }
                  else {
                      flatEnd = ends[o];
                  }
                  for (i = flatOffset; i < flatEnd; i += stride) {
                      this.coordinates.push(flatCoordinates[i], flatCoordinates[i + 1]);
                  }
                  end = this.coordinates.length;
                  flatOffset = ends[o];
                  var declutterGroup = this.declutterGroups_
                      ? o === 0
                          ? this.declutterGroups_[0]
                          : [].concat(this.declutterGroups_[0])
                      : null;
                  this.drawChars_(begin, end, declutterGroup);
                  begin = end;
              }
              this.endGeometry(feature);
          }
          else {
              var geometryWidths = null;
              if (!textState.overflow) {
                  geometryWidths = [];
              }
              switch (geometryType) {
                  case GeometryType.POINT:
                  case GeometryType.MULTI_POINT:
                      flatCoordinates = /** @type {import("../../geom/MultiPoint.js").default} */ (geometry).getFlatCoordinates();
                      end = flatCoordinates.length;
                      break;
                  case GeometryType.LINE_STRING:
                      flatCoordinates = /** @type {import("../../geom/LineString.js").default} */ (geometry).getFlatMidpoint();
                      break;
                  case GeometryType.CIRCLE:
                      flatCoordinates = /** @type {import("../../geom/Circle.js").default} */ (geometry).getCenter();
                      break;
                  case GeometryType.MULTI_LINE_STRING:
                      flatCoordinates = /** @type {import("../../geom/MultiLineString.js").default} */ (geometry).getFlatMidpoints();
                      stride = 2;
                      end = flatCoordinates.length;
                      break;
                  case GeometryType.POLYGON:
                      flatCoordinates = /** @type {import("../../geom/Polygon.js").default} */ (geometry).getFlatInteriorPoint();
                      if (!textState.overflow) {
                          geometryWidths.push(flatCoordinates[2] / this.resolution);
                      }
                      stride = 3;
                      break;
                  case GeometryType.MULTI_POLYGON:
                      var interiorPoints = /** @type {import("../../geom/MultiPolygon.js").default} */ (geometry).getFlatInteriorPoints();
                      flatCoordinates = [];
                      for (i = 0, ii = interiorPoints.length; i < ii; i += 3) {
                          if (!textState.overflow) {
                              geometryWidths.push(interiorPoints[i + 2] / this.resolution);
                          }
                          flatCoordinates.push(interiorPoints[i], interiorPoints[i + 1]);
                      }
                      stride = 2;
                      end = flatCoordinates.length;
                      if (end == 0) {
                          return;
                      }
                      break;
              }
              end = this.appendFlatCoordinates(flatCoordinates, 0, end, stride, false, false);
              this.saveTextStates_();
              if (textState.backgroundFill || textState.backgroundStroke) {
                  this.setFillStrokeStyle(textState.backgroundFill, textState.backgroundStroke);
                  if (textState.backgroundFill) {
                      this.updateFillStyle(this.state, this.createFill);
                      this.hitDetectionInstructions.push(this.createFill(this.state));
                  }
                  if (textState.backgroundStroke) {
                      this.updateStrokeStyle(this.state, this.applyStroke);
                      this.hitDetectionInstructions.push(this.createStroke(this.state));
                  }
              }
              this.beginGeometry(geometry, feature);
              // adjust padding for negative scale
              var padding = textState.padding;
              if (padding != defaultPadding &&
                  (textState.scale[0] < 0 || textState.scale[1] < 0)) {
                  var p0 = textState.padding[0];
                  var p1 = textState.padding[1];
                  var p2 = textState.padding[2];
                  var p3 = textState.padding[3];
                  if (textState.scale[0] < 0) {
                      p1 = -p1;
                      p3 = -p3;
                  }
                  if (textState.scale[1] < 0) {
                      p0 = -p0;
                      p2 = -p2;
                  }
                  padding = [p0, p1, p2, p3];
              }
              // The image is unknown at this stage so we pass null; it will be computed at render time.
              // For clarity, we pass NaN for offsetX, offsetY, width and height, which will be computed at
              // render time.
              var pixelRatio_1 = this.pixelRatio;
              this.instructions.push([
                  Instruction.DRAW_IMAGE,
                  begin,
                  end,
                  null,
                  NaN,
                  NaN,
                  this.declutterGroups_,
                  NaN,
                  1,
                  0,
                  0,
                  this.textRotateWithView_,
                  this.textRotation_,
                  [1, 1],
                  NaN,
                  padding == defaultPadding
                      ? defaultPadding
                      : padding.map(function (p) {
                          return p * pixelRatio_1;
                      }),
                  !!textState.backgroundFill,
                  !!textState.backgroundStroke,
                  this.text_,
                  this.textKey_,
                  this.strokeKey_,
                  this.fillKey_,
                  this.textOffsetX_,
                  this.textOffsetY_,
                  geometryWidths,
              ]);
              var scale = 1 / pixelRatio_1;
              this.hitDetectionInstructions.push([
                  Instruction.DRAW_IMAGE,
                  begin,
                  end,
                  null,
                  NaN,
                  NaN,
                  this.declutterGroups_,
                  NaN,
                  1,
                  0,
                  0,
                  this.textRotateWithView_,
                  this.textRotation_,
                  [scale, scale],
                  NaN,
                  padding,
                  !!textState.backgroundFill,
                  !!textState.backgroundStroke,
                  this.text_,
                  this.textKey_,
                  this.strokeKey_,
                  this.fillKey_,
                  this.textOffsetX_,
                  this.textOffsetY_,
                  geometryWidths,
              ]);
              this.endGeometry(feature);
          }
      };
      /**
       * @private
       */
      CanvasTextBuilder.prototype.saveTextStates_ = function () {
          var strokeState = this.textStrokeState_;
          var textState = this.textState_;
          var fillState = this.textFillState_;
          var strokeKey = this.strokeKey_;
          if (strokeState) {
              if (!(strokeKey in this.strokeStates)) {
                  this.strokeStates[strokeKey] = {
                      strokeStyle: strokeState.strokeStyle,
                      lineCap: strokeState.lineCap,
                      lineDashOffset: strokeState.lineDashOffset,
                      lineWidth: strokeState.lineWidth,
                      lineJoin: strokeState.lineJoin,
                      miterLimit: strokeState.miterLimit,
                      lineDash: strokeState.lineDash,
                  };
              }
          }
          var textKey = this.textKey_;
          if (!(textKey in this.textStates)) {
              this.textStates[textKey] = {
                  font: textState.font,
                  textAlign: textState.textAlign || defaultTextAlign,
                  textBaseline: textState.textBaseline || defaultTextBaseline,
                  scale: textState.scale,
              };
          }
          var fillKey = this.fillKey_;
          if (fillState) {
              if (!(fillKey in this.fillStates)) {
                  this.fillStates[fillKey] = {
                      fillStyle: fillState.fillStyle,
                  };
              }
          }
      };
      /**
       * @private
       * @param {number} begin Begin.
       * @param {number} end End.
       * @param {import("../canvas.js").DeclutterGroup} declutterGroup Declutter group.
       */
      CanvasTextBuilder.prototype.drawChars_ = function (begin, end, declutterGroup) {
          var strokeState = this.textStrokeState_;
          var textState = this.textState_;
          var strokeKey = this.strokeKey_;
          var textKey = this.textKey_;
          var fillKey = this.fillKey_;
          this.saveTextStates_();
          var pixelRatio = this.pixelRatio;
          var baseline = TEXT_ALIGN[textState.textBaseline];
          var offsetY = this.textOffsetY_ * pixelRatio;
          var text = this.text_;
          var strokeWidth = strokeState
              ? (strokeState.lineWidth * Math.abs(textState.scale[0])) / 2
              : 0;
          this.instructions.push([
              Instruction.DRAW_CHARS,
              begin,
              end,
              baseline,
              declutterGroup,
              textState.overflow,
              fillKey,
              textState.maxAngle,
              pixelRatio,
              offsetY,
              strokeKey,
              strokeWidth * pixelRatio,
              text,
              textKey,
              1,
          ]);
          this.hitDetectionInstructions.push([
              Instruction.DRAW_CHARS,
              begin,
              end,
              baseline,
              declutterGroup,
              textState.overflow,
              fillKey,
              textState.maxAngle,
              1,
              offsetY,
              strokeKey,
              strokeWidth,
              text,
              textKey,
              1 / pixelRatio,
          ]);
      };
      /**
       * @param {import("../../style/Text.js").default} textStyle Text style.
       * @param {import("../canvas.js").DeclutterGroups} declutterGroups Declutter.
       */
      CanvasTextBuilder.prototype.setTextStyle = function (textStyle, declutterGroups) {
          var textState, fillState, strokeState;
          if (!textStyle) {
              this.text_ = '';
          }
          else {
              this.declutterGroups_ = declutterGroups;
              var textFillStyle = textStyle.getFill();
              if (!textFillStyle) {
                  fillState = null;
                  this.textFillState_ = fillState;
              }
              else {
                  fillState = this.textFillState_;
                  if (!fillState) {
                      fillState = /** @type {import("../canvas.js").FillState} */ ({});
                      this.textFillState_ = fillState;
                  }
                  fillState.fillStyle = asColorLike(textFillStyle.getColor() || defaultFillStyle);
              }
              var textStrokeStyle = textStyle.getStroke();
              if (!textStrokeStyle) {
                  strokeState = null;
                  this.textStrokeState_ = strokeState;
              }
              else {
                  strokeState = this.textStrokeState_;
                  if (!strokeState) {
                      strokeState = /** @type {import("../canvas.js").StrokeState} */ ({});
                      this.textStrokeState_ = strokeState;
                  }
                  var lineDash = textStrokeStyle.getLineDash();
                  var lineDashOffset = textStrokeStyle.getLineDashOffset();
                  var lineWidth = textStrokeStyle.getWidth();
                  var miterLimit = textStrokeStyle.getMiterLimit();
                  strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;
                  strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;
                  strokeState.lineDashOffset =
                      lineDashOffset === undefined ? defaultLineDashOffset : lineDashOffset;
                  strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;
                  strokeState.lineWidth =
                      lineWidth === undefined ? defaultLineWidth : lineWidth;
                  strokeState.miterLimit =
                      miterLimit === undefined ? defaultMiterLimit : miterLimit;
                  strokeState.strokeStyle = asColorLike(textStrokeStyle.getColor() || defaultStrokeStyle);
              }
              textState = this.textState_;
              var font = textStyle.getFont() || defaultFont;
              registerFont(font);
              var textScale = textStyle.getScaleArray();
              textState.overflow = textStyle.getOverflow();
              textState.font = font;
              textState.maxAngle = textStyle.getMaxAngle();
              textState.placement = textStyle.getPlacement();
              textState.textAlign = textStyle.getTextAlign();
              textState.textBaseline =
                  textStyle.getTextBaseline() || defaultTextBaseline;
              textState.backgroundFill = textStyle.getBackgroundFill();
              textState.backgroundStroke = textStyle.getBackgroundStroke();
              textState.padding = textStyle.getPadding() || defaultPadding;
              textState.scale = textScale === undefined ? [1, 1] : textScale;
              var textOffsetX = textStyle.getOffsetX();
              var textOffsetY = textStyle.getOffsetY();
              var textRotateWithView = textStyle.getRotateWithView();
              var textRotation = textStyle.getRotation();
              this.text_ = textStyle.getText() || '';
              this.textOffsetX_ = textOffsetX === undefined ? 0 : textOffsetX;
              this.textOffsetY_ = textOffsetY === undefined ? 0 : textOffsetY;
              this.textRotateWithView_ =
                  textRotateWithView === undefined ? false : textRotateWithView;
              this.textRotation_ = textRotation === undefined ? 0 : textRotation;
              this.strokeKey_ = strokeState
                  ? (typeof strokeState.strokeStyle == 'string'
                      ? strokeState.strokeStyle
                      : getUid(strokeState.strokeStyle)) +
                      strokeState.lineCap +
                      strokeState.lineDashOffset +
                      '|' +
                      strokeState.lineWidth +
                      strokeState.lineJoin +
                      strokeState.miterLimit +
                      '[' +
                      strokeState.lineDash.join() +
                      ']'
                  : '';
              this.textKey_ =
                  textState.font +
                      textState.scale +
                      (textState.textAlign || '?') +
                      (textState.textBaseline || '?');
              this.fillKey_ = fillState
                  ? typeof fillState.fillStyle == 'string'
                      ? fillState.fillStyle
                      : '|' + getUid(fillState.fillStyle)
                  : '';
          }
      };
      return CanvasTextBuilder;
  }(CanvasBuilder));

  /**
   * @module ol/render/canvas/BuilderGroup
   */
  /**
   * @type {Object<import("./BuilderType").default, typeof Builder>}
   */
  var BATCH_CONSTRUCTORS = {
      'Circle': CanvasPolygonBuilder,
      'Default': CanvasBuilder,
      'Image': CanvasImageBuilder,
      'LineString': CanvasLineStringBuilder,
      'Polygon': CanvasPolygonBuilder,
      'Text': CanvasTextBuilder,
  };
  var BuilderGroup = /** @class */ (function () {
      /**
       * @param {number} tolerance Tolerance.
       * @param {import("../../extent.js").Extent} maxExtent Max extent.
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {boolean} declutter Decluttering enabled.
       */
      function BuilderGroup(tolerance, maxExtent, resolution, pixelRatio, declutter) {
          /**
           * @type {boolean}
           * @private
           */
          this.declutter_ = declutter;
          /**
           * @type {import("../canvas.js").DeclutterGroups}
           * @private
           */
          this.declutterGroups_ = null;
          /**
           * @private
           * @type {number}
           */
          this.tolerance_ = tolerance;
          /**
           * @private
           * @type {import("../../extent.js").Extent}
           */
          this.maxExtent_ = maxExtent;
          /**
           * @private
           * @type {number}
           */
          this.pixelRatio_ = pixelRatio;
          /**
           * @private
           * @type {number}
           */
          this.resolution_ = resolution;
          /**
           * @private
           * @type {!Object<string, !Object<import("./BuilderType").default, Builder>>}
           */
          this.buildersByZIndex_ = {};
      }
      /**
       * @param {boolean} group Group with previous builder.
       * @return {import("../canvas").DeclutterGroups} The resulting instruction groups.
       */
      BuilderGroup.prototype.addDeclutter = function (group) {
          /** @type {Array<*>} */
          var declutter = null;
          if (this.declutter_) {
              if (group) {
                  declutter = this.declutterGroups_;
                  /** @type {number} */ (declutter[0][0])++;
              }
              else {
                  declutter = [[1]];
                  this.declutterGroups_ = declutter;
              }
          }
          return declutter;
      };
      /**
       * @return {!Object<string, !Object<import("./BuilderType").default, import("./Builder.js").SerializableInstructions>>} The serializable instructions
       */
      BuilderGroup.prototype.finish = function () {
          var builderInstructions = {};
          for (var zKey in this.buildersByZIndex_) {
              builderInstructions[zKey] = builderInstructions[zKey] || {};
              var builders = this.buildersByZIndex_[zKey];
              for (var builderKey in builders) {
                  var builderInstruction = builders[builderKey].finish();
                  builderInstructions[zKey][builderKey] = builderInstruction;
              }
          }
          return builderInstructions;
      };
      /**
       * @param {number|undefined} zIndex Z index.
       * @param {import("./BuilderType.js").default} builderType Replay type.
       * @return {import("../VectorContext.js").default} Replay.
       */
      BuilderGroup.prototype.getBuilder = function (zIndex, builderType) {
          var zIndexKey = zIndex !== undefined ? zIndex.toString() : '0';
          var replays = this.buildersByZIndex_[zIndexKey];
          if (replays === undefined) {
              replays = {};
              this.buildersByZIndex_[zIndexKey] = replays;
          }
          var replay = replays[builderType];
          if (replay === undefined) {
              var Constructor = BATCH_CONSTRUCTORS[builderType];
              replay = new Constructor(this.tolerance_, this.maxExtent_, this.resolution_, this.pixelRatio_);
              replays[builderType] = replay;
          }
          return replay;
      };
      return BuilderGroup;
  }());

  var __extends$W = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @template {import("../layer/Layer.js").default} LayerType
   */
  var LayerRenderer = /** @class */ (function (_super) {
      __extends$W(LayerRenderer, _super);
      /**
       * @param {LayerType} layer Layer.
       */
      function LayerRenderer(layer) {
          var _this = _super.call(this) || this;
          /** @private */
          _this.boundHandleImageChange_ = _this.handleImageChange_.bind(_this);
          /**
           * @protected
           * @type {LayerType}
           */
          _this.layer_ = layer;
          return _this;
      }
      /**
       * Asynchronous layer level hit detection.
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @return {Promise<Array<import("../Feature").default>>} Promise that resolves with
       * an array of features.
       */
      LayerRenderer.prototype.getFeatures = function (pixel) {
          return abstract();
      };
      /**
       * Determine whether render should be called.
       * @abstract
       * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
       * @return {boolean} Layer is ready to be rendered.
       */
      LayerRenderer.prototype.prepareFrame = function (frameState) {
          return abstract();
      };
      /**
       * Render the layer.
       * @abstract
       * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
       * @param {HTMLElement} target Target that may be used to render content to.
       * @return {HTMLElement} The rendered element.
       */
      LayerRenderer.prototype.renderFrame = function (frameState, target) {
          return abstract();
      };
      /**
       * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
       * @param {number} zoom Zoom level.
       * @param {import("../Tile.js").default} tile Tile.
       * @return {boolean|void} If `false`, the tile will not be considered loaded.
       */
      LayerRenderer.prototype.loadedTileCallback = function (tiles, zoom, tile) {
          if (!tiles[zoom]) {
              tiles[zoom] = {};
          }
          tiles[zoom][tile.tileCoord.toString()] = tile;
          return undefined;
      };
      /**
       * Create a function that adds loaded tiles to the tile lookup.
       * @param {import("../source/Tile.js").default} source Tile source.
       * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
       * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
       * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
       *     called with a zoom level and a tile range to add loaded tiles to the lookup.
       * @protected
       */
      LayerRenderer.prototype.createLoadedTileFinder = function (source, projection, tiles) {
          return (
          /**
           * @param {number} zoom Zoom level.
           * @param {import("../TileRange.js").default} tileRange Tile range.
           * @return {boolean} The tile range is fully loaded.
           * @this {LayerRenderer}
           */
          function (zoom, tileRange) {
              var callback = this.loadedTileCallback.bind(this, tiles, zoom);
              return source.forEachLoadedTile(projection, zoom, tileRange, callback);
          }.bind(this));
      };
      /**
       * @abstract
       * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {import("../PluggableMap.js").FrameState} frameState Frame state.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {function(import("../Feature.js").FeatureLike, import("../layer/Layer.js").default): T} callback Feature callback.
       * @param {Array<import("../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
       * @return {T|void} Callback result.
       * @template T
       */
      LayerRenderer.prototype.forEachFeatureAtCoordinate = function (coordinate, frameState, hitTolerance, callback, declutteredFeatures) { };
      /**
       * @abstract
       * @param {import("../pixel.js").Pixel} pixel Pixel.
       * @param {import("../PluggableMap.js").FrameState} frameState FrameState.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel
       *    location, null will be returned.  If there is data, but pixel values cannot be
       *    returned, and empty array will be returned.
       */
      LayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {
          return abstract();
      };
      /**
       * @return {LayerType} Layer.
       */
      LayerRenderer.prototype.getLayer = function () {
          return this.layer_;
      };
      /**
       * Perform action necessary to get the layer rendered after new fonts have loaded
       * @abstract
       */
      LayerRenderer.prototype.handleFontsChanged = function () { };
      /**
       * Handle changes in image state.
       * @param {import("../events/Event.js").default} event Image change event.
       * @private
       */
      LayerRenderer.prototype.handleImageChange_ = function (event) {
          var image = /** @type {import("../Image.js").default} */ (event.target);
          if (image.getState() === ImageState.LOADED) {
              this.renderIfReadyAndVisible();
          }
      };
      /**
       * Load the image if not already loaded, and register the image change
       * listener if needed.
       * @param {import("../ImageBase.js").default} image Image.
       * @return {boolean} `true` if the image is already loaded, `false` otherwise.
       * @protected
       */
      LayerRenderer.prototype.loadImage = function (image) {
          var imageState = image.getState();
          if (imageState != ImageState.LOADED && imageState != ImageState.ERROR) {
              image.addEventListener(EventType.CHANGE, this.boundHandleImageChange_);
          }
          if (imageState == ImageState.IDLE) {
              image.load();
              imageState = image.getState();
          }
          return imageState == ImageState.LOADED;
      };
      /**
       * @protected
       */
      LayerRenderer.prototype.renderIfReadyAndVisible = function () {
          var layer = this.getLayer();
          if (layer.getVisible() && layer.getSourceState() == SourceState.READY) {
              layer.changed();
          }
      };
      return LayerRenderer;
  }(Observable));

  var __extends$X = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @abstract
   * @template {import("../../layer/Layer.js").default} LayerType
   */
  var CanvasLayerRenderer = /** @class */ (function (_super) {
      __extends$X(CanvasLayerRenderer, _super);
      /**
       * @param {LayerType} layer Layer.
       */
      function CanvasLayerRenderer(layer) {
          var _this = _super.call(this, layer) || this;
          /**
           * @protected
           * @type {HTMLElement}
           */
          _this.container = null;
          /**
           * @protected
           * @type {number}
           */
          _this.renderedResolution;
          /**
           * A temporary transform.  The values in this transform should only be used in a
           * function that sets the values.
           * @protected
           * @type {import("../../transform.js").Transform}
           */
          _this.tempTransform = create();
          /**
           * The transform for rendered pixels to viewport CSS pixels.  This transform must
           * be set when rendering a frame and may be used by other functions after rendering.
           * @protected
           * @type {import("../../transform.js").Transform}
           */
          _this.pixelTransform = create();
          /**
           * The transform for viewport CSS pixels to rendered pixels.  This transform must
           * be set when rendering a frame and may be used by other functions after rendering.
           * @protected
           * @type {import("../../transform.js").Transform}
           */
          _this.inversePixelTransform = create();
          /**
           * @type {CanvasRenderingContext2D}
           */
          _this.context = null;
          /**
           * @type {boolean}
           */
          _this.containerReused = false;
          return _this;
      }
      /**
       * Get a rendering container from an existing target, if compatible.
       * @param {HTMLElement} target Potential render target.
       * @param {string} transform CSS Transform.
       * @param {number} opacity Opacity.
       */
      CanvasLayerRenderer.prototype.useContainer = function (target, transform, opacity) {
          var layerClassName = this.getLayer().getClassName();
          var container, context;
          if (target &&
              target.style.opacity === '' &&
              target.className === layerClassName) {
              var canvas = target.firstElementChild;
              if (canvas instanceof HTMLCanvasElement) {
                  context = canvas.getContext('2d');
              }
          }
          if (context &&
              (context.canvas.width === 0 ||
                  context.canvas.style.transform === transform)) {
              // Container of the previous layer renderer can be used.
              this.container = target;
              this.context = context;
              this.containerReused = true;
          }
          else if (this.containerReused) {
              // Previously reused container cannot be used any more.
              this.container = null;
              this.context = null;
              this.containerReused = false;
          }
          if (!this.container) {
              container = document.createElement('div');
              container.className = layerClassName;
              var style = container.style;
              style.position = 'absolute';
              style.width = '100%';
              style.height = '100%';
              context = createCanvasContext2D();
              var canvas = context.canvas;
              container.appendChild(canvas);
              style = canvas.style;
              style.position = 'absolute';
              style.left = '0';
              style.transformOrigin = 'top left';
              this.container = container;
              this.context = context;
          }
      };
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @param {import("../../extent.js").Extent} extent Clip extent.
       * @protected
       */
      CanvasLayerRenderer.prototype.clip = function (context, frameState, extent) {
          var pixelRatio = frameState.pixelRatio;
          var halfWidth = (frameState.size[0] * pixelRatio) / 2;
          var halfHeight = (frameState.size[1] * pixelRatio) / 2;
          var rotation = frameState.viewState.rotation;
          var topLeft = getTopLeft(extent);
          var topRight = getTopRight(extent);
          var bottomRight = getBottomRight(extent);
          var bottomLeft = getBottomLeft(extent);
          apply(frameState.coordinateToPixelTransform, topLeft);
          apply(frameState.coordinateToPixelTransform, topRight);
          apply(frameState.coordinateToPixelTransform, bottomRight);
          apply(frameState.coordinateToPixelTransform, bottomLeft);
          context.save();
          rotateAtOffset(context, -rotation, halfWidth, halfHeight);
          context.beginPath();
          context.moveTo(topLeft[0] * pixelRatio, topLeft[1] * pixelRatio);
          context.lineTo(topRight[0] * pixelRatio, topRight[1] * pixelRatio);
          context.lineTo(bottomRight[0] * pixelRatio, bottomRight[1] * pixelRatio);
          context.lineTo(bottomLeft[0] * pixelRatio, bottomLeft[1] * pixelRatio);
          context.clip();
          rotateAtOffset(context, rotation, halfWidth, halfHeight);
      };
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @param {import("../../extent.js").Extent} extent Clip extent.
       * @protected
       */
      CanvasLayerRenderer.prototype.clipUnrotated = function (context, frameState, extent) {
          var topLeft = getTopLeft(extent);
          var topRight = getTopRight(extent);
          var bottomRight = getBottomRight(extent);
          var bottomLeft = getBottomLeft(extent);
          apply(frameState.coordinateToPixelTransform, topLeft);
          apply(frameState.coordinateToPixelTransform, topRight);
          apply(frameState.coordinateToPixelTransform, bottomRight);
          apply(frameState.coordinateToPixelTransform, bottomLeft);
          var inverted = this.inversePixelTransform;
          apply(inverted, topLeft);
          apply(inverted, topRight);
          apply(inverted, bottomRight);
          apply(inverted, bottomLeft);
          context.save();
          context.beginPath();
          context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
          context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
          context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
          context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
          context.clip();
      };
      /**
       * @param {import("../../render/EventType.js").default} type Event type.
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @private
       */
      CanvasLayerRenderer.prototype.dispatchRenderEvent_ = function (type, context, frameState) {
          var layer = this.getLayer();
          if (layer.hasListener(type)) {
              var event_1 = new RenderEvent(type, this.inversePixelTransform, frameState, context);
              layer.dispatchEvent(event_1);
          }
      };
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @protected
       */
      CanvasLayerRenderer.prototype.preRender = function (context, frameState) {
          this.dispatchRenderEvent_(EventType$1.PRERENDER, context, frameState);
      };
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../PluggableMap.js").FrameState} frameState Frame state.
       * @protected
       */
      CanvasLayerRenderer.prototype.postRender = function (context, frameState) {
          this.dispatchRenderEvent_(EventType$1.POSTRENDER, context, frameState);
      };
      /**
       * Creates a transform for rendering to an element that will be rotated after rendering.
       * @param {import("../../coordinate.js").Coordinate} center Center.
       * @param {number} resolution Resolution.
       * @param {number} rotation Rotation.
       * @param {number} pixelRatio Pixel ratio.
       * @param {number} width Width of the rendered element (in pixels).
       * @param {number} height Height of the rendered element (in pixels).
       * @param {number} offsetX Offset on the x-axis in view coordinates.
       * @protected
       * @return {!import("../../transform.js").Transform} Transform.
       */
      CanvasLayerRenderer.prototype.getRenderTransform = function (center, resolution, rotation, pixelRatio, width, height, offsetX) {
          var dx1 = width / 2;
          var dy1 = height / 2;
          var sx = pixelRatio / resolution;
          var sy = -sx;
          var dx2 = -center[0] + offsetX;
          var dy2 = -center[1];
          return compose(this.tempTransform, dx1, dy1, sx, sy, -rotation, dx2, dy2);
      };
      /**
       * @param {import("../../pixel.js").Pixel} pixel Pixel.
       * @param {import("../../PluggableMap.js").FrameState} frameState FrameState.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @return {Uint8ClampedArray|Uint8Array} The result.  If there is no data at the pixel
       *    location, null will be returned.  If there is data, but pixel values cannot be
       *    returned, and empty array will be returned.
       */
      CanvasLayerRenderer.prototype.getDataAtPixel = function (pixel, frameState, hitTolerance) {
          var renderPixel = apply(this.inversePixelTransform, pixel.slice());
          var context = this.context;
          var data;
          try {
              var x = Math.round(renderPixel[0]);
              var y = Math.round(renderPixel[1]);
              var newCanvas = document.createElement('canvas');
              var newContext = newCanvas.getContext('2d');
              newCanvas.width = 1;
              newCanvas.height = 1;
              newContext.clearRect(0, 0, 1, 1);
              newContext.drawImage(context.canvas, x, y, 1, 1, 0, 0, 1, 1);
              data = newContext.getImageData(0, 0, 1, 1).data;
          }
          catch (err) {
              if (err.name === 'SecurityError') {
                  // tainted canvas, we assume there is data at the given pixel (although there might not be)
                  return new Uint8Array();
              }
              return data;
          }
          if (data[3] === 0) {
              return null;
          }
          return data;
      };
      return CanvasLayerRenderer;
  }(LayerRenderer));

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, basedir, module) {
  	return module = {
  		path: basedir,
  		exports: {},
  		require: function (path, base) {
  			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
  		}
  	}, fn(module, module.exports), module.exports;
  }

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  var rbush = createCommonjsModule(function (module, exports) {
  (function (global, factory) {
   module.exports = factory() ;
  }(commonjsGlobal, function () {
  function quickselect(arr, k, left, right, compare) {
      quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
  }

  function quickselectStep(arr, k, left, right, compare) {

      while (right > left) {
          if (right - left > 600) {
              var n = right - left + 1;
              var m = k - left + 1;
              var z = Math.log(n);
              var s = 0.5 * Math.exp(2 * z / 3);
              var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
              var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
              var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
              quickselectStep(arr, k, newLeft, newRight, compare);
          }

          var t = arr[k];
          var i = left;
          var j = right;

          swap(arr, left, k);
          if (compare(arr[right], t) > 0) { swap(arr, left, right); }

          while (i < j) {
              swap(arr, i, j);
              i++;
              j--;
              while (compare(arr[i], t) < 0) { i++; }
              while (compare(arr[j], t) > 0) { j--; }
          }

          if (compare(arr[left], t) === 0) { swap(arr, left, j); }
          else {
              j++;
              swap(arr, j, right);
          }

          if (j <= k) { left = j + 1; }
          if (k <= j) { right = j - 1; }
      }
  }

  function swap(arr, i, j) {
      var tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
  }

  function defaultCompare(a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
  }

  var RBush = function RBush(maxEntries) {
      if ( maxEntries === void 0 ) maxEntries = 9;

      // max entries in a node is 9 by default; min node fill is 40% for best performance
      this._maxEntries = Math.max(4, maxEntries);
      this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));
      this.clear();
  };

  RBush.prototype.all = function all () {
      return this._all(this.data, []);
  };

  RBush.prototype.search = function search (bbox) {
      var node = this.data;
      var result = [];

      if (!intersects(bbox, node)) { return result; }

      var toBBox = this.toBBox;
      var nodesToSearch = [];

      while (node) {
          for (var i = 0; i < node.children.length; i++) {
              var child = node.children[i];
              var childBBox = node.leaf ? toBBox(child) : child;

              if (intersects(bbox, childBBox)) {
                  if (node.leaf) { result.push(child); }
                  else if (contains(bbox, childBBox)) { this._all(child, result); }
                  else { nodesToSearch.push(child); }
              }
          }
          node = nodesToSearch.pop();
      }

      return result;
  };

  RBush.prototype.collides = function collides (bbox) {
      var node = this.data;

      if (!intersects(bbox, node)) { return false; }

      var nodesToSearch = [];
      while (node) {
          for (var i = 0; i < node.children.length; i++) {
              var child = node.children[i];
              var childBBox = node.leaf ? this.toBBox(child) : child;

              if (intersects(bbox, childBBox)) {
                  if (node.leaf || contains(bbox, childBBox)) { return true; }
                  nodesToSearch.push(child);
              }
          }
          node = nodesToSearch.pop();
      }

      return false;
  };

  RBush.prototype.load = function load (data) {
      if (!(data && data.length)) { return this; }

      if (data.length < this._minEntries) {
          for (var i = 0; i < data.length; i++) {
              this.insert(data[i]);
          }
          return this;
      }

      // recursively build the tree with the given data from scratch using OMT algorithm
      var node = this._build(data.slice(), 0, data.length - 1, 0);

      if (!this.data.children.length) {
          // save as is if tree is empty
          this.data = node;

      } else if (this.data.height === node.height) {
          // split root if trees have the same height
          this._splitRoot(this.data, node);

      } else {
          if (this.data.height < node.height) {
              // swap trees if inserted one is bigger
              var tmpNode = this.data;
              this.data = node;
              node = tmpNode;
          }

          // insert the small tree into the large tree at appropriate level
          this._insert(node, this.data.height - node.height - 1, true);
      }

      return this;
  };

  RBush.prototype.insert = function insert (item) {
      if (item) { this._insert(item, this.data.height - 1); }
      return this;
  };

  RBush.prototype.clear = function clear () {
      this.data = createNode([]);
      return this;
  };

  RBush.prototype.remove = function remove (item, equalsFn) {
      if (!item) { return this; }

      var node = this.data;
      var bbox = this.toBBox(item);
      var path = [];
      var indexes = [];
      var i, parent, goingUp;

      // depth-first iterative tree traversal
      while (node || path.length) {

          if (!node) { // go up
              node = path.pop();
              parent = path[path.length - 1];
              i = indexes.pop();
              goingUp = true;
          }

          if (node.leaf) { // check current node
              var index = findItem(item, node.children, equalsFn);

              if (index !== -1) {
                  // item found, remove the item and condense tree upwards
                  node.children.splice(index, 1);
                  path.push(node);
                  this._condense(path);
                  return this;
              }
          }

          if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
              path.push(node);
              indexes.push(i);
              i = 0;
              parent = node;
              node = node.children[0];

          } else if (parent) { // go right
              i++;
              node = parent.children[i];
              goingUp = false;

          } else { node = null; } // nothing found
      }

      return this;
  };

  RBush.prototype.toBBox = function toBBox (item) { return item; };

  RBush.prototype.compareMinX = function compareMinX (a, b) { return a.minX - b.minX; };
  RBush.prototype.compareMinY = function compareMinY (a, b) { return a.minY - b.minY; };

  RBush.prototype.toJSON = function toJSON () { return this.data; };

  RBush.prototype.fromJSON = function fromJSON (data) {
      this.data = data;
      return this;
  };

  RBush.prototype._all = function _all (node, result) {
      var nodesToSearch = [];
      while (node) {
          if (node.leaf) { result.push.apply(result, node.children); }
          else { nodesToSearch.push.apply(nodesToSearch, node.children); }

          node = nodesToSearch.pop();
      }
      return result;
  };

  RBush.prototype._build = function _build (items, left, right, height) {

      var N = right - left + 1;
      var M = this._maxEntries;
      var node;

      if (N <= M) {
          // reached leaf level; return leaf
          node = createNode(items.slice(left, right + 1));
          calcBBox(node, this.toBBox);
          return node;
      }

      if (!height) {
          // target height of the bulk-loaded tree
          height = Math.ceil(Math.log(N) / Math.log(M));

          // target number of root entries to maximize storage utilization
          M = Math.ceil(N / Math.pow(M, height - 1));
      }

      node = createNode([]);
      node.leaf = false;
      node.height = height;

      // split the items into M mostly square tiles

      var N2 = Math.ceil(N / M);
      var N1 = N2 * Math.ceil(Math.sqrt(M));

      multiSelect(items, left, right, N1, this.compareMinX);

      for (var i = left; i <= right; i += N1) {

          var right2 = Math.min(i + N1 - 1, right);

          multiSelect(items, i, right2, N2, this.compareMinY);

          for (var j = i; j <= right2; j += N2) {

              var right3 = Math.min(j + N2 - 1, right2);

              // pack each entry recursively
              node.children.push(this._build(items, j, right3, height - 1));
          }
      }

      calcBBox(node, this.toBBox);

      return node;
  };

  RBush.prototype._chooseSubtree = function _chooseSubtree (bbox, node, level, path) {
      while (true) {
          path.push(node);

          if (node.leaf || path.length - 1 === level) { break; }

          var minArea = Infinity;
          var minEnlargement = Infinity;
          var targetNode = (void 0);

          for (var i = 0; i < node.children.length; i++) {
              var child = node.children[i];
              var area = bboxArea(child);
              var enlargement = enlargedArea(bbox, child) - area;

              // choose entry with the least area enlargement
              if (enlargement < minEnlargement) {
                  minEnlargement = enlargement;
                  minArea = area < minArea ? area : minArea;
                  targetNode = child;

              } else if (enlargement === minEnlargement) {
                  // otherwise choose one with the smallest area
                  if (area < minArea) {
                      minArea = area;
                      targetNode = child;
                  }
              }
          }

          node = targetNode || node.children[0];
      }

      return node;
  };

  RBush.prototype._insert = function _insert (item, level, isNode) {
      var bbox = isNode ? item : this.toBBox(item);
      var insertPath = [];

      // find the best node for accommodating the item, saving all nodes along the path too
      var node = this._chooseSubtree(bbox, this.data, level, insertPath);

      // put the item into the node
      node.children.push(item);
      extend(node, bbox);

      // split on node overflow; propagate upwards if necessary
      while (level >= 0) {
          if (insertPath[level].children.length > this._maxEntries) {
              this._split(insertPath, level);
              level--;
          } else { break; }
      }

      // adjust bboxes along the insertion path
      this._adjustParentBBoxes(bbox, insertPath, level);
  };

  // split overflowed node into two
  RBush.prototype._split = function _split (insertPath, level) {
      var node = insertPath[level];
      var M = node.children.length;
      var m = this._minEntries;

      this._chooseSplitAxis(node, m, M);

      var splitIndex = this._chooseSplitIndex(node, m, M);

      var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
      newNode.height = node.height;
      newNode.leaf = node.leaf;

      calcBBox(node, this.toBBox);
      calcBBox(newNode, this.toBBox);

      if (level) { insertPath[level - 1].children.push(newNode); }
      else { this._splitRoot(node, newNode); }
  };

  RBush.prototype._splitRoot = function _splitRoot (node, newNode) {
      // split root node
      this.data = createNode([node, newNode]);
      this.data.height = node.height + 1;
      this.data.leaf = false;
      calcBBox(this.data, this.toBBox);
  };

  RBush.prototype._chooseSplitIndex = function _chooseSplitIndex (node, m, M) {
      var index;
      var minOverlap = Infinity;
      var minArea = Infinity;

      for (var i = m; i <= M - m; i++) {
          var bbox1 = distBBox(node, 0, i, this.toBBox);
          var bbox2 = distBBox(node, i, M, this.toBBox);

          var overlap = intersectionArea(bbox1, bbox2);
          var area = bboxArea(bbox1) + bboxArea(bbox2);

          // choose distribution with minimum overlap
          if (overlap < minOverlap) {
              minOverlap = overlap;
              index = i;

              minArea = area < minArea ? area : minArea;

          } else if (overlap === minOverlap) {
              // otherwise choose distribution with minimum area
              if (area < minArea) {
                  minArea = area;
                  index = i;
              }
          }
      }

      return index || M - m;
  };

  // sorts node children by the best axis for split
  RBush.prototype._chooseSplitAxis = function _chooseSplitAxis (node, m, M) {
      var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX;
      var compareMinY = node.leaf ? this.compareMinY : compareNodeMinY;
      var xMargin = this._allDistMargin(node, m, M, compareMinX);
      var yMargin = this._allDistMargin(node, m, M, compareMinY);

      // if total distributions margin value is minimal for x, sort by minX,
      // otherwise it's already sorted by minY
      if (xMargin < yMargin) { node.children.sort(compareMinX); }
  };

  // total margin of all possible split distributions where each node is at least m full
  RBush.prototype._allDistMargin = function _allDistMargin (node, m, M, compare) {
      node.children.sort(compare);

      var toBBox = this.toBBox;
      var leftBBox = distBBox(node, 0, m, toBBox);
      var rightBBox = distBBox(node, M - m, M, toBBox);
      var margin = bboxMargin(leftBBox) + bboxMargin(rightBBox);

      for (var i = m; i < M - m; i++) {
          var child = node.children[i];
          extend(leftBBox, node.leaf ? toBBox(child) : child);
          margin += bboxMargin(leftBBox);
      }

      for (var i$1 = M - m - 1; i$1 >= m; i$1--) {
          var child$1 = node.children[i$1];
          extend(rightBBox, node.leaf ? toBBox(child$1) : child$1);
          margin += bboxMargin(rightBBox);
      }

      return margin;
  };

  RBush.prototype._adjustParentBBoxes = function _adjustParentBBoxes (bbox, path, level) {
      // adjust bboxes along the given tree path
      for (var i = level; i >= 0; i--) {
          extend(path[i], bbox);
      }
  };

  RBush.prototype._condense = function _condense (path) {
      // go through the path, removing empty nodes and updating bboxes
      for (var i = path.length - 1, siblings = (void 0); i >= 0; i--) {
          if (path[i].children.length === 0) {
              if (i > 0) {
                  siblings = path[i - 1].children;
                  siblings.splice(siblings.indexOf(path[i]), 1);

              } else { this.clear(); }

          } else { calcBBox(path[i], this.toBBox); }
      }
  };

  function findItem(item, items, equalsFn) {
      if (!equalsFn) { return items.indexOf(item); }

      for (var i = 0; i < items.length; i++) {
          if (equalsFn(item, items[i])) { return i; }
      }
      return -1;
  }

  // calculate node's bbox from bboxes of its children
  function calcBBox(node, toBBox) {
      distBBox(node, 0, node.children.length, toBBox, node);
  }

  // min bounding rectangle of node children from k to p-1
  function distBBox(node, k, p, toBBox, destNode) {
      if (!destNode) { destNode = createNode(null); }
      destNode.minX = Infinity;
      destNode.minY = Infinity;
      destNode.maxX = -Infinity;
      destNode.maxY = -Infinity;

      for (var i = k; i < p; i++) {
          var child = node.children[i];
          extend(destNode, node.leaf ? toBBox(child) : child);
      }

      return destNode;
  }

  function extend(a, b) {
      a.minX = Math.min(a.minX, b.minX);
      a.minY = Math.min(a.minY, b.minY);
      a.maxX = Math.max(a.maxX, b.maxX);
      a.maxY = Math.max(a.maxY, b.maxY);
      return a;
  }

  function compareNodeMinX(a, b) { return a.minX - b.minX; }
  function compareNodeMinY(a, b) { return a.minY - b.minY; }

  function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
  function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

  function enlargedArea(a, b) {
      return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
             (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
  }

  function intersectionArea(a, b) {
      var minX = Math.max(a.minX, b.minX);
      var minY = Math.max(a.minY, b.minY);
      var maxX = Math.min(a.maxX, b.maxX);
      var maxY = Math.min(a.maxY, b.maxY);

      return Math.max(0, maxX - minX) *
             Math.max(0, maxY - minY);
  }

  function contains(a, b) {
      return a.minX <= b.minX &&
             a.minY <= b.minY &&
             b.maxX <= a.maxX &&
             b.maxY <= a.maxY;
  }

  function intersects(a, b) {
      return b.minX <= a.maxX &&
             b.minY <= a.maxY &&
             b.maxX >= a.minX &&
             b.maxY >= a.minY;
  }

  function createNode(children) {
      return {
          children: children,
          height: 1,
          leaf: true,
          minX: Infinity,
          minY: Infinity,
          maxX: -Infinity,
          maxY: -Infinity
      };
  }

  // sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
  // combines selection algorithm with binary divide & conquer approach

  function multiSelect(arr, left, right, n, compare) {
      var stack = [left, right];

      while (stack.length) {
          right = stack.pop();
          left = stack.pop();

          if (right - left <= n) { continue; }

          var mid = left + Math.ceil((right - left) / n / 2) * n;
          quickselect(arr, mid, left, right, compare);

          stack.push(left, mid, mid, right);
      }
  }

  return RBush;

  }));
  });

  /**
   * @module ol/geom/flat/textpath
   */
  /**
   * @param {Array<number>} flatCoordinates Path to put text on.
   * @param {number} offset Start offset of the `flatCoordinates`.
   * @param {number} end End offset of the `flatCoordinates`.
   * @param {number} stride Stride.
   * @param {string} text Text to place on the path.
   * @param {number} startM m along the path where the text starts.
   * @param {number} maxAngle Max angle between adjacent chars in radians.
   * @param {number} scale The product of the text scale and the device pixel ratio.
   * @param {function(string, string, Object<string, number>):number} measureAndCacheTextWidth Measure and cache text width.
   * @param {string} font The font.
   * @param {Object<string, number>} cache A cache of measured widths.
   * @param {number} rotation Rotation to apply to the flatCoordinates to determine whether text needs to be reversed.
   * @return {Array<Array<*>>} The result array (or null if `maxAngle` was
   * exceeded). Entries of the array are x, y, anchorX, angle, chunk.
   */
  function drawTextOnPath(flatCoordinates, offset, end, stride, text, startM, maxAngle, scale, measureAndCacheTextWidth, font, cache, rotation) {
      var result = [];
      // Keep text upright
      var reverse;
      if (rotation) {
          var rotatedCoordinates = rotate(flatCoordinates, offset, end, stride, rotation, [flatCoordinates[offset], flatCoordinates[offset + 1]]);
          reverse =
              rotatedCoordinates[0] >
                  rotatedCoordinates[rotatedCoordinates.length - stride];
      }
      else {
          reverse = flatCoordinates[offset] > flatCoordinates[end - stride];
      }
      var numChars = text.length;
      var x1 = flatCoordinates[offset];
      var y1 = flatCoordinates[offset + 1];
      offset += stride;
      var x2 = flatCoordinates[offset];
      var y2 = flatCoordinates[offset + 1];
      var segmentM = 0;
      var segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
      var angleChanged = false;
      var index, previousAngle;
      for (var i = 0; i < numChars; ++i) {
          index = reverse ? numChars - i - 1 : i;
          var char = text[index];
          var charLength = scale * measureAndCacheTextWidth(font, char, cache);
          var charM = startM + charLength / 2;
          while (offset < end - stride && segmentM + segmentLength < charM) {
              x1 = x2;
              y1 = y2;
              offset += stride;
              x2 = flatCoordinates[offset];
              y2 = flatCoordinates[offset + 1];
              segmentM += segmentLength;
              segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
          }
          var segmentPos = charM - segmentM;
          var angle = Math.atan2(y2 - y1, x2 - x1);
          if (reverse) {
              angle += angle > 0 ? -Math.PI : Math.PI;
          }
          if (previousAngle !== undefined) {
              var delta = angle - previousAngle;
              angleChanged = angleChanged || delta !== 0;
              delta +=
                  delta > Math.PI ? -2 * Math.PI : delta < -Math.PI ? 2 * Math.PI : 0;
              if (Math.abs(delta) > maxAngle) {
                  return null;
              }
          }
          previousAngle = angle;
          var interpolate = segmentPos / segmentLength;
          var x = lerp(x1, x2, interpolate);
          var y = lerp(y1, y2, interpolate);
          result[index] = [x, y, charLength / 2, angle, char];
          startM += charLength;
      }
      return angleChanged
          ? result
          : [[result[0][0], result[0][1], result[0][2], result[0][3], text]];
  }

  /**
   * @module ol/render/canvas/Executor
   */
  /**
   * @typedef {Object} SerializableInstructions
   * @property {Array<*>} instructions The rendering instructions.
   * @property {Array<*>} hitDetectionInstructions The rendering hit detection instructions.
   * @property {Array<number>} coordinates The array of all coordinates.
   * @property {!Object<string, import("../canvas.js").TextState>} textStates The text states (decluttering).
   * @property {!Object<string, import("../canvas.js").FillState>} fillStates The fill states (decluttering).
   * @property {!Object<string, import("../canvas.js").StrokeState>} strokeStates The stroke states (decluttering).
   */
  /**
   * @type {import("../../extent.js").Extent}
   */
  var tmpExtent = createEmpty();
  /**
   * @type {!import("../../transform.js").Transform}
   */
  var tmpTransform$1 = create();
  /** @type {import("../../coordinate.js").Coordinate} */
  var p1 = [];
  /** @type {import("../../coordinate.js").Coordinate} */
  var p2 = [];
  /** @type {import("../../coordinate.js").Coordinate} */
  var p3 = [];
  /** @type {import("../../coordinate.js").Coordinate} */
  var p4 = [];
  var Executor = /** @class */ (function () {
      /**
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {boolean} overlaps The replay can have overlapping geometries.
       * @param {SerializableInstructions} instructions The serializable instructions
       * @param {import("../../size.js").Size} renderBuffer Render buffer (width/height) in pixels.
       */
      function Executor(resolution, pixelRatio, overlaps, instructions, renderBuffer) {
          /**
           * @protected
           * @type {boolean}
           */
          this.overlaps = overlaps;
          /**
           * @protected
           * @type {number}
           */
          this.pixelRatio = pixelRatio;
          /**
           * @protected
           * @const
           * @type {number}
           */
          this.resolution = resolution;
          /**
           * @private
           * @type {boolean}
           */
          this.alignFill_;
          /**
           * @type {Array<*>}
           */
          this.declutterItems = [];
          /**
           * @protected
           * @type {Array<*>}
           */
          this.instructions = instructions.instructions;
          /**
           * @protected
           * @type {Array<number>}
           */
          this.coordinates = instructions.coordinates;
          /**
           * @private
           * @type {!Object<number,import("../../coordinate.js").Coordinate|Array<import("../../coordinate.js").Coordinate>|Array<Array<import("../../coordinate.js").Coordinate>>>}
           */
          this.coordinateCache_ = {};
          /**
           * @private
           * @type {import("../../size.js").Size}
           */
          this.renderBuffer_ = renderBuffer;
          /**
           * @private
           * @type {!import("../../transform.js").Transform}
           */
          this.renderedTransform_ = create();
          /**
           * @protected
           * @type {Array<*>}
           */
          this.hitDetectionInstructions = instructions.hitDetectionInstructions;
          /**
           * @private
           * @type {Array<number>}
           */
          this.pixelCoordinates_ = null;
          /**
           * @private
           * @type {number}
           */
          this.viewRotation_ = 0;
          /**
           * @type {!Object<string, import("../canvas.js").FillState>}
           */
          this.fillStates = instructions.fillStates || {};
          /**
           * @type {!Object<string, import("../canvas.js").StrokeState>}
           */
          this.strokeStates = instructions.strokeStates || {};
          /**
           * @type {!Object<string, import("../canvas.js").TextState>}
           */
          this.textStates = instructions.textStates || {};
          /**
           * @private
           * @type {Object<string, Object<string, number>>}
           */
          this.widths_ = {};
          /**
           * @private
           * @type {Object<string, import("../canvas.js").Label>}
           */
          this.labels_ = {};
      }
      /**
       * @param {string} text Text.
       * @param {string} textKey Text style key.
       * @param {string} fillKey Fill style key.
       * @param {string} strokeKey Stroke style key.
       * @return {import("../canvas.js").Label} Label.
       */
      Executor.prototype.createLabel = function (text, textKey, fillKey, strokeKey) {
          var key = text + textKey + fillKey + strokeKey;
          if (this.labels_[key]) {
              return this.labels_[key];
          }
          var strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
          var fillState = fillKey ? this.fillStates[fillKey] : null;
          var textState = this.textStates[textKey];
          var pixelRatio = this.pixelRatio;
          var scale = [
              textState.scale[0] * pixelRatio,
              textState.scale[1] * pixelRatio,
          ];
          var align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];
          var strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
          var lines = text.split('\n');
          var numLines = lines.length;
          var widths = [];
          var width = measureTextWidths(textState.font, lines, widths);
          var lineHeight = measureTextHeight(textState.font);
          var height = lineHeight * numLines;
          var renderWidth = width + strokeWidth;
          var contextInstructions = [];
          // make canvas 2 pixels wider to account for italic text width measurement errors
          var w = (renderWidth + 2) * scale[0];
          var h = (height + strokeWidth) * scale[1];
          /** @type {import("../canvas.js").Label} */
          var label = {
              width: w < 0 ? Math.floor(w) : Math.ceil(w),
              height: h < 0 ? Math.floor(h) : Math.ceil(h),
              contextInstructions: contextInstructions,
          };
          if (scale[0] != 1 || scale[1] != 1) {
              contextInstructions.push('scale', scale);
          }
          contextInstructions.push('font', textState.font);
          if (strokeKey) {
              contextInstructions.push('strokeStyle', strokeState.strokeStyle);
              contextInstructions.push('lineWidth', strokeWidth);
              contextInstructions.push('lineCap', strokeState.lineCap);
              contextInstructions.push('lineJoin', strokeState.lineJoin);
              contextInstructions.push('miterLimit', strokeState.miterLimit);
              // eslint-disable-next-line
              var Context = WORKER_OFFSCREEN_CANVAS ? OffscreenCanvasRenderingContext2D : CanvasRenderingContext2D;
              if (Context.prototype.setLineDash) {
                  contextInstructions.push('setLineDash', [strokeState.lineDash]);
                  contextInstructions.push('lineDashOffset', strokeState.lineDashOffset);
              }
          }
          if (fillKey) {
              contextInstructions.push('fillStyle', fillState.fillStyle);
          }
          contextInstructions.push('textBaseline', 'middle');
          contextInstructions.push('textAlign', 'center');
          var leftRight = 0.5 - align;
          var x = align * renderWidth + leftRight * strokeWidth;
          var i;
          if (strokeKey) {
              for (i = 0; i < numLines; ++i) {
                  contextInstructions.push('strokeText', [
                      lines[i],
                      x + leftRight * widths[i],
                      0.5 * (strokeWidth + lineHeight) + i * lineHeight,
                  ]);
              }
          }
          if (fillKey) {
              for (i = 0; i < numLines; ++i) {
                  contextInstructions.push('fillText', [
                      lines[i],
                      x + leftRight * widths[i],
                      0.5 * (strokeWidth + lineHeight) + i * lineHeight,
                  ]);
              }
          }
          this.labels_[key] = label;
          return label;
      };
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
       * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
       * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
       * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
       * @param {Array<*>} fillInstruction Fill instruction.
       * @param {Array<*>} strokeInstruction Stroke instruction.
       * @param {boolean} declutter Declutter.
       */
      Executor.prototype.replayTextBackground_ = function (context, p1, p2, p3, p4, fillInstruction, strokeInstruction, declutter) {
          context.beginPath();
          context.moveTo.apply(context, p1);
          context.lineTo.apply(context, p2);
          context.lineTo.apply(context, p3);
          context.lineTo.apply(context, p4);
          context.lineTo.apply(context, p1);
          if (fillInstruction) {
              this.alignFill_ = /** @type {boolean} */ (fillInstruction[2]);
              if (declutter) {
                  context.fillStyle = /** @type {import("../../colorlike.js").ColorLike} */ (fillInstruction[1]);
              }
              this.fill_(context);
          }
          if (strokeInstruction) {
              this.setStrokeStyle_(context, 
              /** @type {Array<*>} */ (strokeInstruction));
              context.stroke();
          }
      };
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} contextScale Scale of the context.
       * @param {number} x X.
       * @param {number} y Y.
       * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
       * @param {number} anchorX Anchor X.
       * @param {number} anchorY Anchor Y.
       * @param {import("../canvas.js").DeclutterGroup} declutterGroup Declutter group.
       * @param {number} height Height.
       * @param {number} opacity Opacity.
       * @param {number} originX Origin X.
       * @param {number} originY Origin Y.
       * @param {number} rotation Rotation.
       * @param {import("../../size.js").Size} scale Scale.
       * @param {boolean} snapToPixel Snap to pixel.
       * @param {number} width Width.
       * @param {Array<number>} padding Padding.
       * @param {Array<*>} fillInstruction Fill instruction.
       * @param {Array<*>} strokeInstruction Stroke instruction.
       * @return {boolean} The image or label was rendered.
       */
      Executor.prototype.replayImageOrLabel_ = function (context, contextScale, x, y, imageOrLabel, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, fillInstruction, strokeInstruction) {
          var fillStroke = fillInstruction || strokeInstruction;
          anchorX *= scale[0];
          anchorY *= scale[1];
          x -= anchorX;
          y -= anchorY;
          var w = width + originX > imageOrLabel.width
              ? imageOrLabel.width - originX
              : width;
          var h = height + originY > imageOrLabel.height
              ? imageOrLabel.height - originY
              : height;
          var boxW = padding[3] + w * scale[0] + padding[1];
          var boxH = padding[0] + h * scale[1] + padding[2];
          var boxX = x - padding[3];
          var boxY = y - padding[0];
          if (fillStroke || rotation !== 0) {
              p1[0] = boxX;
              p4[0] = boxX;
              p1[1] = boxY;
              p2[1] = boxY;
              p2[0] = boxX + boxW;
              p3[0] = p2[0];
              p3[1] = boxY + boxH;
              p4[1] = p3[1];
          }
          var transform = null;
          if (rotation !== 0) {
              var centerX = x + anchorX;
              var centerY = y + anchorY;
              transform = compose(tmpTransform$1, centerX, centerY, 1, 1, rotation, -centerX, -centerY);
              apply(tmpTransform$1, p1);
              apply(tmpTransform$1, p2);
              apply(tmpTransform$1, p3);
              apply(tmpTransform$1, p4);
              createOrUpdate(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent);
          }
          else {
              createOrUpdate(boxX, boxY, boxX + boxW, boxY + boxH, tmpExtent);
          }
          var renderBufferX = 0;
          var renderBufferY = 0;
          if (declutterGroup) {
              var renderBuffer = this.renderBuffer_;
              renderBuffer[0] = Math.max(renderBuffer[0], getWidth(tmpExtent));
              renderBufferX = renderBuffer[0];
              renderBuffer[1] = Math.max(renderBuffer[1], getHeight(tmpExtent));
              renderBufferY = renderBuffer[1];
          }
          var canvas = context.canvas;
          var strokePadding = strokeInstruction
              ? (strokeInstruction[2] * scale[0]) / 2
              : 0;
          var intersects = tmpExtent[0] - strokePadding <=
              (canvas.width + renderBufferX) / contextScale &&
              tmpExtent[2] + strokePadding >= -renderBufferX / contextScale &&
              tmpExtent[1] - strokePadding <=
                  (canvas.height + renderBufferY) / contextScale &&
              tmpExtent[3] + strokePadding >= -renderBufferY / contextScale;
          if (snapToPixel) {
              x = Math.round(x);
              y = Math.round(y);
          }
          if (declutterGroup) {
              if (!intersects && declutterGroup[0] == 1) {
                  return false;
              }
              var declutterArgs = intersects
                  ? [
                      context,
                      transform ? transform.slice(0) : null,
                      opacity,
                      imageOrLabel,
                      originX,
                      originY,
                      w,
                      h,
                      x,
                      y,
                      scale,
                      tmpExtent.slice(),
                  ]
                  : null;
              if (declutterArgs) {
                  if (fillStroke) {
                      declutterArgs.push(fillInstruction, strokeInstruction, p1.slice(0), p2.slice(0), p3.slice(0), p4.slice(0));
                  }
                  declutterGroup.push(declutterArgs);
              }
          }
          else if (intersects) {
              if (fillStroke) {
                  this.replayTextBackground_(context, p1, p2, p3, p4, 
                  /** @type {Array<*>} */ (fillInstruction), 
                  /** @type {Array<*>} */ (strokeInstruction), false);
              }
              drawImageOrLabel(context, transform, opacity, imageOrLabel, originX, originY, w, h, x, y, scale);
          }
          return true;
      };
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       */
      Executor.prototype.fill_ = function (context) {
          if (this.alignFill_) {
              var origin_1 = apply(this.renderedTransform_, [0, 0]);
              var repeatSize = 512 * this.pixelRatio;
              context.save();
              context.translate(origin_1[0] % repeatSize, origin_1[1] % repeatSize);
              context.rotate(this.viewRotation_);
          }
          context.fill();
          if (this.alignFill_) {
              context.restore();
          }
      };
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       * @param {Array<*>} instruction Instruction.
       */
      Executor.prototype.setStrokeStyle_ = function (context, instruction) {
          context.strokeStyle = /** @type {import("../../colorlike.js").ColorLike} */ (instruction[1]);
          context.lineWidth = /** @type {number} */ (instruction[2]);
          context.lineCap = /** @type {CanvasLineCap} */ (instruction[3]);
          context.lineJoin = /** @type {CanvasLineJoin} */ (instruction[4]);
          context.miterLimit = /** @type {number} */ (instruction[5]);
          if (context.setLineDash) {
              context.lineDashOffset = /** @type {number} */ (instruction[7]);
              context.setLineDash(/** @type {Array<number>} */ (instruction[6]));
          }
      };
      /**
       * @param {import("../canvas.js").DeclutterGroup} declutterGroup Declutter group.
       * @param {import("../../Feature.js").FeatureLike} feature Feature.
       * @param {number} opacity Layer opacity.
       * @param {?} declutterTree Declutter tree.
       * @return {?} Declutter tree.
       */
      Executor.prototype.renderDeclutter = function (declutterGroup, feature, opacity, declutterTree) {
          /** @type {Array<import("../../structs/RBush.js").Entry>} */
          var boxes = [];
          for (var i = 1, ii = declutterGroup.length; i < ii; ++i) {
              var declutterData = declutterGroup[i];
              var box = declutterData[11];
              boxes.push({
                  minX: box[0],
                  minY: box[1],
                  maxX: box[2],
                  maxY: box[3],
                  value: feature,
              });
          }
          if (!declutterTree) {
              declutterTree = new rbush(9);
          }
          var collides = false;
          for (var i = 0, ii = boxes.length; i < ii; ++i) {
              if (declutterTree.collides(boxes[i])) {
                  collides = true;
                  break;
              }
          }
          if (!collides) {
              declutterTree.load(boxes);
              for (var j = 1, jj = declutterGroup.length; j < jj; ++j) {
                  var declutterData = /** @type {Array} */ (declutterGroup[j]);
                  var context = declutterData[0];
                  var currentAlpha = context.globalAlpha;
                  if (currentAlpha !== opacity) {
                      context.globalAlpha = opacity;
                  }
                  if (declutterData.length > 12) {
                      this.replayTextBackground_(declutterData[0], declutterData[14], declutterData[15], declutterData[16], declutterData[17], declutterData[12], declutterData[13], true);
                  }
                  drawImageOrLabel.apply(undefined, declutterData);
                  if (currentAlpha !== opacity) {
                      context.globalAlpha = currentAlpha;
                  }
              }
          }
          declutterGroup.length = 1;
          return declutterTree;
      };
      /**
       * @private
       * @param {string} text The text to draw.
       * @param {string} textKey The key of the text state.
       * @param {string} strokeKey The key for the stroke state.
       * @param {string} fillKey The key for the fill state.
       * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
       */
      Executor.prototype.drawLabelWithPointPlacement_ = function (text, textKey, strokeKey, fillKey) {
          var textState = this.textStates[textKey];
          var label = this.createLabel(text, textKey, fillKey, strokeKey);
          var strokeState = this.strokeStates[strokeKey];
          var pixelRatio = this.pixelRatio;
          var align = TEXT_ALIGN[textState.textAlign || defaultTextAlign];
          var baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];
          var strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;
          // Remove the 2 pixels we added in createLabel() for the anchor
          var width = label.width / pixelRatio - 2 * textState.scale[0];
          var anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
          var anchorY = (baseline * label.height) / pixelRatio +
              2 * (0.5 - baseline) * strokeWidth;
          return {
              label: label,
              anchorX: anchorX,
              anchorY: anchorY,
          };
      };
      /**
       * @private
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} contextScale Scale of the context.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {Array<*>} instructions Instructions array.
       * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
       * @param {function(import("../../Feature.js").FeatureLike): T|undefined} featureCallback Feature callback.
       * @param {import("../../extent.js").Extent=} opt_hitExtent Only check features that intersect this
       *     extent.
       * @return {T|undefined} Callback result.
       * @template T
       */
      Executor.prototype.execute_ = function (context, contextScale, transform, instructions, snapToPixel, featureCallback, opt_hitExtent) {
          this.declutterItems.length = 0;
          /** @type {Array<number>} */
          var pixelCoordinates;
          if (this.pixelCoordinates_ && equals(transform, this.renderedTransform_)) {
              pixelCoordinates = this.pixelCoordinates_;
          }
          else {
              if (!this.pixelCoordinates_) {
                  this.pixelCoordinates_ = [];
              }
              pixelCoordinates = transform2D(this.coordinates, 0, this.coordinates.length, 2, transform, this.pixelCoordinates_);
              setFromArray(this.renderedTransform_, transform);
          }
          var i = 0; // instruction index
          var ii = instructions.length; // end of instructions
          var d = 0; // data index
          var dd; // end of per-instruction data
          var anchorX, anchorY, prevX, prevY, roundX, roundY, declutterGroup, declutterGroups, image, text, textKey;
          var strokeKey, fillKey;
          var pendingFill = 0;
          var pendingStroke = 0;
          var lastFillInstruction = null;
          var lastStrokeInstruction = null;
          var coordinateCache = this.coordinateCache_;
          var viewRotation = this.viewRotation_;
          var viewRotationFromTransform = Math.round(Math.atan2(-transform[1], transform[0]) * 1e12) / 1e12;
          var state = /** @type {import("../../render.js").State} */ ({
              context: context,
              pixelRatio: this.pixelRatio,
              resolution: this.resolution,
              rotation: viewRotation,
          });
          // When the batch size gets too big, performance decreases. 200 is a good
          // balance between batch size and number of fill/stroke instructions.
          var batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
          var /** @type {import("../../Feature.js").FeatureLike} */ feature;
          var x, y;
          while (i < ii) {
              var instruction = instructions[i];
              var type = /** @type {import("./Instruction.js").default} */ (instruction[0]);
              switch (type) {
                  case Instruction.BEGIN_GEOMETRY:
                      feature = /** @type {import("../../Feature.js").FeatureLike} */ (instruction[1]);
                      if (!feature.getGeometry()) {
                          i = /** @type {number} */ (instruction[2]);
                      }
                      else if (opt_hitExtent !== undefined &&
                          !intersects(opt_hitExtent, instruction[3])) {
                          i = /** @type {number} */ (instruction[2]) + 1;
                      }
                      else {
                          ++i;
                      }
                      break;
                  case Instruction.BEGIN_PATH:
                      if (pendingFill > batchSize) {
                          this.fill_(context);
                          pendingFill = 0;
                      }
                      if (pendingStroke > batchSize) {
                          context.stroke();
                          pendingStroke = 0;
                      }
                      if (!pendingFill && !pendingStroke) {
                          context.beginPath();
                          prevX = NaN;
                          prevY = NaN;
                      }
                      ++i;
                      break;
                  case Instruction.CIRCLE:
                      d = /** @type {number} */ (instruction[1]);
                      var x1 = pixelCoordinates[d];
                      var y1 = pixelCoordinates[d + 1];
                      var x2 = pixelCoordinates[d + 2];
                      var y2 = pixelCoordinates[d + 3];
                      var dx = x2 - x1;
                      var dy = y2 - y1;
                      var r = Math.sqrt(dx * dx + dy * dy);
                      context.moveTo(x1 + r, y1);
                      context.arc(x1, y1, r, 0, 2 * Math.PI, true);
                      ++i;
                      break;
                  case Instruction.CLOSE_PATH:
                      context.closePath();
                      ++i;
                      break;
                  case Instruction.CUSTOM:
                      d = /** @type {number} */ (instruction[1]);
                      dd = instruction[2];
                      var geometry = /** @type {import("../../geom/SimpleGeometry.js").default} */ (instruction[3]);
                      var renderer = instruction[4];
                      var fn = instruction.length == 6 ? instruction[5] : undefined;
                      state.geometry = geometry;
                      state.feature = feature;
                      if (!(i in coordinateCache)) {
                          coordinateCache[i] = [];
                      }
                      var coords = coordinateCache[i];
                      if (fn) {
                          fn(pixelCoordinates, d, dd, 2, coords);
                      }
                      else {
                          coords[0] = pixelCoordinates[d];
                          coords[1] = pixelCoordinates[d + 1];
                          coords.length = 2;
                      }
                      renderer(coords, state);
                      ++i;
                      break;
                  case Instruction.DRAW_IMAGE:
                      d = /** @type {number} */ (instruction[1]);
                      dd = /** @type {number} */ (instruction[2]);
                      image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */ (instruction[3]);
                      // Remaining arguments in DRAW_IMAGE are in alphabetical order
                      anchorX = /** @type {number} */ (instruction[4]);
                      anchorY = /** @type {number} */ (instruction[5]);
                      declutterGroups = featureCallback ? null : instruction[6];
                      var height = /** @type {number} */ (instruction[7]);
                      var opacity = /** @type {number} */ (instruction[8]);
                      var originX = /** @type {number} */ (instruction[9]);
                      var originY = /** @type {number} */ (instruction[10]);
                      var rotateWithView = /** @type {boolean} */ (instruction[11]);
                      var rotation = /** @type {number} */ (instruction[12]);
                      var scale = /** @type {import("../../size.js").Size} */ (instruction[13]);
                      var width = /** @type {number} */ (instruction[14]);
                      if (!image && instruction.length >= 19) {
                          // create label images
                          text = /** @type {string} */ (instruction[18]);
                          textKey = /** @type {string} */ (instruction[19]);
                          strokeKey = /** @type {string} */ (instruction[20]);
                          fillKey = /** @type {string} */ (instruction[21]);
                          var labelWithAnchor = this.drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey);
                          image = labelWithAnchor.label;
                          instruction[3] = image;
                          var textOffsetX = /** @type {number} */ (instruction[22]);
                          anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
                          instruction[4] = anchorX;
                          var textOffsetY = /** @type {number} */ (instruction[23]);
                          anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
                          instruction[5] = anchorY;
                          height = image.height;
                          instruction[7] = height;
                          width = image.width;
                          instruction[14] = width;
                      }
                      var geometryWidths = void 0;
                      if (instruction.length > 24) {
                          geometryWidths = /** @type {number} */ (instruction[24]);
                      }
                      var padding = void 0, backgroundFill = void 0, backgroundStroke = void 0;
                      if (instruction.length > 16) {
                          padding = /** @type {Array<number>} */ (instruction[15]);
                          backgroundFill = /** @type {boolean} */ (instruction[16]);
                          backgroundStroke = /** @type {boolean} */ (instruction[17]);
                      }
                      else {
                          padding = defaultPadding;
                          backgroundFill = false;
                          backgroundStroke = false;
                      }
                      if (rotateWithView && viewRotationFromTransform) {
                          // Canvas is expected to be rotated to reverse view rotation.
                          rotation += viewRotation;
                      }
                      else if (!rotateWithView && !viewRotationFromTransform) {
                          // Canvas is not rotated, images need to be rotated back to be north-up.
                          rotation -= viewRotation;
                      }
                      var widthIndex = 0;
                      var declutterGroupIndex = 0;
                      for (; d < dd; d += 2) {
                          if (geometryWidths &&
                              geometryWidths[widthIndex++] < width / this.pixelRatio) {
                              continue;
                          }
                          if (declutterGroups) {
                              var index = Math.floor(declutterGroupIndex);
                              declutterGroup =
                                  declutterGroups.length < index + 1
                                      ? [declutterGroups[0][0]]
                                      : declutterGroups[index];
                          }
                          var rendered = this.replayImageOrLabel_(context, contextScale, pixelCoordinates[d], pixelCoordinates[d + 1], image, anchorX, anchorY, declutterGroup, height, opacity, originX, originY, rotation, scale, snapToPixel, width, padding, backgroundFill
                              ? /** @type {Array<*>} */ (lastFillInstruction)
                              : null, backgroundStroke
                              ? /** @type {Array<*>} */ (lastStrokeInstruction)
                              : null);
                          if (rendered &&
                              declutterGroup &&
                              declutterGroups[declutterGroups.length - 1] !== declutterGroup) {
                              declutterGroups.push(declutterGroup);
                          }
                          if (declutterGroup) {
                              if (declutterGroup.length - 1 === declutterGroup[0]) {
                                  this.declutterItems.push(this, declutterGroup, feature);
                              }
                              declutterGroupIndex += 1 / declutterGroup[0];
                          }
                      }
                      ++i;
                      break;
                  case Instruction.DRAW_CHARS:
                      var begin = /** @type {number} */ (instruction[1]);
                      var end = /** @type {number} */ (instruction[2]);
                      var baseline = /** @type {number} */ (instruction[3]);
                      declutterGroup = featureCallback ? null : instruction[4];
                      var overflow = /** @type {number} */ (instruction[5]);
                      fillKey = /** @type {string} */ (instruction[6]);
                      var maxAngle = /** @type {number} */ (instruction[7]);
                      var measurePixelRatio = /** @type {number} */ (instruction[8]);
                      var offsetY = /** @type {number} */ (instruction[9]);
                      strokeKey = /** @type {string} */ (instruction[10]);
                      var strokeWidth = /** @type {number} */ (instruction[11]);
                      text = /** @type {string} */ (instruction[12]);
                      textKey = /** @type {string} */ (instruction[13]);
                      var pixelRatioScale = [
                          /** @type {number} */ (instruction[14]),
                          /** @type {number} */ (instruction[14]),
                      ];
                      var textState = this.textStates[textKey];
                      var font = textState.font;
                      var textScale = [
                          textState.scale[0] * measurePixelRatio,
                          textState.scale[1] * measurePixelRatio,
                      ];
                      var cachedWidths = void 0;
                      if (font in this.widths_) {
                          cachedWidths = this.widths_[font];
                      }
                      else {
                          cachedWidths = {};
                          this.widths_[font] = cachedWidths;
                      }
                      var pathLength = lineStringLength(pixelCoordinates, begin, end, 2);
                      var textLength = Math.abs(textScale[0]) *
                          measureAndCacheTextWidth(font, text, cachedWidths);
                      if (overflow || textLength <= pathLength) {
                          var textAlign = this.textStates[textKey].textAlign;
                          var startM = (pathLength - textLength) * TEXT_ALIGN[textAlign];
                          var parts = drawTextOnPath(pixelCoordinates, begin, end, 2, text, startM, maxAngle, Math.abs(textScale[0]), measureAndCacheTextWidth, font, cachedWidths, viewRotationFromTransform ? 0 : this.viewRotation_);
                          if (parts) {
                              var rendered = false;
                              var c = void 0, cc = void 0, chars = void 0, label = void 0, part = void 0;
                              if (strokeKey) {
                                  for (c = 0, cc = parts.length; c < cc; ++c) {
                                      part = parts[c]; // x, y, anchorX, rotation, chunk
                                      chars = /** @type {string} */ (part[4]);
                                      label = this.createLabel(chars, textKey, '', strokeKey);
                                      anchorX = /** @type {number} */ (part[2]) + strokeWidth;
                                      anchorY =
                                          baseline * label.height +
                                              ((0.5 - baseline) * 2 * strokeWidth * textScale[1]) /
                                                  textScale[0] -
                                              offsetY;
                                      rendered =
                                          this.replayImageOrLabel_(context, contextScale, 
                                          /** @type {number} */ (part[0]), 
                                          /** @type {number} */ (part[1]), label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0, 
                                          /** @type {number} */ (part[3]), pixelRatioScale, false, label.width, defaultPadding, null, null) || rendered;
                                  }
                              }
                              if (fillKey) {
                                  for (c = 0, cc = parts.length; c < cc; ++c) {
                                      part = parts[c]; // x, y, anchorX, rotation, chunk
                                      chars = /** @type {string} */ (part[4]);
                                      label = this.createLabel(chars, textKey, fillKey, '');
                                      anchorX = /** @type {number} */ (part[2]);
                                      anchorY = baseline * label.height - offsetY;
                                      rendered =
                                          this.replayImageOrLabel_(context, contextScale, 
                                          /** @type {number} */ (part[0]), 
                                          /** @type {number} */ (part[1]), label, anchorX, anchorY, declutterGroup, label.height, 1, 0, 0, 
                                          /** @type {number} */ (part[3]), pixelRatioScale, false, label.width, defaultPadding, null, null) || rendered;
                                  }
                              }
                              if (rendered) {
                                  this.declutterItems.push(this, declutterGroup, feature);
                              }
                          }
                      }
                      ++i;
                      break;
                  case Instruction.END_GEOMETRY:
                      if (featureCallback !== undefined) {
                          feature = /** @type {import("../../Feature.js").FeatureLike} */ (instruction[1]);
                          var result = featureCallback(feature);
                          if (result) {
                              return result;
                          }
                      }
                      ++i;
                      break;
                  case Instruction.FILL:
                      if (batchSize) {
                          pendingFill++;
                      }
                      else {
                          this.fill_(context);
                      }
                      ++i;
                      break;
                  case Instruction.MOVE_TO_LINE_TO:
                      d = /** @type {number} */ (instruction[1]);
                      dd = /** @type {number} */ (instruction[2]);
                      x = pixelCoordinates[d];
                      y = pixelCoordinates[d + 1];
                      roundX = (x + 0.5) | 0;
                      roundY = (y + 0.5) | 0;
                      if (roundX !== prevX || roundY !== prevY) {
                          context.moveTo(x, y);
                          prevX = roundX;
                          prevY = roundY;
                      }
                      for (d += 2; d < dd; d += 2) {
                          x = pixelCoordinates[d];
                          y = pixelCoordinates[d + 1];
                          roundX = (x + 0.5) | 0;
                          roundY = (y + 0.5) | 0;
                          if (d == dd - 2 || roundX !== prevX || roundY !== prevY) {
                              context.lineTo(x, y);
                              prevX = roundX;
                              prevY = roundY;
                          }
                      }
                      ++i;
                      break;
                  case Instruction.SET_FILL_STYLE:
                      lastFillInstruction = instruction;
                      this.alignFill_ = instruction[2];
                      if (pendingFill) {
                          this.fill_(context);
                          pendingFill = 0;
                          if (pendingStroke) {
                              context.stroke();
                              pendingStroke = 0;
                          }
                      }
                      context.fillStyle = /** @type {import("../../colorlike.js").ColorLike} */ (instruction[1]);
                      ++i;
                      break;
                  case Instruction.SET_STROKE_STYLE:
                      lastStrokeInstruction = instruction;
                      if (pendingStroke) {
                          context.stroke();
                          pendingStroke = 0;
                      }
                      this.setStrokeStyle_(context, /** @type {Array<*>} */ (instruction));
                      ++i;
                      break;
                  case Instruction.STROKE:
                      if (batchSize) {
                          pendingStroke++;
                      }
                      else {
                          context.stroke();
                      }
                      ++i;
                      break;
                  default:
                      ++i; // consume the instruction anyway, to avoid an infinite loop
                      break;
              }
          }
          if (pendingFill) {
              this.fill_(context);
          }
          if (pendingStroke) {
              context.stroke();
          }
          return undefined;
      };
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} contextScale Scale of the context.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
       */
      Executor.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel) {
          this.viewRotation_ = viewRotation;
          this.execute_(context, contextScale, transform, this.instructions, snapToPixel, undefined, undefined);
      };
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {function(import("../../Feature.js").FeatureLike): T=} opt_featureCallback
       *     Feature callback.
       * @param {import("../../extent.js").Extent=} opt_hitExtent Only check features that intersect this
       *     extent.
       * @return {T|undefined} Callback result.
       * @template T
       */
      Executor.prototype.executeHitDetection = function (context, transform, viewRotation, opt_featureCallback, opt_hitExtent) {
          this.viewRotation_ = viewRotation;
          return this.execute_(context, 1, transform, this.hitDetectionInstructions, true, opt_featureCallback, opt_hitExtent);
      };
      return Executor;
  }());

  /**
   * @module ol/render/canvas/ExecutorGroup
   */
  /**
   * @const
   * @type {Array<import("./BuilderType.js").default>}
   */
  var ORDER = [
      ReplayType.POLYGON,
      ReplayType.CIRCLE,
      ReplayType.LINE_STRING,
      ReplayType.IMAGE,
      ReplayType.TEXT,
      ReplayType.DEFAULT,
  ];
  var ExecutorGroup = /** @class */ (function () {
      /**
       * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
       * `maxExtent` was set on the Buillder for this executor group, the same `maxExtent`
       * should be set here, unless the target context does not exceet that extent (which
       * can be the case when rendering to tiles).
       * @param {number} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {boolean} overlaps The executor group can have overlapping geometries.
       * @param {!Object<string, !Object<import("./BuilderType.js").default, import("./Builder.js").SerializableInstructions>>} allInstructions
       * The serializable instructions.
       * @param {number=} opt_renderBuffer Optional rendering buffer.
       */
      function ExecutorGroup(maxExtent, resolution, pixelRatio, overlaps, allInstructions, opt_renderBuffer) {
          /**
           * @private
           * @type {import("../../extent.js").Extent}
           */
          this.maxExtent_ = maxExtent;
          /**
           * @private
           * @type {boolean}
           */
          this.overlaps_ = overlaps;
          /**
           * @private
           * @type {number}
           */
          this.pixelRatio_ = pixelRatio;
          /**
           * @private
           * @type {number}
           */
          this.resolution_ = resolution;
          /**
           * @private
           * @type {number|undefined}
           */
          this.renderBuffer_ = opt_renderBuffer;
          /**
           * @private
           * @type {!Object<string, !Object<import("./BuilderType.js").default, import("./Executor").default>>}
           */
          this.executorsByZIndex_ = {};
          /**
           * @private
           * @type {CanvasRenderingContext2D}
           */
          this.hitDetectionContext_ = null;
          /**
           * @private
           * @type {import("../../transform.js").Transform}
           */
          this.hitDetectionTransform_ = create();
          this.createExecutors_(allInstructions);
      }
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {import("../../transform.js").Transform} transform Transform.
       */
      ExecutorGroup.prototype.clip = function (context, transform) {
          var flatClipCoords = this.getClipCoords(transform);
          context.beginPath();
          context.moveTo(flatClipCoords[0], flatClipCoords[1]);
          context.lineTo(flatClipCoords[2], flatClipCoords[3]);
          context.lineTo(flatClipCoords[4], flatClipCoords[5]);
          context.lineTo(flatClipCoords[6], flatClipCoords[7]);
          context.clip();
      };
      /**
       * Create executors and populate them using the provided instructions.
       * @private
       * @param {!Object<string, !Object<import("./BuilderType.js").default, import("./Builder.js").SerializableInstructions>>} allInstructions The serializable instructions
       */
      ExecutorGroup.prototype.createExecutors_ = function (allInstructions) {
          for (var zIndex in allInstructions) {
              var executors = this.executorsByZIndex_[zIndex];
              if (executors === undefined) {
                  executors = {};
                  this.executorsByZIndex_[zIndex] = executors;
              }
              var instructionByZindex = allInstructions[zIndex];
              var renderBuffer = [this.renderBuffer_ || 0, this.renderBuffer_ || 0];
              for (var builderType in instructionByZindex) {
                  var instructions = instructionByZindex[builderType];
                  executors[builderType] = new Executor(this.resolution_, this.pixelRatio_, this.overlaps_, instructions, renderBuffer);
              }
          }
      };
      /**
       * @param {Array<import("./BuilderType.js").default>} executors Executors.
       * @return {boolean} Has executors of the provided types.
       */
      ExecutorGroup.prototype.hasExecutors = function (executors) {
          for (var zIndex in this.executorsByZIndex_) {
              var candidates = this.executorsByZIndex_[zIndex];
              for (var i = 0, ii = executors.length; i < ii; ++i) {
                  if (executors[i] in candidates) {
                      return true;
                  }
              }
          }
          return false;
      };
      /**
       * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
       * @param {number} resolution Resolution.
       * @param {number} rotation Rotation.
       * @param {number} hitTolerance Hit tolerance in pixels.
       * @param {function(import("../../Feature.js").FeatureLike): T} callback Feature callback.
       * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
       * @return {T|undefined} Callback result.
       * @template T
       */
      ExecutorGroup.prototype.forEachFeatureAtCoordinate = function (coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
          hitTolerance = Math.round(hitTolerance);
          var contextSize = hitTolerance * 2 + 1;
          var transform = compose(this.hitDetectionTransform_, hitTolerance + 0.5, hitTolerance + 0.5, 1 / resolution, -1 / resolution, -rotation, -coordinate[0], -coordinate[1]);
          if (!this.hitDetectionContext_) {
              this.hitDetectionContext_ = createCanvasContext2D(contextSize, contextSize);
          }
          var context = this.hitDetectionContext_;
          if (context.canvas.width !== contextSize ||
              context.canvas.height !== contextSize) {
              context.canvas.width = contextSize;
              context.canvas.height = contextSize;
          }
          else {
              context.clearRect(0, 0, contextSize, contextSize);
          }
          /**
           * @type {import("../../extent.js").Extent}
           */
          var hitExtent;
          if (this.renderBuffer_ !== undefined) {
              hitExtent = createEmpty();
              extendCoordinate(hitExtent, coordinate);
              buffer(hitExtent, resolution * (this.renderBuffer_ + hitTolerance), hitExtent);
          }
          var mask = getCircleArray(hitTolerance);
          var builderType;
          /**
           * @param {import("../../Feature.js").FeatureLike} feature Feature.
           * @return {?} Callback result.
           */
          function featureCallback(feature) {
              var imageData = context.getImageData(0, 0, contextSize, contextSize)
                  .data;
              for (var i_1 = 0; i_1 < contextSize; i_1++) {
                  for (var j_1 = 0; j_1 < contextSize; j_1++) {
                      if (mask[i_1][j_1]) {
                          if (imageData[(j_1 * contextSize + i_1) * 4 + 3] > 0) {
                              var result_1 = void 0;
                              if (!(declutteredFeatures &&
                                  (builderType == ReplayType.IMAGE ||
                                      builderType == ReplayType.TEXT)) ||
                                  declutteredFeatures.indexOf(feature) !== -1) {
                                  result_1 = callback(feature);
                              }
                              if (result_1) {
                                  return result_1;
                              }
                              else {
                                  context.clearRect(0, 0, contextSize, contextSize);
                                  return undefined;
                              }
                          }
                      }
                  }
              }
          }
          /** @type {Array<number>} */
          var zs = Object.keys(this.executorsByZIndex_).map(Number);
          zs.sort(numberSafeCompareFunction);
          var i, j, executors, executor, result;
          for (i = zs.length - 1; i >= 0; --i) {
              var zIndexKey = zs[i].toString();
              executors = this.executorsByZIndex_[zIndexKey];
              for (j = ORDER.length - 1; j >= 0; --j) {
                  builderType = ORDER[j];
                  executor = executors[builderType];
                  if (executor !== undefined) {
                      result = executor.executeHitDetection(context, transform, rotation, featureCallback, hitExtent);
                      if (result) {
                          return result;
                      }
                  }
              }
          }
          return undefined;
      };
      /**
       * @param {import("../../transform.js").Transform} transform Transform.
       * @return {Array<number>} Clip coordinates.
       */
      ExecutorGroup.prototype.getClipCoords = function (transform) {
          var maxExtent = this.maxExtent_;
          if (!maxExtent) {
              return null;
          }
          var minX = maxExtent[0];
          var minY = maxExtent[1];
          var maxX = maxExtent[2];
          var maxY = maxExtent[3];
          var flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
          transform2D(flatClipCoords, 0, 8, 2, transform, flatClipCoords);
          return flatClipCoords;
      };
      /**
       * @return {boolean} Is empty.
       */
      ExecutorGroup.prototype.isEmpty = function () {
          return isEmpty$1(this.executorsByZIndex_);
      };
      /**
       * @param {CanvasRenderingContext2D} context Context.
       * @param {number} contextScale Scale of the context.
       * @param {import("../../transform.js").Transform} transform Transform.
       * @param {number} viewRotation View rotation.
       * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
       * @param {Array<import("./BuilderType.js").default>=} opt_builderTypes Ordered replay types to replay.
       *     Default is {@link module:ol/render/replay~ORDER}
       * @param {Object<string, import("../canvas.js").DeclutterGroup>=} opt_declutterReplays Declutter replays.
       */
      ExecutorGroup.prototype.execute = function (context, contextScale, transform, viewRotation, snapToPixel, opt_builderTypes, opt_declutterReplays) {
          /** @type {Array<number>} */
          var zs = Object.keys(this.executorsByZIndex_).map(Number);
          zs.sort(numberSafeCompareFunction);
          // setup clipping so that the parts of over-simplified geometries are not
          // visible outside the current extent when panning
          if (this.maxExtent_) {
              context.save();
              this.clip(context, transform);
          }
          var builderTypes = opt_builderTypes ? opt_builderTypes : ORDER;
          var i, ii, j, jj, replays, replay;
          for (i = 0, ii = zs.length; i < ii; ++i) {
              var zIndexKey = zs[i].toString();
              replays = this.executorsByZIndex_[zIndexKey];
              for (j = 0, jj = builderTypes.length; j < jj; ++j) {
                  var builderType = builderTypes[j];
                  replay = replays[builderType];
                  if (replay !== undefined) {
                      if (opt_declutterReplays &&
                          (builderType == ReplayType.IMAGE ||
                              builderType == ReplayType.TEXT)) {
                          var declutter = opt_declutterReplays[zIndexKey];
                          if (!declutter) {
                              opt_declutterReplays[zIndexKey] = [replay, transform.slice(0)];
                          }
                          else {
                              declutter.push(replay, transform.slice(0));
                          }
                      }
                      else {
                          replay.execute(context, contextScale, transform, viewRotation, snapToPixel);
                      }
                  }
              }
          }
          if (this.maxExtent_) {
              context.restore();
          }
      };
      return ExecutorGroup;
  }());
  /**
   * This cache is used for storing calculated pixel circles for increasing performance.
   * It is a static property to allow each Replaygroup to access it.
   * @type {Object<number, Array<Array<(boolean|undefined)>>>}
   */
  var circleArrayCache = {
      0: [[true]],
  };
  /**
   * This method fills a row in the array from the given coordinate to the
   * middle with `true`.
   * @param {Array<Array<(boolean|undefined)>>} array The array that will be altered.
   * @param {number} x X coordinate.
   * @param {number} y Y coordinate.
   */
  function fillCircleArrayRowToMiddle(array, x, y) {
      var i;
      var radius = Math.floor(array.length / 2);
      if (x >= radius) {
          for (i = radius; i < x; i++) {
              array[i][y] = true;
          }
      }
      else if (x < radius) {
          for (i = x + 1; i < radius; i++) {
              array[i][y] = true;
          }
      }
  }
  /**
   * This methods creates a circle inside a fitting array. Points inside the
   * circle are marked by true, points on the outside are undefined.
   * It uses the midpoint circle algorithm.
   * A cache is used to increase performance.
   * @param {number} radius Radius.
   * @returns {Array<Array<(boolean|undefined)>>} An array with marked circle points.
   */
  function getCircleArray(radius) {
      if (circleArrayCache[radius] !== undefined) {
          return circleArrayCache[radius];
      }
      var arraySize = radius * 2 + 1;
      var arr = new Array(arraySize);
      for (var i = 0; i < arraySize; i++) {
          arr[i] = new Array(arraySize);
      }
      var x = radius;
      var y = 0;
      var error = 0;
      while (x >= y) {
          fillCircleArrayRowToMiddle(arr, radius + x, radius + y);
          fillCircleArrayRowToMiddle(arr, radius + y, radius + x);
          fillCircleArrayRowToMiddle(arr, radius - y, radius + x);
          fillCircleArrayRowToMiddle(arr, radius - x, radius + y);
          fillCircleArrayRowToMiddle(arr, radius - x, radius - y);
          fillCircleArrayRowToMiddle(arr, radius - y, radius - x);
          fillCircleArrayRowToMiddle(arr, radius + y, radius - x);
          fillCircleArrayRowToMiddle(arr, radius + x, radius - y);
          y++;
          error += 1 + 2 * y;
          if (2 * (error - x) + 1 > 0) {
              x -= 1;
              error += 1 - 2 * x;
          }
      }
      circleArrayCache[radius] = arr;
      return arr;
  }
  /**
   * @param {!Object<string, Array<*>>} declutterReplays Declutter replays.
   * @param {CanvasRenderingContext2D} context Context.
   * @param {number} rotation Rotation.
   * @param {number} opacity Opacity.
   * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
   * @param {Array<import("../../PluggableMap.js").DeclutterItems>} declutterItems Declutter items.
   */
  function replayDeclutter(declutterReplays, context, rotation, opacity, snapToPixel, declutterItems) {
      var zs = Object.keys(declutterReplays)
          .map(Number)
          .sort(numberSafeCompareFunction);
      for (var z = 0, zz = zs.length; z < zz; ++z) {
          var executorData = declutterReplays[zs[z].toString()];
          var currentExecutor = void 0;
          for (var i = 0, ii = executorData.length; i < ii;) {
              var executor = executorData[i++];
              var transform = executorData[i++];
              executor.execute(context, 1, transform, rotation, snapToPixel);
              if (executor !== currentExecutor && executor.declutterItems.length > 0) {
                  currentExecutor = executor;
                  declutterItems.push({
                      items: executor.declutterItems,
                      opacity: opacity,
                  });
              }
          }
      }
  }

  /**
   * @module ol/style/IconAnchorUnits
   */
  /**
   * Icon anchor units. One of 'fraction', 'pixels'.
   * @enum {string}
   */
  var IconAnchorUnits = {
      /**
       * Anchor is a fraction
       * @api
       */
      FRACTION: 'fraction',
      /**
       * Anchor is in pixels
       * @api
       */
      PIXELS: 'pixels',
  };

  /**
   * @module ol/style/IconOrigin
   */
  /**
   * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.
   * @enum {string}
   */
  var IconOrigin = {
      /**
       * Origin is at bottom left
       * @api
       */
      BOTTOM_LEFT: 'bottom-left',
      /**
       * Origin is at bottom right
       * @api
       */
      BOTTOM_RIGHT: 'bottom-right',
      /**
       * Origin is at top left
       * @api
       */
      TOP_LEFT: 'top-left',
      /**
       * Origin is at top right
       * @api
       */
      TOP_RIGHT: 'top-right',
  };

  var __extends$Y = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @abstract
   */
  var ImageBase = /** @class */ (function (_super) {
      __extends$Y(ImageBase, _super);
      /**
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {number|undefined} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {import("./ImageState.js").default} state State.
       */
      function ImageBase(extent, resolution, pixelRatio, state) {
          var _this = _super.call(this) || this;
          /**
           * @protected
           * @type {import("./extent.js").Extent}
           */
          _this.extent = extent;
          /**
           * @private
           * @type {number}
           */
          _this.pixelRatio_ = pixelRatio;
          /**
           * @protected
           * @type {number|undefined}
           */
          _this.resolution = resolution;
          /**
           * @protected
           * @type {import("./ImageState.js").default}
           */
          _this.state = state;
          return _this;
      }
      /**
       * @protected
       */
      ImageBase.prototype.changed = function () {
          this.dispatchEvent(EventType.CHANGE);
      };
      /**
       * @return {import("./extent.js").Extent} Extent.
       */
      ImageBase.prototype.getExtent = function () {
          return this.extent;
      };
      /**
       * @abstract
       * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
       */
      ImageBase.prototype.getImage = function () {
          return abstract();
      };
      /**
       * @return {number} PixelRatio.
       */
      ImageBase.prototype.getPixelRatio = function () {
          return this.pixelRatio_;
      };
      /**
       * @return {number} Resolution.
       */
      ImageBase.prototype.getResolution = function () {
          return /** @type {number} */ (this.resolution);
      };
      /**
       * @return {import("./ImageState.js").default} State.
       */
      ImageBase.prototype.getState = function () {
          return this.state;
      };
      /**
       * Load not yet loaded URI.
       * @abstract
       */
      ImageBase.prototype.load = function () {
          abstract();
      };
      return ImageBase;
  }(Target));

  var __extends$Z = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * A function that takes an {@link module:ol/Image~Image} for the image and a
   * `{string}` for the src as arguments. It is supposed to make it so the
   * underlying image {@link module:ol/Image~Image#getImage} is assigned the
   * content specified by the src. If not specified, the default is
   *
   *     function(image, src) {
   *       image.getImage().src = src;
   *     }
   *
   * Providing a custom `imageLoadFunction` can be useful to load images with
   * post requests or - in general - through XHR requests, where the src of the
   * image element would be set to a data URI when the content is loaded.
   *
   * @typedef {function(ImageWrapper, string): void} LoadFunction
   * @api
   */
  var ImageWrapper = /** @class */ (function (_super) {
      __extends$Z(ImageWrapper, _super);
      /**
       * @param {import("./extent.js").Extent} extent Extent.
       * @param {number|undefined} resolution Resolution.
       * @param {number} pixelRatio Pixel ratio.
       * @param {string} src Image source URI.
       * @param {?string} crossOrigin Cross origin.
       * @param {LoadFunction} imageLoadFunction Image load function.
       */
      function ImageWrapper(extent, resolution, pixelRatio, src, crossOrigin, imageLoadFunction) {
          var _this = _super.call(this, extent, resolution, pixelRatio, ImageState.IDLE) || this;
          /**
           * @private
           * @type {string}
           */
          _this.src_ = src;
          /**
           * @private
           * @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement}
           */
          _this.image_ = new Image();
          if (crossOrigin !== null) {
              _this.image_.crossOrigin = crossOrigin;
          }
          /**
           * @private
           * @type {?function():void}
           */
          _this.unlisten_ = null;
          /**
           * @protected
           * @type {import("./ImageState.js").default}
           */
          _this.state = ImageState.IDLE;
          /**
           * @private
           * @type {LoadFunction}
           */
          _this.imageLoadFunction_ = imageLoadFunction;
          return _this;
      }
      /**
       * @return {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} Image.
       * @api
       */
      ImageWrapper.prototype.getImage = function () {
          return this.image_;
      };
      /**
       * Tracks loading or read errors.
       *
       * @private
       */
      ImageWrapper.prototype.handleImageError_ = function () {
          this.state = ImageState.ERROR;
          this.unlistenImage_();
          this.changed();
      };
      /**
       * Tracks successful image load.
       *
       * @private
       */
      ImageWrapper.prototype.handleImageLoad_ = function () {
          if (this.resolution === undefined) {
              this.resolution = getHeight(this.extent) / this.image_.height;
          }
          this.state = ImageState.LOADED;
          this.unlistenImage_();
          this.changed();
      };
      /**
       * Load the image or retry if loading previously failed.
       * Loading is taken care of by the tile queue, and calling this method is
       * only needed for preloading or for reloading in case of an error.
       * @api
       */
      ImageWrapper.prototype.load = function () {
          if (this.state == ImageState.IDLE || this.state == ImageState.ERROR) {
              this.state = ImageState.LOADING;
              this.changed();
              this.imageLoadFunction_(this, this.src_);
              this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
          }
      };
      /**
       * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image.
       */
      ImageWrapper.prototype.setImage = function (image) {
          this.image_ = image;
      };
      /**
       * Discards event handlers which listen for load completion or errors.
       *
       * @private
       */
      ImageWrapper.prototype.unlistenImage_ = function () {
          if (this.unlisten_) {
              this.unlisten_();
              this.unlisten_ = null;
          }
      };
      return ImageWrapper;
  }(ImageBase));
  /**
   * @param {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} image Image element.
   * @param {function():any} loadHandler Load callback function.
   * @param {function():any} errorHandler Error callback function.
   * @return {function():void} Callback to stop listening.
   */
  function listenImage(image, loadHandler, errorHandler) {
      var img = /** @type {HTMLImageElement} */ (image);
      if (img.src && IMAGE_DECODE) {
          var promise = img.decode();
          var listening_1 = true;
          var unlisten = function () {
              listening_1 = false;
          };
          promise
              .then(function () {
              if (listening_1) {
                  loadHandler();
              }
          })
              .catch(function (error) {
              if (listening_1) {
                  // FIXME: Unconditionally call errorHandler() when this bug is fixed upstream:
                  //        https://bugs.webkit.org/show_bug.cgi?id=198527
                  if (error.name === 'EncodingError' &&
                      error.message === 'Invalid image type.') {
                      loadHandler();
                  }
                  else {
                      errorHandler();
                  }
              }
          });
          return unlisten;
      }
      var listenerKeys = [
          listenOnce(img, EventType.LOAD, loadHandler),
          listenOnce(img, EventType.ERROR, errorHandler),
      ];
      return function unlisten() {
          listenerKeys.forEach(unlistenByKey);
      };
  }

  /**
   * @module ol/style/IconImage
   */
  var __extends$_ = (undefined && undefined.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  /**
   * @type {CanvasRenderingContext2D}
   */
  var taintedTestContext = null;
  var IconImage = /** @class */ (function (_super) {
      __extends$_(IconImage, _super);
      /**
       * @param {HTMLImageElement|HTMLCanvasElement} image Image.
       * @param {string|undefined} src Src.
       * @param {import("../size.js").Size} size Size.
       * @param {?string} crossOrigin Cross origin.
       * @param {import("../ImageState.js").default} imageState Image state.
       * @param {import("../color.js").Color} color Color.
       */
      function IconImage(image, src, size, crossOrigin, imageState, color) {
          var _this = _super.call(this) || this;
          /**
           * @private
           * @type {HTMLImageElement|HTMLCanvasElement}
           */
          _this.hitDetectionImage_ = null;
          /**
           * @private
           * @type {HTMLImageElement|HTMLCanvasElement}
           */
          _this.image_ = !image ? new Image() : image;
          if (crossOrigin !== null) {
              /** @type {HTMLImageElement} */ (_this.image_).crossOrigin = crossOrigin;
          }
          /**
           * @private
           * @type {Object<number, HTMLCanvasElement>}
           */
          _this.canvas_ = {};
          /**
           * @private
           * @type {import("../color.js").Color}
           */
          _this.color_ = color;
          /**
           * @private
           * @type {?function():void}
           */
          _this.unlisten_ = null;
          /**
           * @private
           * @type {import("../ImageState.js").default}
           */
          _this.imageState_ = imageState;
          /**
           * @private
           * @type {import("../size.js").Size}
           */
          _this.size_ = size;
          /**
           * @private
           * @type {string|undefined}
           */
          _this.src_ = src;
          /**
           * @private
           */
          _this.tainted_;
          return _this;
      }
      /**
       * @private
       * @return {boolean} The image canvas is tainted.
       */
      IconImage.prototype.isTainted_ = function () {
          if (this.tainted_ === undefined && this.imageState_ === ImageState.LOADED) {
              if (!taintedTestContext) {
                  taintedTestContext = createCanvasContext2D(1, 1);
              }
              taintedTestContext.drawImage(this.image_, 0, 0);
              try {
                  taintedTestContext.getImageData(0, 0, 1, 1);
                  this.tainted_ = false;
              }
              catch (e) {
                  taintedTestContext = null;
                  this.tainted_ = true;
              }
          }
          return this.tainted_ === true;
      };
      /**
       * @private
       */
      IconImage.prototype.dispatchChangeEvent_ = function () {
          this.dispatchEvent(EventType.CHANGE);
      };
      /**
       * @private
       */
      IconImage.prototype.handleImageError_ = function () {
          this.imageState_ = ImageState.ERROR;
          this.unlistenImage_();
          this.dispatchChangeEvent_();
      };
      /**
       * @private
       */
      IconImage.prototype.handleImageLoad_ = function () {
          this.imageState_ = ImageState.LOADED;
          if (this.size_) {
              this.image_.width = this.size_[0];
              this.image_.height = this.size_[1];
          }
          else {
              this.size_ = [this.image_.width, this.image_.height];
          }
          this.unlistenImage_();
          this.dispatchChangeEvent_();
      };
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @return {HTMLImageElement|HTMLCanvasElement} Image or Canvas element.
       */
      IconImage.prototype.getImage = function (pixelRatio) {
          this.replaceColor_(pixelRatio);
          return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
      };
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @return {number} Image or Canvas element.
       */
      IconImage.prototype.getPixelRatio = function (pixelRatio) {
          this.replaceColor_(pixelRatio);
          return this.canvas_[pixelRatio] ? pixelRatio : 1;
      };
      /**
       * @return {import("../ImageState.js").default} Image state.
       */
      IconImage.prototype.getImageState = function () {
          return this.imageState_;
      };
      /**
       * @return {HTMLImageElement|HTMLCanvasElement} Image element.
       */
      IconImage.prototype.getHitDetectionImage = function () {
          if (!this.hitDetectionImage_) {
              if (this.isTainted_()) {
                  var width = this.size_[0];
                  var height = this.size_[1];
                  var context = createCanvasContext2D(width, height);
                  context.fillRect(0, 0, width, height);
                  this.hitDetectionImage_ = context.canvas;
              }
              else {
                  this.hitDetectionImage_ = this.image_;
              }
          }
          return this.hitDetectionImage_;
      };
      /**
       * Get the size of the icon (in pixels).
       * @return {import("../size.js").Size} Image size.
       */
      IconImage.prototype.getSize = function () {
          return this.size_;
      };
      /**
       * @return {string|undefined} Image src.
       */
      IconImage.prototype.getSrc = function () {
          return this.src_;
      };
      /**
       * Load not yet loaded URI.
       */
      IconImage.prototype.load = function () {
          if (this.imageState_ == ImageState.IDLE) {
              this.imageState_ = ImageState.LOADING;
              try {
                  /** @type {HTMLImageElement} */ (this.image_).src = this.src_;
              }
              catch (e) {
                  this.handleImageError_();
              }
              this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this));
          }
      };
      /**
       * @param {number} pixelRatio Pixel ratio.
       * @private
       */
      IconImage.prototype.replaceColor_ = function (pixelRatio) {
          if (!this.color_ || this.canvas_[pixelRatio]) {
              return;
          }
          var canvas = document.createElement('canvas');
          this.canvas_[pixelRatio] = canvas;
          canvas.width = Math.ceil(this.image_.width * pixelRatio);
          canvas.height = Math.ceil(this.image_.height * pixelRatio);
          var ctx = canvas.getContext('2d');
          ctx.scale(pixelRatio, pixelRatio);
          ctx.drawImage(this.image_, 0, 0);
          if (this.isTainted_()) {
              // If reading from the canvas throws a SecurityError the same effect can be
              // achieved with globalCompositeOperation.
              // This could be used as the default, but it is not fully supported by all
              // browsers. E. g. Internet Explorer 11 does not support the multiply
              // operation and the resulting image shape will be completelly filled with
              // the provided color.
              // So this is only used as a fallback. It is still better than having no icon
              // at all.
              var c = this.color_;
              ctx.globalCompositeOperation = 'multiply';
              ctx.fillStyle = 'rgb(' + c[0] + ',' + c[1] + ',' + c[2] + ')';
              ctx.fillRect(0, 0, canvas.width, canvas.height);
              ctx.globalCompos